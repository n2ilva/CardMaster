[
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__1",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "Qual modelo de serviço em nuvem fornece infraestrutura virtualizada (servidores, rede e armazenamento) sob demanda?",
    "options": [
      "IaaS",
      "PaaS",
      "SaaS",
      "FaaS"
    ],
    "correctIndex": 0,
    "explanation": "IaaS (Infrastructure as a Service) entrega recursos de infraestrutura virtualizados pela internet. O provedor gerencia o hardware físico enquanto o cliente controla sistemas operacionais, armazenamento e aplicações.",
    "example": "Ao usar Amazon EC2, você aluga máquinas virtuais (IaaS) e instala o SO e aplicações desejadas, sem comprar servidores físicos."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__2",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "Qual modelo de implantação em nuvem combina recursos de nuvem pública e infraestrutura on-premises?",
    "options": [
      "Nuvem híbrida",
      "Nuvem pública",
      "Nuvem privada",
      "Multi-cloud"
    ],
    "correctIndex": 0,
    "explanation": "A nuvem híbrida integra nuvem pública (AWS, Azure, GCP) com infraestrutura on-premises ou nuvem privada, permitindo que dados e aplicações transitem entre ambientes conforme necessidades de custo, conformidade ou desempenho.",
    "example": "Uma empresa mantém dados sensíveis no datacenter local (on-premises) e usa AWS para workloads de alta demanda sazonal (Black Friday), conectando os ambientes via VPN ou Direct Connect."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__3",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "Qual é a principal diferença entre escalabilidade vertical e horizontal na nuvem?",
    "options": [
      "Vertical aumenta recursos de uma máquina; horizontal adiciona mais máquinas",
      "Vertical adiciona máquinas; horizontal aumenta CPU",
      "Ambas são idênticas",
      "Vertical é automática; horizontal é manual"
    ],
    "correctIndex": 0,
    "explanation": "Escalabilidade vertical (scale up/down) significa aumentar CPU, RAM ou disco de uma única instância. Escalabilidade horizontal (scale out/in) significa adicionar ou remover instâncias. Horizontal é preferida na nuvem por não ter limite de hardware e permitir alta disponibilidade.",
    "example": "Vertical: trocar t3.micro (1 vCPU, 1GB RAM) por t3.xlarge (4 vCPU, 16GB). Horizontal: manter t3.micro mas rodar 10 instâncias atrás de um load balancer."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__4",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "O que é uma região (region) em um provedor de nuvem?",
    "options": [
      "Localização geográfica composta por múltiplas zonas de disponibilidade",
      "Tipo de máquina virtual",
      "Nível de suporte ao cliente",
      "Plano de pagamento"
    ],
    "correctIndex": 0,
    "explanation": "Uma região é uma localização geográfica (ex: us-east-1, Brazil South) composta por múltiplas Availability Zones (AZs) — datacenters fisicamente separados. Escolher a região mais próxima dos usuários reduz latência. Dados não são replicados entre regiões automaticamente.",
    "example": "AWS tem 30+ regiões globais. Brazil South (São Paulo) tem 3 AZs. Se sua app atende só o Brasil, use essa região para menor latência (~10ms vs ~150ms de us-east-1)."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__5",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "O que é multi-cloud e qual sua vantagem sobre usar um único provedor?",
    "options": [
      "Usar serviços de múltiplos provedores de nuvem para evitar vendor lock-in e aumentar resiliência",
      "Usar várias regiões do mesmo provedor",
      "Ter múltiplas contas no mesmo provedor",
      "Usar nuvem privada e pública do mesmo fornecedor"
    ],
    "correctIndex": 0,
    "explanation": "Multi-cloud usa dois ou mais provedores (AWS + Azure, GCP + AWS). Vantagens: evitar dependência de um fornecedor (vendor lock-in), usar o melhor serviço de cada provedor, e aumentar resiliência contra falhas de um provedor inteiro.",
    "example": "Empresa usa AWS para compute (EC2/Lambda), GCP BigQuery para analytics e Azure AD para identidade. Se AWS tiver outage, analytics e auth continuam funcionando."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__6",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "O que é PaaS (Platform as a Service) e como difere de IaaS?",
    "options": [
      "PaaS fornece plataforma gerenciada para deploy de apps sem gerenciar infraestrutura; IaaS exige gerenciar SO e middleware",
      "PaaS é mais barato que IaaS em todos os casos",
      "PaaS e IaaS são sinônimos",
      "PaaS requer servidores físicos próprios"
    ],
    "correctIndex": 0,
    "explanation": "PaaS abstrai infraestrutura: você faz deploy do código e a plataforma gerencia SO, runtime, patches e escalabilidade. IaaS entrega VMs/rede onde você controla tudo acima do hypervisor.",
    "example": "PaaS: Heroku, AWS Elastic Beanstalk, Azure App Service — deploy com git push. IaaS: EC2, Azure VM — precisa instalar SO, configurar nginx, manter patches."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__7",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "O que é uma Availability Zone (AZ) em provedores de nuvem?",
    "options": [
      "Datacenter ou grupo de datacenters isolados dentro de uma região",
      "Zona horária do servidor",
      "Região geográfica do provedor",
      "Nível de SLA contratado"
    ],
    "correctIndex": 0,
    "explanation": "Uma AZ é um ou mais datacenters com energia, rede e refrigeração independentes dentro de uma região. Distribuir recursos em múltiplas AZs aumenta disponibilidade: se uma AZ falhar, as outras continuam operando.",
    "example": "us-east-1 tem 6 AZs (us-east-1a a 1f). App em 3 AZs: se uma falhar (incêndio, enchente), 2/3 do capacity continua. RDS Multi-AZ: failover automático em ~60s para AZ secundária."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__8",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "Em arquitetura cloud, por que aplicações stateless escalam melhor horizontalmente?",
    "options": [
      "Porque qualquer instância pode atender a requisição sem depender de sessão local",
      "Porque exigem menos memória sempre",
      "Porque dispensam balanceador de carga",
      "Porque não precisam de banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "Serviços stateless não guardam estado local de sessão. Isso permite adicionar/remover instâncias livremente, mantendo consistência com estado em banco, cache distribuído ou token.",
    "example": "Uma API com JWT pode escalar de 2 para 20 réplicas durante pico sem sessão fixa (sticky session), pois qualquer réplica valida o token e processa a requisição."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Fácil__9",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Fácil",
    "question": "O que caracteriza um componente desacoplado em uma arquitetura cloud moderna?",
    "options": [
      "Baixa dependência direta entre serviços e comunicação por contratos estáveis",
      "Uso obrigatório do mesmo banco para todos os serviços",
      "Deploy único de todos os módulos juntos",
      "Ausência de versionamento de API"
    ],
    "correctIndex": 0,
    "explanation": "Desacoplamento reduz impacto de mudanças e falhas, pois cada serviço evolui de forma independente usando APIs/eventos com contratos claros.",
    "example": "O serviço de faturamento publica evento 'fatura_gerada'; o serviço de notificações consome o evento sem depender de chamadas síncronas diretas."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__1",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "Em uma arquitetura multi-region na nuvem, qual é a principal vantagem de replicar dados entre regiões geográficas distintas?",
    "options": [
      "Reduzir latência e aumentar disponibilidade",
      "Diminuir custos de armazenamento",
      "Eliminar a necessidade de backups",
      "Aumentar a velocidade de CPU das instâncias"
    ],
    "correctIndex": 0,
    "explanation": "Replicação multi-region diminui a latência para usuários em diferentes locais geográficos e aumenta a disponibilidade, pois se uma região inteira falhar, outra pode assumir o tráfego.",
    "example": "Um e-commerce global replica seu banco no us-east-1 e eu-west-1. Usuários europeus acessam a réplica local com ~20ms em vez de ~120ms do servidor americano."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__2",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "O que é um SLA (Service Level Agreement) de 99,99% de disponibilidade e quanto tempo de indisponibilidade ele permite por ano?",
    "options": [
      "Aproximadamente 52 minutos por ano",
      "Aproximadamente 8,7 horas por ano",
      "Zero minutos por ano",
      "Aproximadamente 3,6 dias por ano"
    ],
    "correctIndex": 0,
    "explanation": "99,99% (quatro noves) permite 0,01% de downtime: 365,25 × 24 × 60 × 0,0001 ≈ 52,6 minutos/ano. Para comparação: 99,9% (três noves) ≈ 8,76 horas/ano e 99,999% (cinco noves) ≈ 5,26 minutos/ano.",
    "example": "AWS garante SLA de 99,99% para EC2 multi-AZ. Se o downtime ultrapassar 52 min/ano, o cliente pode solicitar créditos de serviço."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__3",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "Qual é a função de um API Gateway em uma arquitetura de microsserviços na nuvem?",
    "options": [
      "Ponto único de entrada que roteia, autentica e controla tráfego para microsserviços",
      "Armazenar dados dos microsserviços",
      "Compilar o código de todos os serviços",
      "Substituir o load balancer"
    ],
    "correctIndex": 0,
    "explanation": "O API Gateway atua como ponto de entrada único (single entry point) para todos os microsserviços, centralizando responsabilidades como autenticação, rate limiting, roteamento, transformação de requisições e observabilidade.",
    "example": "Amazon API Gateway recebe GET /produtos e roteia para o microsserviço de catálogo; POST /pedidos vai para o microsserviço de pedidos. Ambos passam pela mesma autenticação JWT no gateway."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__4",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "O que é auto-scaling na nuvem e como ele funciona?",
    "options": [
      "Ajuste automático da quantidade de recursos baseado na demanda atual",
      "Escalar manualmente adicionando servidores",
      "Atualizar software automaticamente",
      "Backup automático de dados"
    ],
    "correctIndex": 0,
    "explanation": "Auto-scaling monitora métricas (CPU, requisições, fila) e ajusta automaticamente o número de instâncias. Scale out: adiciona instâncias quando demanda sobe. Scale in: remove quando demanda cai. Garante desempenho nos picos e economia nos vales.",
    "example": "AWS Auto Scaling Group: min=2, max=20, target CPU=70%. Dia normal: 3 instâncias. Black Friday: escala para 18. Madrugada: volta para 2. Sem intervenção manual."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__5",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "O que é um load balancer e qual seu papel em arquiteturas de nuvem?",
    "options": [
      "Distribui tráfego entre múltiplas instâncias para equilibrar carga e garantir disponibilidade",
      "Armazena cache de dados",
      "Criptografa dados em trânsito",
      "Gerencia DNS"
    ],
    "correctIndex": 0,
    "explanation": "Load balancer distribui requisições entre múltiplos servidores/instâncias. Se uma instância falhar, o LB redireciona o tráfego para as saudáveis (health checks). Tipos: L4 (TCP/UDP) e L7 (HTTP - pode rotear por URL, header).",
    "example": "AWS ALB (Application Load Balancer): distribui requests HTTP entre 5 instâncias EC2. Health check: GET /health a cada 30s. Se instância não responder 3 vezes, é removida do pool."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__6",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "O que é um CDN (Content Delivery Network) e qual seu papel na nuvem?",
    "options": [
      "Rede de servidores distribuídos que entrega conteúdo a partir do ponto mais próximo do usuário",
      "Rede privada entre datacenters",
      "Serviço de DNS avançado",
      "Tipo de banco de dados distribuído"
    ],
    "correctIndex": 0,
    "explanation": "CDN cacheia conteúdo (imagens, vídeos, JS/CSS, APIs) em edge locations ao redor do mundo. Reduz latência, descarrega o origin server e protege contra DDoS. Exemplos: CloudFront (AWS), Cloud CDN (GCP), Azure CDN.",
    "example": "Sem CDN: usuário no Japão baixa imagem de servidor em SP (~250ms). Com CloudFront: edge location em Tokyo serve a imagem cacheada (~15ms). Cache hit ratio de 95% = origin recebe só 5% das requests."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__7",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "O que é um Service Mesh e quando é usado em arquiteturas cloud?",
    "options": [
      "Camada de infraestrutura para gerenciar comunicação entre microsserviços com observabilidade e segurança",
      "Tipo de rede física entre servidores",
      "Serviço de deploy automático",
      "Framework de frontend"
    ],
    "correctIndex": 0,
    "explanation": "Service mesh (Istio, Linkerd, AWS App Mesh) adiciona sidecar proxies a cada microsserviço para gerenciar tráfego: mTLS automático, circuit breakers, retries, observabilidade (métricas, traces). Sem alterar código da aplicação.",
    "example": "Istio injeta sidecar Envoy em cada pod Kubernetes. Tráfego entre microsserviços passa pelo Envoy que aplica: mTLS (criptografia), retry (3x), timeout (5s), canary routing (10% para v2)."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__8",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "Quando a estratégia active-active entre regiões é mais indicada que active-passive?",
    "options": [
      "Quando se busca menor latência global e failover quase imediato",
      "Quando se quer custo mínimo em qualquer cenário",
      "Quando não há necessidade de alta disponibilidade",
      "Quando a aplicação só aceita tráfego em uma AZ"
    ],
    "correctIndex": 0,
    "explanation": "Active-active atende tráfego simultâneo em múltiplas regiões, melhorando latência e continuidade. Active-passive tende a ser mais simples e barato, porém com failover mais lento.",
    "example": "Um SaaS global atende usuários da Europa em eu-west e das Américas em us-east; se uma região cair, a outra já está quente para absorver tráfego."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Médio__9",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Médio",
    "question": "Qual benefício principal de usar fila assíncrona entre dois microsserviços cloud?",
    "options": [
      "Absorver picos e reduzir acoplamento temporal entre produtor e consumidor",
      "Eliminar completamente a necessidade de observabilidade",
      "Garantir latência menor que chamada local sempre",
      "Substituir autenticação entre serviços"
    ],
    "correctIndex": 0,
    "explanation": "Filas desacoplam o ritmo entre serviços: o produtor publica rapidamente e o consumidor processa conforme capacidade, com retries e DLQ.",
    "example": "No pico de pedidos, o checkout publica mensagens na fila; o serviço de faturamento processa gradualmente sem derrubar a API principal."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__1",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "No padrão de resiliência 'bulkhead', qual é o objetivo principal ao isolar componentes de um sistema distribuído em nuvem?",
    "options": [
      "Evitar que a falha de um componente se propague para os demais",
      "Aumentar o throughput total do sistema",
      "Reduzir o custo de infraestrutura",
      "Simplificar o deploy contínuo"
    ],
    "correctIndex": 0,
    "explanation": "O padrão Bulkhead (antepara) isola recursos — como pools de threads ou conexões — de modo que a falha ou sobrecarga em um serviço não esgote os recursos usados por outros serviços, limitando o raio de impacto.",
    "example": "Em um microsserviço de pagamentos, você cria um pool de 20 threads exclusivo; se ele travar, o pool de 30 threads do serviço de catálogo continua operando normalmente."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__2",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "O que é o padrão Circuit Breaker em sistemas distribuídos na nuvem e quando ele é ativado?",
    "options": [
      "Interrompe chamadas a um serviço instável após falhas consecutivas, evitando cascata de erros",
      "Desliga fisicamente servidores defeituosos",
      "Balanceia carga entre serviços",
      "Criptografa comunicação entre microsserviços"
    ],
    "correctIndex": 0,
    "explanation": "O Circuit Breaker monitora falhas em chamadas a um serviço. Após um limiar de falhas (ex.: 5 erros em 10s), o circuito 'abre' e bloqueia novas chamadas por um período, retornando fallback imediato. Após o timeout, tenta uma chamada de teste (half-open) para verificar se o serviço se recuperou.",
    "example": "Estados: Closed (normal) → Open (bloqueando, após 5 falhas) → Half-Open (testa 1 requisição). Se o teste passar, volta a Closed. Bibliotecas: Resilience4j (Java), Polly (.NET), opossum (Node.js)."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__3",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre RTO (Recovery Time Objective) e RPO (Recovery Point Objective) em um plano de disaster recovery na nuvem?",
    "options": [
      "RTO é o tempo máximo aceitável para restaurar o serviço; RPO é a perda máxima de dados aceitável",
      "São sinônimos para tempo de backup",
      "RTO trata de dados e RPO de serviços",
      "RTO é automático e RPO é manual"
    ],
    "correctIndex": 0,
    "explanation": "RTO (Recovery Time Objective): quanto tempo o sistema pode ficar fora do ar. RPO (Recovery Point Objective): quanto tempo de dados pode ser perdido (ex: últimos 15 min). Estratégias: Backup & Restore (RTO alto, barato), Pilot Light, Warm Standby, Multi-site Active-Active (RTO baixo, caro).",
    "example": "E-commerce: RTO = 1h, RPO = 15min. Banco financeiro: RTO = 5min, RPO = 0. Quanto menor RTO/RPO, mais caro — multi-site active-active custa ~3x mais que backup & restore."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__4",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "O que é o padrão Saga em microsserviços distribuídos na nuvem?",
    "options": [
      "Padrão para gerenciar transações distribuídas usando sequência de transações locais com compensações",
      "Tipo de banco de dados distribuído",
      "Protocolo de caching",
      "Framework de testes"
    ],
    "correctIndex": 0,
    "explanation": "O padrão Saga divide uma transação distribuída em transações locais em cada microsserviço. Se uma etapa falhar, ações compensatórias desfazem as anteriores. Tipos: Coreografia (eventos) e Orquestração (coordenador central, ex: Step Functions).",
    "example": "Saga de pedido: 1) Reservar estoque → 2) Cobrar pagamento → 3) Enviar. Se pagamento falha, compensação desfaz reserva do estoque. Orquestração: Step Functions controla a sequência."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__5",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "O que é o CAP Theorem e como ele afeta decisões de arquitetura em nuvem?",
    "options": [
      "Um sistema distribuído pode garantir no máximo 2 de 3: Consistência, Disponibilidade e Tolerância a Partição",
      "Framework de segurança com 3 pilares",
      "Método de escalabilidade",
      "Protocolo de rede"
    ],
    "correctIndex": 0,
    "explanation": "CAP Theorem (Brewer): em caso de partição de rede (P), você deve escolher entre Consistência (C — todos os nós veem o mesmo dado) e Disponibilidade (A — toda requisição recebe resposta). CP: DynamoDB strong consistency. AP: Cassandra eventual consistency.",
    "example": "DynamoDB strongly consistent read: sempre dados atualizados (CP), mas pode dar erro se nó indisponível. Eventually consistent read: sempre responde (AP), mas pode retornar dado desatualizado por ~1s."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__6",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "O que é o padrão CQRS (Command Query Responsibility Segregation) em arquiteturas cloud?",
    "options": [
      "Separar modelos de leitura e escrita para otimizar cada um independentemente",
      "Protocolo de cache distribuído",
      "Tipo de banco de dados relacional",
      "Padrão de autenticação em microsserviços"
    ],
    "correctIndex": 0,
    "explanation": "CQRS separa operações de Command (escrita/mutação) e Query (leitura). O modelo de escrita pode usar banco normalizado (PostgreSQL), enquanto leitura usa modelo desnormalizado (ElasticSearch, DynamoDB). Sincronização via eventos.",
    "example": "E-commerce: POST /pedidos grava em PostgreSQL (transacional). GET /produtos/busca lê do ElasticSearch (rápido, full-text). Evento 'ProdutoAtualizado' sincroniza PostgreSQL → ElasticSearch via SQS/SNS."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__7",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "O que é o padrão Strangler Fig para migração de sistemas para nuvem?",
    "options": [
      "Migrar gradualmente funcionalidades do sistema legado para novos microsserviços, até substituí-lo completamente",
      "Desligar o sistema legado antes de migrar",
      "Manter dois sistemas idênticos rodando indefinidamente",
      "Reescrever todo o sistema simultaneamente"
    ],
    "correctIndex": 0,
    "explanation": "Strangler Fig: roteia tráfego seletivamente do monolito para novos serviços. Com o tempo, cada funcionalidade é migrada até que o monolito seja desligado. Usa API gateway ou proxy como router. Minimiza risco vs big-bang rewrite.",
    "example": "Monolito: /users, /orders, /payments. Fase 1: criar microsserviço de payments, proxy roteia /payments para ele. Fase 2: /orders migrado. Fase 3: /users migrado → monolito desligado."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__8",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "Por que idempotência é essencial quando há retry automático em sistemas distribuídos na nuvem?",
    "options": [
      "Porque evita efeitos duplicados quando a mesma operação é executada mais de uma vez",
      "Porque remove a necessidade de logs",
      "Porque impede qualquer timeout de rede",
      "Porque torna transações distribuídas desnecessárias"
    ],
    "correctIndex": 0,
    "explanation": "Retries são comuns por falhas transitórias. Sem idempotência, uma mesma mensagem pode gerar cobrança ou envio duplicado; com chave idempotente, repetições retornam o mesmo resultado.",
    "example": "A API de pagamento usa `idempotency_key` por pedido. Se ocorrer timeout e cliente reenviar, o gateway retorna a transação já criada, sem nova cobrança."
  },
  {
    "id": "cloud__Arquitetura em Nuvem__Difícil__9",
    "track": "cloud",
    "category": "Arquitetura em Nuvem",
    "difficulty": "Difícil",
    "question": "Em quais cenários consistência eventual é uma escolha arquitetural válida em cloud?",
    "options": [
      "Quando disponibilidade e escala global são prioritárias e pequenas janelas de defasagem são aceitáveis",
      "Quando toda leitura deve refletir escrita imediatamente",
      "Quando o domínio exige transações ACID globais em tempo real",
      "Quando não há particionamento de rede possível"
    ],
    "correctIndex": 0,
    "explanation": "Sistemas distribuídos globais frequentemente priorizam disponibilidade e latência. Consistência eventual funciona bem para catálogos, timelines e analytics, desde que o negócio aceite atraso curto.",
    "example": "Uma atualização de perfil pode levar alguns segundos para aparecer em todas as regiões, mas o serviço permanece disponível mesmo durante degradações parciais."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__1",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "Qual serviço da AWS é utilizado para armazenar objetos (arquivos) de forma durável e escalável?",
    "options": [
      "Amazon S3",
      "Amazon EC2",
      "Amazon RDS",
      "Amazon VPC"
    ],
    "correctIndex": 0,
    "explanation": "O Amazon S3 (Simple Storage Service) é um serviço de armazenamento de objetos com durabilidade de 99,999999999% (11 noves). Ele armazena qualquer tipo de arquivo como objetos em buckets.",
    "example": "Você cria um bucket chamado 'meu-app-imagens' e faz upload de fotos via SDK: s3.putObject({ Bucket: 'meu-app-imagens', Key: 'foto.jpg', Body: fileBuffer })."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__2",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "Qual serviço da AWS gerencia bancos de dados relacionais, cuidando de backups, patches e alta disponibilidade automaticamente?",
    "options": [
      "Amazon RDS",
      "Amazon DynamoDB",
      "Amazon S3",
      "Amazon ElastiCache"
    ],
    "correctIndex": 0,
    "explanation": "O Amazon RDS (Relational Database Service) é um serviço gerenciado que suporta MySQL, PostgreSQL, MariaDB, Oracle e SQL Server. A AWS cuida de backups automáticos, patching, failover Multi-AZ e read replicas.",
    "example": "aws rds create-db-instance --db-instance-identifier meu-banco --engine postgres --db-instance-class db.t3.micro --master-username admin --master-user-password senhaForte123 — cria um PostgreSQL gerenciado."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__3",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "Qual é a função do Amazon VPC (Virtual Private Cloud)?",
    "options": [
      "Criar uma rede virtual isolada na AWS para lançar recursos",
      "Armazenar arquivos estáticos",
      "Gerenciar containers Docker",
      "Monitorar custos da conta AWS"
    ],
    "correctIndex": 0,
    "explanation": "O Amazon VPC permite criar uma rede virtual logicamente isolada na nuvem AWS, com controle total sobre faixas de IP, sub-redes, route tables, internet gateways e security groups.",
    "example": "Crie VPC com CIDR 10.0.0.0/16, sub-rede pública 10.0.1.0/24 (com internet gateway) para web servers e sub-rede privada 10.0.2.0/24 (sem IG) para banco de dados."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__4",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "Qual serviço AWS permite enviar notificações push, e-mails e SMS a partir de um tópico centralizado?",
    "options": [
      "Amazon SNS",
      "Amazon SQS",
      "Amazon SES",
      "Amazon Pinpoint"
    ],
    "correctIndex": 0,
    "explanation": "O Amazon SNS (Simple Notification Service) é um serviço pub/sub gerenciado. Um tópico pode ter milhares de assinantes (Lambda, SQS, e-mail, SMS, HTTP). Quando uma mensagem é publicada no tópico, todos os assinantes a recebem simultaneamente.",
    "example": "aws sns publish --topic-arn arn:aws:sns:us-east-1:123:alertas --message 'Servidor fora do ar!' — envia para todos os assinantes: e-mail do CTO + SMS do SRE + Lambda de auto-healing."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__5",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "O que é o Amazon CloudWatch e para que serve?",
    "options": [
      "Serviço de monitoramento que coleta métricas, logs e alarmes para recursos AWS",
      "Serviço de deploy automático",
      "Banco de dados em memória",
      "Ferramenta de versionamento de código"
    ],
    "correctIndex": 0,
    "explanation": "CloudWatch coleta e visualiza métricas (CPU, rede, custom metrics), armazena logs (CloudWatch Logs), cria alarmes (ex: CPU > 80% → notificar) e dashboards. É o serviço central de monitoramento da AWS.",
    "example": "aws cloudwatch put-metric-alarm --alarm-name CPUAlta --metric-name CPUUtilization --threshold 80 --comparison-operator GreaterThanThreshold — cria alarme que dispara quando CPU > 80%."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__6",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "O que é o Amazon EC2 (Elastic Compute Cloud)?",
    "options": [
      "Serviço que fornece servidores virtuais (instâncias) com capacidade computacional redimensionável",
      "Serviço de armazenamento de arquivos",
      "Banco de dados gerenciado",
      "Ferramenta de deploy de containers"
    ],
    "correctIndex": 0,
    "explanation": "EC2 permite lançar máquinas virtuais (instâncias) em minutos, escolhendo SO, tipo de CPU/RAM, armazenamento EBS e rede. Você paga por hora ou segundo de uso. É o serviço de computação mais fundamental da AWS.",
    "example": "Lançar instância: aws ec2 run-instances --image-id ami-abc123 --instance-type t3.micro --key-name minha-chave. Modelos de preço: On-Demand, Reserved, Spot (até 90% desconto)."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__7",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "O que é o AWS IAM (Identity and Access Management)?",
    "options": [
      "Serviço gratuito para gerenciar usuários, grupos, roles e permissões de acesso aos recursos AWS",
      "Serviço de banco de dados de identidades",
      "Ferramenta de monitoramento de segurança",
      "VPN gerenciada pela AWS"
    ],
    "correctIndex": 0,
    "explanation": "IAM controla QUEM pode fazer O QUÊ nos recursos AWS. Componentes: Users (pessoas), Groups (conjuntos de users), Roles (assumidas por serviços), Policies (JSON definindo permissões). Princípio do menor privilégio: dar apenas o necessário.",
    "example": "Policy: { Effect: 'Allow', Action: 's3:GetObject', Resource: 'arn:aws:s3:::meu-bucket/*' } → permite apenas leitura de objetos em um bucket específico. MFA obrigatório para conta root."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__8",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "Qual serviço da AWS é indicado para armazenar segredos de aplicação com rotação automatizada?",
    "options": [
      "AWS Secrets Manager",
      "Amazon CloudWatch",
      "Amazon S3 Glacier",
      "AWS Auto Scaling"
    ],
    "correctIndex": 0,
    "explanation": "Secrets Manager armazena credenciais e tokens com criptografia, controle de acesso via IAM e rotação automática integrada para vários bancos.",
    "example": "Uma aplicação lê senha do RDS no Secrets Manager em vez de salvar no código-fonte ou em arquivo `.env` versionado."
  },
  {
    "id": "cloud__AWS — Fundamentos__Fácil__9",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Fácil",
    "question": "Na AWS, qual serviço fornece armazenamento em bloco para EC2?",
    "options": [
      "Amazon EBS",
      "Amazon S3",
      "Amazon Athena",
      "AWS Lambda"
    ],
    "correctIndex": 0,
    "explanation": "EBS (Elastic Block Store) entrega volumes de bloco persistentes para instâncias EC2, com snapshots e diferentes níveis de performance.",
    "example": "Um servidor web em EC2 usa volume EBS gp3 de 100 GB para sistema operacional e dados da aplicação."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__1",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "Qual tipo de instância EC2 é mais adequado para cargas de trabalho que exigem alto desempenho de CPU, como modelagem científica?",
    "options": [
      "Compute Optimized (C)",
      "Memory Optimized (R)",
      "Storage Optimized (I)",
      "General Purpose (T)"
    ],
    "correctIndex": 0,
    "explanation": "Instâncias Compute Optimized (família C, como c5.xlarge) possuem processadores de alta frequência e são ideais para workloads CPU-intensive como computação científica, modelagem financeira e encoding de vídeo.",
    "example": "Para rodar simulações de Monte Carlo, você escolhe c5.4xlarge com 16 vCPUs de alta frequência, em vez de t3.xlarge que tem CPU com burst limitado."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__2",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "No Amazon S3, qual classe de armazenamento é mais econômica para dados acessados raramente, mas que precisam estar disponíveis em milissegundos?",
    "options": [
      "S3 Standard-IA",
      "S3 Glacier",
      "S3 Standard",
      "S3 Glacier Deep Archive"
    ],
    "correctIndex": 0,
    "explanation": "S3 Standard-IA (Infrequent Access) tem custo de armazenamento menor que Standard, mas cobra por acesso. Dados ficam disponíveis instantaneamente (milissegundos). Glacier leva minutos a horas para recuperar e é para arquivamento de longo prazo.",
    "example": "Logs de auditoria acessados 1-2x/mês: Standard-IA (0.0125 USD/GB). Dados acessados diariamente: Standard (0.023 USD/GB). Backups antigos: Glacier (~0.004 USD/GB)."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__3",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "Qual é a diferença entre Security Group e Network ACL na AWS?",
    "options": [
      "SG é stateful e opera por instância; NACL é stateless e opera por sub-rede",
      "São idênticos",
      "NACL é stateful e SG stateless",
      "SG opera na sub-rede e NACL na instância"
    ],
    "correctIndex": 0,
    "explanation": "Security Group: stateful (resposta automática), opera na instância, permite apenas regras Allow. Network ACL: stateless (regras de entrada e saída independentes), opera na sub-rede, permite regras Allow e Deny com numeração de prioridade.",
    "example": "SG: 'permitir TCP 443 de 0.0.0.0/0' — a resposta de saída é automática. NACL: precisa de regra de entrada E saída separadas. NACL é a primeira linha de defesa (sub-rede), SG é a segunda (instância)."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__4",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "O que são Reserved Instances e Savings Plans na AWS e quando usá-los?",
    "options": [
      "Compromissos de 1 ou 3 anos com desconto de até 72% em instâncias EC2",
      "Instâncias gratuitas para testes",
      "Instâncias com prioridade de rede",
      "Planos de suporte técnico"
    ],
    "correctIndex": 0,
    "explanation": "Reserved Instances (RI) e Savings Plans oferecem descontos de até 72% vs On-Demand em troca de compromisso de 1 ou 3 anos. RI: tipo/região fixos. Savings Plans: mais flexíveis (qualquer tipo/região). Ideal para workloads previsíveis e estáveis.",
    "example": "EC2 On-Demand: $0.046/h. RI 1 ano all-upfront: $0.028/h (39% desconto). Savings Plan 3 anos: $0.019/h (59% desconto). Para servidor de banco 24/7, RI economiza ~$158/ano por instância."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__5",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "O que é o Amazon Route 53 e quais funcionalidades oferece?",
    "options": [
      "Serviço DNS gerenciado com health checks, roteamento geográfico e failover",
      "Proxy reverso para EC2",
      "CDN da AWS",
      "Firewall de rede"
    ],
    "correctIndex": 0,
    "explanation": "Route 53 é o serviço de DNS escalável da AWS. Oferece: registro de domínios, resolução DNS com SLA 100%, health checks, e políticas de roteamento (simple, weighted, latency-based, geolocation, failover).",
    "example": "Route 53 com failover: health check monitora servidor primário. Se falhar, DNS automaticamente resolve para servidor secundário em outra região. Latency-based: resolve para a região com menor latência para o usuário."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__6",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "O que é o Amazon DynamoDB e quando usá-lo em vez de RDS?",
    "options": [
      "Banco NoSQL serverless de chave-valor/documento; ideal para alta escala com latência consistente de milissegundos",
      "Banco relacional gerenciado",
      "Armazenamento de arquivos",
      "Serviço de filas de mensagens"
    ],
    "correctIndex": 0,
    "explanation": "DynamoDB é NoSQL serverless com latência de um dígito de milissegundo em qualquer escala. Usar quando: esquema flexível, alta throughput, acesso por chave primária. RDS: queries complexas (JOINs), transações ACID, esquema relacional.",
    "example": "DynamoDB: sessões de usuário, carrinho de compras, IoT events (milhões de writes/s). RDS: relatórios financeiros com JOINs complexos. DynamoDB DAX: cache in-memory para leituras em microssegundos."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__7",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "O que são Spot Instances na AWS e qual o risco?",
    "options": [
      "Instâncias EC2 com até 90% de desconto, mas podem ser interrompidas pela AWS com aviso de 2 minutos",
      "Instâncias gratuitas para testing",
      "Instâncias com garantia de disponibilidade 100%",
      "Instâncias reservadas por 3 anos"
    ],
    "correctIndex": 0,
    "explanation": "Spot Instances usam capacidade ociosa da AWS com desconto de até 90%. A AWS pode reclamar a instância com 2 min de aviso quando precisar da capacidade. Ideal para workloads tolerantes a interrupção: batch processing, CI/CD, ML training.",
    "example": "On-Demand c5.xlarge: $0.17/h. Spot: ~$0.05/h (70% desconto). Estratégia: misturar On-Demand + Spot em ASG. Spot Fleet diversifica entre tipos (c5, m5, r5) e AZs para reduzir interrupções."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__8",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "Qual é a principal diferença entre EBS e Instance Store em instâncias EC2?",
    "options": [
      "EBS é persistente; Instance Store é efêmero e perdido ao parar/encerrar instância",
      "EBS é efêmero; Instance Store é persistente",
      "Ambos são idênticos em durabilidade",
      "Instance Store é um serviço de objetos"
    ],
    "correctIndex": 0,
    "explanation": "EBS persiste além do ciclo da instância e permite snapshots. Instance Store usa discos locais do host físico e perde dados quando a instância é interrompida/terminada.",
    "example": "Cache temporário pode usar Instance Store; banco de dados de produção deve usar EBS com backup via snapshots."
  },
  {
    "id": "cloud__AWS — Fundamentos__Médio__9",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Médio",
    "question": "Quando usar URL pré-assinada (pre-signed URL) no Amazon S3?",
    "options": [
      "Para conceder acesso temporário e restrito a objetos sem expor credenciais AWS",
      "Para tornar bucket público permanentemente",
      "Para substituir criptografia em repouso",
      "Para criar usuários IAM automaticamente"
    ],
    "correctIndex": 0,
    "explanation": "Pre-signed URL encapsula permissão temporária com expiração, permitindo download/upload controlado sem distribuir chaves de acesso.",
    "example": "Backend gera URL válida por 10 minutos para o cliente enviar um arquivo diretamente ao S3."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__1",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "Em uma política IAM da AWS, qual elemento define explicitamente as ações que são negadas, tendo prioridade sobre qualquer Allow?",
    "options": [
      "Explicit Deny no campo Effect",
      "Principal",
      "Resource com wildcard",
      "Condition com IpAddress"
    ],
    "correctIndex": 0,
    "explanation": "Na avaliação de políticas IAM, um Deny explícito sempre prevalece sobre qualquer Allow. Se qualquer política anexada ao principal contiver Effect: Deny para uma ação, ela será negada independentemente de outras políticas permissivas.",
    "example": "{ \"Effect\": \"Deny\", \"Action\": \"s3:DeleteBucket\", \"Resource\": \"*\" } impede exclusão de qualquer bucket, mesmo que outra política conceda s3:* Allow."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__2",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "Na AWS, o que é o AWS Organizations e como SCPs (Service Control Policies) diferem de IAM Policies?",
    "options": [
      "SCPs definem limites máximos de permissão para contas inteiras; IAM Policies concedem permissões dentro desses limites",
      "São a mesma coisa",
      "IAM é para organizações e SCP para usuários",
      "SCPs substituem completamente IAM"
    ],
    "correctIndex": 0,
    "explanation": "AWS Organizations gerencia múltiplas contas AWS. SCPs são guardrails que definem o TETO de permissões para contas/OUs — não concedem acesso, apenas limitam. IAM Policies DENTRO da conta concedem permissões efetivas, que não podem exceder o que a SCP permite.",
    "example": "SCP na OU 'Produção': Deny ec2:TerminateInstances. Mesmo que um admin IAM na conta tenha ec2:*, ele NÃO consegue terminar instâncias — a SCP é o teto."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__3",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "O que é o AWS Well-Architected Framework e quais são seus pilares?",
    "options": [
      "Framework com 6 pilares: Excelência Operacional, Segurança, Confiabilidade, Eficiência de Performance, Otimização de Custos e Sustentabilidade",
      "Ferramenta de deploy automático com 3 pilares",
      "Serviço de monitoramento com 4 pilares",
      "Framework de migração com 5 pilares"
    ],
    "correctIndex": 0,
    "explanation": "O Well-Architected Framework é um conjunto de boas práticas organizado em 6 pilares para projetar e operar workloads confiáveis, seguros, eficientes e econômicos na nuvem. A Sustentabilidade foi adicionada como 6º pilar em 2021.",
    "example": "Use o AWS Well-Architected Tool para executar reviews contra os 6 pilares e receber recomendações. Exemplo: pilar de Confiabilidade recomenda multi-AZ para bancos de dados críticos."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__4",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "O que é o AWS CloudTrail e por que é essencial para segurança e auditoria?",
    "options": [
      "Serviço que registra todas as chamadas de API feitas na conta AWS para auditoria",
      "Ferramenta de monitoramento de métricas",
      "CDN para distribuição de logs",
      "Serviço de backup automático"
    ],
    "correctIndex": 0,
    "explanation": "CloudTrail registra toda chamada de API na conta AWS: quem fez, quando, de onde, o quê. Essencial para auditoria, investigação de incidentes e compliance. Eventos são armazenados por padrão 90 dias (console) ou indefinidamente em S3.",
    "example": "CloudTrail registrou: 'IAM user 'dev-joao' chamou ec2:TerminateInstances às 03:47 do IP 198.51.100.5 para instância i-abc123'. Investigação: credencial comprometida, 2FA não estava ativo."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__5",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre o AWS Config e o AWS CloudTrail?",
    "options": [
      "CloudTrail registra AÇÕES (quem fez o quê); Config registra ESTADO dos recursos ao longo do tempo",
      "São o mesmo serviço",
      "CloudTrail é para estado e Config para ações",
      "Config substitui CloudTrail"
    ],
    "correctIndex": 0,
    "explanation": "CloudTrail: log de API calls (ações). AWS Config: snapshot contínuo do estado e configuração dos recursos. Config Rules avaliam se recursos estão em compliance (ex: 'todo bucket deve ter encryption'). Juntos: CloudTrail mostra quem mudou, Config mostra o antes e depois.",
    "example": "Security group aberto para 0.0.0.0/0:22. Config rule detecta non-compliance. CloudTrail mostra: user 'junior-dev' executou authorize-security-group-ingress às 14:20. Remediação automática: Config auto-remediation reverte."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__6",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "O que é o AWS Control Tower e como gerencia ambientes multi-account?",
    "options": [
      "Serviço que configura e governa um ambiente multi-account seguro com guardrails automatizados",
      "Painel de custos da AWS",
      "Serviço de migração de dados",
      "Ferramenta de debug de aplicações"
    ],
    "correctIndex": 0,
    "explanation": "Control Tower automatiza a criação de um landing zone com Organizations, SSO, CloudTrail centralizado e guardrails (SCPs + Config Rules). Guardrails: preventivos (SCP bloqueiam ações) e detectivos (Config Rules alertam violações).",
    "example": "Control Tower cria: Log Archive account (logs centralizados), Audit account (segurança), sandbox OU. Guardrail: 'Disallow changes to CloudTrail' — nenhuma conta pode desativar auditoria."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__7",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "O que é o AWS Cost Explorer e como ajuda na otimização de custos?",
    "options": [
      "Ferramenta de visualização e análise de custos com recomendações de otimização",
      "Serviço de deploy automático",
      "Ferramenta de monitoramento de performance",
      "Serviço de backup gerenciado"
    ],
    "correctIndex": 0,
    "explanation": "Cost Explorer oferece dashboards de gastos por serviço, conta, região, tag. Mostra tendências, previsões e recomendações de RI/Savings Plans. Permite criar relatórios customizados e alertas de budget.",
    "example": "Cost Explorer mostra: EC2 é 60% do gasto, 30% das instâncias têm CPU < 5% (oversized). Recomendação: downsizar de m5.2xlarge para m5.large = economia de $200/mês. Budgets: alerta quando gasto > $1000/mês."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__8",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "Como `AssumeRole` do AWS STS melhora segurança em ambientes multi-conta?",
    "options": [
      "Fornece credenciais temporárias, reduzindo uso de chaves de longo prazo",
      "Desativa necessidade de IAM",
      "Replica políticas automaticamente entre regiões",
      "Elimina logs de auditoria"
    ],
    "correctIndex": 0,
    "explanation": "STS emite credenciais temporárias com escopo e duração limitados. Isso reduz exposição de segredos estáticos e facilita governança entre contas via roles.",
    "example": "Pipeline na conta de CI assume role na conta de produção por 15 minutos apenas para executar deploy autorizado."
  },
  {
    "id": "cloud__AWS — Fundamentos__Difícil__9",
    "track": "cloud",
    "category": "AWS — Fundamentos",
    "difficulty": "Difícil",
    "question": "Por que separar contas de segurança, produção e desenvolvimento no AWS Organizations é boa prática?",
    "options": [
      "Porque isola blast radius, melhora governança e permite aplicar SCPs por OU",
      "Porque reduz latência de rede automaticamente",
      "Porque elimina necessidade de backups",
      "Porque evita uso de IAM"
    ],
    "correctIndex": 0,
    "explanation": "A segmentação por contas limita impacto de incidentes e facilita políticas distintas de acesso, custos, auditoria e conformidade por ambiente.",
    "example": "Conta dedicada de logs centraliza CloudTrail/Config e impede que workloads de dev alterem trilhas de auditoria de produção."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__1",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço da AWS permite executar consultas SQL interativas diretamente em dados armazenados no S3, sem precisar de um servidor de banco de dados?",
    "options": [
      "Amazon Athena",
      "Amazon Redshift",
      "Amazon DynamoDB",
      "Amazon Aurora"
    ],
    "correctIndex": 0,
    "explanation": "O Amazon Athena é um serviço serverless de consulta interativa que usa SQL padrão para analisar dados diretamente no S3. Você paga apenas pelas consultas executadas, sem necessidade de provisionar infraestrutura.",
    "example": "SELECT count(*) FROM s3_logs WHERE status = 404 — essa query roda no Athena sobre arquivos Parquet no S3 sem nenhum banco configurado."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__2",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço da AWS permite busca e análise de logs em tempo real de forma gerenciada?",
    "options": [
      "Amazon OpenSearch Service",
      "Amazon Athena",
      "Amazon S3 Select",
      "AWS Glue"
    ],
    "correctIndex": 0,
    "explanation": "O Amazon OpenSearch Service (antigo Elasticsearch Service) é um serviço gerenciado para busca, análise e visualização de logs e dados em tempo real. Integra-se com Kibana/OpenSearch Dashboards para visualização e com Logstash/Fluentd para ingestão.",
    "example": "Envie logs do CloudWatch para OpenSearch via subscription filter. Crie dashboards no OpenSearch Dashboards para visualizar erros 5xx em tempo real com alertas."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__3",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço AWS é usado para processar streams de dados em tempo real, como dados de IoT ou clickstream?",
    "options": [
      "Amazon Kinesis Data Streams",
      "Amazon SQS",
      "Amazon SNS",
      "AWS Batch"
    ],
    "correctIndex": 0,
    "explanation": "O Amazon Kinesis Data Streams captura e processa grandes volumes de dados em tempo real (streams). Diferente do SQS (mensageria assíncrona), o Kinesis permite processar dados ordenados com múltiplos consumidores simultaneamente, ideal para analytics em tempo real.",
    "example": "Dispositivos IoT enviam 10.000 eventos/seg para um stream Kinesis com 10 shards. Um consumer Lambda processa em tempo real e outro consumer grava no S3 para análise histórica."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__4",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço AWS é usado para transferir dados de data warehouse e análise OLAP em petabytes?",
    "options": [
      "Amazon Redshift",
      "Amazon RDS",
      "Amazon DynamoDB",
      "Amazon ElastiCache"
    ],
    "correctIndex": 0,
    "explanation": "Amazon Redshift é um data warehouse colunar totalmente gerenciado para análise OLAP em petabytes. Usa Massively Parallel Processing (MPP) e armazenamento colunar comprimido. Redshift Spectrum permite queries em dados no S3 sem importá-los.",
    "example": "Redshift cluster: 4 nós ra3.xlplus. Query: SELECT product, SUM(revenue) FROM sales WHERE year=2025 GROUP BY product — processa 500GB de dados em 8 segundos usando MPP."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__5",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "O que é o AWS Glue e para que serve?",
    "options": [
      "Serviço serverless de ETL que descobre, prepara e combina dados para análise",
      "Cola para colar snapshots de EC2",
      "Serviço de CDN",
      "Proxy de APIs"
    ],
    "correctIndex": 0,
    "explanation": "AWS Glue é um serviço ETL (Extract, Transform, Load) serverless. O Glue Crawler descobre e cataloga dados no S3/RDS automaticamente. O Glue Data Catalog é um metastore central para Athena, Redshift e EMR.",
    "example": "Glue Crawler escaneia CSVs no S3 → cria tabela no Data Catalog com schema inferido → Athena consulta via SQL sem setup. Glue ETL Job transforma dados JSON → Parquet para otimizar queries."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__6",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "O que é o Amazon SQS (Simple Queue Service)?",
    "options": [
      "Serviço de filas de mensagens gerenciado para desacoplar componentes de aplicações distribuídas",
      "Serviço de notificação push",
      "Banco de dados de mensagens",
      "CDN para mensagens"
    ],
    "correctIndex": 0,
    "explanation": "SQS é um serviço de filas totalmente gerenciado que permite desacoplar producers e consumers. Mensagens ficam na fila até serem processadas. Integra-se com Lambda, EC2 e ECS. Dead Letter Queue (DLQ) captura mensagens que falharam repetidamente.",
    "example": "Fluxo: usuário faz pedido → API publica na fila SQS → Lambda consome a mensagem → processa pagamento. Se API recebe 1000 pedidos/seg, SQS absorve o pico e Lambda processa no ritmo possível."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__7",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "O que é o AWS Lambda e qual a diferença para EC2?",
    "options": [
      "Serviço serverless que executa código sem gerenciar servidores; EC2 requer gerenciar instâncias",
      "Lambda é mais potente que EC2",
      "EC2 é serverless e Lambda não",
      "Lambda substitui bancos de dados"
    ],
    "correctIndex": 0,
    "explanation": "Lambda executa código em resposta a eventos (API Gateway, S3, SQS) sem provisionar servidores. Paga por execução (ms). Timeout máx: 15 min. EC2: servidor full, paga por hora, sem limite de tempo. Lambda para funções curtas; EC2 para workloads longas.",
    "example": "Lambda: redimensionar imagem quando upload no S3. 200ms de execução com 256MB RAM = ~$0.000000833. EC2 t3.micro 24/7: ~$8.50/mês mesmo ocioso. Lambda ideal para cargas intermitentes."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__8",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço da AWS migra bancos de dados com replicação contínua e baixo downtime?",
    "options": [
      "AWS Database Migration Service (DMS)",
      "Amazon Route 53",
      "AWS WAF",
      "Amazon CloudFront"
    ],
    "correctIndex": 0,
    "explanation": "O AWS DMS suporta migração homogênea e heterogênea, permitindo full load com CDC (change data capture) para minimizar indisponibilidade.",
    "example": "Uma empresa migra Oracle on-prem para Aurora com DMS replicando mudanças até o momento do cutover."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Fácil__9",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço da AWS entrega dados de streaming diretamente para S3, Redshift ou OpenSearch de forma gerenciada?",
    "options": [
      "Amazon Kinesis Data Firehose",
      "AWS CodePipeline",
      "Amazon EC2",
      "AWS CloudFormation"
    ],
    "correctIndex": 0,
    "explanation": "Kinesis Data Firehose coleta, transforma opcionalmente e entrega streams em destinos analíticos sem gerenciar consumidores customizados.",
    "example": "Eventos de clique chegam no Firehose e são gravados no S3 em lotes comprimidos para análise posterior."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__1",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "No Amazon SQS, qual é a diferença fundamental entre filas Standard e FIFO?",
    "options": [
      "FIFO garante ordem exata e entrega única; Standard oferece maior throughput sem garantia de ordem",
      "Standard é mais caro que FIFO",
      "FIFO suporta mensagens maiores que Standard",
      "Standard não permite Dead Letter Queue"
    ],
    "correctIndex": 0,
    "explanation": "Filas FIFO (First-In-First-Out) garantem que as mensagens sejam processadas exatamente uma vez e na ordem exata de envio, com throughput de até 3.000 msg/s com batching. Filas Standard oferecem throughput praticamente ilimitado, mas podem entregar mensagens duplicadas e fora de ordem.",
    "example": "Para processar pedidos financeiros onde a ordem importa, use SQS FIFO (minha-fila.fifo). Para notificações por e-mail onde duplicatas são aceitáveis, use Standard."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__2",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "Qual é a função do Amazon EventBridge (antigo CloudWatch Events) em arquiteturas orientadas a eventos?",
    "options": [
      "Barramento de eventos serverless que roteia eventos entre serviços AWS, SaaS e aplicações personalizadas",
      "Banco de dados de eventos",
      "Serviço de filas de mensagens",
      "CDN para distribuição de eventos"
    ],
    "correctIndex": 0,
    "explanation": "O EventBridge é um event bus serverless que recebe eventos de serviços AWS (ex: estado de EC2 mudou), aplicações SaaS (Zendesk, Datadog) e eventos customizados, roteando-os para targets (Lambda, SQS, Step Functions) baseado em regras de padrão (event patterns).",
    "example": "Regra: quando EC2 instanceState = 'stopped' → invocar Lambda de notificação. Pattern: { 'source': ['aws.ec2'], 'detail-type': ['EC2 Instance State-change Notification'], 'detail': { 'state': ['stopped'] } }."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__3",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "No Amazon DynamoDB, o que são GSIs (Global Secondary Indexes) e quando usá-los?",
    "options": [
      "Índices com partition key diferente da tabela principal, permitindo queries por atributos alternativos",
      "Backups globais do banco",
      "Réplicas em outras regiões",
      "Cache em memória para queries frequentes"
    ],
    "correctIndex": 0,
    "explanation": "GSI permite criar índices com uma partition key e sort key diferentes da tabela base, habilitando queries eficientes por atributos que não são a chave primária. Cada GSI é uma projeção esparsada da tabela com throughput provisionado independente.",
    "example": "Tabela 'Pedidos' com PK=pedidoId. GSI 'por-cliente': PK=clienteId, SK=dataPedido. Query 'todos pedidos do cliente X ordenados por data' usa o GSI em vez de scan na tabela."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__4",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "O que é o Amazon ElastiCache e quando usar Redis vs Memcached?",
    "options": [
      "Serviço de cache em memória gerenciado; Redis para estruturas complexas, Memcached para cache simples",
      "Serviço de armazenamento em disco",
      "CDN para conteúdo estático",
      "Banco NoSQL gerenciado"
    ],
    "correctIndex": 0,
    "explanation": "ElastiCache oferece Redis e Memcached gerenciados. Redis: persistência, replicação, Pub/Sub, tipos complexos (sorted sets, hashes), Lua scripting. Memcached: multi-thread, mais simples, apenas key-value volátil. Redis é mais versátil; Memcached para cache puro horizontal.",
    "example": "Redis para sessões de usuário com TTL: SET session:abc123 '{\"userId\":42}' EX 3600. Memcached para cache de queries SQL simples: SET query_hash result. Redis suporta cluster com sharding automático."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__5",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "O que é o AWS CloudFront e para que serve?",
    "options": [
      "CDN global que distribui conteúdo em edge locations para reduzir latência",
      "Firewall de aplicação web",
      "Serviço de DNS",
      "Balanceador de carga regional"
    ],
    "correctIndex": 0,
    "explanation": "CloudFront é CDN da AWS com 400+ PoPs (Points of Presence) globais. Cacheia conteúdo estático (imagens, CSS, JS) e dinâmico próximo ao usuário. Integra-se com S3, ALB, EC2 e Lambda@Edge. Suporta HTTPS, HTTP/3 e WebSocket.",
    "example": "Origem S3 no us-east-1. Usuário no Brasil acessa via CloudFront PoP em São Paulo (~5ms) em vez de ir ao S3 diretamente (~150ms). Invalidation: aws cloudfront create-invalidation --paths '/img/*'."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__6",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "O que é o Amazon EKS (Elastic Kubernetes Service)?",
    "options": [
      "Serviço gerenciado de Kubernetes que opera o control plane sem gerenciamento manual",
      "Serviço de email da AWS",
      "Ferramenta de ETL",
      "CDN para containers"
    ],
    "correctIndex": 0,
    "explanation": "EKS gerencia o control plane do Kubernetes (API server, etcd, scheduler) com SLA 99,95%. Você gerencia os worker nodes (EC2 ou Fargate). Integra com IAM, ALB, CloudWatch, VPC nativamente.",
    "example": "eksctl create cluster --name meu-cluster --region us-east-1 --nodegroup-name workers --node-type t3.medium --nodes 3. kubectl apply -f deployment.yaml — mesmo workflow K8s, infra gerenciada pela AWS."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__7",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "O que é o Amazon SNS vs SQS e quando usar cada um?",
    "options": [
      "SNS é pub/sub (fan-out para múltiplos assinantes); SQS é fila (um consumer por mensagem)",
      "São idênticos",
      "SQS é pub/sub e SNS é fila",
      "SNS substitui SQS completamente"
    ],
    "correctIndex": 0,
    "explanation": "SNS (pub/sub): uma mensagem vai para MÚLTIPLOS assinantes simultaneamente (Lambda, SQS, email). SQS (fila): mensagem vai para UM consumer. Padrão fan-out: SNS publica → múltiplas filas SQS assinam → cada fila processa independentemente.",
    "example": "Pedido recebido → SNS publica 'PedidoCriado'. Assinantes: SQS-pagamento (processa cobrança), SQS-estoque (reserva itens), SQS-email (envia confirmação). Fan-out: cada serviço recebe a mesma mensagem."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__8",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "Em leitura escalável na AWS, quando usar réplica de leitura no Aurora/RDS?",
    "options": [
      "Quando há alto volume de leitura e necessidade de aliviar a instância primária",
      "Quando o objetivo é aumentar escrita transacional",
      "Quando se quer substituir backups automáticos",
      "Quando não existe aplicação de banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "Read replicas distribuem consultas de leitura, preservando o nó primário para escrita e reduzindo contenção de recursos.",
    "example": "Relatórios e dashboards apontam para read replica, enquanto operações de checkout seguem no writer."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Médio__9",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Médio",
    "question": "Para fan-out com múltiplos consumidores e desacoplamento, qual abordagem AWS é mais comum?",
    "options": [
      "Publicar no SNS e assinar filas SQS por consumidor",
      "Enviar tudo para uma única instância EC2",
      "Substituir mensageria por tabelas temporárias",
      "Usar apenas CloudWatch Logs como broker"
    ],
    "correctIndex": 0,
    "explanation": "SNS distribui mensagens para vários assinantes e cada consumidor pode ter sua própria fila SQS, com retries e DLQ independentes.",
    "example": "Evento 'pedido_confirmado' é publicado no SNS; faturamento, antifraude e analytics consomem em filas separadas."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__1",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "Ao configurar o AWS Step Functions com o padrão 'Map State' para processamento paralelo, qual é o limite padrão de execuções concorrentes e como otimizá-lo?",
    "options": [
      "40 iterações concorrentes por padrão; usar MaxConcurrency para ajustar",
      "Sem limite; usar Retry para controlar",
      "10 iterações; usar Parallel State em vez de Map",
      "100 iterações; ativar Express Workflows"
    ],
    "correctIndex": 0,
    "explanation": "O Map State do Step Functions processa itens em paralelo com MaxConcurrency padrão de 40. Você pode ajustar esse valor para controlar o paralelismo e evitar throttling em serviços downstream. Para volumes massivos, Express Workflows são recomendados.",
    "example": "{ \"Type\": \"Map\", \"MaxConcurrency\": 100, \"Iterator\": { ... } } — processa até 100 itens simultaneamente de um array de entrada."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__2",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "No AWS Lambda, o que são Lambda Layers e qual problema elas resolvem?",
    "options": [
      "Pacotes compartilhados de código/dependências reutilizáveis entre múltiplas funções Lambda",
      "Camadas de segurança adicionais",
      "Níveis de log do CloudWatch",
      "Tiers de preço do Lambda"
    ],
    "correctIndex": 0,
    "explanation": "Lambda Layers são arquivos ZIP contendo bibliotecas, runtimes customizados ou dados compartilhados. Até 5 layers por função. Evitam duplicação de código/dependências entre funções, reduzem tamanho do pacote de deploy e facilitam atualizações centralizadas.",
    "example": "Crie uma layer 'shared-utils' com lodash e moment.js. Associe a 20 funções Lambda. Ao atualizar lodash, publique nova versão da layer — todas as funções usam a versão atualizada sem redeploy individual."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__3",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "Como o Amazon Aurora Serverless v2 gerencia a escalabilidade e quando utilizá-lo em vez do Aurora provisionado?",
    "options": [
      "Escala automaticamente capacidade de leitura/escrita em incrementos granulares (ACUs) baseado na demanda",
      "Desliga completamente quando sem tráfego",
      "Apenas escala leituras, não escritas",
      "Requer configuração manual de auto-scaling"
    ],
    "correctIndex": 0,
    "explanation": "Aurora Serverless v2 escala em incrementos de 0.5 ACU (Aurora Capacity Units), respondendo a mudanças de carga em segundos. Diferente do provisionado (tamanho fixo de instância), adapta-se automaticamente a picos e vales de demanda. Ideal para workloads imprevisíveis ou intermitentes.",
    "example": "Config: min 0.5 ACU, max 64 ACU. Noite: 0.5 ACU (~$0.06/h). Pico: 32 ACU (~$3.84/h). Vs provisionado db.r5.4xlarge fixo a $2.74/h 24/7. Serverless economiza 60% para cargas variáveis."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__4",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "O que é o AWS ECS Fargate e como difere do ECS com EC2 launch type?",
    "options": [
      "Fargate é serverless para contêineres — sem gerenciar instâncias EC2; EC2 launch type requer gerenciar o cluster",
      "São idênticos",
      "EC2 launch type é serverless",
      "Fargate não suporta Docker"
    ],
    "correctIndex": 0,
    "explanation": "ECS Fargate: serverless, você define CPU/memória por tarefa e a AWS provisiona infraestrutura automaticamente. ECS EC2: você gerencia instâncias EC2 do cluster (AMI, scaling, patching). Fargate é mais simples; EC2 dá mais controle e pode ser mais econômico para workloads grandes.",
    "example": "Fargate: task com 1 vCPU + 2GB RAM → AWS aloca automaticamente, zero gerenciamento de servidor. EC2 launch type: crie ASG com c5.xlarge, gerencie AMI, configure draining. Use Fargate para simplicidade, EC2 para controle de custo."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__5",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "O que são AWS Step Functions e quando usá-las?",
    "options": [
      "Serviço de orquestração visual para coordenar múltiplos serviços AWS em workflows",
      "Funções Lambda com mais timeout",
      "Framework de testes de integração",
      "CI/CD nativo da AWS"
    ],
    "correctIndex": 0,
    "explanation": "Step Functions orquestram workflows com estados: Task, Choice (if/else), Parallel, Map (loop), Wait. Integram-se nativamente com Lambda, ECS, SNS, SQS, DynamoDB. Dois tipos: Standard (até 1 ano, exatamente uma vez) e Express (até 5 min, alta taxa).",
    "example": "Workflow de processamento de pedido: StartState → ValidarPedido (Lambda) → Choice (estoque?) → Sim: CobrarPagamento → EnviarEmail → End. Não: NotificarSemEstoque → End. Tudo visual e com retry automático."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__6",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "O que é o AWS Lake Formation e como simplifica a criação de data lakes?",
    "options": [
      "Serviço que automatiza coleta, limpeza, cataloging e segurança de dados em um data lake no S3",
      "Serviço de criação de bancos relacionais",
      "Ferramenta de backup para S3",
      "CDN para dados analíticos"
    ],
    "correctIndex": 0,
    "explanation": "Lake Formation automatiza: ingestão de dados de múltiplas fontes, transformação ETL, cataloging (Glue Data Catalog), e controle de acesso granular (column-level security). Centraliza governança do data lake.",
    "example": "Sem Lake Formation: configuração manual de Glue crawlers + IAM policies + S3 bucket policies para cada tabela. Com Lake Formation: interface visual para dar permissão 'usuário X pode ver colunas A,B da tabela Y'."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__7",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "O que é o padrão de Event Sourcing e como se complementa com CQRS na AWS?",
    "options": [
      "Armazenar todos os eventos de mutação como fonte de verdade; CQRS separa modelos de leitura e escrita",
      "Backup baseado em eventos do CloudTrail",
      "Cache de eventos no ElastiCache",
      "Streaming de vídeo em tempo real"
    ],
    "correctIndex": 0,
    "explanation": "Event Sourcing persiste cada mudança de estado como evento imutável (append-only log). O estado atual é reconstruído reproduzindo eventos. Combinado com CQRS: eventos são a fonte de escrita; projections materializam views otimizadas para leitura.",
    "example": "Conta bancária: eventos [Aberta(R$0), Depósito(R$100), Saque(R$30), Depósito(R$50)]. Saldo = replay: 0+100-30+50 = R$120. AWS: Kinesis (event store) + DynamoDB (read model) + Lambda (projections)."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__8",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "Como a escolha da shard key no Kinesis impacta throughput e latência?",
    "options": [
      "Chaves mal distribuídas geram hot shards e gargalo; boa distribuição equilibra carga",
      "Shard key afeta apenas criptografia",
      "Shard key não influencia particionamento",
      "Toda chave cria throughput ilimitado"
    ],
    "correctIndex": 0,
    "explanation": "No Kinesis, partição é definida pela shard key. Baixa cardinalidade concentra tráfego em poucos shards; alta cardinalidade distribui melhor ingestão e consumo.",
    "example": "Usar `customerId` com poucos valores cria hot shard; combinar `customerId#timestampBucket` melhora balanceamento."
  },
  {
    "id": "cloud__AWS — Serviços Avançados__Difícil__9",
    "track": "cloud",
    "category": "AWS — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "Qual trade-off aparece ao buscar semântica quase exactly-once com SQS FIFO e deduplicação?",
    "options": [
      "Maior garantia de ordem/deduplicação com menor throughput e maior complexidade de idempotência",
      "Throughput máximo sem qualquer custo",
      "Eliminação total de necessidade de DLQ",
      "Substituição de observabilidade por padrão"
    ],
    "correctIndex": 0,
    "explanation": "SQS FIFO melhora ordem e deduplicação, mas possui limites de throughput e ainda exige consumidores idempotentes para lidar com reentregas e falhas.",
    "example": "Processamento financeiro usa FIFO por grupo de pedido para preservar ordem, aceitando menor taxa de mensagens por segundo."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__1",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "No Microsoft Azure, qual é o nome do serviço que permite criar e gerenciar máquinas virtuais na nuvem?",
    "options": [
      "Azure Virtual Machines",
      "Azure Functions",
      "Azure Blob Storage",
      "Azure SQL Database"
    ],
    "correctIndex": 0,
    "explanation": "Azure Virtual Machines é o serviço IaaS do Azure que permite provisionar VMs com Windows ou Linux, escolhendo tamanho, região e imagem do sistema operacional.",
    "example": "Você cria uma VM pelo portal: az vm create --name minhaVM --image UbuntuLTS --size Standard_B2s --resource-group meuGrupo."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__2",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "No Azure, qual serviço é equivalente ao Amazon S3 para armazenamento de objetos?",
    "options": [
      "Azure Blob Storage",
      "Azure Files",
      "Azure Disk Storage",
      "Azure Table Storage"
    ],
    "correctIndex": 0,
    "explanation": "O Azure Blob Storage armazena objetos (blobs) de forma massiva e escalável. Suporta tiers de acesso: Hot (acesso frequente), Cool (acesso esporádico) e Archive (arquivamento). É o serviço de armazenamento de objetos do Azure, análogo ao S3.",
    "example": "az storage blob upload --container-name imagens --file foto.jpg --name foto.jpg --account-name meuStorage — faz upload de um arquivo para o Blob Storage."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__3",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "O que são as Availability Zones (Zonas de Disponibilidade) do Azure?",
    "options": [
      "Datacenters fisicamente separados dentro de uma mesma região Azure",
      "Regiões diferentes do Azure",
      "Tipos de assinatura",
      "Níveis de suporte"
    ],
    "correctIndex": 0,
    "explanation": "Availability Zones são locais fisicamente separados (datacenters independentes) dentro de uma região Azure, cada um com energia, refrigeração e rede independentes. Distribuir recursos entre zonas protege contra falhas de datacenter individual.",
    "example": "Região 'Brazil South' tem 3 AZs. Crie VM1 na AZ1 e VM2 na AZ2 com Load Balancer. Se AZ1 falhar, VM2 continua respondendo. SLA sobe de 99,9% (single VM) para 99,99% (multi-AZ)."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__4",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "O que é o Azure App Service e qual tipo de aplicação ele hospeda?",
    "options": [
      "Serviço PaaS para hospedar aplicações web, APIs e back-ends sem gerenciar infraestrutura",
      "Serviço de máquinas virtuais",
      "Banco de dados gerenciado",
      "CDN do Azure"
    ],
    "correctIndex": 0,
    "explanation": "Azure App Service é PaaS que hospeda apps web em .NET, Java, Node.js, Python e PHP. Oferece auto-scaling, deploy slots (staging/prod), SSL gerenciado e integração com CI/CD. Sem gerenciar SO ou servidor.",
    "example": "az webapp up --name minha-api --runtime 'NODE:18-lts' --sku B1 — deploya um app Node.js no App Service com plano Basic, incluindo SSL gratuito e domínio customizado."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__5",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "O que é o Azure SQL Database e como difere de SQL Server em uma VM?",
    "options": [
      "Banco relacional PaaS gerenciado pelo Azure; VM dá controle total mas requer gerenciar o servidor",
      "São idênticos",
      "VM é gerenciada e PaaS não",
      "Azure SQL não suporta T-SQL"
    ],
    "correctIndex": 0,
    "explanation": "Azure SQL Database: PaaS, Azure gerencia patching, backups, HA. Você configura DTUs/vCores. SQL Server em VM: IaaS, controle total (versão, configurações avançadas), mas você gerencia SO e patches. PaaS para simplicidade; VM para customização máxima.",
    "example": "Azure SQL Database: backup automático com retenção de 7-35 dias, geo-replication com 1 clique, escalar de 2 a 128 vCores sem downtime. SQL em VM: precisa configurar Always On AG manualmente."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__6",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "O que é o Azure Resource Manager (ARM)?",
    "options": [
      "Camada de gerenciamento que permite criar, atualizar e excluir recursos Azure via templates declarativos",
      "Gerenciador de memória RAM das VMs",
      "Ferramenta de monitoramento",
      "Banco de dados gerenciado"
    ],
    "correctIndex": 0,
    "explanation": "ARM é o plano de gerenciamento do Azure. Todas as requisições (portal, CLI, SDK) passam pelo ARM. ARM Templates (JSON) ou Bicep permitem deploy declarativo e reproduzível de infraestrutura (Infrastructure as Code).",
    "example": "ARM Template define: VM + VNet + NSG + IP público em JSON. az deployment group create --template-file main.bicep — cria todos os recursos de uma vez. Idempotente: rodar 2x não duplica recursos."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__7",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "O que é o Azure Cosmos DB?",
    "options": [
      "Banco de dados NoSQL distribuído globalmente com múltiplos modelos de consistência",
      "Banco relacional gerenciado",
      "Serviço de cache em memória",
      "Data warehouse"
    ],
    "correctIndex": 0,
    "explanation": "Cosmos DB é NoSQL multi-modelo (document, key-value, graph, column-family) com distribuição global, SLA de 99,999%, latência <10ms p99. 5 níveis de consistência: Strong, Bounded Staleness, Session, Consistent Prefix, Eventual.",
    "example": "Cosmos DB com API MongoDB: app existente migra sem alterar código. Replicação global: dados em Brazil South + East US + West Europe. Consistência Session: mesma sessão sempre lê o que escreveu."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__8",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "No Azure, qual serviço é usado para guardar segredos, chaves e certificados com segurança?",
    "options": [
      "Azure Key Vault",
      "Azure Monitor",
      "Azure DNS",
      "Azure DevTest Labs"
    ],
    "correctIndex": 0,
    "explanation": "Azure Key Vault centraliza gerenciamento de segredos e chaves com controle de acesso, auditoria e integração com managed identities.",
    "example": "Uma API no App Service busca string de conexão no Key Vault durante startup, sem expor segredo no código."
  },
  {
    "id": "cloud__Azure — Fundamentos__Fácil__9",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Fácil",
    "question": "Qual recurso do Azure organiza serviços de um projeto para facilitar gestão e billing?",
    "options": [
      "Resource Group",
      "Availability Zone",
      "Subscription Policy",
      "Tenant"
    ],
    "correctIndex": 0,
    "explanation": "Resource Group é contêiner lógico para recursos relacionados, simplificando permissões, tags, automação e custo por projeto.",
    "example": "App, banco e storage de 'crm-prod' ficam no mesmo Resource Group para aplicar RBAC e políticas em conjunto."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__1",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "No Azure, qual recurso permite agrupar e gerenciar todos os serviços relacionados a um projeto, aplicando políticas e controle de acesso de forma centralizada?",
    "options": [
      "Resource Group",
      "Management Group",
      "Subscription",
      "Azure AD Tenant"
    ],
    "correctIndex": 0,
    "explanation": "Resource Group é um contêiner lógico que agrupa recursos relacionados do Azure (VMs, bancos, redes). Permite gerenciamento conjunto, aplicação de tags, políticas de acesso RBAC e exclusão em massa de todos os recursos do grupo.",
    "example": "Crie o grupo 'rg-ecommerce-prod' e coloque nele a VM, o SQL Database e o App Service do projeto. Para excluir tudo: az group delete --name rg-ecommerce-prod."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__2",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "No Azure, o que é o Azure Active Directory (Entra ID) e qual sua função principal?",
    "options": [
      "Serviço de identidade e acesso baseado na nuvem para autenticação e autorização",
      "Servidor de banco de dados",
      "Serviço de armazenamento de arquivos",
      "Firewall de rede"
    ],
    "correctIndex": 0,
    "explanation": "O Azure AD (renomeado para Microsoft Entra ID) é o serviço de identidade na nuvem da Microsoft. Gerencia autenticação SSO, MFA, acesso condicional, e integra-se com Microsoft 365, Azure e milhares de aplicações SaaS via protocolos OAuth 2.0 e SAML.",
    "example": "Funcionários fazem login com MFA no Azure AD. O Conditional Access permite: 'se dispositivo não é gerenciado, bloqueie acesso ao SharePoint'. SSO permite acesso ao Salesforce, Slack e portal interno com uma única credencial."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__3",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "Qual é a função do Azure Key Vault?",
    "options": [
      "Gerenciar segredos, chaves criptográficas e certificados de forma centralizada e segura",
      "Armazenar backups criptografados",
      "Criar redes virtuais seguras",
      "Monitorar ameaças de segurança"
    ],
    "correctIndex": 0,
    "explanation": "O Azure Key Vault armazena e gerencia segredos (connection strings, API keys), chaves criptográficas (RSA, EC) e certificados TLS/SSL. Usa HSMs para proteger chaves. Integra-se com Azure RBAC para controle de acesso granular.",
    "example": "Em vez de hardcoded: const connStr = 'Server=...;Password=123', use: const connStr = await keyVaultClient.getSecret('db-connection-string'). Segredos são rotacionados sem alterar o código."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__4",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "No Azure, o que são NSGs (Network Security Groups) e como funcionam?",
    "options": [
      "Regras de firewall que filtram tráfego de rede para recursos Azure por IP, porta e protocolo",
      "Grupos de recursos para networking",
      "Backups de configuração de rede",
      "VPNs automáticas"
    ],
    "correctIndex": 0,
    "explanation": "NSGs contêm regras de segurança (Allow/Deny) com prioridade numérica, filtradas por IP de origem/destino, porta e protocolo. Podem ser associados a sub-redes ou NICs individuais. Regras são avaliadas por prioridade (menor número = maior prioridade).",
    "example": "NSG na sub-rede web: regra 100 Allow TCP 443 de Internet (HTTPS), regra 200 Allow TCP 80 de Internet (HTTP), regra 300 Deny * de Internet (bloqueia o resto). Regras Azure padrão permitem tráfego interno da VNet."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__5",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "O que é o Azure Monitor e quais dados ele coleta?",
    "options": [
      "Plataforma de monitoramento que coleta métricas, logs e traces de recursos Azure",
      "Ferramenta de deploy automático",
      "Gerenciador de identidades",
      "CDN para logs"
    ],
    "correctIndex": 0,
    "explanation": "Azure Monitor coleta: métricas (CPU, memória, requests), logs de atividade (quem fez o quê), logs de diagnóstico (performance detalhada), e Application Insights (APM para apps). Integra-se com Log Analytics (KQL), alertas e dashboards.",
    "example": "Azure Monitor → Application Insights: latência p95 = 340ms, taxa de erro 2.1%. Alerta: 'se requests falhando > 5% por 5 min, notifique no Teams'. Log Analytics KQL: AzureActivity | where OperationName == 'Delete'."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__6",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "O que é o Azure DevOps e quais serviços oferece?",
    "options": [
      "Plataforma de DevOps com repos Git, pipelines CI/CD, boards, test plans e artefatos",
      "Serviço de hospedagem de VMs",
      "Banco de dados para DevOps",
      "CDN para código-fonte"
    ],
    "correctIndex": 0,
    "explanation": "Azure DevOps oferece: Repos (Git), Pipelines (CI/CD), Boards (Kanban/Scrum), Test Plans e Artifacts (pacotes npm/Maven). Alternativa: GitHub Actions integrado ao Azure. Suporta deploy para qualquer cloud.",
    "example": "Pipeline YAML: trigger em push na main → build Node.js → npm test → Docker build → push ACR → deploy no AKS. Azure Boards: backlog com sprints, linked a pull requests e builds."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__7",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "O que é o Azure RBAC (Role-Based Access Control)?",
    "options": [
      "Sistema de permissões baseado em roles atribuídas a usuários, grupos ou service principals",
      "Firewall de rede baseado em regras",
      "Sistema de backup baseado em roles",
      "Tipo de criptografia"
    ],
    "correctIndex": 0,
    "explanation": "RBAC atribui roles (Owner, Contributor, Reader, custom) a principals (usuários, grupos, managed identities) em um escopo (management group, subscription, resource group, recurso). Principle of least privilege: dar só o necessário.",
    "example": "az role assignment create --role 'Contributor' --assignee user@empresa.com --scope /subscriptions/abc/resourceGroups/rg-prod. Usuário pode criar/editar recursos no rg-prod, mas não deletar a subscription."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__8",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "Quando Azure Files é mais adequado que Blob Storage?",
    "options": [
      "Quando aplicações precisam de compartilhamento SMB/NFS como file server",
      "Quando só há acesso HTTP a objetos imutáveis",
      "Quando é necessário data warehouse",
      "Quando se busca mensageria pub/sub"
    ],
    "correctIndex": 0,
    "explanation": "Azure Files expõe share de arquivos por SMB/NFS; Blob é armazenamento de objetos via API/HTTP, ideal para conteúdo estático e data lake.",
    "example": "Sistemas legados que dependem de unidade de rede mapeada usam Azure Files; imagens de site público ficam em Blob."
  },
  {
    "id": "cloud__Azure — Fundamentos__Médio__9",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Médio",
    "question": "Qual benefício do Azure Policy para equipes de plataforma?",
    "options": [
      "Aplicar governança contínua com regras de conformidade em escala",
      "Aumentar vCPU de VMs automaticamente",
      "Substituir RBAC para autenticação",
      "Eliminar auditoria de recursos"
    ],
    "correctIndex": 0,
    "explanation": "Azure Policy avalia recursos contra regras (ex.: exigir tags, bloquear SKU proibida, forçar criptografia), evitando drift de compliance.",
    "example": "Uma política 'Deny' impede criação de Storage sem TLS mínimo 1.2 em todas as subscriptions de produção."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__1",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "No Azure Policy, qual é a diferença entre os efeitos 'Deny' e 'DeployIfNotExists'?",
    "options": [
      "Deny bloqueia a criação do recurso; DeployIfNotExists cria automaticamente um recurso complementar se ausente",
      "Deny e DeployIfNotExists fazem a mesma coisa",
      "DeployIfNotExists bloqueia e Deny corrige",
      "Deny é para tags e DeployIfNotExists para redes"
    ],
    "correctIndex": 0,
    "explanation": "O efeito Deny impede a criação ou alteração de recursos que não cumprem a política. Já DeployIfNotExists verifica se um recurso complementar existe (ex.: extensão de diagnóstico) e, se não existir, o cria automaticamente via template ARM durante a avaliação.",
    "example": "Política Deny: impede VMs sem tag 'CentroCusto'. Política DeployIfNotExists: se uma VM não tiver o Azure Monitor Agent instalado, a política dispara um deployment que instala automaticamente."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__2",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "No Azure, qual é o papel do Azure Landing Zone e quais componentes ele padroniza?",
    "options": [
      "Arquitetura pré-configurada com networking, identidade, governança e segurança para escalar na nuvem",
      "Zona de DNS para domínios públicos",
      "Região geográfica prioritária para deploy",
      "Ferramenta de migração de servidores on-premises"
    ],
    "correctIndex": 0,
    "explanation": "Azure Landing Zone é uma arquitetura de referência que padroniza Management Groups, Subscriptions, Networking (hub-spoke), Identity (Entra ID), Governance (Policy, Blueprints) e Security (Defender for Cloud). Permite que novas workloads sejam lançadas em um ambiente pré-configurado e compliant.",
    "example": "Landing Zone inclui: Hub VNet com Firewall + Bastion, Spoke VNets para workloads, Policy assignments para compliance, Log Analytics centralizado, RBAC por subscription. Novas equipes recebem uma subscription pronta com guardrails."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__3",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "Como funciona o Azure Private Link e qual problema de segurança ele resolve?",
    "options": [
      "Permite acessar serviços PaaS via IP privado na VNet, sem expor tráfego à internet pública",
      "Cria VPNs entre regiões",
      "Criptografa dados em repouso",
      "Gerencia certificados SSL"
    ],
    "correctIndex": 0,
    "explanation": "O Azure Private Link cria um private endpoint na sua VNet com um IP privado que se conecta diretamente ao serviço PaaS (Storage, SQL Database, etc.). O tráfego nunca sai da rede backbone da Microsoft, eliminando exposição à internet pública e reduzindo a superfície de ataque.",
    "example": "Sem Private Link: App → Internet → Storage Account (IP público). Com Private Link: App → 10.0.1.5 (private endpoint) → Storage Account. O Storage pode ter 'Deny public access' ativado, acessível apenas via VNet."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__4",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "O que é o Azure Bastion e por que usá-lo em vez de expor SSH/RDP diretamente?",
    "options": [
      "Serviço PaaS que fornece acesso seguro SSH/RDP a VMs via navegador sem expor portas à internet",
      "VPN client-to-site",
      "Firewall de rede virtual",
      "Load balancer para SSH"
    ],
    "correctIndex": 0,
    "explanation": "Azure Bastion é um PaaS que serve como jump host gerenciado. Conecta a VMs via RDP/SSH pelo portal Azure (navegador), sem precisar de IP público na VM ou abrir portas 22/3389 para a internet. Elimina exposição da superfície de ataque.",
    "example": "Sem Bastion: VM com IP público + NSG permitindo 22/0.0.0.0 = risco de brute force. Com Bastion: VM sem IP público, acesso via portal Azure → Bastion → SSH, tráfego via TLS pelo backbone Microsoft."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__5",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "O que é o Azure Cost Management e como ajuda a otimizar gastos en nuvem?",
    "options": [
      "Ferramenta que analisa gastos, cria orçamentos e recomenda otimizações de custo",
      "Plano de desconto por volume",
      "Cálculo automático de ROI",
      "Estimativa de custos de migração"
    ],
    "correctIndex": 0,
    "explanation": "Azure Cost Management permite: visualizar custos por recurso/tag/subscription, criar budgets com alertas (ex: notificar quando atingir 80%), forecast de gastos e Azure Advisor recomendações (ex: reduzir VM ociosa, comprar Reserved Instances).",
    "example": "Budget mensal: R$5.000. Alerta em 80% (R$4.000). Advisor: 'VM Standard_D4 com 10% CPU média → redimensionar para Standard_B2s, economia de R$800/mês'. Cost analysis: 45% compute, 30% storage, 15% networking."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__6",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "O que é o Azure Arc e como estende o gerenciamento além do Azure?",
    "options": [
      "Serviço que projeta gerenciamento Azure (policies, RBAC, monitoring) para servidores on-prem e multi-cloud",
      "Tipo de rede virtual do Azure",
      "Ferramenta de migração de VMs",
      "CDN global do Azure"
    ],
    "correctIndex": 0,
    "explanation": "Azure Arc estende o plano de controle do Azure para fora do Azure: servidores on-premises, VMs em AWS/GCP, e clusters Kubernetes. Permite aplicar Azure Policy, RBAC, Monitor e Defender for Cloud a recursos não-Azure.",
    "example": "Servidor Linux on-prem registrado no Arc: aparece no portal Azure, recebe Azure Policy (compliance), Azure Monitor (métricas/logs), Defender for Cloud (vulnerabilidades). Gestão unificada híbrida."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__7",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "Como funciona o Azure Front Door e quando usá-lo?",
    "options": [
      "Serviço global de load balancing L7 com WAF, cache e aceleração para aplicações distribuídas",
      "Firewall de rede L4",
      "VPN entre regiões Azure",
      "DNS privado"
    ],
    "correctIndex": 0,
    "explanation": "Azure Front Door opera na borda global da Microsoft: roteamento inteligente (latência, prioridade, peso), TLS offloading, caching, WAF integrado. Ideal para apps multi-região que precisam de failover global e baixa latência.",
    "example": "App em Brazil South + East US. Front Door roteia usuários brasileiros para Brazil South (20ms) e americanos para East US (15ms). Se Brazil South cair, failover automático para East US em <30s."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__8",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "Como o Privileged Identity Management (PIM) no Entra ID reduz risco de privilégios excessivos?",
    "options": [
      "Concede acesso administrativo just-in-time e com expiração",
      "Cria usuários locais para cada VM",
      "Desabilita MFA para administradores",
      "Replica permissões sem aprovação"
    ],
    "correctIndex": 0,
    "explanation": "PIM reduz privilégios permanentes, exigindo elevação temporária com aprovação, justificativa e auditoria para funções sensíveis.",
    "example": "Um operador ativa role de Contributor por 1 hora para manutenção e depois o acesso retorna automaticamente ao estado mínimo."
  },
  {
    "id": "cloud__Azure — Fundamentos__Difícil__9",
    "track": "cloud",
    "category": "Azure — Fundamentos",
    "difficulty": "Difícil",
    "question": "Em rede Azure hub-and-spoke, qual vantagem principal do modelo?",
    "options": [
      "Centralizar serviços compartilhados e segurança no hub, isolando workloads nos spokes",
      "Eliminar necessidade de roteamento",
      "Forçar todos os serviços na mesma VNet",
      "Substituir completamente Azure Firewall"
    ],
    "correctIndex": 0,
    "explanation": "Hub-and-spoke melhora governança de rede ao concentrar inspeção, DNS e conectividade híbrida no hub, mantendo segmentação por ambiente nos spokes.",
    "example": "Spokes de dev/prod usam peering com hub que hospeda firewall e gateway VPN, reduzindo regras duplicadas."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__1",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço do Azure permite criar aplicações web e APIs sem gerenciar a infraestrutura do servidor?",
    "options": [
      "Azure App Service",
      "Azure Virtual Machines",
      "Azure Disk Storage",
      "Azure VPN Gateway"
    ],
    "correctIndex": 0,
    "explanation": "O Azure App Service é um serviço PaaS que hospeda aplicações web, APIs REST e back-ends móveis. Suporta .NET, Java, Node.js, Python e PHP, com escalonamento automático e deploy integrado.",
    "example": "az webapp create --name meu-api --plan meuPlano --runtime 'NODE:18-lts' — cria uma aplicação Node.js sem configurar servidor."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__2",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço do Azure permite executar funções de código sem servidor, acionadas por eventos?",
    "options": [
      "Azure Functions",
      "Azure App Service",
      "Azure Batch",
      "Azure Logic Apps"
    ],
    "correctIndex": 0,
    "explanation": "O Azure Functions é o serviço FaaS (Function as a Service) do Azure. Executa código sob demanda em resposta a triggers: HTTP, Timer, Blob Storage, Queue, Event Hub. Cobra apenas pelo tempo de execução (consumption plan).",
    "example": "Uma Azure Function dispara quando um blob é adicionado ao container 'uploads': @BlobTrigger('uploads/{name}') — processa a imagem automaticamente sem servidor dedicado."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__3",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "O que é o Azure DevOps e quais serviços ele oferece?",
    "options": [
      "Plataforma completa com Boards, Repos, Pipelines, Test Plans e Artifacts",
      "Apenas controle de versão",
      "Apenas CI/CD",
      "Serviço de monitoramento"
    ],
    "correctIndex": 0,
    "explanation": "Azure DevOps é uma suíte de ferramentas de desenvolvimento: Azure Boards (gestão ágil), Azure Repos (Git), Azure Pipelines (CI/CD), Azure Test Plans (testes) e Azure Artifacts (pacotes). Integra-se com GitHub e ferramentas de terceiros.",
    "example": "Crie um projeto no Azure DevOps, use Boards com Scrum, Repos para código, Pipelines com YAML para build/deploy e Artifacts para publicar pacotes npm internos."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__4",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço Azure é usado para processar e analisar grandes volumes de dados de forma serverless?",
    "options": [
      "Azure Synapse Analytics",
      "Azure Blob Storage",
      "Azure App Service",
      "Azure Functions"
    ],
    "correctIndex": 0,
    "explanation": "Azure Synapse Analytics (antigo SQL Data Warehouse) unifica big data e data warehousing. Oferece SQL pools (dedicado e serverless), Apache Spark pools, pipelines de integração de dados e integração com Power BI. Tudo em uma plataforma.",
    "example": "Synapse serverless SQL: query direta em Parquet no Data Lake sem provisionar infra. Spark pool: processa 1TB de logs com PySpark. Pipeline: orquestra ETL do Blob para SQL pool dedicado."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__5",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "O que é o Azure Container Instances (ACI) e quando usá-lo?",
    "options": [
      "Serviço para rodar contêineres individualmente sem orquestração, ideal para tarefas simples",
      "Kubernetes gerenciado",
      "Registry de imagens Docker",
      "VM com Docker pré-instalado"
    ],
    "correctIndex": 0,
    "explanation": "ACI roda contêineres sob demanda sem gerenciar VMs ou clusters. Ideal para tarefas pontuais (batch, CI, testes), sidecar containers e burst from AKS (virtual nodes). Não tem orquestração — para workloads complexos, use AKS.",
    "example": "az container create --name meu-batch --image meuacr.azurecr.io/batch:v1 --cpu 2 --memory 4 --restart-policy Never — roda um job de processamento e para ao finalizar. Sem cluster para gerenciar."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__6",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "O que é o Azure Key Vault e para que serve?",
    "options": [
      "Serviço para armazenar e gerenciar secrets, chaves de criptografia e certificados de forma centralizada",
      "Cofre físico para discos de backup",
      "Banco de dados criptografado",
      "Gerenciador de senhas pessoal"
    ],
    "correctIndex": 0,
    "explanation": "Azure Key Vault armazena secrets (connection strings, API keys), chaves de criptografia (RSA, EC) e certificados TLS. Acesso via RBAC e Azure AD. HSM-backed para compliance. Rotação automática de secrets integrada com serviços Azure.",
    "example": "az keyvault secret set --vault-name meu-vault --name DB-CONN --value 'Server=...'. App Service lê: @Microsoft.KeyVault(SecretUri=https://meu-vault.vault.azure.net/secrets/DB-CONN). Zero secrets no app settings."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__7",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "O que é o Azure Service Bus e quando usá-lo?",
    "options": [
      "Serviço de mensageria enterprise com filas e tópicos pub/sub para comunicação assíncrona confiável",
      "Ônibus de rede entre VNets",
      "CDN para APIs",
      "Serviço de DNS"
    ],
    "correctIndex": 0,
    "explanation": "Service Bus oferece filas (point-to-point) e tópicos (pub/sub) com garantias enterprise: FIFO, deduplicação, sessões, dead-letter, transações. Ideal para integração entre microsserviços que requerem entrega garantida e ordenação.",
    "example": "Fila: pedido criado → mensagem na fila → serviço de pagamento consome. Tópico: evento 'PedidoAprovado' → assinantes: estoque (reserva), email (confirma), analytics (registra). Entrega garantida com retry."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__8",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço do Azure é voltado para ingestão de eventos em alto volume (telemetria/streaming)?",
    "options": [
      "Azure Event Hubs",
      "Azure Key Vault",
      "Azure Policy",
      "Azure DNS"
    ],
    "correctIndex": 0,
    "explanation": "Event Hubs é plataforma de streaming com alta taxa de ingestão para cenários como IoT, logs e telemetria.",
    "example": "Milhares de dispositivos enviam eventos por segundo para Event Hubs antes do processamento analítico."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Fácil__9",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Fácil",
    "question": "Qual serviço Azure fornece busca full-text gerenciada para aplicações?",
    "options": [
      "Azure AI Search",
      "Azure Batch",
      "Azure Firewall",
      "Azure Private DNS"
    ],
    "correctIndex": 0,
    "explanation": "Azure AI Search indexa dados e oferece consultas textuais avançadas com filtros, ranking e recursos semânticos.",
    "example": "Portal de produtos usa AI Search para autocomplete e filtragem por preço/categoria em milissegundos."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__1",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "No Azure Cosmos DB, o que representa a unidade 'Request Unit' (RU)?",
    "options": [
      "Uma medida normalizada de throughput que combina CPU, memória e IOPS",
      "O número de documentos lidos por segundo",
      "A quantidade de armazenamento em GB",
      "O número de réplicas ativas"
    ],
    "correctIndex": 0,
    "explanation": "Request Unit (RU) é a moeda de throughput do Cosmos DB. Uma leitura pontual de um documento de 1 KB custa 1 RU. Operações mais complexas (queries, escritas) consomem mais RUs. Você provisiona RU/s por contêiner ou banco.",
    "example": "Se você provisiona 400 RU/s e cada leitura custa 1 RU, pode fazer ~400 leituras/s. Uma query com filtro pode custar 5 RUs, permitindo ~80 queries/s."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__2",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "No Azure, o que é um Managed Identity e como ele melhora a segurança?",
    "options": [
      "Identidade gerenciada pelo Azure AD que elimina necessidade de armazenar credenciais no código",
      "Conta de usuário para administradores",
      "Tipo de criptografia para discos",
      "Certificado SSL automático"
    ],
    "correctIndex": 0,
    "explanation": "Managed Identity é uma identidade Azure AD atribuída automaticamente a recursos (VMs, App Services, Functions). O Azure gerencia a rotação de credenciais. O recurso se autentica no Azure AD sem secrets, connection strings ou certificados no código.",
    "example": "App Service com System-Assigned Managed Identity: const credential = new DefaultAzureCredential(); const secret = await client.getSecret('minha-key'). Zero secrets no código ou variáveis de ambiente."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__3",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "Qual serviço Azure permite orquestrar workflows complexos de forma visual, integrando centenas de conectores SaaS e serviços Azure?",
    "options": [
      "Azure Logic Apps",
      "Azure Functions",
      "Azure Data Factory",
      "Azure Automation"
    ],
    "correctIndex": 0,
    "explanation": "Azure Logic Apps é um serviço de integração serverless com designer visual e 400+ conectores (Office 365, Salesforce, SAP, etc.). Permite criar workflows automatizados sem código, orquestrando ações entre diferentes sistemas.",
    "example": "Workflow: quando e-mail com anexo chega no Outlook → salvar no SharePoint → notificar no Teams → criar tarefa no Jira. Tudo configurado visualmente sem código."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__4",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "O que é o Azure Kubernetes Service (AKS) e o que ele gerencia automaticamente?",
    "options": [
      "Kubernetes gerenciado onde o Azure administra o control plane e você gerencia os nós worker",
      "Docker Compose gerenciado",
      "Serverless para contêineres como Cloud Run",
      "VM com kubectl pré-instalado"
    ],
    "correctIndex": 0,
    "explanation": "AKS é Kubernetes gerenciado: Azure gerencia o control plane (API server, etcd, scheduler, controller manager) gratuitamente. Você gerencia node pools (VMs worker). Integra com Azure AD, Monitor, Policy e Container Registry.",
    "example": "az aks create --name meu-cluster --node-count 3 --enable-managed-identity — cria cluster K8s com 3 nós. Control plane: zero custo e zero gerenciamento. Scale: az aks scale --node-count 10."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__5",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "O que é o Azure Data Factory e para que é utilizado?",
    "options": [
      "Serviço de integração de dados que orquestra pipelines ETL/ELT entre diversas fontes",
      "Banco de dados fabril",
      "Serviço de machine learning",
      "Ferramenta de BI"
    ],
    "correctIndex": 0,
    "explanation": "Azure Data Factory (ADF) é um serviço de integração de dados (ETL/ELT) com 90+ conectores (SQL, S3, Salesforce, SAP). Pipelines visuais orquestram atividades de cópia, transformação (Mapping Data Flows) e controle (If, ForEach, Wait).",
    "example": "Pipeline ADF: Copy Activity (CSV do Blob → staging SQL) → Data Flow (limpar/transformar) → Copy (staging → produção). Trigger: rodar todo dia às 2h. Monitor: visualizar execuções e erros."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__6",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "O que é o Azure Event Grid e como ele difere do Event Hub?",
    "options": [
      "Event Grid é roteamento de eventos discretos (reativo); Event Hub é ingestão massiva de streaming em tempo real",
      "São idênticos",
      "Event Hub é para eventos discretos",
      "Event Grid faz streaming"
    ],
    "correctIndex": 0,
    "explanation": "Event Grid: eventos discretos (blob criado, resource alterado) → roteamento para handlers (Functions, Logic Apps). Event Hub: streaming de alta vazão (milhões/s) para telemetria, logs, IoT. Event Grid é reativo; Event Hub é ingestão massiva.",
    "example": "Event Grid: blob criado no Storage → Function processa imagem. Event Hub: 10.000 dispositivos IoT enviando telemetria/s → Stream Analytics agrega → Power BI exibe dashboard real-time."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__7",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "O que é o Azure Cache for Redis e quando usá-lo?",
    "options": [
      "Serviço gerenciado de cache em memória baseado em Redis para acelerar acesso a dados frequentes",
      "Banco de dados relacional em cache",
      "CDN para arquivos estáticos",
      "Serviço de backup incremental"
    ],
    "correctIndex": 0,
    "explanation": "Azure Cache for Redis é Redis totalmente gerenciado: cache (session store, page cache), broker de mensagens (pub/sub) e data store temporário. Tiers: Basic (dev), Standard (replicado), Premium (cluster, VNet, persistência).",
    "example": "App autenticado: session no Redis (TTL 30min) em vez de bank query toda request. Latência: Redis <1ms vs SQL ~20ms. Pattern cache-aside: busca no Redis → miss → busca no SQL → grava no Redis → retorna."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__8",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "Quando escolher Azure Functions no plano Premium em vez de Consumption?",
    "options": [
      "Quando precisa evitar cold start e usar VNet com escala previsível",
      "Quando não há qualquer requisito de latência",
      "Quando quer custo fixo zero em todos os cenários",
      "Quando a função nunca recebe tráfego"
    ],
    "correctIndex": 0,
    "explanation": "Premium mantém instâncias pré-aquecidas e suporta cenários de rede avançados, adequado para workloads sensíveis a latência.",
    "example": "API de pagamentos com p95 rigoroso migra de Consumption para Premium para reduzir variação por cold start."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Médio__9",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Médio",
    "question": "No Azure Service Bus, quando usar Topic em vez de Queue?",
    "options": [
      "Quando a mesma mensagem precisa ser consumida por múltiplos assinantes independentes",
      "Quando apenas um consumidor processa cada mensagem",
      "Quando não há necessidade de mensageria",
      "Quando se quer armazenar blobs grandes"
    ],
    "correctIndex": 0,
    "explanation": "Queue é ponto-a-ponto; Topic permite pub/sub com subscriptions filtradas, ideal para fan-out entre domínios.",
    "example": "Evento 'pedido_pago' é publicado em Topic; faturamento e analytics recebem cópias em subscriptions distintas."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__1",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "No Azure Service Fabric, qual é a diferença entre Stateless Services e Stateful Services em termos de gerenciamento de estado e particionamento?",
    "options": [
      "Stateful Services mantêm estado replicado em partições locais; Stateless dependem de armazenamento externo",
      "Não há diferença funcional",
      "Stateless tem particionamento e Stateful não",
      "Stateful Services não suportam réplicas"
    ],
    "correctIndex": 0,
    "explanation": "Stateful Services no Service Fabric mantêm o estado diretamente na memória com réplicas distribuídas entre nós, usando particionamento para escalar. Stateless Services não mantêm estado local e dependem de bancos externos. Stateful elimina a latência de acesso ao estado externo.",
    "example": "Um serviço de carrinho de compras Stateful armazena o carrinho na partição do usuário (hash do userId). 3 réplicas garantem durabilidade sem precisar de Redis externo."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__2",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "No Azure, como o Azure Front Door se diferencia do Azure Application Gateway em termos de escopo e funcionalidades?",
    "options": [
      "Front Door é global (anycast) com WAF, CDN e roteamento multi-região; App Gateway é regional com WAF e balanceamento L7",
      "São idênticos",
      "App Gateway é global e Front Door regional",
      "Front Door é apenas CDN"
    ],
    "correctIndex": 0,
    "explanation": "Azure Front Door opera globalmente via anycast, oferecendo CDN, WAF, SSL offloading e roteamento inteligente entre regiões. Azure Application Gateway opera dentro de uma região, fornecendo balanceamento L7 com WAF, SSL termination e URL-based routing para backends regionais.",
    "example": "Front Door: usuários do Brasil são roteados para Brazil South, europeus para West Europe (menor latência). App Gateway: dentro de Brazil South, distribui tráfego entre VMs do pool backend com health probes."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__3",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "O que são Durable Functions no Azure e qual problema elas resolvem que Azure Functions comuns não resolvem?",
    "options": [
      "Permitem orquestrar workflows stateful com estado preservado entre execuções de Functions",
      "São functions com mais memória",
      "Functions com timeout ilimitado",
      "Functions com GPU dedicada"
    ],
    "correctIndex": 0,
    "explanation": "Durable Functions estendem Azure Functions com padrões stateful: orchestration (sequência), fan-out/fan-in (paralelo), human interaction (aguardar aprovação) e monitoring (polling periódico). O estado é gerenciado automaticamente via Azure Storage, permitindo workflows de longa duração.",
    "example": "Padão fan-out/fan-in: const tasks = cities.map(c => context.df.callActivity('GetWeather', c)); const results = await context.df.Task.all(tasks); — busca clima de 50 cidades em paralelo e aguarda todas."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__4",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "O que são Availability Sets e como diferem de Availability Zones?",
    "options": [
      "Availability Sets protegem contra falhas de rack/host dentro de um datacenter; Zones protegem contra falhas de datacenter inteiro",
      "São sinônimos",
      "Sets são mais resilientes que Zones",
      "Zones são dentro de um rack"
    ],
    "correctIndex": 0,
    "explanation": "Availability Set: distribui VMs entre fault domains (racks) e update domains dentro de um datacenter. SLA: 99.95%. Availability Zone: datacenters fisicamente separados na mesma região. SLA: 99.99%. Zones oferecem proteção maior contra desastres.",
    "example": "Availability Set: 2 fault domains → VMs em racks diferentes, se 1 rack cai o outro funciona. Availability Zones: VMs em datacenters com energia/rede independentes. Para alta disponibilidade crítica, use Zones."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__5",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "O que é o Azure Arc e qual problema ele resolve?",
    "options": [
      "Estende serviços Azure (governance, policy, monitoring) para recursos on-premises e multi-cloud",
      "CDN global do Azure",
      "Ferramenta de migração de VMs",
      "Serviço de DNS"
    ],
    "correctIndex": 0,
    "explanation": "Azure Arc permite gerenciar servidores, clusters Kubernetes e bancos de dados fora do Azure com as mesmas ferramentas (Azure Policy, Monitor, RBAC). Suporta on-premises, AWS, GCP e edge. Visão unificada de todos os recursos no portal Azure.",
    "example": "Servidor Linux on-premises registrado no Azure Arc: aplique Azure Policy para compliance, colete logs com Azure Monitor, gerencie via portal Azure como se fosse uma VM Azure nativa."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__6",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "Como funciona o Azure Private Link e qual problema de segurança ele resolve?",
    "options": [
      "Cria endpoint privado na VNet para acessar serviços PaaS via rede privada da Microsoft, eliminando exposição à internet",
      "VPN entre Azure e on-premises",
      "Criptografia de disco",
      "Antivírus para VMs"
    ],
    "correctIndex": 0,
    "explanation": "Private Link cria um Private Endpoint (NIC privada) na sua VNet que mapeia para um serviço PaaS (Storage, SQL, Cosmos DB). O tráfego permanece na rede backbone da Microsoft, nunca trafega pela internet pública. Elimina exfiltração de dados via DNS.",
    "example": "Sem Private Link: App → Internet → storage.blob.core.windows.net (IP público). Com Private Link: App → 10.0.1.5 (private endpoint) → rede backbone MS → Storage. NSG + Private DNS Zone completam isolamento."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__7",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "O que é o Azure Bicep e como se compara com ARM Templates?",
    "options": [
      "DSL declarativa que compila para ARM Templates JSON, com sintaxe mais limpa e modular",
      "Linguagem de programação imperativa",
      "Ferramenta de monitoramento",
      "Alternativa ao Terraform incompatível com Azure"
    ],
    "correctIndex": 0,
    "explanation": "Bicep é uma DSL (Domain-Specific Language) que transpila para ARM JSON. Vantagens: sintaxe concisa (~60% menos código), modules reutilizáveis, detecção de erros em tempo de compilation, IntelliSense nativo no VS Code. É a evolução recomendada dos ARM Templates.",
    "example": "Bicep: resource sa 'Microsoft.Storage/storageAccounts@2023-01-01' = { name: 'meustore', location: 'brazilsouth', sku: { name: 'Standard_LRS' }, kind: 'StorageV2' }. Equivale a ~40 linhas de ARM JSON."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__8",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "Como combinar API Management e Private Endpoint para expor APIs com backend privado no Azure?",
    "options": [
      "Publica gateway controlado e mantém tráfego até o backend por rede privada",
      "Expõe backend diretamente na internet sem autenticação",
      "Substitui necessidade de DNS interno",
      "Remove completamente RBAC"
    ],
    "correctIndex": 0,
    "explanation": "API Management pode atuar como fachada pública/privada com políticas, enquanto backends permanecem isolados via Private Endpoint e VNet integration.",
    "example": "Consumidores externos acessam APIM com OAuth; o App Service de backend aceita tráfego apenas privado via endpoint interno."
  },
  {
    "id": "cloud__Azure — Serviços Avançados__Difícil__9",
    "track": "cloud",
    "category": "Azure — Serviços Avançados",
    "difficulty": "Difícil",
    "question": "No Cosmos DB, qual risco de uma partição quente (hot partition) e como mitigar?",
    "options": [
      "Concentração de RU em uma chave de partição; mitiga-se com chave de alta cardinalidade e bom acesso",
      "Aumento automático de consistência forte",
      "Perda imediata de replicação geográfica",
      "Eliminação de latência de leitura"
    ],
    "correctIndex": 0,
    "explanation": "Chaves mal escolhidas geram distribuição desigual e throttling local. Projetar partição com boa cardinalidade melhora throughput efetivo.",
    "example": "Usar `tenantId` único para milhões de registros cria hotspot; combinar `tenantId#month` distribui carga."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__1",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "Qual comando Docker é utilizado para criar uma imagem a partir de um Dockerfile?",
    "options": [
      "docker build",
      "docker run",
      "docker pull",
      "docker create"
    ],
    "correctIndex": 0,
    "explanation": "O comando 'docker build' lê as instruções do Dockerfile (FROM, COPY, RUN, etc.) e cria uma imagem de contêiner camada por camada. O flag -t permite nomear e taguear a imagem resultante.",
    "example": "docker build -t meu-app:1.0 . — constrói a imagem 'meu-app' com tag '1.0' usando o Dockerfile do diretório atual."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__2",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "Qual é a diferença entre um contêiner Docker e uma máquina virtual?",
    "options": [
      "Contêiner compartilha o kernel do host e é mais leve; VM virtualiza hardware completo com SO próprio",
      "São a mesma coisa",
      "VM é mais leve que contêiner",
      "Contêiner tem SO completo embutido"
    ],
    "correctIndex": 0,
    "explanation": "Contêineres compartilham o kernel do sistema operacional host, isolando apenas o processo e suas dependências (libs, bins). São leves (MBs) e iniciam em segundos. VMs virtualizam hardware completo com hypervisor e SO próprio, são pesadas (GBs) e levam minutos para iniciar.",
    "example": "Uma imagem Alpine Linux Docker tem ~5MB e inicia em <1s. Uma VM Ubuntu completa tem ~2GB e leva ~30s para bootar. Em um servidor, cabem centenas de contêineres vs dezenas de VMs."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__3",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "O que é um Dockerfile e qual instrução define a imagem base?",
    "options": [
      "FROM define a imagem base do contêiner",
      "RUN define a imagem base",
      "CMD define a imagem base",
      "COPY define a imagem base"
    ],
    "correctIndex": 0,
    "explanation": "Um Dockerfile é um arquivo de texto com instruções para construir uma imagem Docker. FROM é a primeira instrução e define a imagem base. Outras instruções: COPY (copiar arquivos), RUN (executar comandos), EXPOSE (portas), CMD (comando padrão ao rodar).",
    "example": "FROM node:18-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --production\nCOPY . .\nEXPOSE 3000\nCMD ['node', 'server.js'] — Dockerfile para app Node.js."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__4",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "O que é o Docker Compose e para que serve?",
    "options": [
      "Ferramenta que define e executa múltiplos contêineres com um arquivo YAML",
      "Linguagem de programação para Docker",
      "Orquestrador de produção como Kubernetes",
      "Sistema de build de imagens"
    ],
    "correctIndex": 0,
    "explanation": "Docker Compose usa um docker-compose.yml para definir múltiplos serviços (contêineres), redes e volumes. Ideal para ambientes de desenvolvimento local com vários serviços (app + banco + cache). Não é recomendado para produção em escala.",
    "example": "services:\n  app:\n    build: .\n    ports: ['3000:3000']\n  db:\n    image: postgres:15\n    environment: { POSTGRES_PASSWORD: 'dev' }\n  redis:\n    image: redis:7\nComando: docker compose up -d."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__5",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "O que é um container registry e para que serve?",
    "options": [
      "Repositório centralizado para armazenar e distribuir imagens de contêineres",
      "Ferramenta de execução de contêineres",
      "Sistema operacional para contêineres",
      "Orquestrador de clusters"
    ],
    "correctIndex": 0,
    "explanation": "Container registry armazena imagens Docker versionadas. Públicos: Docker Hub. Privados: Amazon ECR, Azure ACR, Google Artifact Registry, GitHub Container Registry. Push (upload) e pull (download) imagens. Integra-se com CI/CD para build → push → deploy.",
    "example": "docker build -t meuacr.azurecr.io/api:v2 . && docker push meuacr.azurecr.io/api:v2 — builda e envia para o Azure Container Registry. Kubernetes faz pull desta imagem no deploy."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__6",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "O que são Docker volumes e por que são importantes?",
    "options": [
      "Mecanismo de persistência de dados que sobrevive ao ciclo de vida do contêiner",
      "Unidades de disco virtuais da VM",
      "Cache de imagens Docker",
      "Partições do sistema operacional"
    ],
    "correctIndex": 0,
    "explanation": "Volumes Docker persistem dados fora do filesystem do contêiner. Quando o contêiner é removido, dados no volume permanecem. Três tipos: named volumes (gerenciados pelo Docker), bind mounts (diretório do host), tmpfs (memória). Volumes são a forma recomendada.",
    "example": "docker run -v pgdata:/var/lib/postgresql/data postgres:15 — dados do PostgreSQL no volume 'pgdata'. docker rm container → dados seguros. docker run -v pgdata:/var/lib/postgresql/data postgres:15 → reconecta aos mesmos dados."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__7",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "O que é um Pod no Kubernetes?",
    "options": [
      "Menor unidade deployável que encapsula um ou mais contêineres com rede e storage compartilhados",
      "Um nó físico do cluster",
      "Uma máquina virtual completa",
      "Um namespace isolado"
    ],
    "correctIndex": 0,
    "explanation": "Pod é a unidade atômica do Kubernetes. Contém um ou mais contêineres que compartilham IP, portas, volumes e namespace de rede. Na prática, maioria dos Pods tem um contêiner principal + sidecar opcional (logging, proxy). Pods são efêmeros — não persistem após falha.",
    "example": "Pod com 1 contêiner: app Node.js na porta 3000. Pod multi-container: app + Envoy sidecar (proxy) + fluentd (logs). Todos compartilham localhost e volumes. kubectl get pods → NAME: api-5d8f9, STATUS: Running."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__8",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "Qual prática reduz tamanho da imagem Docker e melhora segurança?",
    "options": [
      "Usar build multi-stage e imagem base mínima",
      "Executar tudo como root",
      "Copiar código de testes para produção",
      "Instalar ferramentas de debug em runtime"
    ],
    "correctIndex": 0,
    "explanation": "Build multi-stage separa etapa de compilação da imagem final, reduzindo superfície de ataque e tempo de download.",
    "example": "Aplicação Go compila em imagem grande de build e publica artefato final em `distroless`, com poucos MB."
  },
  {
    "id": "cloud__Containers e Kubernetes__Fácil__9",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Fácil",
    "question": "No Kubernetes, para que serve o comando `kubectl get pods`?",
    "options": [
      "Listar pods e seus estados no namespace atual",
      "Criar deployment automaticamente",
      "Expor serviço externo",
      "Escalar cluster de nós"
    ],
    "correctIndex": 0,
    "explanation": "É um comando de inspeção operacional para verificar status, reinícios e saúde de workloads executando como pods.",
    "example": "Após deploy, o time roda `kubectl get pods` para confirmar se todos os pods estão em `Running`."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__1",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "No Kubernetes, qual objeto é responsável por garantir que um número especificado de réplicas de um Pod esteja sempre em execução?",
    "options": [
      "ReplicaSet",
      "DaemonSet",
      "StatefulSet",
      "Job"
    ],
    "correctIndex": 0,
    "explanation": "O ReplicaSet garante que o número desejado de réplicas de um Pod esteja rodando a qualquer momento. Se um Pod falhar, o ReplicaSet cria automaticamente um novo. Na prática, usamos Deployments que gerenciam ReplicaSets internamente.",
    "example": "spec: { replicas: 3 } no ReplicaSet garante 3 Pods ativos. Se um nó cair e perder 1 Pod, o ReplicaSet agenda um novo Pod em outro nó."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__2",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "No Kubernetes, qual é a diferença entre um Service do tipo ClusterIP, NodePort e LoadBalancer?",
    "options": [
      "ClusterIP é interno ao cluster; NodePort expõe numa porta do nó; LoadBalancer cria um LB externo",
      "São idênticos",
      "LoadBalancer é interno e ClusterIP externo",
      "NodePort substitui os outros dois"
    ],
    "correctIndex": 0,
    "explanation": "ClusterIP: IP virtual interno, acessível apenas dentro do cluster (padrão). NodePort: expõe o Service em uma porta estática (30000-32767) em cada nó do cluster. LoadBalancer: provisiona um load balancer externo do cloud provider que distribui tráfego para os nós.",
    "example": "Microsserviço interno: ClusterIP (service-a.default.svc.cluster.local:80). API pública: LoadBalancer (obtém IP externo 34.95.10.5:80 no GKE). Debug: NodePort (acesso via <nodeIP>:31234)."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__3",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "O que é um Helm Chart no Kubernetes e para que serve?",
    "options": [
      "Pacote de templates Kubernetes que facilita deploy e versionamento de aplicações",
      "Ferramenta de monitoramento",
      "Tipo de volume de armazenamento",
      "Plugin de rede do cluster"
    ],
    "correctIndex": 0,
    "explanation": "Helm é o gerenciador de pacotes do Kubernetes. Um Chart é um pacote contendo templates de manifests K8s (Deployment, Service, ConfigMap, etc.) parametrizáveis via values.yaml. Permite instalar, atualizar e fazer rollback de aplicações complexas com um comando.",
    "example": "helm install meu-redis bitnami/redis --set architecture=replication — instala Redis com replicação usando o Chart oficial da Bitnami, sem escrever nenhum YAML manualmente."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__4",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "No Kubernetes, o que é um ConfigMap e quando usá-lo?",
    "options": [
      "Objeto que armazena configurações como pares chave-valor para injetar em Pods",
      "Mapa de rotas de rede",
      "Configuração do cluster",
      "Dashboard de monitoramento"
    ],
    "correctIndex": 0,
    "explanation": "ConfigMap armazena dados de configuração não-sensíveis (URLs, feature flags, configs). Injeta em Pods como variáveis de ambiente ou arquivos montados. Separa configuração do código. Para dados sensíveis (senhas, tokens), use Secret.",
    "example": "apiVersion: v1\nkind: ConfigMap\ndata:\n  DATABASE_URL: 'postgres://db:5432/app'\n  LOG_LEVEL: 'info'\nPod: envFrom: - configMapRef: name: app-config. Mude a config sem rebuild da imagem."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__5",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "No Kubernetes, o que é um Ingress e para que serve?",
    "options": [
      "Objeto que gerencia acesso externo HTTP/HTTPS ao cluster com roteamento por host/path",
      "Interface de rede interna do Pod",
      "Tipo de armazenamento persistente",
      "Sonda de saúde dos Pods"
    ],
    "correctIndex": 0,
    "explanation": "Ingress é um objeto que define regras de roteamento HTTP/HTTPS para Services internos baseado em hostname ou path. Requer um Ingress Controller (Nginx, Traefik, ALB). Centraliza TLS termination, virtual hosts e roteamento em um ponto.",
    "example": "rules:\n- host: api.meuapp.com\n  http:\n    paths:\n    - path: /v1\n      backend: { service: api-v1, port: 80 }\n    - path: /v2\n      backend: { service: api-v2, port: 80 }\nTLS com cert-manager automático."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__6",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "No Kubernetes, o que é um Namespace e quando criar múltiplos?",
    "options": [
      "Divisão lógica do cluster para isolar recursos por equipe, ambiente ou projeto",
      "Tipo de rede do Pod",
      "Volume compartilhado entre Pods",
      "Réplica do cluster inteiro"
    ],
    "correctIndex": 0,
    "explanation": "Namespaces dividem um cluster em escopos lógicos isolados. Cada namespace tem seus próprios Pods, Services, ConfigMaps. RBAC, ResourceQuotas e NetworkPolicies podem ser aplicados por namespace. Padrões: default, kube-system, kube-public.",
    "example": "kubectl create namespace staging && kubectl create namespace production. Deploy no staging: kubectl apply -f app.yaml -n staging. ResourceQuota: limitar staging a 4 CPUs e 8Gi RAM para evitar consumir recursos de produção."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__7",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "No Kubernetes, o que é um PersistentVolumeClaim (PVC)?",
    "options": [
      "Requisição de armazenamento persistente que vincula um Pod a um PersistentVolume",
      "Cache temporário do Pod",
      "Backup automático do Pod",
      "Tipo de rede persistente"
    ],
    "correctIndex": 0,
    "explanation": "PVC é uma requisição de storage que abstrai o backend de armazenamento. O PVC especifica tamanho e modo de acesso (ReadWriteOnce, ReadWriteMany). O cluster provisiona ou vincula a um PersistentVolume (PV). StorageClass permite provisionamento dinâmico.",
    "example": "PVC: resources: { requests: { storage: 10Gi } }, storageClassName: 'gp3'. Pod monta o PVC: volumeMounts: [{ mountPath: '/data' }]. Se Pod reiniciar, /data persiste. AWS provisiona EBS gp3 automaticamente."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__8",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "Qual diferença entre readiness probe e liveness probe no Kubernetes?",
    "options": [
      "Readiness controla recebimento de tráfego; liveness decide reinício do container",
      "Readiness reinicia pod e liveness publica serviço",
      "Ambas fazem autoscaling horizontal",
      "Não há diferença funcional"
    ],
    "correctIndex": 0,
    "explanation": "Readiness evita enviar tráfego para pods não prontos. Liveness detecta travamentos e reinicia containers quando necessário.",
    "example": "API pode levar 20s para aquecer: readiness aguarda; se entrar em deadlock depois, liveness dispara restart."
  },
  {
    "id": "cloud__Containers e Kubernetes__Médio__9",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Médio",
    "question": "Quando usar um DaemonSet em vez de Deployment?",
    "options": [
      "Quando é necessário um pod por nó, como agentes de log/monitoramento",
      "Quando precisa de escala por requisição HTTP",
      "Quando quer apenas um pod no cluster",
      "Quando precisa de banco stateful"
    ],
    "correctIndex": 0,
    "explanation": "DaemonSet garante instância por nó elegível, ideal para componentes de infraestrutura que devem rodar em toda a frota.",
    "example": "Promtail/Fluent Bit em DaemonSet coleta logs de cada nó e envia para sistema central."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__1",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "Ao implementar um Service Mesh com Istio no Kubernetes, qual componente é injetado como sidecar em cada Pod para interceptar o tráfego de rede?",
    "options": [
      "Envoy Proxy",
      "Pilot",
      "Citadel",
      "Galley"
    ],
    "correctIndex": 0,
    "explanation": "O Istio injeta um proxy Envoy como sidecar container em cada Pod. O Envoy intercepta todo tráfego de entrada e saída do Pod, permitindo funcionalidades como mTLS, circuit breaking, retry, observabilidade e roteamento avançado sem alterar o código da aplicação.",
    "example": "kubectl label namespace default istio-injection=enabled — todos os novos Pods no namespace recebem automaticamente o sidecar Envoy via Mutating Webhook."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__2",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "No Kubernetes, como o Horizontal Pod Autoscaler (HPA) funciona e quais métricas ele pode usar?",
    "options": [
      "Escala automaticamente o número de Pods baseado em métricas como CPU, memória ou métricas customizadas",
      "Escala os nós do cluster",
      "Aumenta CPU dos Pods existentes",
      "Reinicia Pods com alto consumo"
    ],
    "correctIndex": 0,
    "explanation": "O HPA monitora métricas (CPU/memória via Metrics Server ou customizadas via Prometheus Adapter) e ajusta o número de réplicas do Deployment automaticamente. Verifica métricas a cada 15s (padrão) e calcula: desiredReplicas = ceil(currentReplicas × currentMetricValue / targetValue).",
    "example": "apiVersion: autoscaling/v2\nspec:\n  minReplicas: 2, maxReplicas: 20\n  metrics:\n  - type: Resource\n    resource: { name: cpu, target: { type: Utilization, averageUtilization: 70 } } — escala entre 2 e 20 pods mantendo CPU média em 70%."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__3",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre Kubernetes Operators e Helm Charts para gerenciar aplicações complexas?",
    "options": [
      "Operators usam controllers customizados com lógica operacional; Helm Charts são templates estáticos de manifests",
      "São idênticos",
      "Helm é mais avançado que Operators",
      "Operators substituem o kubectl"
    ],
    "correctIndex": 0,
    "explanation": "Helm Charts empacotam manifests K8s com parametrização, mas não têm lógica operacional. Operators são controladores customizados que implementam conhecimento operacional (backup, scaling, failover) usando o padrão Reconciliation Loop, reagindo automaticamente a mudanças de estado.",
    "example": "Helm instala PostgreSQL, mas você faz backup manualmente. PostgreSQL Operator (Zalando) monitora o CR 'postgresql', cria réplicas, faz failover automático, agenda backups e gerencia o ciclo de vida completo."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__4",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "O que é um StatefulSet no Kubernetes e quando usá-lo?",
    "options": [
      "Objeto para workloads stateful que requer identidade persistente, storage e ordering (ex: bancos de dados)",
      "Set de regras de firewall stateful",
      "Deployment para aplicações stateless",
      "Tipo de load balancer"
    ],
    "correctIndex": 0,
    "explanation": "StatefulSet garante: identidade estável (pod-0, pod-1), storage persistente por Pod (PVC vinculado), criação/terminadação ordenada. Ideal para bancos (PostgreSQL, MySQL), Kafka, Elasticsearch. Deployments regulares não garantem essas propriedades.",
    "example": "StatefulSet 'postgres' com 3 réplicas: postgres-0 (primary), postgres-1 (replica), postgres-2 (replica). Cada um tem PVC próprio. Se postgres-1 reiniciar, reconecta ao mesmo PVC com os mesmos dados."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__5",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "O que é Network Policy no Kubernetes e por que é importante para segurança?",
    "options": [
      "Regras que controlam comunicação de rede entre Pods, implementando microsegmentação",
      "Regras de DNS do cluster",
      "Políticas de auto-scaling",
      "Configurações de proxy"
    ],
    "correctIndex": 0,
    "explanation": "Network Policy define regras de ingress/egress entre Pods usando labels. Por padrão, todos os Pods no K8s podem se comunicar com todos (flat network). Network Policies implementam microsegmentação: só o frontend pode acessar o backend, só o backend pode acessar o banco.",
    "example": "spec:\n  podSelector: { matchLabels: { app: database } }\n  ingress:\n  - from:\n    - podSelector: { matchLabels: { app: backend } }\n    ports: [{ port: 5432 }]\nApenas Pods com label app=backend podem acessar o banco na porta 5432."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__6",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "O que é o padrão Sidecar no Kubernetes e quais são os casos de uso comuns?",
    "options": [
      "Contêiner auxiliar no mesmo Pod que complementa o contêiner principal com funcionalidades transversais",
      "Pod que roda ao lado de outro Pod",
      "Réplica de backup do contêiner principal",
      "Contêiner que substitui o principal em caso de falha"
    ],
    "correctIndex": 0,
    "explanation": "Sidecar é um contêiner auxiliar no mesmo Pod que adiciona funcionalidades sem modificar o app: proxy (Envoy/Istio), logging (fluentd), secrets injection (Vault agent), certificate rotation. Compartilham rede (localhost) e volumes com o contêiner principal.",
    "example": "Pod com sidecar Vault Agent: init-container busca secrets do HashiCorp Vault → escreve em /vault/secrets/config.json → app lê o arquivo. Rotação automática: sidecar atualiza secrets a cada 5min sem restart do app."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__7",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "O que é o Kubernetes Gateway API e como se compara ao Ingress?",
    "options": [
      "API de próxima geração mais expressiva e role-oriented que substitui gradualmente o Ingress",
      "API para gerenciar gateways VPN",
      "Versão simplificada do Ingress",
      "API exclusiva para service mesh"
    ],
    "correctIndex": 0,
    "explanation": "Gateway API é a evolução do Ingress: multi-tenant (GatewayClass → Gateway → HTTPRoute), suporta TCP/UDP/gRPC nativamente, header-based routing, traffic splitting, e políticas extensíveis. Role-oriented: infra team gerencia Gateway, dev teams criam Routes.",
    "example": "HTTPRoute: matches: [{path: {value: '/api'}}, {headers: [{name: 'version', value: 'v2'}]}] → backendRefs: [{name: api-v2, weight: 80}, {name: api-v3, weight: 20}]. Canary deploy: 80% v2, 20% v3 com routing por header."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__8",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "Qual papel do PodDisruptionBudget (PDB) em operações de manutenção do cluster?",
    "options": [
      "Limitar quantos pods podem ficar indisponíveis durante interrupções voluntárias",
      "Impedir qualquer rollout de aplicação",
      "Substituir readiness probes",
      "Escalar nós automaticamente"
    ],
    "correctIndex": 0,
    "explanation": "PDB protege disponibilidade durante drain/upgrade, definindo mínimo de pods disponíveis ou máximo indisponível por workload.",
    "example": "Com 10 réplicas e `minAvailable: 8`, o cluster não remove mais de 2 pods simultaneamente em manutenção."
  },
  {
    "id": "cloud__Containers e Kubernetes__Difícil__9",
    "track": "cloud",
    "category": "Containers e Kubernetes",
    "difficulty": "Difícil",
    "question": "Como requests e limits de CPU/memória influenciam QoS e estabilidade no Kubernetes?",
    "options": [
      "Definem agendamento e risco de throttling/eviction, impactando prioridade de sobrevivência",
      "Servem apenas para documentação",
      "Eliminam necessidade de monitoramento",
      "Substituem autoscaling"
    ],
    "correctIndex": 0,
    "explanation": "Requests orientam scheduler; limits impõem teto. Configuração incorreta pode causar OOMKill, throttling e baixa previsibilidade sob carga.",
    "example": "Pod sem request adequado é preterido no agendamento; com limit muito baixo sofre throttling em picos."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__1",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "O que significa a sigla CI no contexto de DevOps?",
    "options": [
      "Continuous Integration",
      "Continuous Inspection",
      "Code Integration",
      "Container Infrastructure"
    ],
    "correctIndex": 0,
    "explanation": "CI (Continuous Integration) é a prática de integrar código ao repositório compartilhado frequentemente, onde cada integração é verificada por builds e testes automatizados para detectar erros rapidamente.",
    "example": "A cada push na branch main, o GitHub Actions executa 'npm test' e 'npm run build'. Se algum teste falhar, o desenvolvedor é notificado em minutos."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__2",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "O que significa CD no contexto de DevOps e quais são suas duas interpretações?",
    "options": [
      "Continuous Delivery (deploy manual em produção) e Continuous Deployment (deploy automático)",
      "Code Deployment e Container Distribution",
      "Central Directory e Cloud Distribution",
      "Certified Developer e Code Design"
    ],
    "correctIndex": 0,
    "explanation": "Continuous Delivery: código é automaticamente testado e preparado para release, mas o deploy em produção requer aprovação manual. Continuous Deployment: vai além — o deploy em produção é automático após todos os testes passarem, sem intervenção humana.",
    "example": "Continuous Delivery: PR mergeado → build → testes → staging automático → botão 'Deploy to Production'. Continuous Deployment: PR mergeado → build → testes → staging → produção, tudo automático."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__3",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "Qual ferramenta de CI/CD é integrada nativamente ao GitHub e usa arquivos YAML para definir workflows?",
    "options": [
      "GitHub Actions",
      "Jenkins",
      "CircleCI",
      "Travis CI"
    ],
    "correctIndex": 0,
    "explanation": "GitHub Actions é a plataforma de CI/CD nativa do GitHub. Workflows são definidos em arquivos YAML em .github/workflows/. Oferece runners gratuitos para projetos open-source e marketplace com milhares de actions reutilizáveis.",
    "example": ".github/workflows/ci.yml: on: push → jobs: test: runs-on: ubuntu-latest, steps: checkout, setup-node, npm ci, npm test. Cada push dispara o workflow automaticamente."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__4",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "O que é um pipeline de CI/CD e quais são seus estágios típicos?",
    "options": [
      "Fluxo automatizado: build → teste → análise → deploy, acionado por eventos como push/merge",
      "Apenas compilação automática",
      "Fluxo manual de deploy",
      "Ferramenta de versionamento"
    ],
    "correctIndex": 0,
    "explanation": "Pipeline CI/CD automatiza: 1) Build (compilar código, gerar artefato), 2) Test (unit, integração, e2e), 3) Análise (linting, SAST, coverage), 4) Publish (imagem Docker, pacote), 5) Deploy (staging, produção). Acionado por push, PR ou schedule.",
    "example": "GitHub Actions pipeline: push → checkout → npm install → npm test (unit) → npm run build → docker build/push → deploy to staging → smoke tests → approve → deploy to production."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__5",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "O que é um artefato de build e por que é importante no CI/CD?",
    "options": [
      "Resultado imutável do build (imagem Docker, JAR, ZIP) promovido entre ambientes",
      "Código-fonte versionado",
      "Log de execução do pipeline",
      "Configuração de infraestrutura"
    ],
    "correctIndex": 0,
    "explanation": "Artefato é o output imutável do build: imagem Docker, JAR, pacote npm. O MESMO artefato é promovido de dev → staging → prod para garantir que o que foi testado é exatamente o que vai para produção. Nunca rebuilde entre ambientes.",
    "example": "Build gera imagem api:sha-abc123. Staging recebe api:sha-abc123, testes passam. Produção recebe api:sha-abc123 (mesma imagem, zero rebuilds). Armazenado em registry (ECR, ACR) até a próxima versão."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__6",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "O que é um ambiente de staging e por que é essencial no CI/CD?",
    "options": [
      "Cópia do ambiente de produção para validar deploys antes de ir ao ar, reduzindo riscos",
      "Ambiente exclusivo para desenvolvimento",
      "Backup da produção",
      "Ambiente para testes unitários"
    ],
    "correctIndex": 0,
    "explanation": "Staging espelha produção: mesma infra (menor escala), mesmas configs, mesma rede. Permite executar smoke tests, testes de integração e validação manual antes do deploy real. Sem staging, bugs só aparecem em produção.",
    "example": "Pipeline: build → unit tests → deploy staging → selenium e2e tests no staging → QA aprova → deploy produção. Staging encontrou bug de CORS que não apareceu nos unit tests."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__7",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "O que é versionamento semântico (SemVer) e como é usado no CI/CD?",
    "options": [
      "Formato MAJOR.MINOR.PATCH onde cada número indica tipo de mudança (breaking, feature, fix)",
      "Numeração sequencial de builds",
      "Versão baseada em data",
      "Hash do commit"
    ],
    "correctIndex": 0,
    "explanation": "SemVer: MAJOR (breaking changes), MINOR (novas features compatíveis), PATCH (bug fixes). Ex: 2.3.1 → 2.4.0 (nova feature) → 3.0.0 (breaking change). CI/CD pode gerar versões automaticamente baseado em commits convencionais.",
    "example": "Conventional Commits: 'feat: add auth' → bump minor (1.2.0 → 1.3.0). 'fix: null check' → bump patch (1.3.0 → 1.3.1). 'feat!: new API' → bump major (1.3.1 → 2.0.0). Ferramenta: semantic-release."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__8",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "Em fluxo com pull request, qual prática ajuda a evitar quebra da branch principal?",
    "options": [
      "Exigir checks obrigatórios de testes e lint antes do merge",
      "Permitir merge direto sem validação",
      "Ignorar revisão de código",
      "Desativar pipeline em horários de pico"
    ],
    "correctIndex": 0,
    "explanation": "Gates de qualidade automáticos evitam que código com falhas óbvias chegue à main, reduzindo incidentes e retrabalho.",
    "example": "Repositório só permite merge após aprovação + CI verde com testes unitários e análise estática."
  },
  {
    "id": "cloud__DevOps e CI/CD__Fácil__9",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Fácil",
    "question": "O que significa tratar pipeline como código (Pipeline as Code)?",
    "options": [
      "Versionar e revisar definição do pipeline no mesmo repositório da aplicação",
      "Executar deploy apenas manualmente",
      "Guardar pipeline em planilha",
      "Evitar qualquer automação"
    ],
    "correctIndex": 0,
    "explanation": "Pipeline as Code aumenta rastreabilidade e colaboração, pois mudanças em CI/CD seguem revisão, histórico e rollback como qualquer código.",
    "example": "Arquivo YAML de workflow é alterado via PR, com revisão do time de plataforma."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__1",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "Qual estratégia de deploy envia o tráfego novo gradualmente para a nova versão enquanto mantém a versão anterior ativa?",
    "options": [
      "Canary Deployment",
      "Blue-Green Deployment",
      "Rolling Update",
      "Recreate"
    ],
    "correctIndex": 0,
    "explanation": "No Canary Deployment, uma pequena porcentagem do tráfego (ex.: 5%) é direcionada à nova versão. Métricas são monitoradas e, se tudo estiver saudável, o tráfego é aumentado gradualmente até 100%. Permite rollback rápido.",
    "example": "Envie 5% do tráfego para v2.0 via Ingress weight. Monitore taxa de erros por 30 min. Se erro < 0.1%, aumente para 25%, 50%, 100%."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__2",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "O que é Blue-Green Deployment e como funciona o rollback?",
    "options": [
      "Mantém dois ambientes idênticos (blue/green) e alterna o tráfego entre eles; rollback é instantâneo",
      "Deploy em duas regiões geográficas",
      "Deploy em horários alternados",
      "Deploy com duas branches Git"
    ],
    "correctIndex": 0,
    "explanation": "No Blue-Green, o ambiente Blue roda a versão atual e Green é preparado com a nova versão. Após testes no Green, o roteador/load balancer muda todo o tráfego de Blue para Green instantaneamente. Se houver problemas, o rollback é imediato: basta apontar de volta para Blue.",
    "example": "Blue (v1.0) recebendo tráfego → Deploy v2.0 no Green → Testar Green internamente → Alterar DNS/ALB para Green → Green agora recebe todo tráfego → Se erro: alterar de volta para Blue em segundos."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__3",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "No conceito de Infrastructure as Code, qual é a diferença entre abordagem declarativa e imperativa?",
    "options": [
      "Declarativa descreve o estado desejado; imperativa descreve os passos para alcançá-lo",
      "São a mesma coisa",
      "Imperativa é mais moderna",
      "Declarativa exige mais código"
    ],
    "correctIndex": 0,
    "explanation": "Declarativa (Terraform, CloudFormation): você define QUAL é o estado final desejado e a ferramenta calcula como chegar lá. Imperativa (scripts bash, AWS CLI): você define os PASSOS exatos para executar. Declarativa é idempotente por natureza; imperativa precisa de lógica de verificação.",
    "example": "Declarativo: 'quero 3 instâncias t3.large' → Terraform verifica que existem 2 e cria mais 1. Imperativo: 'crie 1 instância t3.large' → se rodar 3 vezes, cria 3 extras (total 5)."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__4",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "O que é o conceito de 'imutable infrastructure' e como se aplica ao deploy?",
    "options": [
      "Servidores nunca são modificados após criação; novas versões substituem instâncias antigas",
      "Infraestrutura que não pode ser destruída",
      "Configuração que não muda com scale",
      "Uso de hardware dedicado"
    ],
    "correctIndex": 0,
    "explanation": "Infraestrutura imutável: em vez de SSH + atualizar servidor (mutável, configuration drift), crie nova imagem com a nova versão e substitua as instâncias antigas. Garante consistência: toda instância é idêntica, testada e reproduzível.",
    "example": "Mutável: SSH → apt upgrade → restart (cada servidor pode ficar diferente). Imutável: Packer cria AMI v2.0 → ASG launch template atualizado → rolling update substitui instâncias v1.0 por v2.0."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__5",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "O que é um rollback automático no CI/CD e quando ele é acionado?",
    "options": [
      "Reverte automaticamente para a versão anterior quando health checks ou testes pós-deploy falham",
      "Restauração manual de backup",
      "Desfazer commit no Git",
      "Reiniciar o pipeline"
    ],
    "correctIndex": 0,
    "explanation": "Rollback automático: após deploy, smoke tests ou health checks monitoram a nova versão. Se erros ultrapassarem threshold (ex: error rate > 5%), o sistema reverte automaticamente para a versão anterior. Kubernetes faz nativamente via Deployment rollout undo.",
    "example": "Kubernetes: kubectl rollout undo deployment/api. AWS CodeDeploy: se health check falhar, reverte automaticamente para a TaskDefinition anterior. ArgoCD: auto-sync volta para o commit anterior no Git."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__6",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "O que é o padrão GitFlow e quando ele é apropriado?",
    "options": [
      "Modelo de branching com branches main, develop, feature, release e hotfix para releases planejadas",
      "Workflow de deploy contínuo",
      "Ferramenta de merge automático",
      "Sistema de code review"
    ],
    "correctIndex": 0,
    "explanation": "GitFlow: main (produção), develop (integração), feature/* (funcionalidades), release/* (preparação), hotfix/* (correções urgentes). Ideal para releases planejadas com versões. Para deploys contínuos, trunk-based development é mais adequado.",
    "example": "GitFlow: feature/login → merge develop → release/2.0 (testes) → merge main + tag v2.0 → deploy. Trunk-based: commit direto na main com feature flags, deploy contínuo. GitFlow: apps mobile. Trunk: SaaS web."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__7",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "O que é um smoke test e onde ele se encaixa no pipeline?",
    "options": [
      "Teste rápido pós-deploy que verifica se funcionalidades críticas estão operacionais",
      "Teste de estresse",
      "Teste unitário",
      "Análise estática de código"
    ],
    "correctIndex": 0,
    "explanation": "Smoke test: após deploy em staging/produção, verifica rapidamente se o sistema está funcional (health check, login, operações críticas). Não é exaustivo — se smoke falhar, rollback imediato. Geralmente < 2 minutos.",
    "example": "Smoke test pós-deploy: 1) GET /health → 200? 2) POST /auth/login → token válido? 3) GET /api/users → resposta < 500ms? Se qualquer falhar → rollback automático → alerta no Slack."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__8",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "Quando a estratégia trunk-based development tende a funcionar melhor?",
    "options": [
      "Quando o time integra mudanças pequenas e frequentes com automação robusta",
      "Quando features ficam meses em branches longas",
      "Quando não há testes automatizados",
      "Quando releases são sempre manuais"
    ],
    "correctIndex": 0,
    "explanation": "Trunk-based reduz divergência de branches longas. Requer disciplina de integração contínua, testes confiáveis e uso de feature flags.",
    "example": "Equipe integra diariamente na main e ativa funcionalidades gradualmente por flag."
  },
  {
    "id": "cloud__DevOps e CI/CD__Médio__9",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Médio",
    "question": "Qual impacto do cache de dependências no tempo de execução de pipelines CI?",
    "options": [
      "Reduz etapas repetitivas de download/instalação, acelerando builds",
      "Aumenta obrigatoriamente tempo de build",
      "Substitui todos os testes",
      "Elimina versionamento de pacotes"
    ],
    "correctIndex": 0,
    "explanation": "Cache bem configurado reaproveita artefatos entre execuções, diminuindo latência e custo sem alterar qualidade das validações.",
    "example": "Pipeline Node reaproveita cache de `~/.npm`, reduzindo instalação de 4 min para 40 s."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__1",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "No GitOps com ArgoCD, o que acontece quando o estado do cluster Kubernetes diverge do estado declarado no repositório Git?",
    "options": [
      "O ArgoCD detecta o drift e pode sincronizar automaticamente para restaurar o estado desejado",
      "O cluster sobrescreve o repositório Git",
      "O ArgoCD ignora a divergência até o próximo push",
      "O deploy é pausado indefinidamente"
    ],
    "correctIndex": 0,
    "explanation": "O ArgoCD monitora continuamente o estado do cluster e compara com o estado declarado no Git. Quando detecta drift (divergência), marca a aplicação como 'OutOfSync'. Com auto-sync habilitado, aplica automaticamente as correções; sem auto-sync, aguarda aprovação manual.",
    "example": "Alguém edita um Deployment via kubectl direto. O ArgoCD detecta que 'replicas: 5' no cluster difere de 'replicas: 3' no Git e reverte automaticamente para 3."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__2",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "O que é um pipeline multistage com ambientes de staging, QA e produção, e como gates de aprovação funcionam?",
    "options": [
      "Pipeline que promove artefatos entre ambientes sequenciais, com gates manuais ou automáticos entre stages",
      "Pipeline que roda testes em paralelo",
      "Pipeline que faz deploy em múltiplas regiões simultaneamente",
      "Pipeline exclusivo para microserviços"
    ],
    "correctIndex": 0,
    "explanation": "Um pipeline multistage promove o mesmo artefato (imagem Docker, pacote) por ambientes: Dev → QA → Staging → Prod. Gates são checkpoints entre stages: manuais (aprovação humana) ou automáticos (métricas de qualidade, testes de integração, security scans).",
    "example": "Stage 1 (Dev): build + unit tests → Stage 2 (QA): integration tests + security scan (gate automático: coverage > 80%) → Stage 3 (Staging): smoke tests → Gate manual: gerente aprova → Stage 4 (Prod): deploy canary → full rollout."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__3",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "O que é o conceito de 'Shift Left' em segurança no pipeline CI/CD?",
    "options": [
      "Mover verificações de segurança para etapas iniciais do desenvolvimento, antes do deploy",
      "Mover o deploy para a esquerda da tela",
      "Usar branches da esquerda antes",
      "Fazer rollback automático"
    ],
    "correctIndex": 0,
    "explanation": "Shift Left Security (DevSecOps) significa integrar verificações de segurança desde o início do ciclo de desenvolvimento: análise estática de código (SAST), análise de dependências vulneráveis (SCA), secrets scanning e container image scanning no pipeline CI, antes que código inseguro chegue a produção.",
    "example": "Pipeline CI com Shift Left: 1) Pre-commit: detect-secrets + eslint-security. 2) Build: Snyk SCA (dependências). 3) Test: SAST com SonarQube. 4) Image: Trivy scan na imagem Docker. Vulnerabilidade crítica = pipeline falha."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__4",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "O que é Feature Flag (Feature Toggle) e como se usa no CI/CD?",
    "options": [
      "Mecanismo para ativar/desativar funcionalidades em produção sem redeploy, controlado por configuração",
      "Branch de feature no Git",
      "Flag de compilação condicional",
      "Tipo de teste automatizado"
    ],
    "correctIndex": 0,
    "explanation": "Feature flags permitem deploy de código novo desabilitado e ativá-lo gradualmente (por usuário, %, região) sem redeploy. Desacopla deploy de release. Ferramentas: LaunchDarkly, Unleash, AWS AppConfig, Azure App Configuration.",
    "example": "if (featureFlags.isEnabled('novo-checkout', { userId })) { renderNewCheckout(); } else { renderOldCheckout(); } — ativa novo checkout para 10% dos usuários, monitora, escala para 100%."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__5",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "O que é um postmortem (post-incident review) e por que é importante em DevOps?",
    "options": [
      "Análise sem culpa após incidente para identificar causas raiz e prevenir recorrência",
      "Autopásia médica",
      "Revisão de código",
      "Teste de carga"
    ],
    "correctIndex": 0,
    "explanation": "Postmortem (blameless): após incidente, documenta timeline, causa raiz, impacto, resposta e action items preventivos. Cultura blameless foca em SISTEMAS, não em pessoas. Google SRE: postmortem obrigatório para incidentes que afetam SLO.",
    "example": "Template: Data, Duração, Impacto (2000 usuários), Timeline, Causa raiz (deploy sem feature flag), Ações (adicionar canary deploy, melhorar alertas). Compartilhado com toda a empresa para aprendizado."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__6",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "O que é o padrão de Progressive Delivery e como vai além do canary deploy?",
    "options": [
      "Combina canary, feature flags, análise automática de métricas e rollback automático em um fluxo unificado",
      "Deploy progressivo por região geográfica",
      "Deploy incremental de microserviços",
      "Pipeline com aprovação em cada stage"
    ],
    "correctIndex": 0,
    "explanation": "Progressive Delivery: canary deploy + análise automática de métricas (Kayenta/Flagger) + rollback automático. O sistema decide matematicamente se a nova versão é melhor que a atual baseado em SLIs. Ferramentas: Argo Rollouts, Flagger, Spinnaker.",
    "example": "Argo Rollouts: deploy canary 10% → análise por 5 min (p99 < 200ms? error rate < 1%?) → aprovado → 30% → análise → 60% → 100%. Se métrica degradar em qualquer step → rollback automático."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__7",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "O que é o conceito de 'Chaos Engineering' e como ele melhora a resiliência?",
    "options": [
      "Prática de introduzir falhas controladas em produção para validar resiliência do sistema",
      "Testes de estresse em staging",
      "Debugging de bugs aleatórios",
      "Redesenho de arquitetura após incidentes"
    ],
    "correctIndex": 0,
    "explanation": "Chaos Engineering (Netflix Simian Army): injeta falhas controladas (matar instâncias, latência de rede, falha de AZ) em produção para validar hipóteses de resiliência. Princípio: se você não testa falhas, falhas te testam. Ferramentas: Chaos Monkey, Litmus, Gremlin.",
    "example": "Experimento: 'Se matarmos 50% dos pods do serviço de pagamento, o circuit breaker ativa e usuários veem mensagem de retry em < 3s?'. Litmus injeta pod-kill → valida SLO → documenta resultado."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__8",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "Como métricas DORA ajudam a priorizar melhorias de engenharia em CI/CD?",
    "options": [
      "Medem lead time, frequência de deploy, taxa de falha e MTTR para guiar gargalos",
      "Servem apenas para cobrança individual",
      "Substituem observabilidade de produção",
      "Eliminam necessidade de retrospectiva"
    ],
    "correctIndex": 0,
    "explanation": "DORA oferece visão sistêmica de fluxo e confiabilidade. Times usam essas métricas para atacar causas-raiz em vez de otimizar etapas irrelevantes.",
    "example": "Após observar MTTR alto, equipe automatiza rollback e playbooks, reduzindo recuperação média de 45 para 12 minutos."
  },
  {
    "id": "cloud__DevOps e CI/CD__Difícil__9",
    "track": "cloud",
    "category": "DevOps e CI/CD",
    "difficulty": "Difícil",
    "question": "Qual combinação aumenta segurança de rollout progressivo com baixa exposição a risco?",
    "options": [
      "Canary deployment com feature flags, métricas de erro e rollback automático",
      "Big-bang deploy sem monitoramento",
      "Deploy em produção sem testes de fumaça",
      "Liberação de 100% do tráfego imediatamente"
    ],
    "correctIndex": 0,
    "explanation": "Progressive delivery limita blast radius: libera para pequena fatia, observa SLOs e reverte automaticamente se houver degradação.",
    "example": "Nova versão começa com 5% do tráfego; aumento para 25/50/100% só ocorre se erro e latência permanecerem dentro do limite."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__1",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "Qual serviço do Google Cloud é equivalente ao Amazon S3 para armazenamento de objetos?",
    "options": [
      "Cloud Storage",
      "Cloud SQL",
      "Compute Engine",
      "BigQuery"
    ],
    "correctIndex": 0,
    "explanation": "O Google Cloud Storage é o serviço de armazenamento de objetos do GCP. Oferece classes de armazenamento (Standard, Nearline, Coldline, Archive) com durabilidade de 99,999999999% e integração nativa com outros serviços GCP.",
    "example": "gsutil cp arquivo.csv gs://meu-bucket/dados/ — faz upload de um arquivo para o Cloud Storage usando a ferramenta de linha de comando gsutil."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__2",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "Qual serviço do GCP é equivalente ao Amazon EC2 para executar máquinas virtuais?",
    "options": [
      "Compute Engine",
      "Cloud Run",
      "App Engine",
      "Cloud Functions"
    ],
    "correctIndex": 0,
    "explanation": "O Google Compute Engine é o serviço IaaS do GCP para criar e gerenciar máquinas virtuais. Oferece tipos de máquina predefinidos e customizados, SSD local, GPUs, e integra-se com load balancers e auto-scaling gerenciados.",
    "example": "gcloud compute instances create minha-vm --zone=us-central1-a --machine-type=e2-medium --image-family=debian-11 — cria uma VM Debian com 2 vCPUs e 4GB RAM."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__3",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "O que é o Google Cloud Run e para qual tipo de workload ele é indicado?",
    "options": [
      "Plataforma serverless que executa contêineres stateless, escalando de zero automaticamente",
      "Serviço de banco de dados",
      "Ferramenta de CI/CD",
      "Serviço de CDN"
    ],
    "correctIndex": 0,
    "explanation": "Cloud Run executa contêineres Docker stateless de forma serverless. Escala automaticamente de zero (sem tráfego = sem custo) até milhares de instâncias. Aceita qualquer linguagem/framework desde que esteja em um contêiner que escute HTTP.",
    "example": "gcloud run deploy meu-api --image gcr.io/meu-projeto/api:v1 --platform managed --allow-unauthenticated — deploya um contêiner que escala de 0 a 1000 instâncias automaticamente."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__4",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "O que é o Google Cloud Functions e como difere do Cloud Run?",
    "options": [
      "FaaS que executa funções individuais acionadas por eventos; Cloud Run executa contêineres inteiros",
      "São o mesmo serviço",
      "Cloud Run é FaaS",
      "Cloud Functions roda contêineres"
    ],
    "correctIndex": 0,
    "explanation": "Cloud Functions: FaaS, escreva apenas a função, GCP gerencia todo o runtime. Triggers: HTTP, Pub/Sub, Cloud Storage, Firestore. Cloud Run: roda qualquer contêiner Docker. Funções simples → Cloud Functions. Apps complexos/multi-rota → Cloud Run.",
    "example": "Cloud Function: exports.processImage = (event) => { /* thumbnail */ }. Cloud Run: Express app com 20 rotas em contêiner Docker. Ambos escalam de 0, mas Cloud Run aceita qualquer framework."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__5",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "O que é o Google Cloud Pub/Sub e para que serve?",
    "options": [
      "Serviço de mensageria assíncrona pub/sub para comunicar serviços desacoplados",
      "Banco de dados público/privado",
      "CDN do GCP",
      "Ferramenta de CI/CD"
    ],
    "correctIndex": 0,
    "explanation": "Cloud Pub/Sub é um serviço de mensageria serverless em que publishers enviam mensagens para topics e subscribers recebem independentemente. Garante entrega at-least-once. Ideal para desacoplar microsserviços e processar eventos assíncronos.",
    "example": "Publisher: pubsub.topic('pedidos').publishMessage({ json: { pedidoId: 123 } }). Subscriptions: sub-pagamentos (push para Cloud Run), sub-email (pull por Cloud Function), sub-analytics (BigQuery subscription direta)."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__6",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "O que é o Firebase e como se relaciona com o GCP?",
    "options": [
      "Plataforma de desenvolvimento de apps móveis/web que roda sobre infraestrutura do GCP",
      "Serviço de email do Google",
      "Alternativa ao GCP",
      "Banco de dados relacional"
    ],
    "correctIndex": 0,
    "explanation": "Firebase é uma plataforma BaaS (Backend as a Service) do Google para apps móveis e web. Oferece Auth, Firestore (NoSQL), Realtime Database, Cloud Storage, Hosting, Cloud Functions e Analytics. Roda sobre infra GCP e compartilha projeto com console GCP.",
    "example": "App React Native: Firebase Auth (login social), Firestore (dados real-time), Cloud Storage (imagens), Cloud Functions (lógica backend). Mesmo projeto acessível no console Firebase e GCP."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__7",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "O que é o Google Cloud VPC (Virtual Private Cloud)?",
    "options": [
      "Rede virtual privada global que conecta recursos GCP com isolação e controle de tráfego",
      "VPN para acessar o Google",
      "Serviço de CDN",
      "Banco de dados em nuvem privada"
    ],
    "correctIndex": 0,
    "explanation": "VPC no GCP é global por padrão (subnets são regionais). Recursos em regiões diferentes na mesma VPC se comunicam via rede interna do Google. Firewall rules, Cloud NAT, Cloud Router e VPC peering controlam o tráfego.",
    "example": "VPC 'producao' com subnet us-central1 (10.0.1.0/24) e subnet southamerica-east1 (10.0.2.0/24). VMs nas duas regiões se comunicam internamente sem exposição à internet. Firewall: allow tcp:443 de 0.0.0.0/0."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__8",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "No GCP, qual serviço armazena segredos de forma gerenciada e auditável?",
    "options": [
      "Google Secret Manager",
      "Cloud Logging",
      "Cloud Scheduler",
      "Cloud Armor"
    ],
    "correctIndex": 0,
    "explanation": "Secret Manager protege segredos com IAM, versionamento e integração com workloads sem hardcode de credenciais.",
    "example": "Função serverless lê token de API no Secret Manager e registra acesso em auditoria."
  },
  {
    "id": "cloud__Google Cloud Platform__Fácil__9",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Fácil",
    "question": "Qual serviço do Google Cloud fornece DNS autoritativo gerenciado?",
    "options": [
      "Cloud DNS",
      "Cloud Build",
      "Cloud Run",
      "Bigtable"
    ],
    "correctIndex": 0,
    "explanation": "Cloud DNS hospeda zonas DNS com alta disponibilidade global e integração com outros recursos do GCP.",
    "example": "Domínio `api.exemplo.com` aponta para load balancer global via registro em Cloud DNS."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__1",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "No Google Cloud, qual serviço de data warehouse serverless permite executar queries SQL em petabytes de dados?",
    "options": [
      "BigQuery",
      "Cloud Spanner",
      "Dataflow",
      "Dataproc"
    ],
    "correctIndex": 0,
    "explanation": "O BigQuery é o data warehouse analítico serverless do GCP. Usa armazenamento colunar e processamento massivamente paralelo para executar queries SQL em petabytes de dados em segundos. Cobrança por volume de dados processados.",
    "example": "SELECT user_id, COUNT(*) FROM `projeto.dataset.eventos` WHERE data > '2025-01-01' GROUP BY user_id — processa 2TB de dados em ~15 segundos."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__2",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "No GCP, qual é a diferença entre Cloud SQL e Cloud Spanner?",
    "options": [
      "Cloud SQL é regional com réplicas limitadas; Cloud Spanner é globalmente distribuído com consistência forte",
      "São o mesmo serviço",
      "Cloud Spanner é NoSQL",
      "Cloud SQL é global e Spanner regional"
    ],
    "correctIndex": 0,
    "explanation": "Cloud SQL é um serviço gerenciado para MySQL, PostgreSQL e SQL Server, ideal para aplicações regionais (single-region com read replicas). Cloud Spanner é um banco relacional distribuído globalmente com consistência forte, escala horizontal ilimitada e SLA de 99.999%.",
    "example": "Blog pessoal: Cloud SQL PostgreSQL (~$50/mês). Sistema bancário global que precisa de consistência ACID entre continentes: Cloud Spanner ($$$). Spanner escala horizontalmente mantendo transações distribuídas."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__3",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "O que é o Google Kubernetes Engine (GKE) Autopilot e como difere do GKE Standard?",
    "options": [
      "Autopilot gerencia nós automaticamente e cobra por Pod; Standard dá controle total dos nós",
      "São idênticos",
      "Standard é mais novo",
      "Autopilot não suporta GPUs"
    ],
    "correctIndex": 0,
    "explanation": "GKE Autopilot: Google gerencia nós, auto-scaling, segurança e configuração. Cobra por recursos (CPU/memória) dos Pods. GKE Standard: você gerencia node pools, escolhe tipos de máquina e configura auto-scaling. Mais controle, mas mais responsabilidade operacional.",
    "example": "Autopilot: defina apenas os Pods (requests: cpu: 500m, memory: 512Mi) e o GKE provisiona nós automaticamente. Standard: crie node pool com n2-standard-4, configure cluster autoscaler min=2 max=10."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__4",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "O que é o Google Cloud IAM e como funciona o modelo de permissões?",
    "options": [
      "Gerenciamento de acesso baseado em roles (RBAC) que vincula member + role + resource",
      "Firewall do GCP",
      "Serviço de criptografia",
      "Auditoria de logs"
    ],
    "correctIndex": 0,
    "explanation": "GCP IAM usa o modelo: Member (quem: usuário, service account, grupo) + Role (o quê: conjunto de permissões) + Resource (onde: projeto, pasta, org). Roles: Basic (Owner/Editor/Viewer), Predefined (ex: roles/storage.objectViewer) e Custom.",
    "example": "gcloud projects add-iam-policy-binding meu-projeto --member='serviceAccount:app@meu-projeto.iam' --role='roles/storage.objectViewer' — app só pode ler objetos do Storage, nada mais."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__5",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "O que são Service Accounts no GCP e quando usá-las?",
    "options": [
      "Identidades para aplicações e serviços se autenticarem sem credenciais de usuário",
      "Contas compartilhadas para equipes",
      "Contas de faturamento",
      "Grupos de usuários"
    ],
    "correctIndex": 0,
    "explanation": "Service Accounts são identidades não-humanas para apps, VMs e serviços. Geram tokens automaticamente (sem senha). Cada recurso GCP pode ter uma SA associada com roles mínimas. Evitam usar credenciais pessoais em automações.",
    "example": "Cloud Run com SA 'api-sa': role storage.objectCreator (upload) + role bigquery.dataEditor (queries). A app autentica automaticamente sem chaves JSON exportadas (Workload Identity)."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__6",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "O que é o Cloud Build no GCP e como funciona como CI/CD?",
    "options": [
      "Serviço serverless de CI/CD que executa builds, testes e deploys definidos em YAML",
      "Compilador de código Go exclusivo",
      "IDE online do GCP",
      "Ferramenta de IaC"
    ],
    "correctIndex": 0,
    "explanation": "Cloud Build é CI/CD serverless do GCP. Define steps em cloudbuild.yaml: build Docker image, executar testes, push para Artifact Registry, deploy no Cloud Run/GKE. Triggers: push Git, tag, PR. Integra com GitHub, Bitbucket e Cloud Source Repos.",
    "example": "cloudbuild.yaml: steps: [{name: node:18, args: ['npm','test']}, {name: gcr.io/cloud-builders/docker, args: ['build','-t','gcr.io/$PROJECT_ID/api']}]. Trigger: push na main → build+test+deploy automático."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__7",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "O que é o Google Cloud Armor e para que serve?",
    "options": [
      "Serviço de WAF e proteção DDoS para aplicações atrás de Load Balancers",
      "Antivírus para VMs",
      "Criptografia de discos",
      "Firewall de rede L4"
    ],
    "correctIndex": 0,
    "explanation": "Cloud Armor é WAF (Web Application Firewall) + proteção DDoS do GCP. Integra-se com HTTP(S) Load Balancer. Regras personalizadas: bloquear IPs, geo-blocking, rate limiting, regras OWASP Top 10 pré-configuradas. Adaptive Protection usa ML para detectar ataques.",
    "example": "Security policy: deny(403) se origin.region == 'CN' || 'RU'. Rate limit: max 100 req/min por IP. OWASP: bloquear SQL injection e XSS automaticamente. Adaptive Protection: detecta e mitiga DDoS L7 em < 1 min."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__8",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "Qual vantagem do Cloud Load Balancing global com Anycast no GCP?",
    "options": [
      "Roteamento para ponto de presença mais próximo, reduzindo latência percebida",
      "Obrigar tráfego a uma única região",
      "Eliminar necessidade de health checks",
      "Substituir IAM em aplicações"
    ],
    "correctIndex": 0,
    "explanation": "Anycast usa um IP global e direciona usuários ao edge adequado, aumentando desempenho e resiliência regional.",
    "example": "Usuários da Ásia e Europa acessam o mesmo IP, mas são atendidos por backends regionais distintos."
  },
  {
    "id": "cloud__Google Cloud Platform__Médio__9",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Médio",
    "question": "Quando Memorystore (Redis) é indicado no GCP?",
    "options": [
      "Para cache de baixa latência, sessões e dados efêmeros de alto throughput",
      "Para armazenar arquivos de data lake",
      "Para substituir IAM e autenticação",
      "Para executar jobs batch longos"
    ],
    "correctIndex": 0,
    "explanation": "Memorystore oferece Redis gerenciado para acelerar leituras e reduzir carga em bancos transacionais.",
    "example": "E-commerce guarda carrinho e cache de catálogo em Redis, diminuindo chamadas repetidas ao banco principal."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__1",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "No Google Cloud Spanner, como o protocolo TrueTime permite transações distribuídas globais com consistência externa?",
    "options": [
      "Usa relógios atômicos e GPS para criar timestamps com margem de erro conhecida, permitindo ordenação global sem bloqueios",
      "Usa consenso Paxos puro sem relógios",
      "Replica dados com eventual consistency",
      "Depende de NTP padrão para sincronizar nós"
    ],
    "correctIndex": 0,
    "explanation": "O Cloud Spanner usa o TrueTime API que combina relógios atômicos e receptores GPS em cada datacenter para fornecer intervalos de tempo com margem de incerteza conhecida. Isso permite atribuir timestamps globalmente consistentes a transações distribuídas, garantindo serialização sem locks globais.",
    "example": "Uma transação no Spanner recebe timestamp T=[t1, t2] com incerteza de ~7ms. O Spanner espera a incerteza passar antes de confirmar, garantindo que nenhuma outra transação possa receber timestamp sobreposto."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__2",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "No GCP, como o Anthos permite gerenciar clusters Kubernetes em ambientes multi-cloud e on-premises?",
    "options": [
      "Plataforma unificada que estende GKE para AWS, Azure e on-premises com políticas consistentes via Config Management",
      "Apenas migra VMs para GCP",
      "Ferramenta de backup multi-cloud",
      "CDN distribuída entre clouds"
    ],
    "correctIndex": 0,
    "explanation": "Anthos é a plataforma de aplicações multi-cloud do Google. Permite rodar clusters Kubernetes gerenciados no GCP (GKE), on-premises (Anthos on VMware/bare metal), AWS e Azure. Anthos Config Management sincroniza políticas via GitOps, e Anthos Service Mesh fornece observabilidade e segurança uniforme.",
    "example": "Cluster GKE no GCP + cluster Anthos on-premises + cluster Anthos na AWS. Anthos Config Management aplica NetworkPolicy e RBAC idênticos nos 3 clusters via repositório Git centralizado."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__3",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "No BigQuery, o que são tabelas particionadas e clusterizadas e como elas otimizam custo e performance?",
    "options": [
      "Particionamento divide dados por coluna (ex: data); clustering ordena dentro da partição, ambos reduzem volume processado",
      "São índices tradicionais",
      "Particionamento é para backup",
      "Clustering replica dados entre regiões"
    ],
    "correctIndex": 0,
    "explanation": "Particionamento divide a tabela em segmentos por uma coluna (tipicamente data), permitindo que queries filtrem apenas partições relevantes. Clustering ordena os dados dentro de cada partição por até 4 colunas. Juntos, reduzem drasticamente o volume de bytes processados (= menor custo e mais velocidade).",
    "example": "CREATE TABLE eventos PARTITION BY DATE(timestamp) CLUSTER BY user_id, country. Query 'WHERE date = 2025-01-15 AND country = BR' escaneia apenas 1 partição e os blocos do cluster 'BR', processando 1GB em vez de 500GB."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__4",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "O que é o Google Cloud Dataflow e quando usá-lo?",
    "options": [
      "Serviço gerenciado baseado em Apache Beam para processamento batch e stream de dados",
      "Ferramenta de transferência de arquivos",
      "CDN para streaming de vídeo",
      "Banco de dados de fluxo"
    ],
    "correctIndex": 0,
    "explanation": "Dataflow é um serviço de processamento de dados (batch e streaming) baseado no Apache Beam. Tem auto-scaling de workers, exatamente-uma-vez para streaming e integração nativa com Pub/Sub, BigQuery e Cloud Storage.",
    "example": "Pipeline Beam: ReadFromPubSub (eventos) → Window (janelas de 5 min) → GroupByKey → Aggregate → WriteToBigQuery. Dataflow escala workers automaticamente conforme volume de eventos."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__5",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "O que é o principío de consistorial forte do Cloud Spanner e como afeta o design de aplicação?",
    "options": [
      "Toda leitura retorna o dado mais recente em qualquer réplica global, simplificando o design",
      "Dados podem estar desatualizados por minutos",
      "Consistência apenas na região primária",
      "Requer cache local para consistência"
    ],
    "correctIndex": 0,
    "explanation": "Cloud Spanner garante consistência externa (strongest form): qualquer leitura em qualquer região retorna o valor mais recente. Elimina complexidade de eventual consistency no código. Trade-off: latência de escrita ligeiramente maior (espera TrueTime) e custo elevado.",
    "example": "Transferência bancária entre contas em continentes diferentes: Spanner garante que ambos os saldos são atualizados atomicamente com consistência global. Com DynamoDB eventual, precisaria de lógica de reconciliação no código."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__6",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "O que é o VPC Service Controls no GCP e qual problema de segurança ele resolve?",
    "options": [
      "Perímetro de segurança que impede exfiltração de dados de serviços GCP mesmo com credenciais válidas",
      "Firewall de rede para VMs",
      "VPN entre VPCs",
      "Antivírus para Cloud Storage"
    ],
    "correctIndex": 0,
    "explanation": "VPC Service Controls cria perímetros de segurança ao redor de serviços GCP (BigQuery, Cloud Storage, etc.). Mesmo com credenciais IAM válidas, operações que cruzam o perímetro são bloqueadas. Previne exfiltração: dados não podem ser copiados para projetos fora do perímetro.",
    "example": "Perímetro inclui projeto-prod (BigQuery + Storage). Usuário com role bigquery.admin tenta: bq cp dataset projeto-externo:dataset → BLOQUEADO pelo perímetro. Dados não saem mesmo com permissão IAM."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__7",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "O que são Cloud Interconnect e Cloud VPN e quando usar cada um?",
    "options": [
      "Interconnect é conexão física dedicada de alta largura de banda; VPN é túnel criptografado pela internet",
      "São o mesmo serviço",
      "VPN é mais rápido que Interconnect",
      "Interconnect é gratuito"
    ],
    "correctIndex": 0,
    "explanation": "Dedicated Interconnect: conexão física 10/100 Gbps entre datacenter on-prem e GCP, latência baixa e previsível. Partner Interconnect: via provedor para 50 Mbps-50 Gbps. Cloud VPN: túnel IPsec pela internet, até 3 Gbps por túnel, setup rápido.",
    "example": "Hospital com 500TB de dados: Dedicated Interconnect 10 Gbps para transferência diária ao BigQuery. Startup com 10 devs remotos: Cloud VPN HA (2 túneis, 99.99% SLA) para acessar recursos na VPC. Custo vs performance."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__8",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "Como Workload Identity Federation no GCP melhora segurança em integração com CI externo?",
    "options": [
      "Evita chaves estáticas de service account, trocando por credenciais temporárias federadas",
      "Exige salvar JSON de credencial no repositório",
      "Remove auditoria de acesso",
      "Desativa políticas IAM"
    ],
    "correctIndex": 0,
    "explanation": "A federação confia em identidade externa (ex.: OIDC do GitHub) para emitir token temporário, reduzindo risco de vazamento de chave longa.",
    "example": "Pipeline GitHub Actions autentica no GCP sem arquivo de chave, usando trust configurado no workload identity pool."
  },
  {
    "id": "cloud__Google Cloud Platform__Difícil__9",
    "track": "cloud",
    "category": "Google Cloud Platform",
    "difficulty": "Difícil",
    "question": "Qual trade-off de usar reservas de slots no BigQuery em vez de cobrança puramente on-demand?",
    "options": [
      "Maior previsibilidade de custo/performance com risco de subutilização se mal dimensionado",
      "Sempre reduz custo independentemente do uso",
      "Elimina necessidade de particionamento",
      "Impede escalabilidade horizontal"
    ],
    "correctIndex": 0,
    "explanation": "Reservas dedicam capacidade analítica para workloads críticos, melhorando previsibilidade, mas exigem planejamento para evitar ociosidade.",
    "example": "Time de BI reserva slots para relatórios de manhã e monitora utilização para ajustar capacidade contratada."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__1",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "Qual ferramenta de Infrastructure as Code usa a linguagem declarativa HCL para provisionar recursos em múltiplos provedores de nuvem?",
    "options": [
      "Terraform",
      "Ansible",
      "Chef",
      "Puppet"
    ],
    "correctIndex": 0,
    "explanation": "O Terraform, da HashiCorp, usa a linguagem HCL (HashiCorp Configuration Language) para definir infraestrutura de forma declarativa. Suporta múltiplos provedores (AWS, Azure, GCP) através de plugins chamados providers.",
    "example": "resource \"aws_instance\" \"web\" { ami = \"ami-0c55b159\" instance_type = \"t3.micro\" } — cria uma instância EC2 com Terraform usando HCL."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__2",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "Qual ferramenta de IaC é focada em gerenciamento de configuração (instalar pacotes, configurar serviços) em vez de provisionamento de infraestrutura?",
    "options": [
      "Ansible",
      "Terraform",
      "CloudFormation",
      "Pulumi"
    ],
    "correctIndex": 0,
    "explanation": "Ansible usa YAML (playbooks) para automatizar configuração de servidores: instalar pacotes, copiar arquivos, reiniciar serviços. É agentless (conecta via SSH). Terraform provisiona infraestrutura (VMs, redes); Ansible as configura. Frequentemente usados juntos.",
    "example": "Terraform cria 3 VMs na AWS. Ansible configura cada uma: instala Nginx, copia o app, configura SSL e reinicia o serviço. Playbook: hosts: webservers, tasks: [apt: name=nginx, copy: src=app/ dest=/var/www/]."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__3",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "O que é o AWS CloudFormation e como ele se compara ao Terraform?",
    "options": [
      "Serviço nativo da AWS para provisionar recursos via templates JSON/YAML; Terraform é multi-cloud",
      "São idênticos",
      "CloudFormation é multi-cloud",
      "Terraform é exclusivo AWS"
    ],
    "correctIndex": 0,
    "explanation": "CloudFormation é o IaC nativo da AWS que usa templates JSON ou YAML para provisionar recursos. Vantagem: integração profunda com AWS (drift detection, rollback automático). Desvantagem: exclusivo AWS. Terraform é multi-cloud mas requer gerenciamento externo do state.",
    "example": "CloudFormation template: Resources: MinhaVM: Type: AWS::EC2::Instance, Properties: InstanceType: t3.micro, ImageId: ami-xxx. Deploy: aws cloudformation create-stack --stack-name prod --template-body file://template.yaml."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__4",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "O que é o Bicep do Azure e como se compara ao ARM Templates?",
    "options": [
      "Linguagem declarativa simplificada que compila para ARM Templates JSON",
      "Linguagem de programação general-purpose",
      "Substituição do Terraform",
      "Ferramenta de CI/CD"
    ],
    "correctIndex": 0,
    "explanation": "Bicep é uma DSL que simplifica a escrita de ARM Templates. Sintaxe concisa (sem JSON verboso), módulos reutilizáveis e validação em tempo de autoria. Compila para ARM JSON transparentemente. Suporte nativo da Microsoft.",
    "example": "resource storageAccount 'Microsoft.Storage/storageAccounts@2023-01-01' = { name: 'meuStorage', location: 'brazilsouth', kind: 'StorageV2', sku: { name: 'Standard_LRS' } } — muito mais limpo que ARM JSON equivalente."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__5",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "O que é GitOps e como ele se relaciona com Infrastructure as Code?",
    "options": [
      "Usar Git como fonte única de verdade para infraestrutura e deploy, com sincronização automática",
      "Usar GitHub para hospedar código",
      "Ferramenta de versionamento",
      "CI/CD baseado em Jenkins"
    ],
    "correctIndex": 0,
    "explanation": "GitOps: todo estado desejado (infra, configs, apps) é declarado em Git. Um operador (ArgoCD, Flux) monitora o repositório e sincroniza automaticamente o cluster/ambiente com o estado declarado. Push-based ou pull-based. PR = change request auditado.",
    "example": "Dev abre PR alterando replicas: 3 para 5 no YAML. Reviewer aprova. Merge no main. ArgoCD detecta diff e escala o deployment para 5 réplicas automaticamente. Histórico completo de mudanças no Git."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__6",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "O que é o Terraform e qual o conceito de 'state' (estado)?",
    "options": [
      "Ferramenta de IaC que mantém um state file mapeando código aos recursos reais provisionados",
      "Editor de código para infraestrutura",
      "Serviço de cloud computing",
      "Banco de dados de configurações"
    ],
    "correctIndex": 0,
    "explanation": "Terraform usa HCL para declarar infraestrutura desejada. O state file (terraform.tfstate) mapeia cada recurso declarado ao recurso real na nuvem (com IDs, atributos). Comandos: init (setup), plan (preview), apply (executar), destroy (remover).",
    "example": "terraform init → baixa provider AWS. terraform plan → '+1 S3 bucket'. terraform apply → cria o bucket. State salva: aws_s3_bucket.dados = bucket-id-abc123. Próximo plan compara state com código."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__7",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "O que é o CDK (Cloud Development Kit) e como difere do CloudFormation nativo?",
    "options": [
      "Framework que permite definir recursos AWS usando linguagens de programação (TypeScript, Python) que compilam para CloudFormation",
      "Substituio do Terraform",
      "Ferramenta de CI/CD",
      "IDE exclusiva da AWS"
    ],
    "correctIndex": 0,
    "explanation": "AWS CDK permite escrever infraestrutura em TypeScript, Python, Java, C#. Compila para CloudFormation templates. Vantagens: constructs reutilizáveis, lógica real (loops, condicionais), autocomplete de IDE, testes unitários. Abstrações L1 (raw), L2 (opinativas) e L3 (patterns).",
    "example": "const api = new apigateway.RestApi(this, 'Api'); const fn = new lambda.Function(this, 'Handler', { runtime: Runtime.NODEJS_18_X }); api.root.addMethod('GET', new apigateway.LambdaIntegration(fn)); — 3 linhas vs 150 de CloudFormation YAML."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__8",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "O que significa dizer que uma ferramenta de IaC é idempotente?",
    "options": [
      "Aplicar o mesmo código repetidas vezes converge para o mesmo estado desejado",
      "Executa apenas uma vez e falha depois",
      "Cria recursos duplicados em toda execução",
      "Não precisa de controle de versão"
    ],
    "correctIndex": 0,
    "explanation": "Idempotência evita mudanças desnecessárias e reduz risco operacional: se o estado já está correto, a execução não altera recursos.",
    "example": "Rodar `terraform apply` duas vezes seguidas sem mudanças deve resultar em 'no changes'."
  },
  {
    "id": "cloud__Infrastructure as Code__Fácil__9",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Fácil",
    "question": "Por que versionar módulos IaC é uma boa prática em times?",
    "options": [
      "Para garantir reprodutibilidade e evitar quebra por alterações inesperadas",
      "Para impedir reutilização entre projetos",
      "Para remover revisão de código",
      "Para dispensar testes de infraestrutura"
    ],
    "correctIndex": 0,
    "explanation": "Versionamento semântico de módulos permite atualizações controladas, rollback e adoção gradual em múltiplos ambientes.",
    "example": "Produção usa módulo de rede v2.3.1 enquanto desenvolvimento testa v2.4.0 antes da promoção."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__1",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "No Terraform, qual comando mostra o plano de execução detalhando quais recursos serão criados, modificados ou destruídos?",
    "options": [
      "terraform plan",
      "terraform apply",
      "terraform init",
      "terraform validate"
    ],
    "correctIndex": 0,
    "explanation": "O 'terraform plan' compara o estado atual (state file) com a configuração desejada e exibe um plano detalhado: recursos a criar (+), modificar (~) e destruir (-). É uma etapa de revisão antes de aplicar mudanças reais.",
    "example": "terraform plan mostra: '+ aws_s3_bucket.dados will be created', '~ aws_instance.web will be updated (instance_type: t3.micro → t3.small)', '- aws_rds_instance.old will be destroyed'."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__2",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "No Terraform, o que é o state file e por que ele é crítico para o funcionamento correto?",
    "options": [
      "Arquivo que mapeia recursos declarados no código aos recursos reais na nuvem",
      "Arquivo de log de erros",
      "Template de configuração",
      "Backup dos recursos"
    ],
    "correctIndex": 0,
    "explanation": "O terraform.tfstate é um arquivo JSON que armazena o mapeamento entre recursos declarados no código HCL e recursos reais provisionados (com IDs, atributos). O Terraform compara o state com o código para calcular o plan. Sem ele, o Terraform não sabe o que já existe.",
    "example": "State local: terraform.tfstate no disco. State remoto (recomendado em equipe): S3 + DynamoDB para locking. backend \"s3\" { bucket = \"my-tf-state\" key = \"prod/terraform.tfstate\" dynamodb_table = \"tf-locks\" }. Evita conflitos de escrita concorrente."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__3",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "O que são módulos no Terraform e qual problema eles resolvem?",
    "options": [
      "Pacotes reutilizáveis de configuração Terraform que evitam duplicação de código",
      "Plugins de provedores de nuvem",
      "Extensões da linguagem HCL",
      "Ferramentas de teste"
    ],
    "correctIndex": 0,
    "explanation": "Módulos Terraform encapsulam grupos de recursos relacionados em pacotes reutilizáveis com variáveis de entrada e outputs. Podem ser locais (pastas) ou remotos (Terraform Registry, Git). Eliminam duplicação e padronizam infraestrutura entre projetos e equipes.",
    "example": "module \"vpc\" { source = \"terraform-aws-modules/vpc/aws\", version = \"5.0.0\", cidr = \"10.0.0.0/16\", azs = [\"us-east-1a\", \"us-east-1b\"] } — cria VPC completa com sub-redes usando módulo do Registry."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__4",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "O que é drift detection em Infrastructure as Code e por que é importante?",
    "options": [
      "Detecção de diferenças entre o estado declarado no código e o estado real da infraestrutura",
      "Detecção de erros de sintaxe no código",
      "Monitoramento de performance",
      "Backup incremental"
    ],
    "correctIndex": 0,
    "explanation": "Drift: alguém altera a infra manualmente (console/CLI) sem atualizar o código IaC. O estado real diverge do declarado. terraform plan detecta drift. AWS Config e CloudFormation Drift Detection também detectam. Drift é perigoso pois próximo apply pode sobrescrever.",
    "example": "Dev alterou security group pelo console (adicionou porta 22). terraform plan mostra: ~ security_group_rule será modificado (removendo porta 22). Prática: proibir mudanças manuais, usar apenas IaC."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__5",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "O que é o conceito de state locking no Terraform e por que é necessário?",
    "options": [
      "Mecanismo que impede dois usuários de modificar o state file simultaneamente",
      "Criptografia do state file",
      "Lock de recursos na nuvem",
      "Bloqueio de deploys em produção"
    ],
    "correctIndex": 0,
    "explanation": "State locking impede aplicações concorrentes do Terraform que poderiam corromper o state ou criar recursos duplicados. Com backend S3, use DynamoDB para locking. Terraform Cloud tem locking nativo. Se dois devs rodarem apply simultaneamente sem lock, o state pode ficar inconsistente.",
    "example": "Dev A e Dev B rodam terraform apply ao mesmo tempo sem lock — state corrompido, recursos duplicados. Com DynamoDB lock: Dev B recebe 'Error: state locked by Dev A'. Dev B espera Dev A terminar."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__6",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "No Terraform, o que são data sources e como diferem de resources?",
    "options": [
      "Data sources consultam informações de recursos existentes sem gerenciá-los; resources criam/modificam recursos",
      "São sinônimos",
      "Data sources criam recursos somente-leitura",
      "Resources consultam dados externos"
    ],
    "correctIndex": 0,
    "explanation": "Data sources (data blocks) permitem ler informações de recursos existentes NÃO gerenciados pelo Terraform (ex: AMI mais recente, VPC existente). Resources criam e gerenciam o ciclo de vida completo. Data sources são somente leitura.",
    "example": "data \"aws_ami\" \"ubuntu\" { filter { name = \"name\", values = [\"ubuntu/images/hvm-ssd/ubuntu-22.04-*\"] } } → retorna AMI ID mais recente do Ubuntu. resource \"aws_instance\" { ami = data.aws_ami.ubuntu.id }."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__7",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "O que é o Terraform Workspace e quando usá-lo?",
    "options": [
      "Permite manter múltiplos states independentes para o mesmo código (ex: dev, staging, prod)",
      "IDE integrada ao Terraform",
      "Pasta de módulos",
      "Backend de armazenamento"
    ],
    "correctIndex": 0,
    "explanation": "Workspaces criam states independentes para a mesma configuração: terraform workspace new staging → state separado. Variáveis podem mudar por workspace: instance_type = terraform.workspace == 'prod' ? 't3.large' : 't3.micro'. Alternativa: diretórios separados por ambiente.",
    "example": "terraform workspace new dev → terraform apply (cria infra dev com t3.micro). terraform workspace select prod → terraform apply (cria infra prod com t3.large). Dois states separados, mesmo código."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__8",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "No Terraform, quando `for_each` costuma ser preferível a `count`?",
    "options": [
      "Quando recursos têm identidade estável por chave e podem mudar sem recriação em massa",
      "Quando só existe um recurso",
      "Quando não se usa variáveis",
      "Quando estado remoto está desabilitado"
    ],
    "correctIndex": 0,
    "explanation": "`for_each` usa chaves explícitas, reduzindo drift e recriações desnecessárias ao adicionar/remover elementos intermediários.",
    "example": "Mapear sub-redes por nome com `for_each` evita renumeração problemática que acontece com `count`."
  },
  {
    "id": "cloud__Infrastructure as Code__Médio__9",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Médio",
    "question": "Qual problema backend remoto com state locking resolve em IaC colaborativo?",
    "options": [
      "Evita escrita concorrente no estado e corrupção por execuções simultâneas",
      "Aumenta latência de aplicação em produção",
      "Substitui revisão de pull request",
      "Desativa auditoria de mudanças"
    ],
    "correctIndex": 0,
    "explanation": "State remoto centraliza verdade do ambiente e locking impede corrida entre dois `apply` ao mesmo tempo.",
    "example": "Enquanto uma pipeline aplica mudanças, outra execução aguarda lock para não sobrescrever estado."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__1",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "No Terraform, qual é a diferença funcional entre 'terraform import' e configurar um bloco 'import' no código HCL (Terraform 1.5+)?",
    "options": [
      "O CLI import apenas atualiza o state; o bloco import também gera o código HCL do recurso automaticamente",
      "Não há diferença",
      "O bloco import é mais lento",
      "O CLI import gera código e o bloco não"
    ],
    "correctIndex": 0,
    "explanation": "O comando 'terraform import' (CLI) adiciona o recurso existente ao state file, mas você precisa escrever o bloco resource manualmente. A partir do Terraform 1.5, o bloco 'import' no HCL permite importar e gerar o código de configuração automaticamente via 'terraform plan -generate-config-out=generated.tf'.",
    "example": "import { to = aws_s3_bucket.existente, id = \"meu-bucket\" } — no próximo plan com -generate-config-out, o Terraform gera o bloco resource completo com todos os atributos do bucket existente."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__2",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "O que é Terraform Cloud/Enterprise e quais problemas ele resolve em equipes?",
    "options": [
      "Plataforma SaaS que centraliza state, gerencia runs concorrentes e adiciona workflow de aprovação",
      "IDE para escrever HCL",
      "CDN para distribuição de state",
      "Ferramenta de teste unitário"
    ],
    "correctIndex": 0,
    "explanation": "Terraform Cloud centraliza: state remoto com locking automático, runs remotos (plan/apply no servidor), políticas Sentinel (policy as code), workspace por ambiente, VCS integration (GitHub/GitLab), e workflow de aprovação para applies. Elimina problemas de state local em equipes.",
    "example": "Fluxo: dev faz PR no GitHub → Terraform Cloud executa plan automaticamente → reviewer vê o plan na PR → aprova → TFC executa apply → state atualizado centralmente. Sentinel verifica: 'toda instância DEVE ter tag Environment'."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__3",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "O que é Pulumi e como sua abordagem difere fundamentalmente do Terraform?",
    "options": [
      "Usa linguagens de programação reais (TypeScript, Python, Go) em vez de DSL dedicada como HCL",
      "Usa YAML exclusivamente",
      "É exclusivo para Azure",
      "Não gerencia state"
    ],
    "correctIndex": 0,
    "explanation": "Pulumi permite definir infraestrutura usando linguagens genéricas: TypeScript, Python, Go, C#, Java. Vantagens sobre HCL: loops nativos, condições complexas, testes unitários com frameworks padrão, autocomplete de IDE, abstracões orientadas a objeto. Também gerencia state (Pulumi Cloud ou self-hosted).",
    "example": "import * as aws from '@pulumi/aws';\nconst bucket = new aws.s3.Bucket('meu-bucket', { acl: 'private' });\nexport const bucketName = bucket.id; — TypeScript real ao invés de HCL. Pode usar for loops, classes, funções."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__4",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "O que é o Packer da HashiCorp e como complementa o Terraform?",
    "options": [
      "Ferramenta que cria imagens de máquinas (AMIs, VM images) automáticas e reproduzíveis",
      "Alternativa ao Terraform",
      "Compactador de arquivos",
      "Gerenciador de pacotes"
    ],
    "correctIndex": 0,
    "explanation": "Packer cria imagens de máquinas (AMI, Azure Image, GCE Image) automatizadas: instala pacotes, configura SO, hardening. Terraform usa essas imagens para provisionar instâncias. Juntos: Packer cria a imagem, Terraform a usa.",
    "example": "Packer: instala Nginx + Node.js + app na AMI. Terraform: lança 5 instâncias EC2 com essa AMI. Atualização: Packer cria AMI v2, Terraform faz rolling update das instâncias para a nova AMI."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__5",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "O que é Policy as Code e como ferramentas como Sentinel e OPA implementam isso?",
    "options": [
      "Definir políticas de compliance e segurança como código, validadas automaticamente no pipeline",
      "Código-fonte das políticas de privacidade",
      "Documentação de políticas em PDF",
      "Smart contracts blockchain"
    ],
    "correctIndex": 0,
    "explanation": "Policy as Code: regras de compliance/segurança escritas como código e avaliadas automaticamente. Sentinel (HashiCorp): integrada ao Terraform Cloud. OPA/Rego (open source): avalia políticas em Kubernetes, Terraform, APIs. Garante que nenhum recurso non-compliant seja criado.",
    "example": "Sentinel: 'todo aws_instance deve ter tag Environment'. OPA: 'todo container deve ter limits de CPU/memória'. Se a política falhar, terraform apply é bloqueado antes de criar o recurso."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__6",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "O que é o Crossplane e como se diferencia do Terraform?",
    "options": [
      "Framework que gerencia infraestrutura cloud como recursos Kubernetes nativos (CRDs), usando o reconciliation loop do K8s",
      "Versão do Terraform para Kubernetes",
      "Plugin do Terraform",
      "Ferramenta de monitoring"
    ],
    "correctIndex": 0,
    "explanation": "Crossplane estende o Kubernetes com CRDs para gerenciar recursos cloud (S3, RDS, VPC). Usa o reconciliation loop nativo: se alguém deletar um bucket manualmente, Crossplane recria automaticamente (self-healing). Terraform precisa de re-run manual.",
    "example": "apiVersion: s3.aws.crossplane.io/v1beta1, kind: Bucket, spec: { forProvider: { region: us-east-1, acl: private } }. kubectl apply → cria bucket S3. kubectl get bucket → READY: True. Alguém deleta na console → Crossplane recria."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__7",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "Como funciona o teste de infraestrutura com Terratest?",
    "options": [
      "Framework Go que provisiona infra real em ambiente temporário, valida e destrói automaticamente",
      "Validação de sintaxe HCL",
      "Linter para Terraform",
      "Simulador de cloud local"
    ],
    "correctIndex": 0,
    "explanation": "Terratest (Gruntwork): escreve testes em Go que executam terraform apply em conta AWS real, validam outputs e recursos (HTTP request, SSH, query), e executam terraform destroy no final. Integra com CI/CD para testar módulos antes de publicar.",
    "example": "func TestWebServer(t *testing.T) { terraformOptions := { TerraformDir: './modules/web' }. defer terraform.Destroy(t, opts). terraform.InitAndApply(t, opts). url := terraform.Output(t, opts, 'url'). http_helper.HttpGetWithRetry(t, url, 200, 'Hello', 30, 5*time.Second) }."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__8",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "Em migração de state Terraform entre backends, qual prática reduz risco de downtime?",
    "options": [
      "Planejar janela, validar `plan`, fazer backup do state e migrar com bloqueio controlado",
      "Editar state manual em produção sem backup",
      "Ignorar drift antes da migração",
      "Executar múltiplos apply concorrentes"
    ],
    "correctIndex": 0,
    "explanation": "Migrar state requer governança: backup, validação prévia e serialização de mudanças para evitar divergência entre estado real e declarado.",
    "example": "Equipe exporta cópia do `tfstate`, executa `init -migrate-state` em ambiente controlado e valida `plan` limpo após migração."
  },
  {
    "id": "cloud__Infrastructure as Code__Difícil__9",
    "track": "cloud",
    "category": "Infrastructure as Code",
    "difficulty": "Difícil",
    "question": "Como Policy as Code melhora segurança antes do `apply` em pipelines IaC?",
    "options": [
      "Bloqueia configurações não conformes automaticamente durante revisão/CI",
      "Substitui completamente monitoramento pós-deploy",
      "Permite qualquer recurso em produção",
      "Remove necessidade de tags e padrões"
    ],
    "correctIndex": 0,
    "explanation": "Regras codificadas (OPA, Sentinel etc.) impedem infra insegura desde o ciclo de entrega, reduzindo retrabalho e incidentes.",
    "example": "Policy reprova plano que cria bucket público sem criptografia ou sem tags obrigatórias de conformidade."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Fácil__1",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Fácil",
    "question": "Quais são os três pilares da observabilidade em sistemas distribuídos?",
    "options": [
      "Logs, Métricas e Traces",
      "CPU, Memória e Disco",
      "Firewall, Proxy e VPN",
      "Frontend, Backend e Banco"
    ],
    "correctIndex": 0,
    "explanation": "Os três pilares da observabilidade são: Logs (registros de eventos), Métricas (medições quantitativas ao longo do tempo) e Traces (rastreamento de requisições entre serviços). Juntos, permitem entender o comportamento interno do sistema.",
    "example": "Um request lento: o Trace mostra que passou por 5 microsserviços; a Métrica mostra latência p99 = 2s no serviço de pagamento; o Log do pagamento revela timeout na conexão com o banco."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Fácil__2",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Fácil",
    "question": "O que é um alerta de monitoramento e quais boas práticas para configurá-lo?",
    "options": [
      "Notificação automática quando métricas ultrapassam thresholds; evitar alert fatigue",
      "Email diário com resumo de métricas",
      "Log automático de erros",
      "Dashboard atualizado em tempo real"
    ],
    "correctIndex": 0,
    "explanation": "Alertas bons são acionáveis (alguém precisa agir), urgentes e não-redundantes. Evite alert fatigue (muitos alertas irrelevantes). Use severidades (critical, warning, info). Agrupe alertas correlacionados. Alertas baseados em SLOs são mais eficazes que thresholds estáticos.",
    "example": "Ruim: alerta a cada erro 500 individual (100 alertas/dia). Bom: alerta quando taxa de erro 5xx > 1% por 5 minutos (acionável, com contexto). Inclua runbook link no alerta."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Fácil__3",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Fácil",
    "question": "O que é um dashboard de observabilidade e quais informações essenciais deve conter?",
    "options": [
      "Painel visual com Golden Signals, SLIs e status dos serviços em tempo real",
      "Lista de todos os servidores",
      "Histórico de deploys",
      "Organograma da equipe de SRE"
    ],
    "correctIndex": 0,
    "explanation": "Dashboard essencial: Golden Signals (latência, tráfego, erros, saturação), SLI/SLO status e error budget restante, health check dos serviços, últimos deploys. Use Grafana, Datadog ou CloudWatch Dashboards. Organize por serviço/equipe.",
    "example": "Dashboard de produção: painel 1 — latência p50/p95/p99 (Prometheus). Painel 2 — error rate com SLO line (99.9%). Painel 3 — req/s por endpoint. Painel 4 — CPU/memória dos pods. Painel 5 — últimos deploys."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Fácil__4",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Fácil",
    "question": "O que é o Prometheus e para que é utilizado?",
    "options": [
      "Sistema open-source de monitoramento e alertas que coleta métricas numéricas de séries temporais",
      "Banco de dados relacional",
      "Ferramenta de tracing distribuído",
      "CDN para dashboards"
    ],
    "correctIndex": 0,
    "explanation": "Prometheus coleta métricas via pull (scrape de endpoints /metrics). Armazena como time series com labels. PromQL para queries. AlertManager para notificações. Integra com Grafana para dashboards. Padrão em K8s. 4 tipos de métricas: Counter, Gauge, Histogram, Summary.",
    "example": "Configuração: scrape_configs: [{job_name: 'api', static_configs: [{targets: ['api:3000']}]}]. PromQL: rate(http_requests_total{status='500'}[5m]) → taxa de erros 500 nos últimos 5 min."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Fácil__5",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Fácil",
    "question": "O que é o Grafana e como se integra com o ecossistema de observabilidade?",
    "options": [
      "Plataforma de visualização que conecta múltiplas fontes de dados para criar dashboards interativos",
      "Banco de métricas",
      "Coletor de logs",
      "Sistema de alertas exclusivo"
    ],
    "correctIndex": 0,
    "explanation": "Grafana é visualização, não armazena dados. Conecta com Prometheus (métricas), Loki (logs), Tempo (traces), Elasticsearch, CloudWatch, InfluxDB. Dashboards com painéis, variáveis, alertas. Grafana Cloud oferece stack LGTM (Loki, Grafana, Tempo, Mimir).",
    "example": "Dashboard Grafana: painel de métricas (Prometheus), painel de logs (Loki) com correlação temporal, link para trace (Tempo) ao clicar em um log de erro. Tudo em uma interface unificada."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Fácil__6",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Fácil",
    "question": "Em observabilidade, para que servem logs estruturados em formato JSON?",
    "options": [
      "Facilitam busca, filtro e correlação automática por campos",
      "Substituem totalmente métricas e traces",
      "Reduzem a necessidade de timestamp",
      "Impedem indexação em ferramentas de log"
    ],
    "correctIndex": 0,
    "explanation": "Logs estruturados carregam campos padronizados (nível, serviço, trace_id, usuário), permitindo consultas rápidas e análises consistentes.",
    "example": "Com JSON, o time filtra `service=checkout` e `status=500` em segundos para investigar um incidente."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Fácil__7",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Fácil",
    "question": "Qual é o objetivo de um health check sintético em monitoramento?",
    "options": [
      "Executar testes periódicos simulando usuário para detectar indisponibilidade cedo",
      "Apenas medir uso de CPU no servidor",
      "Substituir logs de aplicação",
      "Desligar alertas durante horário comercial"
    ],
    "correctIndex": 0,
    "explanation": "Monitoramento sintético valida disponibilidade de ponta a ponta, mesmo sem tráfego real, ajudando a detectar falhas antes de usuários reportarem.",
    "example": "A cada minuto, um robô faz login e consulta saldo; se falhar três vezes, abre alerta crítico automaticamente."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__1",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "No Prometheus, qual tipo de métrica é mais adequado para medir a duração de requisições HTTP, permitindo calcular percentis como p95 e p99?",
    "options": [
      "Histogram",
      "Counter",
      "Gauge",
      "Summary"
    ],
    "correctIndex": 0,
    "explanation": "O Histogram agrupa observações em buckets configuráveis e registra contagem e soma total. Permite calcular percentis (p50, p95, p99) no servidor Prometheus usando a função histogram_quantile(), ideal para latências.",
    "example": "http_request_duration_seconds_bucket{le=\"0.5\"} = 900 — 900 das 1000 requisições levaram até 0.5s. histogram_quantile(0.95, ...) calcula o p95."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__2",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "O que são os Golden Signals definidos pelo Google SRE e quais são?",
    "options": [
      "Latência, Tráfego, Erros e Saturação — 4 métricas essenciais para monitorar serviços",
      "CPU, Memória, Disco e Rede",
      "Disponibilidade, Durabilidade, Escalabilidade e Segurança",
      "Uptime, Downtime, MTTR e MTBF"
    ],
    "correctIndex": 0,
    "explanation": "Golden Signals (Google SRE Book): 1) Latência: tempo de resposta das requisições. 2) Tráfego: volume de demanda (req/s). 3) Erros: taxa de requisições que falham. 4) Saturação: quão cheio o serviço está (CPU, memória, fila). Se você monitora apenas esses 4, já tem excelente visibilidade.",
    "example": "Dashboard com Golden Signals: Latência p99 = 200ms ✓, Tráfego = 1.2k req/s ✓, Erros = 0.1% ✓, Saturação CPU = 85% ⚠️. A saturação alta indica necessidade de scaling antes que afete latência."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__3",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "O que é distributed tracing e qual problema ele resolve em microsserviços?",
    "options": [
      "Rastreamento de requisições entre múltiplos serviços, identificando gargalos na cadeia",
      "Monitoramento de CPU distribuída",
      "Backup distribuído de logs",
      "Balanceamento de carga entre traces"
    ],
    "correctIndex": 0,
    "explanation": "Distributed tracing propaga um trace ID único através de todos os serviços que processam uma requisição. Cada serviço cria spans com timestamps, permitindo visualizar a jornada completa da requisição, identificar qual serviço está lento e entender dependências. Ferramentas: Jaeger, Zipkin, Tempo.",
    "example": "Trace ID abc123: API Gateway (5ms) → Auth Service (15ms) → Product Service (8ms) → Database Query (350ms) → Cache Write (2ms). Total: 380ms. Gargalo claro: query ao banco de 350ms."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__4",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "O que é o Grafana Loki e como difere do Elasticsearch para logs?",
    "options": [
      "Sistema de logs que indexa apenas labels, mais leve e barato que Elasticsearch",
      "Fork do Elasticsearch",
      "Banco de métricas",
      "Ferramenta de tracing"
    ],
    "correctIndex": 0,
    "explanation": "Loki: indexa apenas labels (app, namespace, level), não o texto do log. Busca via LogQL similar a PromQL. Muito mais barato em armazenamento que Elasticsearch. Integração nativa com Grafana. Ideal quando já usa Prometheus+Grafana.",
    "example": "LogQL: {app=\"api\", level=\"error\"} |= \"timeout\" | json | duration > 5s — busca logs de erro da API contendo timeout onde duração > 5s. Loki armazena logs comprimidos no S3."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__5",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "O que é APM (Application Performance Monitoring) e quais insights fornece?",
    "options": [
      "Monitoramento de performance de aplicações: latência, erros, dependências e transações",
      "Monitoramento de infraestrutura apenas",
      "Ferramenta de load testing",
      "Scanner de vulnerabilidades"
    ],
    "correctIndex": 0,
    "explanation": "APM instrumenta aplicações para rastrear cada transação: tempo de resposta, queries SQL, chamadas HTTP externas, erros com stack trace. Ferramentas: Datadog APM, New Relic, Azure Application Insights, Elastic APM, OpenTelemetry.",
    "example": "Datadog APM mostra: endpoint GET /users p99=450ms. Drill down: 200ms no PostgreSQL (query N+1 detectada), 150ms em chamada HTTP para serviço de auth, 100ms processamento. Recomendação: resolver N+1."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__6",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "O que é log estruturado e por que é superior ao log de texto livre?",
    "options": [
      "Logs em formato JSON/chave-valor que permitem filtragem e análise programática eficiente",
      "Logs organizados por data",
      "Logs em XML",
      "Logs compactados em ZIP"
    ],
    "correctIndex": 0,
    "explanation": "Log estruturado (JSON): cada campo é queryável separadamente (userId, duration, status). Log de texto livre: precisa de regex para extrair informações. Structured logging permite agregação, correlação e alertas baseados em campos específicos.",
    "example": "Texto livre: '2025-01-15 10:30:45 ERROR Payment failed for user 123 after 450ms'. Estruturado: {\"timestamp\":\"2025-01-15T10:30:45Z\",\"level\":\"error\",\"msg\":\"Payment failed\",\"userId\":123,\"duration_ms\":450}. Query: level=error AND duration_ms>400."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__7",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "O que é o OpenTelemetry e por que está se tornando o padrão de observabilidade?",
    "options": [
      "Framework open-source vendor-neutral que unifica coleta de traces, métricas e logs com SDKs padronizados",
      "Ferramenta de monitoramento da Google",
      "Substituto do Prometheus",
      "CDN para telemetria"
    ],
    "correctIndex": 0,
    "explanation": "OpenTelemetry (OTel) é o merge de OpenTracing + OpenCensus. Fornece SDKs para instrumentação (auto e manual), OTLP (protocolo padrão) e Collector (pipeline). Vendor-neutral: instrumenta uma vez, exporta para qualquer backend (Jaeger, Datadog, New Relic, Grafana).",
    "example": "SDK OTel Node.js: auto-instrumenta Express, pg, Redis automaticamente. Exporta traces via OTLP para Collector → Collector envia métricas para Prometheus e traces para Tempo. Troca de backend: só muda config do Collector."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__8",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "Como alertas de burn rate ajudam a evitar fadiga de alertas (alert fatigue)?",
    "options": [
      "Disparam com base no consumo do error budget e severidade temporal, não em ruído pontual",
      "Alertam toda variação mínima de CPU",
      "Ignoram completamente SLO",
      "Substituem investigação de causa-raiz"
    ],
    "correctIndex": 0,
    "explanation": "Burn rate conecta incidentes ao orçamento de erro, priorizando sinais que realmente ameaçam metas de confiabilidade.",
    "example": "Regra multi-janela alerta rápido se burn rate em 5 min for muito alto e confirma persistência em janela de 1 h."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Médio__9",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Médio",
    "question": "Qual é a diferença prática entre head sampling e tail sampling em tracing distribuído?",
    "options": [
      "Head decide no início da requisição; tail decide após conhecer resultado final do trace",
      "Head coleta mais contexto de erro sempre",
      "Tail ignora traces lentos",
      "Não há diferença de custo"
    ],
    "correctIndex": 0,
    "explanation": "Head sampling é mais simples e barato; tail sampling preserva melhor traces raros/importantes (erros/lentos), porém exige processamento adicional.",
    "example": "Em alto volume, o time usa head 5% + tail para manter 100% dos traces com erro."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__1",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "No OpenTelemetry, qual é o papel do 'Collector' na arquitetura e quais são seus três componentes internos de pipeline?",
    "options": [
      "Recebe, processa e exporta telemetria — Receivers, Processors e Exporters",
      "Apenas armazena dados — Storage, Index e Query",
      "Gera métricas — Generator, Filter e Display",
      "Coleta logs — Agent, Parser e Writer"
    ],
    "correctIndex": 0,
    "explanation": "O OpenTelemetry Collector é um proxy/pipeline de telemetria com três componentes: Receivers (recebem dados via OTLP, Jaeger, Prometheus), Processors (filtram, agrupam, enriquecem dados) e Exporters (enviam para backends como Jaeger, Prometheus, Datadog).",
    "example": "receivers: { otlp: { protocols: { grpc: {} } } }, processors: { batch: {} }, exporters: { jaeger: { endpoint: 'jaeger:14250' } } — recebe OTLP, agrupa em batch e exporta para Jaeger."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__2",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "O que são SLIs, SLOs e SLAs no contexto de SRE e como se relacionam?",
    "options": [
      "SLI é a métrica medida; SLO é o objetivo interno; SLA é o contrato externo com penalidades",
      "São sinônimos",
      "SLA é a métrica e SLI o contrato",
      "SLO substitui SLA"
    ],
    "correctIndex": 0,
    "explanation": "SLI (Service Level Indicator): métrica real (ex: latência p99 = 180ms). SLO (Service Level Objective): alvo interno (ex: p99 < 200ms em 99.9% do tempo). SLA (Service Level Agreement): contrato com cliente com penalidades (ex: 99.9% uptime, crédito se descumprir). Hierarquia: SLI mede, SLO define objetivo, SLA compromete.",
    "example": "SLI: latência p99 nos últimos 30 dias = 185ms. SLO: p99 < 200ms → status: OK (dentro do budget). SLA: 99.9% disponibilidade → se ultrapassar 43min de downtime/mês, cliente recebe 10% de crédito."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__3",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "O que é error budget em SRE e como ele guia decisões entre velocidade de release e confiabilidade?",
    "options": [
      "Orçamento de indisponibilidade permitido pelo SLO; quando esgotado, prioriza-se estabilidade sobre features",
      "Budget financeiro para corrigir bugs",
      "Limite de erros em logs",
      "Tempo de resposta máximo"
    ],
    "correctIndex": 0,
    "explanation": "Se o SLO é 99.9% uptime mensal, o error budget é 0.1% = ~43 minutos de downtime permitido. Enquanto houver budget, equipes podem deployar agressivamente. Quando o budget se esgota (muitos incidentes), deploys são congelados e o foco muda para confiabilidade. Política objective de trade-off velocidade vs estabilidade.",
    "example": "Mês com error budget de 43 min. Dia 15: incidente consumiu 30 min. Restam 13 min. Equipe reduz frequência de deploys e foca em testes. Dia 25: segundo incidente de 15 min → budget estourado → freeze de releases + postmortem obrigatório."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__4",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "O que é o padrão RED (Rate, Errors, Duration) para monitoramento de microsserviços?",
    "options": [
      "Método que monitora taxa de requisições, taxa de erros e duração por serviço",
      "Framework de segurança",
      "Linguagem de configuração",
      "Tipo de alerta crítico"
    ],
    "correctIndex": 0,
    "explanation": "RED (Tom Wilkie, Grafana): Rate (req/s), Errors (req com falha/s), Duration (latência). Complementa USE (Utilization, Saturation, Errors) para infraestrutura. RED para serviços request-driven; USE para recursos (CPU, disco).",
    "example": "Dashboard RED do serviço de pagamentos: Rate: 500 req/s OK. Errors: 2 req/s (0.4%) OK. Duration p99: 800ms (SLO: < 500ms). Investigação: query lenta no banco após deploy v2.3."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__5",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "O que é observability-driven development e como impacta a engenharia?",
    "options": [
      "Instrumentar observabilidade desde o desenvolvimento, não apenas após produzir o código",
      "Desenvolver dashboards antes do código",
      "Usar logs como documentação",
      "Substituir testes por monitoramento"
    ],
    "correctIndex": 0,
    "explanation": "Observability-driven: adicione métricas, logs estruturados e spans de tracing DURANTE o desenvolvimento, não como afterthought. Pergunte: como vou debugar isso em produção? OpenTelemetry facilita com SDKs idiomáticos.",
    "example": "Dev adiciona: span.setAttributes({ 'payment.method': 'pix', 'payment.amount': 150.00 }); logger.info('Payment processed', { orderId, duration }); meter.counter('payments_total').add(1); — tudo instrumentado antes do merge."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__6",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "O que é o conceito de 'Cardinality' em métricas e por que alta cardinalidade é problemática?",
    "options": [
      "Número de combinações únicas de labels; alta cardinalidade consome memória e disco excessivos no sistema de métricas",
      "Número de métricas distintas",
      "Quantidade de dashboards",
      "Frequência de scrape"
    ],
    "correctIndex": 0,
    "explanation": "Cardinalidade = combinações únicas de label values em uma métrica. http_requests{method, path, status}: 5 methods × 1000 paths × 10 status = 50.000 séries. Alta cardinalidade: Prometheus consome GBs de RAM. Solução: evitar labels de alta variação (userId, requestId).",
    "example": "RUIM: http_requests_total{userId='abc123'} → 1M usuários = 1M séries → OOM do Prometheus. BOM: http_requests_total{endpoint='/api/users', method='GET', status='200'} → centenas de séries. UserID vai no trace/log, NÃO na métrica."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__7",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "O que é o padrão USE (Utilization, Saturation, Errors) para monitoramento de infraestrutura?",
    "options": [
      "Método que monitora utilização, saturação e erros de cada recurso de hardware/software",
      "Framework de deploy",
      "Tipo de SLO",
      "Método de capacity planning"
    ],
    "correctIndex": 0,
    "explanation": "USE (Brendan Gregg): para cada recurso (CPU, memória, disco, rede): U=Utilization (% em uso), S=Saturation (fila de espera), E=Errors (falhas). Complementa RED (para serviços). USE identifica gargalos de infraestrutura; RED identifica problemas de aplicação.",
    "example": "CPU: U=85% (alto), S=12 processos na run queue (saturado), E=0. Diagnóstico: CPU sobrecarregada, precisa scale up ou otimizar código. Disco: U=95%, S=await 150ms, E=3 I/O errors → disco degradando, substituir."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__8",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "Como a correlação por `trace_id` entre logs, métricas e traces acelera diagnóstico?",
    "options": [
      "Permite navegar do sintoma ao ponto exato da falha entre camadas do sistema",
      "Substitui totalmente testes de carga",
      "Elimina necessidade de retenção de logs",
      "Impede uso de APM"
    ],
    "correctIndex": 0,
    "explanation": "Com contexto unificado, o time liga erro de negócio a spans e logs específicos, reduzindo MTTR e suposições durante incidentes.",
    "example": "Alerta de latência aponta `trace_id`; analista abre o trace e encontra consulta SQL lenta no serviço de inventário."
  },
  {
    "id": "cloud__Monitoramento e Observabilidade__Difícil__9",
    "track": "cloud",
    "category": "Monitoramento e Observabilidade",
    "difficulty": "Difícil",
    "question": "Por que SLO com alerta multi-janela (curta + longa) é mais robusto?",
    "options": [
      "Detecta degradações agudas e problemas persistentes, equilibrando sensibilidade e precisão",
      "Gera menos contexto para incidentes",
      "Funciona sem métricas históricas",
      "Serve apenas para ambientes de teste"
    ],
    "correctIndex": 0,
    "explanation": "Combinar janelas evita tanto atraso na detecção quanto excesso de falso positivo por picos breves sem impacto duradouro.",
    "example": "Regra de 5 min captura queda abrupta de disponibilidade; janela de 6 h confirma tendência antes de escalar severidade."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__1",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "Em computação serverless, quem é responsável por gerenciar e escalar os servidores que executam o código?",
    "options": [
      "O provedor de nuvem",
      "O desenvolvedor",
      "O cliente final",
      "O time de infraestrutura interno"
    ],
    "correctIndex": 0,
    "explanation": "No modelo serverless, o provedor de nuvem gerencia toda a infraestrutura: provisiona servidores, aplica patches, escala automaticamente conforme a demanda e cobra apenas pelo tempo de execução efetivo do código.",
    "example": "Uma função Lambda recebe 0 requisições à noite → custo zero. Às 9h recebe 10.000 requisições → AWS escala automaticamente para várias instâncias. Você só paga pelo tempo de execução."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__2",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "Qual é um exemplo comum de trigger (gatilho) que pode invocar uma função serverless?",
    "options": [
      "Requisição HTTP, upload de arquivo no storage ou mensagem em uma fila",
      "Reiniciar o servidor",
      "Compilar o código-fonte",
      "Criar uma máquina virtual"
    ],
    "correctIndex": 0,
    "explanation": "Funções serverless são acionadas por eventos (triggers): HTTP requests (API Gateway), uploads em storage (S3, Blob), mensagens em filas (SQS, Pub/Sub), alterações em banco (DynamoDB Streams), schedules (cron), e eventos de outros serviços.",
    "example": "Usuário faz upload de foto no S3 → S3 Event Notification dispara Lambda → Lambda redimensiona a foto → salva thumbnail no S3. Tudo automático, sem servidor dedicado."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__3",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "Qual é a principal vantagem financeira do modelo de preço serverless?",
    "options": [
      "Pagamento apenas pelo tempo de execução real (pay-per-use), sem custos com ociosidade",
      "Preço fixo mensal",
      "Desconto por volume de dados",
      "Gratuito para todos os usos"
    ],
    "correctIndex": 0,
    "explanation": "No modelo serverless, você paga por invocação e tempo de computação (ex: $0.20/1M invocações + $0.0000166667/GB-segundo no Lambda). Se a função não é invocada, o custo é zero. Em servidores tradicionais, você paga 24/7 mesmo com 5% de utilização.",
    "example": "API com 100k requests/mês, 200ms cada, 256MB memória: Lambda custa ~$0.42/mês. Servidor EC2 t3.micro 24/7: ~$8.50/mês. Para workloads esporádicos, serverless é 10-20x mais barato."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__4",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "O que é BaaS (Backend as a Service) e como complementa o FaaS?",
    "options": [
      "Serviços gerenciados de backend (auth, banco, storage) que eliminam a necessidade de servidor próprio",
      "Backup como serviço",
      "Blockchain como serviço",
      "Browser como serviço"
    ],
    "correctIndex": 0,
    "explanation": "BaaS fornece componentes de backend prontos: Firebase (auth, Firestore, Storage), Supabase (PostgreSQL, auth, storage), AWS Amplify. Combinado com FaaS (Lambda, Cloud Functions), permite criar aplicações completas sem servidor. Ideal para MVPs e apps mobile.",
    "example": "App mobile com Firebase: Auth (login Google), Firestore (banco real-time), Storage (imagens), Cloud Functions (lógica de negócio). Zero servidores para gerenciar. Custo: $0 até 50k usuários no free tier."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__5",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "O que é o conceito de event-driven architecture em serverless?",
    "options": [
      "Arquitetura onde componentes reagem a eventos assíncronos em vez de chamadas síncronas diretas",
      "Arquitetura baseada em polling contínuo",
      "Modelo request-response tradicional",
      "Arquitetura monolítica com eventos"
    ],
    "correctIndex": 0,
    "explanation": "Event-driven: produtores emitem eventos (pedido criado, arquivo salvo) e consumidores reagem independentemente. Desacoplamento total. Componentes: event source (S3, API), event router (EventBridge, SNS) e event handler (Lambda). Escala naturalmente.",
    "example": "Usuário faz upload (S3 event) → Lambda gera thumbnail → publica evento 'thumbnail-created' no EventBridge → Lambda atualiza banco → Lambda envia notificação. Tudo desacoplado e independente."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__6",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "O que é o AWS API Gateway e como se integra com Lambda?",
    "options": [
      "Serviço que cria e gerencia APIs REST/HTTP/WebSocket, encaminhando requisições para Lambda ou outros backends",
      "Gateway de rede entre VPCs",
      "CDN para APIs",
      "Banco de dados para APIs"
    ],
    "correctIndex": 0,
    "explanation": "API Gateway cria endpoints HTTP que roteiam para Lambda, HTTP backends ou serviços AWS. Oferece: throttling, caching, autorização (Cognito, Lambda authorizer), versionamento, CORS. Dois tipos: REST API (mais features) e HTTP API (mais barato e simples).",
    "example": "API Gateway HTTP API: GET /users → Lambda listUsers. POST /users → Lambda createUser. Throttle: 1000 req/s. Custom domain: api.meuapp.com com certificado ACM. Custo HTTP API: $1.00/milhão de requests."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__7",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "O que é scale-to-zero e por que é uma característica importante do serverless?",
    "options": [
      "Capacidade de reduzir instâncias a zero quando não há tráfego, eliminando custo de ociosidade",
      "Escalar para performance zero",
      "Zerar os logs do servidor",
      "Remover todos os dados"
    ],
    "correctIndex": 0,
    "explanation": "Scale-to-zero: quando não há requisições, o serviço não consome recursos (e não cobra). Ao receber tráfego, escala automaticamente. Lambda, Cloud Run e Azure Functions (Consumption) fazem isso nativamente. Trade-off: cold start na primeira requisição após ociosidade.",
    "example": "API serverless às 3h da manhã: 0 instâncias, custo $0. Às 9h: pico de tráfego, escala para 100 instâncias. Às 22h: demanda cai, escala para 5. Às 2h: 0 novamente. Servidor trad: $8.50/mês 24/7."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__8",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "O que é cold start em plataformas serverless?",
    "options": [
      "Latência adicional quando a plataforma cria/aquece instância para executar a função",
      "Falha permanente de execução",
      "Erro de autenticação no banco",
      "Rollback automático de deploy"
    ],
    "correctIndex": 0,
    "explanation": "Cold start ocorre quando não há instância pronta e o runtime precisa inicializar ambiente, dependências e código antes de responder.",
    "example": "Primeira chamada após período sem tráfego demora 700 ms; chamadas seguintes ficam em ~80 ms com instância quente."
  },
  {
    "id": "cloud__Serverless e Functions__Fácil__9",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Fácil",
    "question": "Por que funções serverless devem ser preferencialmente stateless?",
    "options": [
      "Porque execuções são efêmeras e podem ocorrer em instâncias diferentes",
      "Porque estado local é replicado automaticamente entre regiões",
      "Porque elimina necessidade de banco",
      "Porque impede paralelismo"
    ],
    "correctIndex": 0,
    "explanation": "A plataforma pode reiniciar ou mover execuções a qualquer momento; estado persistente deve ficar em serviços externos (DB, cache, storage).",
    "example": "Função grava progresso em DynamoDB/Firestore em vez de depender de variável global em memória."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__1",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "O que é o problema de 'cold start' em funções serverless e qual seu impacto?",
    "options": [
      "Latência extra na primeira invocação quando o runtime precisa ser inicializado",
      "Perda de dados quando a função é encerrada",
      "Erro de conexão com o banco de dados",
      "Limitação de memória da função"
    ],
    "correctIndex": 0,
    "explanation": "Cold start ocorre quando uma função serverless é invocada após período de inatividade e o provedor precisa alocar um contêiner, carregar o runtime e inicializar o código. Isso adiciona latência de 100ms a vários segundos dependendo do runtime e tamanho do pacote.",
    "example": "Uma Lambda em Java com SDK AWS demora ~3s no cold start. Provisioned Concurrency mantém N instâncias quentes: aws lambda put-provisioned-concurrency-config --function-name api --qualifier prod --provisioned-concurrent-executions 10."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__2",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "Qual é o limite de tempo de execução (timeout) máximo de uma AWS Lambda e como isso afeta o design da aplicação?",
    "options": [
      "15 minutos — processos longos devem ser divididos ou usar Step Functions",
      "30 segundos",
      "1 hora",
      "Sem limite"
    ],
    "correctIndex": 0,
    "explanation": "AWS Lambda tem timeout máximo de 15 minutos (900 segundos). Para processos mais longos, use: Step Functions para orquestração, divida em funções menores encadeadas, ou use ECS/Fargate para tarefas sem limite de tempo. Azure Functions (Consumption): 10 min (Premium: sem limite).",
    "example": "Processar vídeo de 2h em uma única Lambda é impossível (>15min). Solução: Lambda 1 divide o vídeo em chunks de 5 min → Step Functions dispara N Lambdas paralelas (Map State) → Lambda final concatena os resultados."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__3",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "O que é o AWS SAM (Serverless Application Model) e como ele simplifica o desenvolvimento serverless?",
    "options": [
      "Framework que estende CloudFormation com sintaxe simplificada para recursos serverless",
      "IDE para Lambda",
      "Linguagem de programação serverless",
      "Serviço de deploy de contêineres"
    ],
    "correctIndex": 0,
    "explanation": "AWS SAM é um framework open-source que usa templates YAML com sintaxe simplificada para definir Lambda, API Gateway, DynamoDB e outros recursos serverless. Inclui CLI para build, teste local (sam local invoke) e deploy. É transformado em CloudFormation na hora do deploy.",
    "example": "template.yaml: Type: AWS::Serverless::Function, Properties: Handler: index.handler, Runtime: nodejs18.x, Events: Api: { Type: Api, Properties: { Path: /hello, Method: get } }. sam local start-api → testa localmente na porta 3000."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__4",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "O que é o Serverless Framework e como simplifica o desenvolvimento serverless?",
    "options": [
      "Framework open-source multi-cloud para definir, deployar e gerenciar aplicações serverless via YAML",
      "SDK para Azure Functions",
      "IDE para Lambda",
      "Container runtime serverless"
    ],
    "correctIndex": 0,
    "explanation": "Serverless Framework usa serverless.yml para definir funções, eventos (HTTP, SQS, schedule) e recursos (DynamoDB, S3). Suporta AWS, Azure, GCP. Comandos: sls deploy (provisiona tudo), sls invoke (testa função), sls logs (visualiza logs).",
    "example": "serverless.yml: functions: hello: handler: handler.hello, events: [httpApi: GET /hello]. process: handler: handler.process, events: [sqs: arn]. sls deploy — cria API Gateway + 2 Lambdas + vincula SQS."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__5",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "Quais são as limitações comuns de funções serverless que afetam o design da aplicação?",
    "options": [
      "Timeout, tamanho do pacote, memória, cold start e falta de estado persistente",
      "Não suportam HTTP",
      "Não podem acessar bancos de dados",
      "Só funcionam com JavaScript"
    ],
    "correctIndex": 0,
    "explanation": "Limitações: timeout (Lambda 15min), pacote (250MB unzipped), memória (10GB max), cold start (100ms-10s), sem estado persistente (stateless), concurrency limits. Design: funções pequenas, idempotentes, stateless, com timeouts curtos.",
    "example": "Lambda: max 15min, 10GB RAM, 250MB pacote. Para vídeo de 2h: divide em chunks via Step Functions. Para estado: use DynamoDB/Redis. Para conectar ao RDS: use RDS Proxy para evitar exaurir conexões."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__6",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "O que é o AWS EventBridge e como difere do SNS?",
    "options": [
      "Barramento de eventos serverless com roteamento baseado em conteúdo, schema registry e integração SaaS",
      "São idênticos",
      "SNS é mais avançado",
      "EventBridge é para streaming"
    ],
    "correctIndex": 0,
    "explanation": "EventBridge: barramento de eventos com roteamento baseado em conteúdo (filtrar por campos do evento), schema registry, integração com SaaS (Zendesk, Shopify), archive e replay de eventos. SNS: pub/sub simples com filtering por atributos. EventBridge é a evolução.",
    "example": "EventBridge rule: source='orders', detail-type='OrderCreated', detail: { amount: [{numeric: ['>', 1000]}] } → target: Lambda antifraud. Apenas pedidos > R$1000 disparam a função de antifraude."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__7",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "O que é o conceito de 'fan-in' em arquiteturas serverless?",
    "options": [
      "Padrão onde múltiplas execuções paralelas convergem em um ponto de agregação",
      "Distribuir eventos para múltiplos consumidores",
      "Replicar funções em múltiplas regiões",
      "Comprimir payloads de eventos"
    ],
    "correctIndex": 0,
    "explanation": "Fan-in é o oposto de fan-out: múltiplas execuções paralelas produzem resultados que são agregados em um único ponto. Step Functions Map State faz fan-out (paralelo) e depois fan-in (coleta todos os resultados). SQS + batch Lambda também implementa fan-in.",
    "example": "Step Functions: Map State processa 100 imagens em paralelo (fan-out). Cada Lambda retorna metadata. Após todas completarem, próximo state agrega os 100 resultados em um relatório final (fan-in)."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__8",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "Quando inserir uma fila entre API e função serverless melhora robustez?",
    "options": [
      "Quando há picos de tráfego e processamento assíncrono com retry controlado",
      "Quando toda requisição exige resposta síncrona imediata",
      "Quando não se quer observabilidade",
      "Quando se precisa de estado local durável"
    ],
    "correctIndex": 0,
    "explanation": "Fila desacopla ingestão e processamento, absorvendo bursts e permitindo retentativas com DLQ sem derrubar a API de entrada.",
    "example": "Endpoint recebe 10 mil uploads/min e enfileira jobs; funções consumidoras processam no ritmo disponível."
  },
  {
    "id": "cloud__Serverless e Functions__Médio__9",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Médio",
    "question": "Como memória configurada em função serverless pode impactar desempenho?",
    "options": [
      "Muitas plataformas atrelam mais CPU à memória, reduzindo tempo de execução",
      "Memória afeta apenas logging",
      "Menor memória sempre melhora latência",
      "Memória não influencia custo"
    ],
    "correctIndex": 0,
    "explanation": "Ajuste de memória altera recursos computacionais e custo/execução. Benchmark é necessário para achar ponto ótimo de preço-performance.",
    "example": "Função em 128 MB leva 4 s; em 512 MB cai para 900 ms e custo final por requisição pode até reduzir."
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__1",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "Ao projetar um sistema event-driven serverless com AWS Lambda, SQS e DynamoDB, como evitar processamento duplicado de eventos garantindo idempotência?",
    "options": [
      "Armazenar um ID de idempotência no DynamoDB com conditional write antes de processar",
      "Confiar na entrega exactly-once do SQS Standard",
      "Usar timeout curtos na Lambda",
      "Desabilitar retries na fila SQS"
    ],
    "correctIndex": 0,
    "explanation": "SQS Standard pode entregar mensagens duplicadas. Para garantir idempotência, cada mensagem deve ter um ID único. Antes de processar, faça um PutItem condicional no DynamoDB com condition 'attribute_not_exists(pk)'. Se o item já existir, a mensagem já foi processada.",
    "example": "const params = { TableName: 'ProcessedEvents', Item: { pk: eventId }, ConditionExpression: 'attribute_not_exists(pk)' }; try { await dynamo.put(params); await processEvent(); } catch (e) { if (e.code === 'ConditionalCheckFailedException') return; /* já processado */ }"
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__2",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "No AWS Lambda, o que é Lambda@Edge e como ela difere de CloudFront Functions?",
    "options": [
      "Lambda@Edge roda em edge locations do CloudFront com mais recursos e suporte a origin request/response; CloudFront Functions são mais leves e rápidas para viewer events",
      "São idênticas",
      "CloudFront Functions têm mais recursos",
      "Lambda@Edge é mais barata"
    ],
    "correctIndex": 0,
    "explanation": "Lambda@Edge: roda nas edge locations do CloudFront, suporta Node.js/Python, até 5s (viewer) ou 30s (origin), até 10GB de memória, acesso a rede. CloudFront Functions: execução sub-milissegundo em 200+ PoPs, apenas JavaScript, até 10ms, 2MB de memória. CF Functions para manipulações simples (headers, redirects); Lambda@Edge para lógica complexa.",
    "example": "CloudFront Function: adicionar header de segurança em toda response (< 1ms). Lambda@Edge: verificar autenticação JWT na origin request, fazer A/B testing com cookies, ou gerar conteúdo dinâmico no edge."
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__3",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "Como projetar uma arquitetura serverless event-driven com fan-out pattern usando SNS + SQS + Lambda?",
    "options": [
      "SNS publica evento para múltiplas filas SQS (fan-out); cada fila dispara uma Lambda consumidora independente",
      "Lambda chama Lambda diretamente",
      "SQS publica para SNS",
      "Fan-out é possível apenas com Kinesis"
    ],
    "correctIndex": 0,
    "explanation": "Padrão fan-out: SNS topic recebe um evento e distribui para múltiplas filas SQS inscritas (subscribers). Cada fila SQS tem uma Lambda consumidora independente com retry próprio e DLQ. Isso desacopla produtores e consumidores, permite processamento paralelo e independente de cada consumidor.",
    "example": "Evento 'PedidoCriado' → SNS Topic → SQS-Pagamento (→ Lambda processa pagamento) + SQS-Estoque (→ Lambda atualiza estoque) + SQS-Email (→ Lambda envia confirmação). Se a Lambda de e-mail falhar, as outras não são afetadas."
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__4",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "O que é o Knative e como ele traz serverless para o Kubernetes?",
    "options": [
      "Plataforma que adiciona capacidades serverless (scale-to-zero, event-driven) ao Kubernetes",
      "Distribuição de Kubernetes",
      "Alternativa ao Docker",
      "Plugin de rede para K8s"
    ],
    "correctIndex": 0,
    "explanation": "Knative adiciona dois componentes ao K8s: Serving (scale-to-zero, revisions, traffic splitting) e Eventing (event sources, brokers, triggers). Permite experiência serverless (como Cloud Run, que é baseado em Knative) dentro do seu cluster K8s.",
    "example": "apiVersion: serving.knative.dev/v1, kind: Service, spec: template: spec: containers: [{image: gcr.io/app:v1}]. Escala de 0 a N automaticamente. Traffic: 90% v1, 10% v2 para canary."
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__5",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "O que é o conceito de connection pooling e por que é crítico em serverless?",
    "options": [
      "Reutilizar conexões de banco em pool; serverless cria muitas instâncias que podem esgotar conexões",
      "Pool de threads para computação paralela",
      "Cache de requisições HTTP",
      "Agrupamento de logs"
    ],
    "correctIndex": 0,
    "explanation": "Cada instância Lambda/Function abre conexão ao banco. Com 1000 instâncias simultâneas, são 1000 conexões — PostgreSQL default max_connections=100. Solução: RDS Proxy (AWS), PgBouncer, Prisma Data Proxy — pool compartilhado entre instâncias.",
    "example": "Sem proxy: 500 Lambdas x 1 conexão = 500 (RDS suporta 100 — erro). Com RDS Proxy: 500 Lambdas → proxy → 50 conexões ao RDS, reutilizando. Latência de conexão também cai com proxy."
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__6",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "O que é o padrão Saga em arquiteturas serverless e como implementar com Step Functions?",
    "options": [
      "Padrão para transações distribuídas que usa compensações (rollback) em caso de falha em qualquer etapa",
      "Backup automático de funções",
      "Cache distribuído",
      "Tipo de fila de mensagens"
    ],
    "correctIndex": 0,
    "explanation": "Saga executa uma sequência de transações locais. Se uma falhar, executa compensações (desfazer) das anteriores. Dois tipos: orchestration (Step Functions coordena) e choreography (eventos assíncronos). Substitui transações distribuídas (2PC) em microsserviços.",
    "example": "Step Functions Saga: ReservarVoo → ReservarHotel → CobrarCartão. Se CobrarCartão falhar: Catch → CancelarHotel → CancelarVoo. Cada step tem compensador. State machine garante que rollback completo ocorra."
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__7",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "O que é o conceito de 'ephemeral compute' e como afeta o design serverless?",
    "options": [
      "Instâncias de computação temporárias que podem ser destruídas a qualquer momento, exigindo design stateless",
      "Computação com menor custo",
      "Servidores com uptime garantido",
      "Cache que persiste entre invocações"
    ],
    "correctIndex": 0,
    "explanation": "Em serverless, instâncias são efêmeras: criadas sob demanda, recicladas após período de inatividade. Implicações: todo estado deve ser externo (DynamoDB, S3, Redis), filesystem é temporário (/tmp, max 10GB no Lambda), conexões devem ser resilientes a reconexão.",
    "example": "Lambda usa /tmp para cache local (válido apenas durante warm instances). Sessão de usuário: DynamoDB (não em memória local). Upload temporário: S3 com lifecycle policy de 24h. Variáveis de ambiente para configs."
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__8",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "Por que chave de idempotência é crítica em processamento assíncrono serverless?",
    "options": [
      "Porque eventos podem ser reentregues e a chave evita efeitos duplicados",
      "Porque elimina necessidade de fila",
      "Porque impede qualquer timeout",
      "Porque substitui autenticação"
    ],
    "correctIndex": 0,
    "explanation": "Mensageria e funções distribuídas seguem semântica at-least-once com reentrega. Idempotência garante consistência funcional diante de retries.",
    "example": "Consumidor grava `eventId` processado em tabela de dedupe antes de faturar para não cobrar duas vezes."
  },
  {
    "id": "cloud__Serverless e Functions__Difícil__9",
    "track": "cloud",
    "category": "Serverless e Functions",
    "difficulty": "Difícil",
    "question": "Qual estratégia melhora observabilidade fim a fim em arquitetura serverless orientada a eventos?",
    "options": [
      "Propagar correlation ID e coletar traces/logs estruturados em cada salto",
      "Registrar somente logs locais sem contexto",
      "Desabilitar métricas para reduzir custo",
      "Evitar DLQ para simplificar pipeline"
    ],
    "correctIndex": 0,
    "explanation": "Sem correlação, eventos assíncronos viram caixa-preta. IDs propagados e telemetria padronizada facilitam rastrear atrasos e falhas entre serviços.",
    "example": "Evento entra no API Gateway com `correlation_id`; fila, função e banco registram o mesmo valor para diagnóstico rápido."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__1",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "Qual é o princípio de segurança que determina que cada usuário ou serviço deve ter apenas as permissões mínimas necessárias para realizar sua função?",
    "options": [
      "Princípio do menor privilégio",
      "Defesa em profundidade",
      "Separação de deveres",
      "Zero Trust"
    ],
    "correctIndex": 0,
    "explanation": "O princípio do menor privilégio (Least Privilege) estabelece que identidades devem receber apenas as permissões estritamente necessárias para suas tarefas, reduzindo a superfície de ataque caso a credencial seja comprometida.",
    "example": "Em vez de dar AdministratorAccess a um desenvolvedor, conceda apenas s3:GetObject e s3:PutObject no bucket específico do projeto dele."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__2",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "O que é MFA (Multi-Factor Authentication) e por que é recomendado para contas em nuvem?",
    "options": [
      "Autenticação com dois ou mais fatores (algo que sabe + algo que tem), dificultando acesso não autorizado",
      "Usar senha mais longa",
      "Criptografia de dados",
      "Firewall em múltiplas camadas"
    ],
    "correctIndex": 0,
    "explanation": "MFA exige pelo menos dois fatores de autenticação: fator de conhecimento (senha), fator de posse (token, celular), fator biométrico (digital, face). Mesmo que a senha seja comprometida, o atacante precisa do segundo fator. Essencial para contas root e IAM com privilégios elevados.",
    "example": "AWS root account com MFA: ao fazer login, além da senha, insira o código de 6 dígitos do Google Authenticator ou toque na YubiKey (hardware token). Sem o dispositivo físico, login é impossível."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__3",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "O que é um WAF (Web Application Firewall) e contra quais ataques ele protege?",
    "options": [
      "Firewall de aplicação web que protege contra SQL injection, XSS, CSRF e outros ataques HTTP",
      "Firewall de rede que bloqueia IPs",
      "Antivírus para servidores",
      "Sistema de backup"
    ],
    "correctIndex": 0,
    "explanation": "WAF opera na camada 7 (aplicação) e inspeciona requisições HTTP/HTTPS. Regras protegem contra: SQL Injection, Cross-Site Scripting (XSS), path traversal, bots maliciosos e DDoS na camada de aplicação. Diferente de firewall de rede (camada 3/4) que filtra por IP/porta.",
    "example": "AWS WAF no ALB: regra 1 bloqueia requests com padrão SQL Injection (ex: ' OR 1=1--). Regra 2 limita 100 req/s por IP (rate limiting). Regra 3 bloqueia user-agents de bots conhecidos. Managed Rules incluem OWASP Top 10."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__4",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "O que é Identity Federation (federação de identidade) na nuvem?",
    "options": [
      "Permite que usuários usem credenciais de provedores externos (Google, AD) para acessar recursos cloud",
      "Criar usuários duplicados em cada provedor",
      "Compartilhar senhas entre clouds",
      "Tipo de criptografia federada"
    ],
    "correctIndex": 0,
    "explanation": "Identity Federation permite autenticar com provedores de identidade externos (corporate AD, Google, Facebook) via SAML, OIDC ou OAuth. O usuário faz login no IdP corporativo e recebe credenciais temporárias para acessar AWS/Azure/GCP sem criar conta separada.",
    "example": "Funcionário faz login no Azure AD corporativo → IAM Identity Center federa para AWS → assume IAM Role com permissões. Zero passwords AWS. STS gera credenciais temporárias de 1h."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__5",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "O que é criptografia do lado do cliente vs do lado do servidor na nuvem?",
    "options": [
      "Client-side: dados criptografados ANTES de enviar à nuvem; server-side: provedor criptografa ao receber",
      "São idênticas",
      "Client-side usa TLS e server-side usa AES",
      "Server-side é sempre preferível"
    ],
    "correctIndex": 0,
    "explanation": "Server-side encryption (SSE): o provedor criptografa ao armazenar e descriptografa ao ler (S3 SSE-S3, SSE-KMS). Client-side encryption (CSE): você criptografa antes de enviar — o provedor nunca vê dados em claro. CSE é mais seguro mas mais complexo.",
    "example": "SSE-KMS: S3 criptografa com chave KMS ao gravar, descriptografa ao ler. CSE: app criptografa com chave local AES-256 ANTES de fazer PUT no S3. O S3 armazena blob criptografado — mesmo a AWS não pode ler."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__6",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "O que é um Security Group e o que é um NACL (Network ACL) na AWS?",
    "options": [
      "Security Group é firewall stateful por instância; NACL é firewall stateless por sub-rede",
      "São idênticos",
      "NACL é stateful e SG é stateless",
      "SG opera na sub-rede e NACL na instância"
    ],
    "correctIndex": 0,
    "explanation": "Security Group: stateful (resposta automática), ligado à instância/recurso, só regras ALLOW. NACL: stateless (precisa regra explícita para request E response), ligado à sub-rede, regras ALLOW e DENY com prioridade numérica.",
    "example": "SG: Allow Inbound TCP 443 → response na porta efêmera retorna automaticamente (stateful). NACL: precisa de regra Allow Inbound TCP 443 E Allow Outbound TCP 1024-65535 (stateless). Defesa em profundidade: NACL + SG."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__7",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "O que é o modelo Zero Trust e como difere da segurança baseada em perímetro?",
    "options": [
      "Zero Trust não confia em nenhuma rede por padrão e verifica cada acesso; perímetro confia na rede interna",
      "São abordagens idênticas",
      "Perímetro é mais seguro",
      "Zero Trust só se aplica à nuvem"
    ],
    "correctIndex": 0,
    "explanation": "Perímetro: 'dentro da rede = confiável' (castelo com fosso). Zero Trust: 'nunca confie, sempre verifique' — cada acesso é autenticado/autorizado independente da rede. Princípios: verificação explícita, menor privilégio, assume breach.",
    "example": "Perímetro: VPN conecta → acesso total à rede interna. Zero Trust: login com MFA + dispositivo compliance + localização verificada → acessa APENAS o recurso autorizado via conditional access. Lateral movement bloqueado."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__8",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "Qual princípio de segurança recomenda conceder apenas o acesso estritamente necessário?",
    "options": [
      "Princípio do menor privilégio",
      "Acesso total por padrão",
      "Segurança por obscuridade",
      "Permissão herdada irrestrita"
    ],
    "correctIndex": 0,
    "explanation": "Menor privilégio reduz superfície de ataque e impacto de credenciais comprometidas ao limitar ações permitidas por usuário/serviço.",
    "example": "Uma função só recebe permissão de leitura no bucket específico em vez de `s3:*` na conta inteira."
  },
  {
    "id": "cloud__Segurança em Cloud__Fácil__9",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Fácil",
    "question": "Por que habilitar MFA em contas administrativas cloud é essencial?",
    "options": [
      "Porque adiciona um segundo fator e reduz risco de takeover por senha vazada",
      "Porque substitui políticas de senha",
      "Porque elimina auditoria",
      "Porque dispensa gestão de identidade"
    ],
    "correctIndex": 0,
    "explanation": "MFA dificulta acesso indevido mesmo quando senha é comprometida, especialmente em contas privilegiadas com alto impacto.",
    "example": "Admin com senha exposta em phishing ainda bloqueia invasão porque atacante não possui token MFA válido."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__1",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "O que é 'encryption at rest' e como ela se diferencia de 'encryption in transit'?",
    "options": [
      "At rest protege dados armazenados em disco; in transit protege dados trafegando pela rede",
      "São sinônimos para criptografia AES",
      "At rest usa TLS e in transit usa AES",
      "At rest é para bancos de dados e in transit é para arquivos"
    ],
    "correctIndex": 0,
    "explanation": "Encryption at rest criptografa dados armazenados em disco (S3, EBS, RDS) usando chaves como AES-256, protegendo contra acesso físico não autorizado. Encryption in transit usa TLS/SSL para criptografar dados enquanto trafegam pela rede, protegendo contra interceptação.",
    "example": "S3 com SSE-S3 = encryption at rest (AES-256 gerenciado pela AWS). HTTPS no ALB com certificado ACM = encryption in transit (TLS 1.3)."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__2",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "O que é CSPM (Cloud Security Posture Management) e quais problemas ele detecta?",
    "options": [
      "Ferramenta que monitora configurações de nuvem em busca de violações de segurança e compliance",
      "Antivírus para nuvem",
      "Ferramenta de pen test",
      "Backup criptografado"
    ],
    "correctIndex": 0,
    "explanation": "CSPM monitora continuamente configurações de recursos de nuvem contra best practices e frameworks de compliance (CIS, SOC 2, PCI DSS). Detecta: buckets S3 públicos, security groups abertos (0.0.0.0/0:22), discos sem criptografia, MFA desabilitado, credentials expostas.",
    "example": "Azure Defender for Cloud (CSPM): alerta 'Storage Account sem HTTPS obrigatório', 'VM com porta SSH aberta para 0.0.0.0/0', 'SQL Server sem Transparent Data Encryption'. Score de segurança: 72/100."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__3",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "O que é o modelo de responsabilidade compartilhada na nuvem e como ele divide as responsabilidades entre provedor e cliente?",
    "options": [
      "Provedor protege a infraestrutura DA nuvem; cliente protege o que coloca NA nuvem",
      "O provedor é responsável por tudo",
      "O cliente é responsável por tudo",
      "Não há divisão"
    ],
    "correctIndex": 0,
    "explanation": "O provedor protege a infraestrutura física, hypervisor, rede e serviços gerenciados (segurança DA nuvem). O cliente é responsável por: configuração de segurança, IAM, criptografia de dados, OS patching (em IaaS), security groups e compliance (segurança NA nuvem).",
    "example": "IaaS (EC2): AWS protege hardware e hypervisor; você patcha o SO e configura firewall. PaaS (RDS): AWS também patcha o SO e banco; você configura security groups e criptografia. SaaS (S3): AWS gerencia quase tudo; você configura permissões de bucket."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__4",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "O que é o AWS KMS (Key Management Service) e qual a diferença entre chaves gerenciadas pelo cliente e pelo serviço?",
    "options": [
      "Serviço para criar e gerenciar chaves criptográficas; CMK dá controle total das políticas de chave",
      "Serviço de armazenamento de senhas",
      "Firewall criptografado",
      "Proxy para SSL/TLS"
    ],
    "correctIndex": 0,
    "explanation": "KMS gerencia chaves de criptografia. AWS-managed keys: AWS cria/gerencia automaticamente (SSE-S3). Customer-managed keys (CMK): você controla políticas, rotação, quem pode usar. CMK do KMS: roteia automaticamente a cada 1 ano (configurável).",
    "example": "CMK para S3: você define política 'apenas role X pode Decrypt'. Audit: CloudTrail registra todo uso da chave. Rotation: KMS rotaciona automaticamente. Custo: $1/mês por chave + $0.03/10k requests."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__5",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "O que são security groups e por que são considerados a primeira defesa na nuvem?",
    "options": [
      "Firewalls virtuais que controlam tráfego de entrada e saída para recursos na nuvem",
      "Grupos de usuários com permissões",
      "Certificados de segurança",
      "Antivírus gerenciado"
    ],
    "correctIndex": 0,
    "explanation": "Security groups são firewalls stateful que filtram tráfego por protocolo, porta e IP de origem/destino. Liga-se à instância/recurso. Best practice: menor privilégio — só abrir portas necessárias. Nunca 0.0.0.0/0 para SSH/RDP.",
    "example": "SG do web server: Inbound Allow TCP 443 de 0.0.0.0/0 (HTTPS), Inbound Allow TCP 80 de 0.0.0.0/0 (HTTP). SG do banco: Inbound Allow TCP 5432 APENAS do SG do web server. Banco nunca acessível da internet."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__6",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "O que é secrets management e quais ferramentas são utilizadas?",
    "options": [
      "Prática de armazenar e rotacionar credenciais de forma segura usando serviços dedicados",
      "Guardar senhas em variáveis de ambiente",
      "Criptografar o código-fonte",
      "Compartilhar senhas via chat"
    ],
    "correctIndex": 0,
    "explanation": "Secrets (senhas, API keys, tokens) NUNCA devem estar em código ou env vars em plain text. Ferramentas: AWS Secrets Manager (rotação automática), Azure Key Vault, GCP Secret Manager, HashiCorp Vault (multi-cloud). Integram com IAM para controle de acesso.",
    "example": "RUIM: DB_PASSWORD=mypass123 no .env commitado no Git. BOM: AWS Secrets Manager armazena a senha, Lambda lê via SDK: const secret = await secretsManager.getSecretValue({ SecretId: 'db/prod' }). Rotação a cada 30 dias automática."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__7",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "O que é o AWS IAM Identity Center (antigo SSO) e para que serve?",
    "options": [
      "Serviço que centraliza acesso a múltiplas contas AWS e aplicações SaaS com login único",
      "Centro de gerenciamento de VPCs",
      "Serviço de DNS",
      "Portal de billing"
    ],
    "correctIndex": 0,
    "explanation": "IAM Identity Center permite SSO para múltiplas contas AWS (Organizations) e apps SaaS (Salesforce, Slack). Integra com Azure AD, Okta, Google Workspace como IdP. Permission Sets definem roles por conta. Um login → acesso a todas as contas autorizadas.",
    "example": "Funcionário acessa portal SSO → vê: Conta Dev (PowerUser), Conta Staging (ReadOnly), Conta Prod (ViewOnly). Clica em 'Conta Dev' → assume role DevPowerUser com credenciais temporárias de 1h. Sem IAM users em cada conta."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__8",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "Qual vantagem de armazenar credenciais em cofre de segredos em vez de variável de ambiente fixa?",
    "options": [
      "Permite rotação centralizada, auditoria e controle fino de acesso",
      "Torna vazamento impossível em qualquer cenário",
      "Elimina necessidade de criptografia em trânsito",
      "Substitui autenticação de aplicação"
    ],
    "correctIndex": 0,
    "explanation": "Cofres de segredos melhoram governança e ciclo de vida das credenciais, reduzindo exposição em código, imagens e pipelines.",
    "example": "Senha do banco é rotacionada no Key Vault/Secrets Manager sem rebuild da aplicação."
  },
  {
    "id": "cloud__Segurança em Cloud__Médio__9",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Médio",
    "question": "O que é rotação automática de chaves/segredos e qual benefício principal?",
    "options": [
      "Troca periódica de credenciais para limitar janela de exploração em caso de vazamento",
      "Aumentar latência da aplicação",
      "Desativar logs de auditoria",
      "Remover necessidade de IAM"
    ],
    "correctIndex": 0,
    "explanation": "Rotação automática diminui tempo de exposição de segredos comprometidos e padroniza higiene de segurança sem operação manual constante.",
    "example": "Token de integração é renovado a cada 30 dias e versões antigas são invalidadas automaticamente."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__1",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "Em uma arquitetura Zero Trust na nuvem, qual componente é responsável por avaliar continuamente o contexto (identidade, dispositivo, localização, risco) antes de conceder acesso a cada recurso?",
    "options": [
      "Policy Decision Point (PDP)",
      "Firewall de perímetro",
      "VPN concentrator",
      "Load Balancer"
    ],
    "correctIndex": 0,
    "explanation": "No modelo Zero Trust, o Policy Decision Point (PDP) avalia cada requisição de acesso com base em múltiplos sinais contextuais: identidade do usuário, postura do dispositivo, localização, horário e nível de risco. Não há confiança implícita baseada na rede. Cada acesso é verificado continuamente.",
    "example": "Um PDP (ex.: Azure AD Conditional Access) nega acesso ao SharePoint porque: usuário autenticado via MFA ✓, mas dispositivo sem patch crítico ✗ e localização = país incomum ✗. Risco calculado = Alto → bloqueia."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__2",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "O que é SIEM (Security Information and Event Management) e como ele funciona na nuvem?",
    "options": [
      "Sistema que coleta, correlaciona e analisa logs de segurança de múltiplas fontes para detectar ameaças",
      "Firewall de próxima geração",
      "Scanner de vulnerabilidades",
      "Ferramenta de criptografia"
    ],
    "correctIndex": 0,
    "explanation": "SIEM agrega logs de diversas fontes (firewalls, servidores, aplicações, cloud), correlaciona eventos usando regras e ML para detectar ameaças em tempo real, e gera alertas prioritizados. Na nuvem: Azure Sentinel, AWS Security Hub + GuardDuty, Google Chronicle.",
    "example": "Azure Sentinel detecta: 'usuário logou dos EUA às 14h e da Rússia às 14h05 (impossible travel)' → alerta crítico + playbook automático desabilita a conta e notifica a equipe de segurança via Teams."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__3",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "O que é SOAR (Security Orchestration, Automation and Response) e como complementa o SIEM?",
    "options": [
      "Plataforma que automatiza respostas a incidentes de segurança com playbooks, integrando-se ao SIEM",
      "Sinônimo de SIEM",
      "Scanner de vulnerabilidades automático",
      "Ferramenta de pen testing"
    ],
    "correctIndex": 0,
    "explanation": "SOAR recebe alertas do SIEM e executa playbooks automatizados de resposta: bloquear IP no firewall, desabilitar usuário comprometido, isolar instância infectada, criar ticket de incidente, notificar equipe. Reduz tempo de resposta (MTTR) de horas para segundos.",
    "example": "Playbook SOAR: alerta 'brute force SSH detectado' → 1) bloquear IP no Security Group (automático) → 2) capturar logs da instância (automático) → 3) criar ticket no Jira (automático) → 4) notificar analista no Slack → 5) analista investiga e fecha. MTTR: 2 minutos."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__4",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "O que é o AWS GuardDuty e como ele detecta ameaças?",
    "options": [
      "Serviço de detecção de ameaças que analisa logs (CloudTrail, VPC Flow, DNS) com ML",
      "Firewall gerenciado",
      "Antivírus para EC2",
      "Scanner de vulnerabilidades"
    ],
    "correctIndex": 0,
    "explanation": "GuardDuty analisa CloudTrail logs, VPC Flow Logs e DNS logs usando machine learning e threat intelligence para detectar atividades maliciosas: API calls suspeitas, comunicação com IPs de C2, port scanning, criptomineração. Ativação em 1 clique.",
    "example": "GuardDuty findings: 'UnauthorizedAccess: EC2 instance i-abc comunicando com IP de botnet conhecida'. 'Recon: Port scan detectado de IP externo'. Integra com Security Hub para centralizar findings de múltiplos serviços."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__5",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "O que é o princípio de defense in depth (defesa em profundidade) na nuvem?",
    "options": [
      "Aplicar múltiplas camadas de segurança para proteger contra falha de uma camada individual",
      "Usar apenas um firewall forte",
      "Criptografar tudo com a mesma chave",
      "Concentrar toda segurança no perímetro"
    ],
    "correctIndex": 0,
    "explanation": "Defense in depth: camadas independentes: WAF (L7) → NACL (L3/4 sub-rede) → Security Group (L3/4 instância) → IAM (autenticação/autorização) → Encryption (at rest/in transit) → Monitoring (GuardDuty/SIEM). Se uma camada falhar, as outras ainda protegem.",
    "example": "Ataque SQL Injection: WAF bloqueia (camada 1). Se passar: app usa parameterized queries (camada 2). Se explorar: banco encriptado com CMK (camada 3). Se exfiltrar: GuardDuty detecta tráfego anômalo (camada 4)."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__6",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "O que é o AWS Organizations com SCPs (Service Control Policies) e como implementam governança multi-conta?",
    "options": [
      "SCPs definem o limite máximo de permissões para todas as contas na OU, mesmo para admins",
      "Políticas de custo",
      "Configurações de rede",
      "Templates de CloudFormation"
    ],
    "correctIndex": 0,
    "explanation": "SCPs são guardrails que limitam o QUE pode ser feito em contas AWS, independente das IAM policies. Exemplo: SCP deny all regions except sa-east-1 — mesmo um admin não consegue criar recursos em outras regiões. SCPs não concedem permissões, apenas restringem.",
    "example": "OU 'Produção' com SCP: Deny ec2:TerminateInstances unless mfa-authenticated. Deny iam:CreateUser (usar SSO). Deny s3:PutBucketPublicAccess. Mesmo root da conta filha não pode violar essas restrições."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__7",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "O que é o conceito de 'supply chain security' em cloud e como mitigar riscos?",
    "options": [
      "Segurança da cadeia de dependências de software: imagens base, bibliotecas, pipelines CI/CD e artefatos",
      "Segurança de entrega de hardware",
      "Proteção de APIs de fornecedores",
      "Backup de dependências"
    ],
    "correctIndex": 0,
    "explanation": "Supply chain attacks exploram dependências (npm packages, imagens Docker, GitHub Actions). Mitigações: SCA (scan de dependências: Snyk, Dependabot), imagens base verificadas, SBOM (Software Bill of Materials), signed images (cosign/Sigstore), pins de versão exatas.",
    "example": "Ataque: pacote npm 'colors' v1.4.1 introduziu loop infinito (sabotagem). Mitigações: lockfile (package-lock.json), npm audit em CI, Snyk monitora CVEs, Dependabot cria PRs de update. SBOM documenta todas as dependências."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__8",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "Como modelagem de ameaças (ex.: STRIDE) contribui para segurança em arquitetura cloud?",
    "options": [
      "Ajuda a identificar vetores de ataque por componente e definir controles preventivos",
      "Substitui testes de segurança e pentest",
      "Elimina necessidade de monitoramento contínuo",
      "Serve apenas para documentação final"
    ],
    "correctIndex": 0,
    "explanation": "Threat modeling antecipa riscos de spoofing, tampering, repúdio, disclosure, DoS e elevação de privilégio, guiando decisões de design seguro.",
    "example": "Ao modelar API pública, equipe adiciona mTLS interno, rate limit e assinatura de mensagens antes do go-live."
  },
  {
    "id": "cloud__Segurança em Cloud__Difícil__9",
    "track": "cloud",
    "category": "Segurança em Cloud",
    "difficulty": "Difícil",
    "question": "Em Zero Trust cloud, qual combinação melhor representa o modelo?",
    "options": [
      "Verificação contínua de identidade, contexto e postura antes de cada acesso",
      "Confiar automaticamente em todo tráfego interno",
      "Liberar acesso amplo após login inicial",
      "Concentrar defesa apenas no perímetro"
    ],
    "correctIndex": 0,
    "explanation": "Zero Trust assume que nenhuma rede é implicitamente confiável; acesso é concedido de forma adaptativa por identidade, dispositivo, risco e política.",
    "example": "Mesmo dentro da VNet, serviço precisa autenticar com identidade gerenciada e cumprir política de device compliance para acessar dados sensíveis."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__1",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "Qual estrutura de dados segue o princípio FIFO (primeiro a entrar, primeiro a sair)?",
    "options": [
      "Fila (Queue)",
      "Pilha (Stack)",
      "Árvore Binária",
      "Grafo"
    ],
    "correctIndex": 0,
    "explanation": "A Fila (Queue) segue o princípio FIFO: o primeiro elemento inserido é o primeiro a ser removido. Operações básicas são enqueue (inserir no final) e dequeue (remover do início).",
    "example": "Fila de impressão: documento A entra primeiro, depois B e C. A impressora processa A primeiro, depois B, depois C — exatamente na ordem de chegada."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__2",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "Qual estrutura de dados usa o princípio LIFO (last in, first out)?",
    "options": [
      "Pilha (Stack)",
      "Fila (Queue)",
      "Lista Ligada",
      "Hash Table"
    ],
    "correctIndex": 0,
    "explanation": "A Pilha segue LIFO: o último elemento inserido é o primeiro removido. Operações: push (inserir no topo) e pop (remover do topo). Usada em chamadas de funções (call stack), undo/redo e avaliação de expressões.",
    "example": "Empilhe pratos: A, B, C. Para tirar, só consegue pegar C primeiro (topo), depois B, depois A. Ctrl+Z (undo) funciona como pilha: a última ação é desfeita primeiro."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__3",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "Qual é a complexidade de tempo para acessar um elemento por índice em um array?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n²)"
    ],
    "correctIndex": 0,
    "explanation": "Arrays armazenam elementos em posições contíguas de memória. Como cada posição tem tamanho fixo, o endereço do elemento i é calculado diretamente: base + (i × tamanho). Isso permite acesso em tempo constante O(1), independente do tamanho do array.",
    "example": "Array com 1 milhão de elementos: arr[999999] acessa diretamente o último elemento tão rápido quanto arr[0]. Mas inserir no início é O(n) porque todos os elementos precisam ser deslocados."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__4",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "O que é uma Lista Ligada (Linked List) e qual sua vantagem sobre arrays?",
    "options": [
      "Estrutura onde cada nó aponta para o próximo; inserção/remoção em O(1) sem deslocar elementos",
      "Array mais rápido",
      "Lista que ordena automaticamente",
      "Tipo de árvore binária"
    ],
    "correctIndex": 0,
    "explanation": "Lista Ligada: cada nó contém um valor e um ponteiro para o próximo nó. Inserção/remoção no início é O(1) (sem deslocamento). Desvantagem: acesso por índice é O(n) (percorrer nó a nó). Arrays: acesso O(1), inserção O(n).",
    "example": "Array: inserir no início desloca todos os 100 mil itens. Lista Ligada: cria nó novo e aponta para o antigo head — O(1). Mas acessar o item 50.000 na lista requer percorrer 50 mil nós."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__5",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "O que é uma Árvore Binária de Busca (BST) e qual sua propriedade principal?",
    "options": [
      "Árvore onde filhos à esquerda são menores e à direita são maiores que o nó pai",
      "Árvore com exatamente dois filhos por nó",
      "Lista ordenada em formato de árvore",
      "Estrutura FIFO hierárquica"
    ],
    "correctIndex": 0,
    "explanation": "BST: para cada nó, todos os valores na subárvore esquerda são menores e na direita são maiores. Busca, inserção e remoção são O(log n) quando balanceada. Permite busca eficiente, in-order traversal retorna elementos em ordem crescente.",
    "example": "BST com raiz 10: esquerda 5 (esquerda 3, direita 7), direita 15 (esquerda 12, direita 20). Buscar 7: 10→5→7 (3 passos). In-order: 3, 5, 7, 10, 12, 15, 20."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__6",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "O que é uma busca binária e qual sua complexidade?",
    "options": [
      "Algoritmo que divide o array ordenado ao meio a cada passo; O(log n)",
      "Percorrer todo o array; O(n)",
      "Busca em lista ligada; O(n²)",
      "Busca em grafo; O(V+E)"
    ],
    "correctIndex": 0,
    "explanation": "Busca binária funciona em arrays ORDENADOS. Compara o elemento do meio: se igual, encontrou; se menor, busca na metade esquerda; se maior, busca na metade direita. Elimina metade dos elementos a cada passo → O(log n). Array desordenado requer busca linear O(n).",
    "example": "Array [2,5,8,12,16,23,38,45] — buscar 23: meio=12 (menor → direita), meio=23 (encontrou!). 2 passos em vez de 6 na busca linear. Para 1M de itens: ~20 passos vs 1M."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__7",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "O que é um grafo e qual a diferença entre dirigido e não-dirigido?",
    "options": [
      "Estrutura com nós e arestas; dirigido tem direção nas arestas, não-dirigido não tem",
      "Tipo de árvore binária",
      "Array bidimensional",
      "Lista com ponteiros"
    ],
    "correctIndex": 0,
    "explanation": "Grafo: conjunto de vértices (nós) conectados por arestas. Dirigido: arestas têm direção (A→B não implica B→A). Não-dirigido: conexão bilateral. Ponderado: arestas têm peso (distância). Usos: GPS, redes sociais, dependências.",
    "example": "Rede social (não-dirigido): Ana-Bob = amizade mútua. Twitter (dirigido): Ana→Bob = Ana segue Bob, não implica Bob seguir Ana. GPS (ponderado): São Paulo→5km→Guarulhos."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__8",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "O que é uma Tabela Hash (Hash Table) e qual é sua complexidade média de busca?",
    "options": [
      "Estrutura que mapeia chaves para valores usando função hash; busca em O(1) em média",
      "Árvore que ordena elementos; busca em O(log n)",
      "Lista duplamente ligada com acesso indexado; busca em O(n)",
      "Pilha com função de lookup; busca em O(1) sempre"
    ],
    "correctIndex": 0,
    "explanation": "Hash Table usa uma função hash para converter a chave em um índice do array, permitindo acesso O(1) em média. Colisões (duas chaves mapeadas ao mesmo índice) são tratadas por encadeamento (linked list no slot) ou endereçamento aberto (probing).",
    "example": "Dicionário do Python é uma hash table. {'nome': 'Ana'} → hash('nome') = índice 42. dict['nome'] em O(1). No pior caso (todas as chaves colidem no mesmo slot) degrada para O(n), mas a função hash bem distribuída evita isso."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__9",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "O que é recursão e qual a condição essencial para evitar stack overflow?",
    "options": [
      "Função que chama a si mesma com subproblema menor; condição base (base case) interrompe a recursão",
      "Laço que itera sobre uma coleção usando índice decrescente",
      "Função que chama outra função em cadeia infinita",
      "Algoritmo iterativo que usa pilha explícita para simular recursão"
    ],
    "correctIndex": 0,
    "explanation": "Recursão: função chama a si mesma com um subproblema menor. A condição base é obrigatória — sem ela a função chama infinitamente até estourar a call stack (stack overflow). Cada chamada recursiva cria um novo frame na pilha de execução.",
    "example": "Fatorial: fatorial(0) = 1 (base), fatorial(n) = n * fatorial(n-1). fatorial(3) → 3 * fatorial(2) → 3 * 2 * fatorial(1) → 3 * 2 * 1 * fatorial(0) = 6. Sem a base fatorial(0)=1: chamaria para sempre."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__10",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "O que é recursão em programação e quais são os dois componentes fundamentais de uma função recursiva?",
    "options": [
      "Caso base (condição de parada) e caso recursivo (chamada a si mesma reduzindo o problema)",
      "Loop infinito e variável global de controle",
      "Chamada a outra função e retorno de null",
      "Iteração com for e condição de break"
    ],
    "correctIndex": 0,
    "explanation": "Recursão: função que chama a si mesma. Caso base: condição que encerra a recursão (sem ele, stack overflow). Caso recursivo: reduz o problema e chama a função novamente. Exemplos: fatorial(n) = n × fatorial(n-1), com fatorial(0) = 1 como caso base; Fibonacci, percurso de árvores.",
    "example": "function fatorial(n) { if (n <= 1) return 1; /* caso base */ return n * fatorial(n - 1); /* caso recursivo */ } fatorial(5) → 5×4×3×2×1 = 120. Sem caso base: fatorial(5) → fatorial(4) → ... → stack overflow. Cada chamada empilha um frame na call stack."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Fácil__11",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Fácil",
    "question": "O que é uma fila de prioridade (priority queue) e qual estrutura de dados a implementa de forma eficiente?",
    "options": [
      "Fila onde elementos saem por prioridade (não por ordem de chegada); implementada eficientemente com heap binário",
      "Fila FIFO comum onde o primeiro a entrar sai primeiro; usa array",
      "Pilha LIFO onde o último inserido é removido primeiro; usa linked list",
      "Lista ordenada que mantém elementos em ordem crescente; usa árvore binária de busca"
    ],
    "correctIndex": 0,
    "explanation": "Priority queue: cada elemento tem prioridade associada. Dequeue retira o de maior (ou menor) prioridade, não o mais antigo. Heap binário: árvore binária completa onde pai ≥ filhos (max-heap) ou pai ≤ filhos (min-heap). Inserção e remoção: O(log n). Peek: O(1). Usos: algoritmo de Dijkstra, agendamento de processos, merge de k listas ordenadas.",
    "example": "Min-heap: inserir(5), inserir(2), inserir(8), inserir(1). peek() → 1. remove() → 1, heap reorganiza → peek() = 2. Em Python: import heapq; h=[]; heapq.heappush(h,5); heapq.heappush(h,2); heapq.heappop(h) → 2. Java: PriorityQueue<Integer> pq = new PriorityQueue<>();"
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__1",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "Qual é a complexidade de tempo no pior caso para buscar um elemento em uma árvore binária de busca (BST) desbalanceada?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ],
    "correctIndex": 0,
    "explanation": "Em uma BST desbalanceada, os nós podem formar uma lista encadeada (todos à direita ou todos à esquerda), fazendo com que a busca percorra todos os n nós no pior caso, resultando em O(n). BSTs balanceadas (AVL, Red-Black) garantem O(log n).",
    "example": "Inserindo 1, 2, 3, 4, 5 em sequência numa BST, cada nó fica à direita do anterior (lista). Buscar 5 requer percorrer todos os 5 nós: O(n)."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__2",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "Qual algoritmo de ordenação tem complexidade O(n log n) no caso médio e é baseado em divisão e conquista?",
    "options": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ],
    "correctIndex": 0,
    "explanation": "O Merge Sort divide o array ao meio recursivamente até ter sub-arrays de 1 elemento, depois combina (merge) os sub-arrays em ordem. Complexidade: O(n log n) em todos os casos (melhor, médio e pior). Desvantagem: usa O(n) de espaço extra.",
    "example": "[38, 27, 43, 3] → divide em [38,27] e [43,3] → divide em [38],[27],[43],[3] → merge: [27,38],[3,43] → merge final: [3,27,38,43]. Número de operações: n × log₂(n)."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__3",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "O que é uma Hash Table e qual é sua complexidade média para busca?",
    "options": [
      "Estrutura que mapeia chaves a valores usando função hash, com busca O(1) na média",
      "Array ordenado com busca O(log n)",
      "Árvore binária com busca O(n)",
      "Lista ligada com busca O(n)"
    ],
    "correctIndex": 0,
    "explanation": "Hash Table usa uma função hash para converter chaves em índices de um array. Busca, inserção e remoção são O(1) na média. No pior caso (muitas colisões), degenera para O(n). JavaScript Objects e Maps são implementados como hash tables.",
    "example": "const mapa = new Map(); mapa.set('ana', 28); mapa.get('ana') → 28 em O(1). A função hash converte 'ana' em índice 42 do array interno, acesso direto."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__4",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "O que é o algoritmo Quick Sort e qual sua complexidade no caso médio?",
    "options": [
      "Algoritmo de divisão e conquista que escolhe um pivô e particiona o array; O(n log n) na média",
      "Algoritmo que ordena comparando pares adjacentes; O(n²)",
      "Algoritmo que encontra o mínimo a cada passo; O(n log n)",
      "Algoritmo baseado em heap; O(n)"
    ],
    "correctIndex": 0,
    "explanation": "Quick Sort escolhe um pivô, particiona o array em menores e maiores que o pivô, e repete recursivamente. Caso médio: O(n log n). Pior caso: O(n²) quando pivô é sempre o menor/maior. Na prática é o mais rápido. In-place (sem memória extra).",
    "example": "[3,6,8,10,1,2,1]: pivô=6 → [3,1,2,1] + 6 + [8,10]. Recursão nos sub-arrays. Pior caso: array já ordenado com pivô no extremo → cada partição remove apenas 1 elemento → O(n²)."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__5",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "O que é uma Heap (fila de prioridade) e para que é usada?",
    "options": [
      "Árvore binária completa onde o pai é sempre maior (max-heap) ou menor (min-heap) que os filhos",
      "Hash table com prioridade",
      "Fila FIFO com prioridade",
      "Array ordenado"
    ],
    "correctIndex": 0,
    "explanation": "Heap é uma árvore binária completa que satisfaz a propriedade heap: em min-heap, o pai é menor que os filhos (raiz = mínimo). Inserção e remoção são O(log n). Usada em filas de prioridade, Dijkstra, heap sort e agendamento de tarefas.",
    "example": "Min-heap: [1, 3, 5, 7, 9]. Inserir 2: coloca no final e faz sift-up até posição correta → [1, 2, 5, 7, 9, 3]. Extrair mínimo (1): troca raiz com último, remove, sift-down."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__6",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "O que é uma Árvore AVL e qual problema ela resolve?",
    "options": [
      "Árvore binária de busca auto-balanceada que garante O(log n) em todas as operações",
      "Array circular",
      "Hash table com encadeamento",
      "Lista duplamente ligada"
    ],
    "correctIndex": 0,
    "explanation": "AVL é uma BST que mantém o fator de balanceamento (diferença de altura entre subárvores) em {-1, 0, 1} para cada nó. Após inserção/remoção, rotações (simples ou dupla) rebalanceiam a árvore. Garante O(log n) no pior caso, ao contrário de BST simples.",
    "example": "Inserir 1,2,3 em BST: 1→2→3 (lista, busca O(n)). Em AVL: após inserir 3, rotação esquerda → 2 (raiz), 1 (esquerda), 3 (direita). Busca O(log n) garantida."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__7",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "O que é o algoritmo de ordenação Counting Sort e quando é mais eficiente?",
    "options": [
      "Algoritmo O(n+k) que conta ocorrências; eficiente quando o range de valores (k) é pequeno",
      "Algoritmo O(n log n) geral",
      "Algoritmo O(n²) por comparação",
      "Algoritmo recursivo de divisão"
    ],
    "correctIndex": 0,
    "explanation": "Counting Sort não compara elementos: conta quantas vezes cada valor aparece e reconstrói o array. Complexidade O(n+k), onde k é o range dos valores. Ideal quando k é pequeno relativo a n. Não funciona bem com floats ou strings longas.",
    "example": "Ordenar notas [3,1,2,3,1,2,3]: contagem=[0,2,2,3]. Reconstrói: [1,1,2,2,3,3,3]. 7 passos (n=7, k=3). Merge Sort faria 7×log7 ≈ 20 operações por comparação."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__8",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "O que é o algoritmo QuickSort e por que seu pior caso é O(n²)?",
    "options": [
      "Divide array pelo pivô recursivamente; O(n log n) médio mas O(n²) se pivô sempre é o menor/maior elemento (array já ordenado)",
      "Ordena por inserção com complexidade O(n log n) em todos os casos",
      "Usa heap para ordenar com O(n log n) garantido no pior caso",
      "Ordena por contagem de frequências com O(n+k) sempre"
    ],
    "correctIndex": 0,
    "explanation": "QuickSort escolhe um pivô, particiona o array (menores à esquerda, maiores à direita) e aplica recursão. Pior caso O(n²): pivô sempre é o menor ou maior elemento — partição desbalanceada (n-1 de um lado, 0 do outro). Mitigações: pivô aleatório, mediana de 3, 3-way partition para duplicatas. In-place, sem array extra.",
    "example": "Array já ordenado [1,2,3,4,5] com pivô sempre no início: 5 iterações de n, n-1, n-2... = O(n²). Solução: pivô aleatório; Python usa Timsort (hibrido merge+insertion) para evitar esse cenário. Caso médio: O(n log n) na prática."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__9",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "O que é uma Min-Heap e como funciona a extração do mínimo?",
    "options": [
      "Árvore binária completa onde cada pai ≤ filhos; raiz é sempre o mínimo; extração remove raiz, sobe último elemento e aplica sift-down em O(log n)",
      "Array ordenado em ordem crescente com acesso O(1) ao menor",
      "BST com balanceamento automático que garante mínimo na folha mais à esquerda",
      "Fila circular onde o menor elemento fica sempre na frente"
    ],
    "correctIndex": 0,
    "explanation": "Min-Heap: árvore binária completa (armazenada em array) onde pai ≤ filhos: raiz = mínimo global. Inserção: adiciona ao final e sobe (sift-up). Extração do mínimo: remove raiz, coloca último elemento na raiz e desce (sift-down comparando com filhos). Ambas operações: O(log n).",
    "example": "Priority Queue de tarefas urgentes: inserir(pagar_conta, p=1), inserir(tirar_lixo, p=5). extractMin() retorna pagar_conta. Dijkstra usa Min-Heap para sempre processar o vértice de menor distância acumulada. Python: heapq.heappush / heapq.heappop."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__10",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "Como funciona o algoritmo Merge Sort e por que ele garante complexidade O(n log n) mesmo no pior caso?",
    "options": [
      "Divide o array ao meio recursivamente até ter subarrays unitários, depois intercala (merge) em ordem; log n níveis × O(n) por nível = O(n log n) garantido",
      "Seleciona um pivô e particiona em menores e maiores; no pior caso é O(n²)",
      "Compara elementos adjacentes e troca se necessário; complexidade O(n²)",
      "Constrói um heap e extrai o máximo repetidamente; instável"
    ],
    "correctIndex": 0,
    "explanation": "Merge Sort: dividir-e-conquistar. 1) Divide array ao meio recursivamente até tamanho 1 (log n divisões). 2) Intercala (merge) dois subarrays ordenados percorrendo ambos linearmente. Cada nível de recursão processa todos os n elementos → O(n) por nível × log n níveis = O(n log n) sempre. Estável (preserva ordem de iguais). Desvantagem: O(n) espaço extra para o merge.",
    "example": "[38,27,43,3,9,82,10] → divide até unitários → merge: [27,38],[3,43],[9,82],[10] → [3,27,38,43],[9,10,82] → [3,9,10,27,38,43,82]. 3 níveis (log₂7 ≈ 3), cada nível percorre 7 elementos. Python usa Timsort (merge+insertion híbrido)."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Médio__11",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Médio",
    "question": "O que é a técnica Two Pointers em algoritmos e em quais tipos de problemas ela é aplicada?",
    "options": [
      "Usa dois índices que percorrem a estrutura (do início/fim ou ambos do início) para resolver problemas em O(n) sem espaço extra",
      "Cria duas cópias do array e compara elemento a elemento",
      "Divide o array em duas metades e processa cada uma separadamente com threads",
      "Usa duas estruturas de dados separadas (pilha e fila) para processar dados"
    ],
    "correctIndex": 0,
    "explanation": "Two Pointers: dois índices percorrem a estrutura de dados. Variantes: 1) Opostos: left=0, right=n-1, convergem ao centro (ex: two sum em array ordenado, palíndromo). 2) Mesmo sentido: slow/fast (ex: remover duplicatas in-place, detectar ciclo em linked list — Floyd). Complexidade: O(n) tempo, O(1) espaço. Pré-requisito comum: array ordenado.",
    "example": "Two Sum em array ordenado [2,7,11,15], target=9: left=0(2), right=3(15), soma=17>9 → right--; left=0(2), right=2(11), soma=13>9 → right--; left=0(2), right=1(7), soma=9=target ✓. O(n) vs O(n²) brute force. Floyd cycle: slow=next, fast=next.next; se encontram = ciclo."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__1",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "Em um algoritmo de Dijkstra usando min-heap (priority queue), qual é a complexidade de tempo para um grafo com V vértices e E arestas?",
    "options": [
      "O((V + E) log V)",
      "O(V²)",
      "O(V × E)",
      "O(E log E)"
    ],
    "correctIndex": 0,
    "explanation": "Com min-heap, cada vértice é extraído uma vez — O(V log V). Cada aresta pode causar uma operação decrease-key — O(E log V). Total: O((V + E) log V). Sem heap (array), a complexidade seria O(V²), melhor para grafos densos.",
    "example": "Grafo com 1000 vértices e 5000 arestas: com heap → O(6000 × 10) ≈ 60.000 operações. Sem heap → O(1.000.000) operações. Heap é ~16x mais rápido neste caso."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__2",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que é programação dinâmica e em quais problemas ela é mais eficaz que a abordagem recursiva ingrénua?",
    "options": [
      "Técnica que armazena resultados de subproblemas para evitar recálculo; eficaz em problemas com subproblemas sobrepostos",
      "Método de alocação de memória",
      "Tipo de paralelismo",
      "Linguagem de programação"
    ],
    "correctIndex": 0,
    "explanation": "Programação dinâmica resolve problemas dividindo-os em subproblemas e armazenando resultados (memoization ou tabulation) para evitar recálculo. Eficaz quando há subproblemas sobrepostos (mesma subcomputação repetida) e subestrutura ótima. Exemplos: Fibonacci, mochila, LCS.",
    "example": "Fibonacci recursivo: fib(50) faz 2⁵⁰ chamadas (exponencial). Com memoization: fib(50) faz 50 chamadas (linear). const memo = {}; function fib(n) { if (memo[n]) return memo[n]; memo[n] = fib(n-1) + fib(n-2); return memo[n]; }"
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__3",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre BFS (Breadth-First Search) e DFS (Depth-First Search) em grafos?",
    "options": [
      "BFS explora vizinhos nível a nível (usa fila); DFS vai o mais fundo possível primeiro (usa pilha)",
      "São idênticos",
      "DFS é mais rápido",
      "BFS só funciona em árvores"
    ],
    "correctIndex": 0,
    "explanation": "BFS (Busca em Largura): explora todos os vizinhos do nó atual antes de ir para o próximo nível. Usa fila (FIFO). Encontra menor caminho em grafos não-ponderados. DFS (Busca em Profundidade): segue um caminho até o fim antes de retroceder. Usa pilha (LIFO) ou recursão. Usado em detecção de ciclos e ordenação topológica.",
    "example": "Grafo: A-B, A-C, B-D, C-D. BFS a partir de A: A → B,C → D (nível por nível). DFS a partir de A: A → B → D → (volta) → C (desce ao máximo antes de voltar)."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__4",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que é o algoritmo A* (A-star) e em que ele difere do Dijkstra?",
    "options": [
      "Algoritmo que usa heurística para estimar distância ao destino, focando a busca na direção certa",
      "Versão mais lenta do Dijkstra",
      "Algoritmo que só funciona em grafos sem peso",
      "Dijkstra com backtracking"
    ],
    "correctIndex": 0,
    "explanation": "A* usa f(n) = g(n) + h(n): g(n) = custo real do início até n, h(n) = heurística estimando custo de n ao destino. Dijkstra é A* com h(n)=0. A heurística direciona a busca, explorando menos nós. A* é ótimo se h(n) for admissível (nunca superestimar).",
    "example": "GPS: Dijkstra explora em todas as direções (círculo expandindo). A* com heurística de distância euclidiana foca na direção do destino, visitando ~5x menos nós para encontrar o caminho mínimo."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__5",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que é a notação Big-O e qual a diferença entre O(n), O(n²) e O(log n)?",
    "options": [
      "Notação que descreve o crescimento do tempo/espaço em função do input; O(log n) < O(n) < O(n²)",
      "Mede o tempo exato em milissegundos",
      "Só se aplica a algoritmos de ordenação",
      "Análise de memória RAM"
    ],
    "correctIndex": 0,
    "explanation": "Big-O descreve o limite superior de crescimento. O(1): constante. O(log n): busca binária — cada passo elimina metade. O(n): percorrer lista. O(n log n): merge sort. O(n²): comparar todos com todos. O(2^n): subsets. Para n=1M: O(n)=1M ops, O(n²)=1T ops.",
    "example": "n=1.000.000: O(log n)=20 ops, O(n)=1M ops, O(n log n)=20M ops, O(n²)=1T ops. Um algoritmo O(n²) com n=1M demoraria ~11 dias; O(n log n) demoraria 0.2 segundos."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__6",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que é o Trie (Prefix Tree) e para que é usado?",
    "options": [
      "Árvore onde cada nó representa um caractere, otimizada para busca por prefixo em strings",
      "Tipo de hash table",
      "Árvore binária balanceada",
      "Grafo acíclico para números"
    ],
    "correctIndex": 0,
    "explanation": "Trie armazena strings caractere por caractere nos nós. Busca por prefixo é O(m) onde m = tamanho do prefixo. Ideal para autocomplete, spell check, dicionários e roteamento IP. Consome mais memória que hash table mas é superior para operações com prefixo.",
    "example": "Trie com 'car', 'card', 'cat': raiz→c→a→r(✓)→d(✓), raiz→c→a→t(✓). Buscar prefixo 'ca': 2 passos → retorna ['car','card','cat']. Hash table precisaria iterar todas as chaves."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__7",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que é uma Red-Black Tree e como se compara com AVL?",
    "options": [
      "Árvore auto-balanceada com garantias mais relaxadas que AVL; inserção mais rápida, busca ligeiramente mais lenta",
      "Árvore com nós coloridos sem balanceamento",
      "Hash table com cores",
      "Grafo bicolorido"
    ],
    "correctIndex": 0,
    "explanation": "Red-Black Tree: BST auto-balanceada com regras de coloração (nós vermelhos/pretos). Menos estrita que AVL: permite diferença de altura 2x (vs 1 da AVL). Resultado: menos rotações em inserção/remoção. Usada no Java TreeMap, C++ std::map e Linux kernel.",
    "example": "AVL: busca ~1.44×log n (mais curta). Red-Black: busca ~2×log n (pode ser mais alta). Mas inserção AVL: até log n rotações; Red-Black: no máximo 2 rotações. Para muitas escritas: Red-Black. Para muitas leituras: AVL."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__8",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que é o algoritmo de Dijkstra e quais estruturas otimizam sua complexidade?",
    "options": [
      "Caminho mais curto em grafos com pesos positivos; com Min-Heap (Priority Queue) atinge O((V+E) log V) em vez de O(V²) com array simples",
      "Ordena grafos topologicamente usando pilha; O(V+E)",
      "Encontra caminho mais longo em DAG using programação dinâmica; O(V²)",
      "Busca em largura ponderada com fila simples; O(V+E)"
    ],
    "correctIndex": 0,
    "explanation": "Dijkstra: inicializa dist[origem]=0, demais=∞. Extrai vértice de menor dist (Min-Heap), relaxa arestas. Arrays simples: O(V²). Min-Heap: O((V+E) log V). Não funciona com pesos negativos (usar Bellman-Ford). Para grafos densos (E≈V²), array simples pode ser tão bom quanto heap.",
    "example": "Mapa: SP→RJ=400, SP→BH=600, RJ→BH=350. Dijkstra de SP: dist[RJ]=400, dist[BH]=600. Processa RJ: SP→RJ→BH=750 > 600, mantém. Resultado: SP→BH direto (600) é mais curto que via RJ (750)."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__9",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que são árvores AVL e como as rotações garantem balanceamento O(log n)?",
    "options": [
      "BST auto-balanceada onde |altura(esq)-altura(dir)| ≤ 1 em cada nó; rotações LL, RR, LR e RL reequilibram em O(1) após inserção/remoção",
      "Árvore B usada em bancos de dados com fator de balanceamento variável",
      "BST que usa cores vermelho/preto para balanceamento amortizado",
      "Heap que mantém propriedade de BST com reestruturação por comparação"
    ],
    "correctIndex": 0,
    "explanation": "AVL: cada nó guarda fator de balanceamento fb = altura(esq) - altura(dir) ∈ {-1, 0, 1}. Após inserção/remoção, se fb sair do intervalo: LL (rotação simples direita), RR (rotação simples esquerda), LR (rotação dupla esq+dir), RL (rotação dupla dir+esq). Garante altura ≤ 1.44 log₂(n). Todas operações em O(log n) garantido.",
    "example": "Inserindo 1,2,3 em BST sem balanceamento: lista com 3 nós à direita (O(n) busca). Inserindo 3 na AVL: fb do nó 1 fica -2 (desbalanceado RR). Rotação esquerda: 2 vira raiz, 1 filho esq, 3 filho dir. Árvore balanceada, busca O(log n)."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__10",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que são Segment Trees e como permitem consultas e atualizações em intervalos de forma eficiente?",
    "options": [
      "Árvore binária onde cada nó armazena informação agregada de um intervalo do array; consulta e atualização em O(log n)",
      "Árvore binária de busca auto-balanceada que mantém elementos ordenados",
      "Estrutura que armazena todos os prefixos de um array para consultas rápidas",
      "Grafo direcionado que conecta intervalos sobrepostos para detecção de conflitos"
    ],
    "correctIndex": 0,
    "explanation": "Segment Tree: árvore binária construída sobre array. Cada nó guarda resultado agregado (soma, mín, máx) de um intervalo [l, r]. Raiz: intervalo total. Folhas: elementos individuais. Construção: O(n). Query de intervalo [ql, qr]: percorre nós relevantes em O(log n). Update pontual: propaga em O(log n). Lazy propagation: permite updates em intervalo também em O(log n).",
    "example": "Array [1,3,5,7,9,11]. Segment tree de soma: raiz=36 [0-5]; esq=9 [0-2], dir=27 [3-5]. Query soma(1,4): nós [1-2]=8, [3-3]=7, [4-4]=9 → 24. Update idx=2 para 10: propaga da folha à raiz. Sem segment tree: query O(n); com: O(log n). Usada em competitive programming e bancos de dados geoespaciais."
  },
  {
    "id": "desenvolvimento__Algoritmos e Estruturas de Dados__Difícil__11",
    "track": "desenvolvimento",
    "category": "Algoritmos e Estruturas de Dados",
    "difficulty": "Difícil",
    "question": "O que é o algoritmo de Kruskal para árvore geradora mínima (MST) e qual estrutura o torna eficiente?",
    "options": [
      "Ordena arestas por peso e adiciona a menor que não forma ciclo, usando Union-Find para detectar ciclos em O(α(n)) amortizado",
      "Começa de um vértice e expande adicionando a aresta mais barata ao conjunto visitado",
      "Percorre o grafo em largura calculando distância mínima de cada vértice à origem",
      "Remove iterativamente a aresta de maior peso até restar uma árvore conexa"
    ],
    "correctIndex": 0,
    "explanation": "Kruskal: algoritmo guloso para MST. 1) Ordena arestas por peso: O(E log E). 2) Itera: para cada aresta (u,v,w), se u e v estão em componentes diferentes (Union-Find), adiciona à MST. 3) Para com V-1 arestas. Union-Find com path compression + union by rank: operações em O(α(n)) ≈ O(1). Total: O(E log E). Prim é melhor para grafos densos.",
    "example": "Grafo: A-B(4), A-C(2), B-C(1), B-D(5), C-D(8), D-E(2). Ordenar: B-C(1), A-C(2), D-E(2), A-B(4), B-D(5), C-D(8). Adicionar: B-C(1)✓, A-C(2)✓, D-E(2)✓, A-B(4)→A,B já conectados (skip), B-D(5)✓. MST: {B-C,A-C,D-E,B-D}, peso=10. V-1=4 arestas ✓."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__1",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "Qual método HTTP é utilizado para criar um novo recurso em uma API REST?",
    "options": [
      "POST",
      "GET",
      "PUT",
      "DELETE"
    ],
    "correctIndex": 0,
    "explanation": "O método POST é usado para criar novos recursos. Ele envia dados no corpo da requisição para o servidor, que cria o recurso e retorna normalmente o status 201 (Created) com a URL do novo recurso no header Location.",
    "example": "POST /api/users com body { \"name\": \"Ana\", \"email\": \"ana@email.com\" } → resposta 201 Created com Location: /api/users/42."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__2",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "Qual método HTTP é idempotente e usado para atualizar completamente um recurso existente?",
    "options": [
      "PUT",
      "POST",
      "PATCH",
      "DELETE"
    ],
    "correctIndex": 0,
    "explanation": "PUT é idempotente: enviar o mesmo PUT várias vezes produz o mesmo resultado. Ele substitui o recurso inteiro com os dados enviados. Diferente de PATCH, que altera parcialmente, e POST, que cria novo recurso (não idempotente).",
    "example": "PUT /api/users/42 com body { \"name\": \"Ana Silva\", \"email\": \"ana@email.com\" } — substitui todos os dados do usuário 42. Se repetir a chamada, o resultado é o mesmo."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__3",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "O que significa o código de status HTTP 404?",
    "options": [
      "Not Found — o recurso solicitado não foi encontrado",
      "Sucesso na operação",
      "Erro interno do servidor",
      "Acesso não autorizado"
    ],
    "correctIndex": 0,
    "explanation": "HTTP 404 Not Found indica que o servidor não encontrou o recurso solicitado. Classes de status: 2xx = sucesso (200 OK, 201 Created), 4xx = erro do cliente (400 Bad Request, 401 Unauthorized, 404 Not Found), 5xx = erro do servidor (500 Internal Server Error).",
    "example": "GET /api/users/99999 → 404 Not Found (usuário não existe). GET /api/users/1 → 200 OK com dados do usuário."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__4",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "O que é uma API e para que serve?",
    "options": [
      "Interface de programação que permite comunicação entre sistemas diferentes",
      "Linguagem de programação",
      "Banco de dados",
      "Protocolo de rede"
    ],
    "correctIndex": 0,
    "explanation": "API (Application Programming Interface) define um contrato de comunicação entre sistemas. Expõe funcionalidades de um serviço sem revelar sua implementação interna. APIs HTTP/REST são as mais comuns, mas existem APIs de bibliotecas, SO e hardware.",
    "example": "A API do Stripe expõe POST /v1/charges para processar pagamentos. Você não precisa saber como o Stripe processa internamente — só segue o contrato da API."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__5",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "O que significa o verbo HTTP GET e quando usá-lo?",
    "options": [
      "Solicita a leitura/busca de um recurso sem alterá-lo",
      "Cria um novo recurso",
      "Deleta um recurso",
      "Atualiza um recurso"
    ],
    "correctIndex": 0,
    "explanation": "GET é idempotente e seguro (safe): não modifica dados no servidor. Usado para buscar/ler recursos. Parâmetros vão na URL (query string). Respostas podem ser cacheadas. Não deve ter body na requisição.",
    "example": "GET /api/users → retorna lista de usuários. GET /api/users/42 → retorna dados do usuário 42. GET /api/users?status=active → filtra por query string."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__6",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "O que é JSON e por que é o formato mais usado em APIs?",
    "options": [
      "Formato leve de troca de dados baseado em texto, legível por humanos e fácil de parsear",
      "Linguagem de programação",
      "Banco de dados",
      "Protocolo de rede"
    ],
    "correctIndex": 0,
    "explanation": "JSON (JavaScript Object Notation): formato texto com pares chave-valor, arrays e tipos primitivos. Leve comparado a XML, suportado nativamente em JavaScript (JSON.parse/stringify) e na maioria das linguagens. Tipo MIME: application/json.",
    "example": "{\"id\": 1, \"name\": \"Ana\", \"skills\": [\"TypeScript\", \"React\"], \"active\": true}. JavaScript: const obj = JSON.parse(jsonString); const str = JSON.stringify(obj);"
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__7",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "Qual é a diferença entre os métodos HTTP PATCH e PUT?",
    "options": [
      "PUT substitui o recurso inteiro; PATCH atualiza parcialmente apenas os campos enviados",
      "São idênticos",
      "PATCH cria e PUT atualiza",
      "PUT é parcial e PATCH é completo"
    ],
    "correctIndex": 0,
    "explanation": "PUT: envia a representação completa do recurso (campos omitidos são removidos). PATCH: envia apenas os campos que devem mudar. PUT é idempotente por padrão. PATCH pode ou não ser idempotente dependendo da implementação.",
    "example": "Usuário { name: \"Ana\", email: \"ana@x.com\", age: 25 }. PUT { name: \"Ana S.\" } → email e age removidos. PATCH { name: \"Ana S.\" } → só name muda, email e age permanecem."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__8",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "Qual método HTTP deve ser usado para criar um novo recurso em uma API REST?",
    "options": [
      "POST",
      "GET",
      "PUT",
      "DELETE"
    ],
    "correctIndex": 0,
    "explanation": "POST é o método HTTP para criar novos recursos. A resposta típica é 201 Created com o recurso no body. GET lê recursos (safe, idempotente), PUT substitui recurso completo (idempotente), PATCH atualiza parcialmente, DELETE remove. REST usa verbos HTTP como operações semânticas.",
    "example": "POST /api/usuarios Body: {\"nome\": \"Ana\"} → 201 Created {\"id\": 42, \"nome\": \"Ana\"}. GET /api/usuarios/42 → 200 OK {\"id\": 42, ...}. DELETE /api/usuarios/42 → 204 No Content. PUT /api/usuarios/42 Body: {\"nome\":\"Ana Silva\"} → substitui recurso completo."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__9",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "O que significa o código de status HTTP 401 e como difere do 403?",
    "options": [
      "401: não autenticado (credenciais ausentes/inválidas); 403: autenticado mas sem permissão para o recurso",
      "401: recurso não encontrado; 403: servidor indisponível",
      "401: erro interno do servidor; 403: requisição mal formada",
      "São sinônimos que indicam acesso negado sem distinção"
    ],
    "correctIndex": 0,
    "explanation": "401 Unauthorized: sem credenciais ou credenciais inválidas. Header WWW-Authenticate informa método de autenticação. 403 Forbidden: autenticado mas sem permissão (ex: usuário comum tentando acessar area admin). 404 Not Found: recurso inexistente. 429 Too Many Requests: rate limit atingido.",
    "example": "GET /api/perfil sem token → 401. Com token expirado → 401. Com token válido de usuário comum em GET /api/admin → 403. GET /api/usuario/999 (não existe) → 404. 100 requisições em 1 minuto → 429."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__10",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "O que é uma query string na URL de uma API e como é usada para filtrar ou paginar resultados?",
    "options": [
      "Parte da URL após '?' com pares chave=valor separados por '&'; usada para filtros, paginação e ordenação em requisições GET",
      "Corpo da requisição HTTP em JSON para criar recursos",
      "Header que define o tipo de resposta esperada pelo cliente",
      "Caminho da URL que identifica o recurso específico a ser acessado"
    ],
    "correctIndex": 0,
    "explanation": "Query string: parte da URL após '?'. Formato: ?chave1=valor1&chave2=valor2. Usada em GET para filtros, paginação, ordenação, busca. Não deve conter dados sensíveis (aparece no log e histórico). Limite prático: ~2048 caracteres. Caracteres especiais são URL-encoded (%20 para espaço).",
    "example": "GET /api/products?category=electronics&min_price=100&sort=price&order=asc&page=2&limit=20. Servidor recebe: category='electronics', min_price=100, sort='price', page=2, limit=20. Resposta inclui total, hasMore ou Link header para próxima página."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Fácil__11",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Fácil",
    "question": "O que significa uma API REST ser stateless e qual a implicação para autenticação entre requisições?",
    "options": [
      "Cada requisição deve conter todas as informações necessárias; o servidor não guarda estado da sessão, então tokens (JWT/API key) são enviados em cada request",
      "O servidor mantém sessão em memória e o cliente usa apenas cookie de sessão",
      "Stateless significa que a API não retorna dados, apenas confirma operações",
      "O servidor armazena histórico de todas as requisições do cliente para manter contexto"
    ],
    "correctIndex": 0,
    "explanation": "Stateless: servidor não guarda estado entre requisições. Cada request é independente. Implicação para auth: não existe sessão no servidor — token (JWT, API key, Bearer) é enviado em cada chamada via Authorization header. Benefícios: escalabilidade horizontal (qualquer servidor atende qualquer request), simplicidade, cacheabilidade.",
    "example": "Request 1: GET /api/profile, Authorization: Bearer eyJhbGciOi... → 200 OK {name:'Ana'}. Request 2: GET /api/orders, Authorization: Bearer eyJhbGciOi... → 200 OK [...]. Sem header: 401 Unauthorized. Servidor não 'lembra' request 1 ao processar request 2."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__1",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "Qual é a principal vantagem do GraphQL sobre REST quando o cliente precisa de dados de múltiplos recursos relacionados?",
    "options": [
      "Buscar todos os dados necessários em uma única requisição, evitando over-fetching e under-fetching",
      "Maior velocidade de rede",
      "Melhor cache no navegador",
      "Menor uso de memória no servidor"
    ],
    "correctIndex": 0,
    "explanation": "No REST, buscar um usuário com seus posts e comentários exige 3 chamadas (under-fetching). No GraphQL, uma única query especifica exatamente os campos desejados de múltiplos tipos, retornando tudo em uma resposta. Também evita over-fetching ao não trazer campos desnecessários.",
    "example": "query { user(id: 1) { name, posts { title, comments { text } } } } — uma única requisição retorna nome do usuário, títulos dos posts e textos dos comentários."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__2",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que é paginação em APIs REST e quais são as duas abordagens mais comuns?",
    "options": [
      "Offset-based (page/limit) e Cursor-based (after/first); dividem respostas grandes em páginas",
      "Compressão e cache",
      "Autenticação e autorização",
      "Criptografia e hashing"
    ],
    "correctIndex": 0,
    "explanation": "Offset-based: GET /items?page=3&limit=20 (pula 40, retorna 20). Simples mas inconsistente com inserções. Cursor-based: GET /items?after=abc123&first=20 (retorna 20 após o cursor abc123). Consistente e eficiente para grandes datasets, usado por Facebook e GitHub.",
    "example": "Offset: /posts?page=100&limit=20 — banco faz OFFSET 1980 (lento em tabelas grandes). Cursor: /posts?after=eyJpZCI6MTk4MH0&first=20 — banco faz WHERE id > 1980 LIMIT 20 (rápido com índice)."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__3",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que é rate limiting em APIs e por que é importante?",
    "options": [
      "Limitar o número de requisições por cliente em um período, protegendo contra abuso e sobrecarga",
      "Limitar o tamanho do payload",
      "Limitar o número de rotas",
      "Limitar conexões WebSocket"
    ],
    "correctIndex": 0,
    "explanation": "Rate limiting restringe quantas requisições um cliente pode fazer por período (ex: 100 req/min). Protege contra DDoS, abuso de API, e garante fairness entre clientes. Retorna HTTP 429 Too Many Requests quando o limite é excedido.",
    "example": "Headers de resposta: X-RateLimit-Limit: 100, X-RateLimit-Remaining: 23, X-RateLimit-Reset: 1625097600. Cliente sabe que pode fazer mais 23 requests antes do reset."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__4",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que é versionamento de API e quais são as abordagens comuns?",
    "options": [
      "Mecanismo para evoluir a API sem quebrar clientes existentes; via URL, header ou query param",
      "Controle de versão do código-fonte",
      "Backup de endpoints",
      "Cache de requisições"
    ],
    "correctIndex": 0,
    "explanation": "Versionamento permite manter versões antigas funcionando ao lançar novas. Via URL: /api/v1/users, /api/v2/users. Via header: Accept: application/vnd.api.v2+json. Via query: /api/users?version=2. URL path é o mais comum e explícito.",
    "example": "v1: GET /api/v1/users → { name: 'Ana Silva' }. v2: GET /api/v2/users → { firstName: 'Ana', lastName: 'Silva' }. Ambas coexistem. Clientes migram gradualmente."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__5",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que é paginação em APIs REST e por que é importante?",
    "options": [
      "Dividir grandes conjuntos de dados em páginas menores para evitar respostas enormes",
      "Ordenar resultados por data",
      "Cachear respostas da API",
      "Comprimir dados da resposta"
    ],
    "correctIndex": 0,
    "explanation": "Paginação evita retornar milhões de registros de uma vez. Offset-based: ?page=2&limit=20. Cursor-based: ?cursor=abc123&limit=20 (mais eficiente para dados que mudam). Resposta inclui total, hasNext, nextCursor.",
    "example": "GET /api/users?page=3&limit=20 → retorna usuários 41-60 de 500 totais. Response: { data: [...], meta: { total: 500, page: 3, limit: 20, totalPages: 25 } }."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__6",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que é CORS (Cross-Origin Resource Sharing) e por que é necessário?",
    "options": [
      "Mecanismo que permite ou bloqueia requisições HTTP entre domínios diferentes via headers",
      "Tipo de criptografia",
      "Protocolo de autenticação",
      "Compressão de dados"
    ],
    "correctIndex": 0,
    "explanation": "Browsers bloqueiam requisições cross-origin por segurança (Same-Origin Policy). CORS permite o servidor indicar quais origens podem acessá-lo via headers: Access-Control-Allow-Origin, Access-Control-Allow-Methods. Requisições complexas fazem preflight (OPTIONS).",
    "example": "Frontend em localhost:3000 chama API em api.com. Browser envia OPTIONS (preflight). API responde: Access-Control-Allow-Origin: http://localhost:3000, Allow-Methods: GET,POST. Browser permite a requisição."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__7",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que é autenticação via JWT (JSON Web Token) em APIs?",
    "options": [
      "Token assinado contendo claims do usuário, enviado no header Authorization para autenticação stateless",
      "Cookie de sessão",
      "API key no header",
      "Autenticação básica com senha"
    ],
    "correctIndex": 0,
    "explanation": "JWT: header.payload.signature codificados em base64. Header (alg, type), Payload (sub, exp, iat, claims customizados), Signature (HMAC ou RSA). Enviado como: Authorization: Bearer <token>. Stateless: servidor não mantém sessão, valida pela assinatura.",
    "example": "Login: POST /auth/login {email, password} → {token: 'eyJ...'}. Requisições seguintes: GET /api/users, Header: Authorization: Bearer eyJ... Servidor valida assinatura e extrai userId do payload."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__8",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "Qual é a principal vantagem do GraphQL sobre REST para consultas de dados aninhados?",
    "options": [
      "Evita overfetching e underfetching: cliente especifica exatamente os campos necessários e obtém dados de múltiplas entidades relacionadas em uma única requisição",
      "GraphQL é sempre mais rápido que REST por usar protocolo binário",
      "Usa WebSockets nativamente para comunicação em tempo real",
      "Processa queries no cliente sem necessidade de servidor"
    ],
    "correctIndex": 0,
    "explanation": "REST: endpoints fixos retornam estrutura predefinida. Overfetching: recebe 20 campos quando precisa de 2. Underfetching: precisa de múltiplas requisições para dados relacionados. GraphQL: cliente define query com exatamente os campos desejados. Introspection: schema autodocumentado. Desvantagem: complexidade de caching (sem URLs fixas), curva de aprendizado.",
    "example": "REST: GET /usuario/1 (20 campos) + GET /posts?userId=1 = 2 requests. GraphQL: query { usuario(id:1) { nome posts { titulo } } } = 1 request com somente nome e títulos dos posts. N-fields, 1-request. Playground: GraphiQL, Apollo Studio."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__9",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que é idempotência em APIs REST e quais métodos HTTP são idempotentes?",
    "options": [
      "Operação que produz o mesmo resultado independente de quantas vezes é executada; GET, PUT, DELETE são idempotentes; POST não é",
      "Operação sem efeitos colaterais; somente GET é idempotente",
      "Operação reversível; todos os métodos exceto DELETE são idempotentes",
      "Operação atômica; POST e PATCH são idempotentes"
    ],
    "correctIndex": 0,
    "explanation": "Idempotência: executar N vezes = executar 1 vez (mesmo estado final). GET: leitura sem efeito. PUT: substituição total — PUT /pedidos/42 com mesmo body sempre resulta no mesmo estado. DELETE: deletar item já deletado retorna 404 mas estado é o mesmo (ausente). POST: cria novo recurso a cada chamada. PATCH: depende da implementação (pode ou não ser idempotente).",
    "example": "PUT /pedidos/42 {status:'cancelado'}: executar 10 vezes = mesmo resultado. Importante para retries automáticos em caso de falha de rede. POST /pedidos: 10 execuções = 10 pedidos. Idempotency-Key header: permite POST idempotente em pagamentos (Stripe usa isso)."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__10",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que são webhooks e como diferem de polling para receber notificações de eventos de serviços externos?",
    "options": [
      "Webhooks: servidor externo envia HTTP POST ao seu endpoint quando evento ocorre (push); polling: seu sistema consulta periodicamente (pull) — webhooks são mais eficientes",
      "Webhooks usam WebSockets bidirecionais; polling usa SSE unidirecional",
      "Webhooks requerem conexão TCP persistente; polling usa UDP",
      "Webhooks são exclusivos para GraphQL; polling é o padrão REST"
    ],
    "correctIndex": 0,
    "explanation": "Polling: cliente consulta servidor repetidamente em intervalos (ex: GET a cada 30s). Desperdício se não há dados novos. Webhooks: evento ocorre → servidor externo faz POST para URL cadastrada com payload do evento. Eficiente (tráfego só quando há dados). Desafios: idempotência (evento pode ser reenviado), verificar assinatura (HMAC), retry com backoff em falhas.",
    "example": "Stripe webhook: pagamento confirmado → POST https://seusite.com/webhooks/stripe, body:{type:'payment_intent.succeeded', data:{amount:5000}}. Servidor: verifica Stripe-Signature header (HMAC-SHA256), processa, retorna 200. Se retornar 5xx, Stripe reenvia com backoff exponencial até 72h."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Médio__11",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Médio",
    "question": "O que é paginação cursor-based e como difere de offset-based em APIs com grandes volumes de dados?",
    "options": [
      "Cursor-based usa ponteiro opaco para o último item retornado; offset pula N registros — cursor é mais eficiente e consistente em datasets grandes e mutáveis",
      "Cursor-based numera páginas sequencialmente; offset usa índices de array",
      "Cursor-based só funciona com GraphQL; offset é exclusivo de REST",
      "Ambas são idênticas em performance; a escolha é puramente estética"
    ],
    "correctIndex": 0,
    "explanation": "Offset-based: GET /items?offset=1000&limit=20. Banco: OFFSET 1000 LIMIT 20 — precisa pular 1000 rows (lento em datasets grandes). Problema: inserções/deleções entre páginas causam duplicatas ou itens pulados. Cursor-based: GET /items?after=eyJpZCI6MTAwMH0. Banco: WHERE id > 1000 LIMIT 20 — usa index, O(log n). Consistente mesmo com mutações.",
    "example": "1M registros. Offset página 5000 → OFFSET 100000 — banco itera 100K rows. Cursor after=id_100000 → WHERE id > 100000 LIMIT 20 — index seek direto. Resposta: { data: [...], pageInfo: { endCursor: 'abc123', hasNextPage: true } }. GitHub API v4 usa cursor-based."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__1",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "Em uma API GraphQL, como o DataLoader resolve o problema N+1 de queries ao banco de dados?",
    "options": [
      "Agrupa múltiplas chaves em uma única query batch usando deduplicação e coalescing por tick do event loop",
      "Usa cache de segundo nível no servidor",
      "Limita o número de resolvers executados",
      "Converte GraphQL em REST internamente"
    ],
    "correctIndex": 0,
    "explanation": "O DataLoader coleta todas as chaves requisitadas dentro de um mesmo tick do event loop e dispara uma única query batch (ex.: WHERE id IN (1,2,3)) em vez de N queries individuais. Também deduplica chaves repetidas e cacheia resultados por request.",
    "example": "Sem DataLoader: 1 query para listar 50 posts + 50 queries para buscar o autor de cada post = 51 queries. Com DataLoader: 1 query posts + 1 query WHERE author_id IN (...50 ids) = 2 queries."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__2",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que são Mutations no GraphQL e como diferem de Queries?",
    "options": [
      "Mutations modificam dados (criar, atualizar, deletar); Queries apenas leem dados",
      "São idênticos",
      "Queries modificam e Mutations leem",
      "Mutations são assincronas e Queries síncronas"
    ],
    "correctIndex": 0,
    "explanation": "Queries são operações de leitura (análogas a GET). Mutations são operações de escrita (análogas a POST/PUT/DELETE). Queries são executadas em paralelo; Mutations são executadas sequencialmente para garantir consistência. Subscriptions permitem dados em tempo real via WebSocket.",
    "example": "mutation { createUser(input: { name: \"Ana\", email: \"ana@email.com\" }) { id, name } } — cria usuário e retorna apenas id e name do recém-criado."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__3",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que é o padrão HATEOAS em APIs REST e qual sua vantagem?",
    "options": [
      "Respostas incluem links para ações relacionadas, permitindo que o cliente navegue pela API sem conhecer URLs previamente",
      "Protocolo de criptografia para APIs",
      "Formato de compressão de JSON",
      "Tipo de autenticação OAuth"
    ],
    "correctIndex": 0,
    "explanation": "HATEOAS (Hypermedia as the Engine of Application State) é o nível mais alto de maturidade REST (Richardson Level 3). As respostas incluem links (hypermedia) para ações possíveis, permitindo ao cliente descobrir a API dinamicamente sem documentacação externa.",
    "example": "GET /api/orders/42 retorna: { \"id\": 42, \"status\": \"pending\", \"_links\": { \"self\": \"/orders/42\", \"cancel\": \"/orders/42/cancel\", \"pay\": \"/orders/42/pay\" } }. O cliente sabe que pode cancelar ou pagar seguindo os links."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__4",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que é o problema N+1 em GraphQL e como resolvê-lo?",
    "options": [
      "Quando cada item de uma lista dispara uma query adicional; resolvido com DataLoader (batching)",
      "Limite de 1 query por requisição",
      "Erro de sintaxe na query",
      "Problema de cache"
    ],
    "correctIndex": 0,
    "explanation": "N+1: query de users (1 query) onde cada user resolve posts (N queries). DataLoader agrupa todas as chamadas do mesmo tick em um batch: em vez de 100 queries SELECT * FROM posts WHERE userId=?, faz 1 query SELECT * FROM posts WHERE userId IN (1,2,...100).",
    "example": "Sem DataLoader: 1 query users + 100 queries posts = 101 queries (N+1). Com DataLoader: 1 query users + 1 query posts com IN clause = 2 queries. Performance 50x melhor."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__5",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que são WebSockets e como diferem de REST para comunicação em tempo real?",
    "options": [
      "Protocolo bidirecional persistente; REST é request-response sem conexão persistente",
      "REST mais rápido é idêntico",
      "WebSockets substituem REST completamente",
      "WebSockets só funcionam com GraphQL"
    ],
    "correctIndex": 0,
    "explanation": "WebSockets: conexão TCP persistente bidirecional. Servidor pode enviar dados ao cliente sem request (push). Ideal para chat, games, dashboards real-time, notificações. REST: cada interação é request-response independente (stateless).",
    "example": "Chat com REST: cliente faz polling GET /messages a cada 1s (1000 requests inúteis se não há mensagem nova). Chat com WebSocket: servidor envia mensagem ao cliente instantaneamente quando chega. Latência: 1s vs 50ms."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__6",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que é o padrão BFF (Backend for Frontend) e quando usá-lo?",
    "options": [
      "Backend específico para cada tipo de cliente (web, mobile) que agrega e formata dados de microsserviços",
      "Framework de frontend",
      "Tipo de API Gateway",
      "Padrão de cache"
    ],
    "correctIndex": 0,
    "explanation": "BFF: camada backend dedicada por cliente. BFF web retorna dados completos; BFF mobile retorna dados compactos. Cada BFF agrega chamadas a microsserviços internos, formata resposta para o cliente específico. Evita API genérica que não atende bem nenhum cliente.",
    "example": "BFF Web: /dashboard → agrega users + orders + analytics → resposta completa com gráficos. BFF Mobile: /dashboard → agrega só orders resumidos → payload 80% menor para economia de dados."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__7",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que é gRPC e como difere de REST?",
    "options": [
      "Framework RPC que usa Protocol Buffers (binário) sobre HTTP/2; mais rápido que REST/JSON",
      "Versão mais nova do REST",
      "REST com compressão",
      "GraphQL binário"
    ],
    "correctIndex": 0,
    "explanation": "gRPC: Remote Procedure Call do Google. Usa Protocol Buffers (serialização binária, ~10x menor que JSON) sobre HTTP/2 (multiplexing, streaming bidirecional). Tipagem forte via .proto files. Ideal para comunicação entre microsserviços (alta performance).",
    "example": "Proto: service UserService { rpc GetUser(UserRequest) returns (User); }. Gera client e server em qualquer linguagem. Payload: User em protobuf = 50 bytes vs JSON = 500 bytes. Latência: gRPC ~2ms vs REST ~10ms."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__8",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que é o problema N+1 em GraphQL e como o DataLoader resolve?",
    "options": [
      "N+1: cada item de uma lista dispara query individual ao banco; DataLoader agrupa (batching) todos os IDs em um único tick do event loop e faz uma query com IN",
      "N queries para buscar 1 campo; cache do Apollo resolve automaticamente",
      "N+1 é exclusivo de REST; GraphQL não sofre esse problema",
      "DataLoader elimina a necessidade de banco de dados ao fazer cache total"
    ],
    "correctIndex": 0,
    "explanation": "N+1: query busca 100 usuários (1 query) e, para cada um, busca seus posts (100 queries) = 101 queries. DataLoader: acumula IDs solicitados durante o tick do event loop, executa 1 batch query (SELECT * FROM posts WHERE user_id IN (ids)), distribui resultados. Facebook criou DataLoader para esse problema. Reduz de N+1 para 2 queries.",
    "example": "Sem DataLoader: 100 users → 100×SELECT posts WHERE user_id=X. Com DataLoader: dataloader.load(userId) acumula; batchLoadFn recebe [1..100] → SELECT posts WHERE user_id IN (1,...,100). 101 queries → 2 queries. graphql-dataloader, prime cache por key."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__9",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que são middlewares de rate limiting e quais algoritmos existem para implementá-los?",
    "options": [
      "Controle de taxa de requisições para proteger APIs; algoritmos: Token Bucket (bursts permitidos), Leaky Bucket (saída constante), Fixed Window (janela fixa) e Sliding Window (mais precisa)",
      "Cache de respostas de API para reduzir carga no servidor",
      "Balanceamento de carga entre instâncias da API",
      "Compressão de payload para reduzir largura de banda consumida"
    ],
    "correctIndex": 0,
    "explanation": "Rate limiting protege contra abuso e DDoS. Token Bucket: tokens gerados a taxa fixa, cada req consome um token (permite bursts ate o tamanho do bucket). Leaky Bucket: fila com saída constante (suaviza tráfego, sem bursts). Fixed Window: conta reqs em janela fixa (problema: burst na virada da janela). Sliding Window Log: preciso mas custoso em memória. Sliding Window Counter: equilíbrio.",
    "example": "Token Bucket: limite 100 req/min, 100 tokens disponíveis. 100 reqs simultâneas (burst): aceita todas. Next second: ~1-2 tokens. API Gateway AWS usa Token Bucket. Nginx: limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s. Redis usado para rate limiting distribuído entre múltiplos pods."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__10",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que é o problema N+1 em GraphQL e como o DataLoader resolve esse problema de performance?",
    "options": [
      "Resolver de campo dispara 1 query por item (N queries + 1 inicial); DataLoader agrupa IDs e faz uma única query batch por tick do event loop",
      "N+1 refere-se ao limite de profundidade de queries; DataLoader limita a N+1 níveis",
      "N+1 é o número máximo de campos retornados; DataLoader comprime a resposta",
      "N+1 é um limite de rate limiting; DataLoader faz cache local ilimitado"
    ],
    "correctIndex": 0,
    "explanation": "Problema N+1: query { users { posts { title } } }. Resolver users: 1 query. Para cada user, resolver posts: N queries (SELECT FROM posts WHERE user_id=?). Total: N+1 queries. DataLoader: agrupa load(userId) no mesmo tick do event loop → batch function com todos IDs: SELECT FROM posts WHERE user_id IN (1,2,...N). Resultado: 2 queries. Também cacheia por request.",
    "example": "Sem DataLoader: users [1,2,3] → SELECT * FROM posts WHERE user_id=1; WHERE user_id=2; WHERE user_id=3 (4 queries). Com: const loader = new DataLoader(ids => db.query('SELECT * FROM posts WHERE user_id IN (?)', [ids])); resolver: loader.load(user.id); → batch: 1 query IN(1,2,3). Total: 2 queries."
  },
  {
    "id": "desenvolvimento__APIs REST e GraphQL__Difícil__11",
    "track": "desenvolvimento",
    "category": "APIs REST e GraphQL",
    "difficulty": "Difícil",
    "question": "O que são Server-Sent Events (SSE) e como diferem de WebSockets para comunicação em tempo real?",
    "options": [
      "SSE: conexão HTTP unidirecional server→client com reconexão automática e text/event-stream; WebSocket: bidirecional full-duplex sobre protocolo ws://",
      "SSE usa UDP para streaming; WebSocket usa TCP com garantia de entrega",
      "SSE requer servidor dedicado; WebSocket funciona em qualquer servidor HTTP padrão",
      "SSE é bidirecional como WebSocket mas com menor latência"
    ],
    "correctIndex": 0,
    "explanation": "SSE: API nativa do navegador (EventSource). HTTP simples, Content-Type: text/event-stream. Unidirecional: server→client. Reconexão automática com Last-Event-ID. WebSocket: protocolo ws://, upgrade de HTTP. Bidirecional: client↔server. Mais complexo (handshake, heartbeat, reconnect manual). SSE para: notificações, feeds, dashboards. WebSocket para: chat, gaming, colaboração.",
    "example": "SSE server: res.writeHead(200,{'Content-Type':'text/event-stream'}); setInterval(()=>res.write('data:'+JSON.stringify({price:42})+'\\n\\n'),1000). Client: const es=new EventSource('/stream'); es.onmessage=e=>console.log(JSON.parse(e.data)). Se cair, navegador reconecta em 3s com Last-Event-ID."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__1",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "Qual padrão arquitetural divide a aplicação em três camadas: apresentação, lógica de negócios e acesso a dados?",
    "options": [
      "MVC (Model-View-Controller)",
      "Microserviços",
      "Event Sourcing",
      "Serverless"
    ],
    "correctIndex": 0,
    "explanation": "O MVC separa a aplicação em Model (dados e regras de negócio), View (interface com o usuário) e Controller (intermediário que recebe requisições, manipula o Model e retorna a View). Facilita manutenção e testes independentes de cada camada.",
    "example": "No Express.js: Router (Controller) recebe GET /users, chama UserService (Model) para buscar dados do banco, e retorna um JSON (View) ao cliente."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__2",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que significa arquitetura 'Cliente-Servidor' e onde ela é aplicada?",
    "options": [
      "Modelo onde clientes fazem requisições a um servidor central que processa e responde",
      "Modelo peer-to-peer sem servidor",
      "Modelo onde tudo roda no navegador",
      "Modelo exclusivo para jogos online"
    ],
    "correctIndex": 0,
    "explanation": "Na arquitetura cliente-servidor, clientes (navegadores, apps móveis) enviam requisições pela rede a um servidor que processa, acessa banco de dados e retorna respostas. O servidor centraliza lógica de negócio e dados. É o modelo básico da web.",
    "example": "App React Native (cliente) faz GET /api/cards para o servidor Express (servidor). O servidor consulta o PostgreSQL e retorna os flashcards em JSON."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__3",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que é uma API e qual seu papel na arquitetura de software?",
    "options": [
      "Interface que define como componentes de software se comunicam sem expor detalhes internos",
      "Banco de dados compartilhado",
      "Linguagem de programação",
      "Framework de interface gráfica"
    ],
    "correctIndex": 0,
    "explanation": "API (Application Programming Interface) define um contrato de comunicação entre sistemas. Expõe funcionalidades de um serviço sem revelar sua implementação interna. APIs HTTP/REST são as mais comuns, mas existem APIs de bibliotecas, SO e hardware.",
    "example": "A API do Stripe expõe POST /v1/charges para processar pagamentos. Você não precisa saber como o Stripe processa internamente — só segue o contrato da API."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__4",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que é arquitetura monolítica e quais suas características principais?",
    "options": [
      "Aplicação em uma única unidade de código deployável com todos os componentes juntos",
      "Aplicação distribuída em vários serviços",
      "Arquitetura baseada em eventos",
      "Sistema sem banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "Monolito: toda a aplicação (UI, lógica, acesso a dados) em um único deployável. Vantagens: simples de desenvolver, debugar e deployar inicialmente. Desvantagens: escalação (escala tudo ou nada), acoplamento, deploys arriscados, stack único.",
    "example": "E-commerce monolítico: um único servidor Java com módulos de pagamento, estoque, usuários, notificações. Para escalar só o pagamento (Black Friday), precisa escalar o monolito inteiro."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__5",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que significa o padrão MVC (Model-View-Controller)?",
    "options": [
      "Padrão que separa aplicação em Model (dados), View (interface) e Controller (lógica de controle)",
      "Framework JavaScript",
      "Tipo de banco de dados",
      "Protocolo de comunicação"
    ],
    "correctIndex": 0,
    "explanation": "MVC separa responsabilidades: Model gerencia dados e regras de negócio, View apresenta a interface ao usuário, Controller recebe input do usuário e coordena Model e View. Reduz acoplamento e facilita testes. Usado em Rails, Django, Spring MVC.",
    "example": "Cadastro de usuário: View (formulário HTML) → Controller (recebe POST, valida dados) → Model (salva no banco) → Controller redireciona → View (página de sucesso)."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__6",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre escalabilidade horizontal e vertical?",
    "options": [
      "Horizontal adiciona mais máquinas; vertical aumenta recursos da máquina existente",
      "São termos para banco de dados apenas",
      "Horizontal é mais barato sempre",
      "Vertical exige microsserviços"
    ],
    "correctIndex": 0,
    "explanation": "Escala vertical (scale up): mais CPU, RAM ou disco na mesma máquina — simples, mas tem limite físico. Escala horizontal (scale out): adicionar mais instâncias/máquinas atrás de um load balancer — mais complexo (estado, sessão), mas virtualmente ilimitado.",
    "example": "Vertical: trocar servidor de 8GB RAM por 64GB. Horizontal: manter 8 servidores de 8GB atrás de um NGINX. Microsserviços facilitam escala horizontal; monolitos geralmente escalam verticalmente."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__7",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que é o padrão de camadas (Layered Architecture)?",
    "options": [
      "Organização em camadas onde cada uma só se comunica com a camada adjacente",
      "Divisão de código em microsserviços",
      "Padrão de cache multinível",
      "Técnica de compressão de dados"
    ],
    "correctIndex": 0,
    "explanation": "Layered Architecture organiza o código em camadas horizontais: Apresentação → Lógica de Negócio → Acesso a Dados → Banco. Cada camada depende apenas da camada abaixo. Facilita separação de responsabilidades e substituição de uma camada sem afetar as outras.",
    "example": "Controller (Apresentação) → Service (Negócio) → Repository (Dados) → PostgreSQL. O Controller nunca acessa o banco diretamente; sempre passa pelo Service e Repository."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__8",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que é o padrão arquitetural MVC (Model-View-Controller)?",
    "options": [
      "Separa a aplicação em Model (dados/regras), View (interface) e Controller (lógica de controle), desacoplando responsabilidades",
      "Padrão de banco de dados com três tabelas obrigatórias",
      "Arquitetura de microsserviços com três serviços core",
      "Metodologia ágil com três papéis: dev, QA e PO"
    ],
    "correctIndex": 0,
    "explanation": "MVC: Model gerencia dados e regras de negócio. View renderiza a interface ao usuário. Controller recebe input do usuário, atualiza o Model e seleciona a View para resposta. Promove separação de responsabilidades, reuso (mesmo Model para múltiplas Views) e testabilidade independente das camadas.",
    "example": "Blog: Model=Post (busca/salva no BD), View=post.html (renderiza HTML), Controller=PostController (recebe GET /post/1, chama Post.find(1), passa para View). Rails, Django, Laravel, ASP.NET MVC seguem esse padrão. Spring MVC e Express.js também."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__9",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que é um microsserviço e qual a diferença principal em relação a uma arquitetura monolítica?",
    "options": [
      "Serviço pequeno e independente com domínio específico, deployado separadamente; monolito é uma única aplicação unificada deployada por completo",
      "Serviço externo de terceiros integrado via API REST",
      "Container Docker com um único processo isolado",
      "Função serverless com escopo e tempo de vida limitados"
    ],
    "correctIndex": 0,
    "explanation": "Microsserviços: aplicação decomposta em serviços pequenos e independentes, cada um com sua base de código, banco de dados e ciclo de deploy próprio. Comunicam via APIs HTTP/gRPC ou mensageria (Kafka, RabbitMQ). Monolito: tudo em um processo. Microsserviços: escalabilidade e independência de times a custo de complexidade distribuída.",
    "example": "E-commerce monolítico: 1 deploy para tudo (risco: falha afeta tudo). Microsserviços: Pedidos, Pagamentos, Estoque, Usuários independentes. Time de Pagamentos faz deploy isolado. Escalabilidade: 10× o serviço de Pedidos sem escalar Usuários. Netflix, Amazon, Uber usam microsserviços."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__10",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que é escalabilidade horizontal vs vertical e quando cada abordagem é mais adequada?",
    "options": [
      "Vertical: aumentar recursos da máquina (CPU, RAM); horizontal: adicionar mais máquinas — horizontal é preferível para alta disponibilidade e elasticidade",
      "Vertical: adicionar servidores; horizontal: melhorar hardware de um servidor",
      "Vertical: escalar frontend; horizontal: escalar backend",
      "Ambas significam adicionar mais capacidade de processamento"
    ],
    "correctIndex": 0,
    "explanation": "Vertical (scale up): CPU mais potente, mais RAM — mesma máquina. Limite: hardware tem teto, single point of failure. Horizontal (scale out): mais instâncias distribuídas. Requer: app stateless, load balancer, dados compartilhados. Benefícios: sem teto teórico, alta disponibilidade (nó cai, outros continuam). Desafio: consistência de dados, complexidade.",
    "example": "App com 10K users. Vertical: trocar de 4GB para 32GB RAM — rápido mas limite ~256GB. Horizontal: 3 instâncias de 4GB atrás de ALB. Sessão: JWT stateless. Upload: S3 compartilhado. Auto-scaling AWS: adiciona instâncias quando CPU > 70%. Kubernetes: HPA escala pods horizontalmente."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Fácil__11",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Fácil",
    "question": "O que é uma fila de mensagens (message queue) e por que é usada em sistemas distribuídos?",
    "options": [
      "Middleware que desacopla produtor/consumidor: produtor envia mensagem à fila, consumidor processa assincronamente — garante resiliência e absorção de picos",
      "Banco NoSQL otimizado para mensagens curtas e efêmeras",
      "Protocolo de comunicação síncrona entre microsserviços",
      "Sistema de cache que armazena respostas de APIs para reduzir latência"
    ],
    "correctIndex": 0,
    "explanation": "Message queue: produtor publica mensagem → fila armazena → consumidor consome quando disponível. Desacoplamento: produtor e consumidor não precisam estar online simultaneamente. Buffer de picos: 1000 req/s → fila absorve → consumidor processa a 100/s gradualmente. Garantias: at-least-once (RabbitMQ), at-most-once, exactly-once (Kafka). Exemplos: RabbitMQ, Apache Kafka, SQS, Redis Streams.",
    "example": "Checkout e-commerce → publica 'pedido_criado' no Kafka. Consumers independentes: email (envia confirmação), estoque (reserva itens), analytics (registra venda). Se serviço de email cair, mensagem permanece no Kafka; ao voltar, consome e envia. Checkout não espera nenhum deles."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__1",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "Qual é a principal diferença entre arquitetura monolítica e microsserviços em termos de deploy?",
    "options": [
      "Microsserviços permitem deploy independente de cada serviço; monolito exige deploy da aplicação inteira",
      "Monolito é mais rápido para deploy",
      "Microsserviços não podem ser containerizados",
      "Não há diferença de deploy, apenas de organização de código"
    ],
    "correctIndex": 0,
    "explanation": "Em microsserviços, cada serviço tem seu próprio repositório, pipeline CI/CD e processo de deploy independente. Uma alteração no serviço de pagamentos pode ser deployada sem afetar o serviço de catálogo. No monolito, qualquer mudança exige rebuild e redeploy de toda a aplicação.",
    "example": "Time A faz deploy do serviço de pagamentos às 14h. Time B faz deploy do serviço de notificações às 15h. Nenhum interfere no outro. No monolito, ambos teriam que coordenar um único deploy."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__2",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é o padrão Repository na arquitetura de software?",
    "options": [
      "Camada de abstração entre lógica de negócio e acesso a dados, encapsulando operações de persistência",
      "Repositório Git",
      "Cache de banco de dados",
      "Servidor de CI/CD"
    ],
    "correctIndex": 0,
    "explanation": "O Repository Pattern cria uma interface entre a camada de domínio e a camada de dados. A lógica de negócio usa métodos como findById(), save(), delete() sem saber se os dados vêm de PostgreSQL, MongoDB ou API externa. Facilita testes (mock do repo) e troca de banco.",
    "example": "interface UserRepository { findById(id: string): User; save(user: User): void; } class PgUserRepository implements UserRepository { ... } — service usa a interface, teste usa MockUserRepository."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__3",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é DDD (Domain-Driven Design) e qual seu conceito central?",
    "options": [
      "Abordagem que coloca o domínio de negócio no centro do design, usando linguagem ubíqua entre devs e especialistas",
      "Metodologia ágil",
      "Ferramenta de deploy",
      "Banco de dados orientado a domínios"
    ],
    "correctIndex": 0,
    "explanation": "DDD foca em modelar o software refletindo o domínio do negócio. Conceitos-chave: Entidades (identidade única), Value Objects (imutáveis, igualdade por valor), Aggregates (grupo transacional), Bounded Contexts (limites de contexto), Ubiquitous Language (terminologia compartilhada entre devs e negócio).",
    "example": "No domínio de e-commerce: Pedido (Entity com ID), Dinheiro (Value Object: { valor: 100, moeda: 'BRL' }), Carrinho (Aggregate Root que contém ItemCarrinho). Dev e PO usam os mesmos termos: 'Pedido', não 'Order row'."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__4",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é arquitetura de microsserviços e quais suas vantagens sobre monolitos?",
    "options": [
      "Dividir a aplicação em serviços independentes, cada um com deploy e escalabilidade própria",
      "Monolito com módulos internos",
      "Aplicação frontend dividida",
      "Banco de dados distribuído"
    ],
    "correctIndex": 0,
    "explanation": "Microsserviços: cada serviço é independente (deploy, stack, banco próprio), comunica via API/mensageria. Vantagens: escala independente, deploys frequentes, equipes autônomas. Desvantagens: complexidade operacional, consistência distribuída, latency overhead.",
    "example": "Netflix: serviço de recomendação (Python/ML), serviço de streaming (Java), serviço de billing (Go), serviço de perfil (Node.js). Cada um escala independentemente conforme demanda."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__5",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é o padrão CQRS (Command Query Responsibility Segregation)?",
    "options": [
      "Separar operações de leitura (Query) e escrita (Command) em modelos diferentes",
      "Cache de queries SQL",
      "Compressão de requisições",
      "Controle de acesso por query"
    ],
    "correctIndex": 0,
    "explanation": "CQRS separa leitura e escrita: Command modelo otimizado para writes (validações, regras), Query modelo otimizado para reads (denormalizado, rápido). Frequentemente combinado com Event Sourcing. Ideal quando leitura e escrita têm cargas muito diferentes.",
    "example": "E-commerce: Command escreve pedido no banco normalizado com validações. Query lê de uma view materializada denormalizada com join pré-calculado. Escrita: 100 req/s. Leitura: 10.000 req/s — modelos otimizados separadamente."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__6",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é o padrão Strangler Fig para migração de monolito para microsserviços?",
    "options": [
      "Substituir gradualmente partes do monolito por microsserviços, roteando tráfego progressivamente",
      "Derrubar o monolito e reescrever tudo do zero",
      "Executar monolito e microsserviços em paralelo permanentemente",
      "Usar cache para acelerar o monolito"
    ],
    "correctIndex": 0,
    "explanation": "Strangler Fig (inspirado na figueira que envolve a árvore hospedeira) migra gradualmente: cria o microsserviço novo, roteia parte do tráfego para ele via proxy, e quando 100% do tráfego estiver no novo serviço, remove o código antigo do monolito. Minimiza risco.",
    "example": "Monolito com módulo de pagamento. Cria PagamentoService em microsserviço. NGINX redireciona /api/pagamentos para o novo serviço. Testa com 10% do tráfego → 50% → 100%. Remove módulo de pagamento do monolito."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__7",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é Event-Driven Architecture (EDA) e quando usá-la?",
    "options": [
      "Arquitetura onde componentes se comunicam por eventos assíncronos via message broker",
      "Arquitetura com chamadas síncronas entre serviços",
      "Arquitetura exclusiva para frontend",
      "Tipo de banco de dados reativo"
    ],
    "correctIndex": 0,
    "explanation": "EDA: produtores emitem eventos (PedidoCriado, PagamentoConfirmado) para um broker (Kafka, RabbitMQ). Consumidores processam independentemente. Vantagens: desacoplamento, escalabilidade, resiliência. Desvantagens: complexidade, eventual consistency, debug mais difícil.",
    "example": "Pedido criado → evento PedidoCriado no Kafka → EstoqueService consome (reserva itens), NotificacaoService consome (envia email), AnalyticsService consome (registra métrica). Cada um independente."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__8",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é CQRS (Command Query Responsibility Segregation) e qual problema ele resolve?",
    "options": [
      "Separa operações de leitura (Query) e escrita (Command) em modelos distintos; permite otimizar leitura e escrita independentemente",
      "Padrão de cache que separa dados quentes de dados frios em camadas",
      "Separação entre banco relacional (escrita) e NoSQL (leitura)",
      "Padrão de segurança que separa autenticação e autorização"
    ],
    "correctIndex": 0,
    "explanation": "CQRS: Commands (escrita) alteram estado e não retornam dados, executados no modelo de escrita com validação de invariantes. Queries (leitura) retornam dados sem efeito colateral, executadas em modelo de leitura otimizado (desnormalizado, cache, Elasticsearch). Frequentemente combinado com Event Sourcing. Custo: complexidade de sincronização eventual entre os modelos.",
    "example": "E-commerce: Command CreateOrder → BD relacional normalizado (grava). Query GetOrderHistory → view materializada ou Elasticsearch desnormalizado (lê rápido). Escrita usa PostgreSQL; leitura usa Elasticsearch para busca por texto livre. Sync via eventos de domínio."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__9",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é Domain-Driven Design (DDD) e o que são Bounded Contexts?",
    "options": [
      "Abordagem que alinha código ao domínio do negócio; Bounded Context define limite explícito onde um modelo de domínio tem significado específico e coerente",
      "Framework de banco de dados organizado por domínio de negócio",
      "Metodologia de desenvolvimento de microsserviços orientada a domínio",
      "Padrão de UI que organiza componentes conforme o domínio do usuário"
    ],
    "correctIndex": 0,
    "explanation": "DDD: modelagem de software orientada ao domínio do problema, com linguagem ubíqua entre devs e especialistas de negócio. Conceitos: Entidades (identidade), Value Objects (imutáveis por valor), Aggregates (cluster com invariantes), Domain Events, Repositories. Bounded Context: fronteira explícita onde termos e modelos têm significado único (Produto em Vendas ≠ Produto em Estoque).",
    "example": "E-commerce: Bounded Context de Vendas tem Pedido com lineItems e valor total. Bounded Context de Logística tem Pedido com endereço e tracking. Mesma palavra 'Pedido', modelos completamente diferentes. Comunicação entre contextos via eventos de domínio publicados."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__10",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é o padrão Outbox para garantir consistência entre banco de dados e sistema de mensageria?",
    "options": [
      "Grava o evento numa tabela outbox na mesma transação do dado; processo separado publica os eventos pendentes no broker",
      "Envia mensagem ao broker e depois persiste no banco na mesma operação",
      "Usa transações distribuídas (2PC) entre banco e broker para atomicidade",
      "Replica o banco inteiro para o broker em intervalos regulares"
    ],
    "correctIndex": 0,
    "explanation": "Problema: salvar no DB + publicar no broker não é atômico. Publicação falha após commit = evento perdido. Outbox pattern: 1) Transação atômica: INSERT pedido + INSERT outbox_events (mesmo TX). 2) Processo separado (polling ou CDC/Debezium) lê outbox e publica no Kafka. 3) Marca evento como publicado. Garante at-least-once. Consumer deve ser idempotente.",
    "example": "BEGIN TX; INSERT INTO orders(id,total) VALUES(1,100); INSERT INTO outbox_events(id,type,payload) VALUES(uuid,'Order','{id:1,total:100}'); COMMIT; — Debezium (CDC) detecta INSERT na outbox → publica no Kafka topic 'order.events'. Consumer grava processed_event_id para idempotência."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Médio__11",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Médio",
    "question": "O que é Observability e quais são os três pilares (logs, métricas e traces) em sistemas distribuídos?",
    "options": [
      "Capacidade de entender o estado interno do sistema; logs registram eventos, métricas quantificam comportamento e traces rastreiam requisições entre serviços",
      "Monitoramento de uptime com ping; logs são suficientes para total observabilidade",
      "Alertas automáticos que reiniciam serviços quando detectam falhas",
      "Dashboard que mostra apenas uso de CPU e memória"
    ],
    "correctIndex": 0,
    "explanation": "Observability: diagnosticar problemas em sistemas complexos. Três pilares: 1) Logs: registros de eventos (JSON estruturado). Ferramentas: ELK, Loki. 2) Métricas: valores numéricos ao longo do tempo (latência p99, error rate). Ferramentas: Prometheus, Grafana. 3) Traces: rastreamento de request através de múltiplos serviços com correlation ID. Ferramentas: Jaeger, OpenTelemetry.",
    "example": "Request lenta: 1) Métrica: p99 latência subiu de 200ms para 2s no serviço de pagamento. 2) Trace: OpenTelemetry mostra request por API Gateway→Auth→Pagamento→Banco. Span do banco: 1.8s (bottleneck). 3) Log: query SQL com full table scan. Solução: adicionar índice. trace-id=abc123 liga os 3."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__1",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "No padrão CQRS (Command Query Responsibility Segregation), por que separar os modelos de leitura e escrita pode aumentar a escalabilidade?",
    "options": [
      "Permite otimizar e escalar independentemente cada lado: writes para consistência e reads para performance com modelos desnormalizados",
      "Reduz o número de tabelas no banco",
      "Elimina a necessidade de eventos assíncronos",
      "Simplifica o código removendo validações"
    ],
    "correctIndex": 0,
    "explanation": "CQRS separa o modelo de comando (escrita) do modelo de consulta (leitura). O lado de escrita pode usar um modelo normalizado otimizado para integridade. O lado de leitura usa modelos desnormalizados (views materializadas) otimizados para queries. Cada lado escala independentemente.",
    "example": "Write side: insere pedido na tabela normalizada Orders + OrderItems. Read side: tabela desnormalizada OrderSummary com todos os dados pré-calculados. 10x mais reads que writes → escale apenas o read side."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__2",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que é o padrão Saga em microsserviços e como ele substitui transações distribuídas?",
    "options": [
      "Sequência de transações locais com compensações em caso de falha, substituindo 2PC",
      "Transação SQL distribuída",
      "Cache distribuído",
      "Tipo de mensageria"
    ],
    "correctIndex": 0,
    "explanation": "O padrão Saga divide uma transação distribuída em uma sequência de transações locais. Cada passo tem uma ação compensatória (rollback). Se o passo 3 falhar, executa compensações 2 e 1 na ordem inversa. Abordagens: coreografia (eventos) ou orquestração (orquestrador central).",
    "example": "Criar Pedido: 1) ReservarEstoque → 2) ProcessarPagamento → 3) EnviarNotificação. Se pagamento falhar: compensar estoque (liberar reserva). Cada serviço gerencia sua transação local."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__3",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre arquitetura hexagonal (Ports & Adapters) e arquitetura em camadas tradicional?",
    "options": [
      "Hexagonal coloca o domínio no centro com portas (interfaces) e adaptadores (implementações), invertendo dependências",
      "São idênticas",
      "Hexagonal não usa interfaces",
      "Camadas é mais modular"
    ],
    "correctIndex": 0,
    "explanation": "Na arquitetura hexagonal, o domínio (core) não depende de nada externo. Ports são interfaces definidas pelo domínio (ex: IOrderRepo). Adapters são implementações concretas (ex: PostgresOrderRepo, HttpOrderController). Dependências apontam para dentro. Na arquitetura em camadas, dependências vão de cima para baixo.",
    "example": "Core: OrderService depende de IOrderRepository (port). Adapter DB: PostgresOrderRepo implements IOrderRepository. Adapter HTTP: ExpressController chama OrderService. Trocar PostgreSQL por MongoDB: apenas novo adapter, core intocado."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__4",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que é Event Sourcing e como difere de CRUD tradicional?",
    "options": [
      "Armazenar sequência de eventos em vez de estado atual; reconstrói o estado reproduzindo eventos",
      "Cache de eventos do DOM",
      "Log de auditoria simples",
      "Banco de dados de séries temporais"
    ],
    "correctIndex": 0,
    "explanation": "Event Sourcing: em vez de UPDATE no estado, armazena eventos imutáveis (PedidoCriado, ItemAdicionado, PagamentoConfirmado). Estado atual = replay de todos os eventos. Vantagens: auditoria completa, debug no tempo, projetar múltiplas views. Complexidade: snapshots para performance.",
    "example": "Conta bancária CRUD: UPDATE saldo=900. Event Sourcing: eventos [ContaCriada(1000), Saque(100)]. Saldo = replay: 1000-100 = 900. Pode auditar toda história e criar novas projeções retroativamente."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__5",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que são Design Patterns de arquitetura e qual a diferença entre Saga e Two-Phase Commit em transações distribuídas?",
    "options": [
      "Saga usa compensações locais em sequência; 2PC usa coordenador global com lock distribuído",
      "São idênticos",
      "2PC é mais moderno que Saga",
      "Saga só funciona com monolitos"
    ],
    "correctIndex": 0,
    "explanation": "Two-Phase Commit: coordenador pede prepare a todos, depois commit. Bloqueia recursos e não escala bem. Saga: sequência de transações locais, cada uma com compensação. Falha no passo 3 → executa compensações 2, 1. Tipos: Choreography (eventos) e Orchestration (orquestrador central).",
    "example": "Saga de pedido: 1) ReservarEstoque 2) CobrarPagamento 3) EnviarEmail. Se pagamento falha: compensação LiberarEstoque. Orchestrator coordena ou cada serviço ouve eventos do anterior."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__6",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que é o padrão Circuit Breaker em microsserviços e como previne falhas em cascata?",
    "options": [
      "Monitora falhas de um serviço e 'abre o circuito' para bloquear chamadas quando detecta instabilidade",
      "Balanceador de carga round-robin",
      "Firewall entre microsserviços",
      "Mecanismo de retry infinito"
    ],
    "correctIndex": 0,
    "explanation": "Circuit Breaker tem 3 estados: Closed (normal, chamadas passam), Open (serviço instável, chamadas bloqueadas com fallback), Half-Open (testa se serviço se recuperou). Previne cascading failures: um serviço lento não trava os que dependem dele.",
    "example": "Serviço de recomendação está lento (timeout 5s). Sem CB: 100 requests acumulam, 500s de thread bloqueada → crash. Com CB: após 5 falhas consecutivas, circuito abre, retorna cache local ou lista genérica em 10ms. Testa recuperação a cada 30s."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__7",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que é o princípio de Inversão de Dependências (DIP) e como se aplica em arquitetura de software?",
    "options": [
      "Módulos de alto nível não devem depender de módulos de baixo nível; ambos devem depender de abstrações",
      "Inverter a ordem das camadas na arquitetura",
      "Usar injeção de dependência com framework",
      "Remover todas as interfaces do código"
    ],
    "correctIndex": 0,
    "explanation": "DIP (SOLID 'D'): dependências devem apontar para abstrações (interfaces), não implementações concretas. OrderService depende de IPaymentGateway, não de StripeGateway diretamente. Facilita testes (mock), troca de implementação e respeita Open/Closed Principle.",
    "example": "Sem DIP: OrderService importa StripeGateway → acoplado ao Stripe. Com DIP: OrderService depende de IPaymentGateway (interface). StripeGateway e PayPalGateway implementam a interface. Trocar gateway: mudar apenas a injeção, zero alteração no OrderService."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__8",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que é Event Sourcing e como difere do armazenamento tradicional de estado?",
    "options": [
      "Persiste sequência imutável de eventos ao invés do estado atual; estado reconstruído via replay dos eventos; permite auditoria e viagem no tempo",
      "Cache de eventos em memória para acelerar queries de estado",
      "Pub/Sub para notificar microserviços sobre mudanças de estado em tempo real",
      "Log de auditoria opcional sobre o banco de estado relacional"
    ],
    "correctIndex": 0,
    "explanation": "Event Sourcing: fonte da verdade = sequência de eventos (OrderCreated, ItemAdded, PaymentProcessed). Estado atual = replay de eventos. Vantagens: auditoria completa e imutável, estado em qualquer ponto do passado, base natural para CQRS. Desvantagens: complexidade de queries diretas, snapshots periódicos para evitar replay longo, eventual consistency.",
    "example": "Conta bancária: em vez de saldo=1500, armazenamos Deposito(1000), Deposito(800), Saque(300). saldo = replay = 1500. Saldo em 01/jan: replay até aquela data. Eventstore, Axon, EventStoreDB. Snapshots: a cada 100 eventos, salva snapshot do estado para evitar replay completo."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__9",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que é o padrão Saga para gerenciar transações distribuídas em microsserviços?",
    "options": [
      "Sequência de transações locais com compensações em caso de falha; implementada via coreografia (eventos) ou orquestração (coordenador central)",
      "Two-phase commit (2PC) distribuído entre microsserviços",
      "Fila de mensagens que garante entrega exatamente uma vez entre serviços",
      "Circuit breaker que interrompe transações em cascata em caso de falha"
    ],
    "correctIndex": 0,
    "explanation": "Em microsserviços não há transações ACID distribuídas. Saga: sequência de transações locais; se uma falha, executa transações compensatórias nas anteriores. Coreografia: cada serviço emite eventos e reage a eventos de outros (sem coordenador, mas difícil de rastrear). Orquestração: Saga Orchestrator centraliza coordenação (mais visível, ponto único de falha).",
    "example": "Pedido: 1-CriarPedido → 2-ReservarEstoque → 3-ProcessarPagamento → 4-DespacharPedido. Se 3 falha: compensação 2=LiberarEstoque, 1=CancelarPedido. Coreografia via eventos Kafka. Orquestração: AWS Step Functions, Temporal, Conductor. Cada etapa tem transação compensatória correspondente."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__10",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que são CRDTs (Conflict-free Replicated Data Types) e como permitem edição concorrente sem coordenação central?",
    "options": [
      "Estruturas que garantem convergência eventual automática em réplicas independentes sem consenso ou lock; operações são comutativas e idempotentes",
      "Bancos com transações ACID distribuídas que previnem conflitos via locking pessimista",
      "Algoritmos de consenso como Raft que elegem líder para serializar operações",
      "Caches distribuídos que invalidam entradas conflitantes e forçam releitura"
    ],
    "correctIndex": 0,
    "explanation": "CRDTs: data structures para replicação sem conflito. State-based (CvRDT): envia estado completo, merge com lattice join. Operation-based (CmRDT): envia operações comutativas. Exemplos: G-Counter (incremento), LWW-Register (last writer wins), OR-Set. Strong Eventual Consistency: réplicas que receberam mesmas updates convergem sem coordenação. Usado em: Google Docs, Figma, Redis CRDTs.",
    "example": "G-Counter 3 nós: A=[1,0,0], B=[0,2,0], C=[0,0,1]. A incrementa: A=[2,0,0]. B recebe de A: merge([0,2,0],[2,0,0])=[2,2,0]. Valor=4. Merge comutativo e idempotente → ordem não importa → convergência garantida. Figma usa CRDT para posição de objetos no canvas colaborativo."
  },
  {
    "id": "desenvolvimento__Arquitetura de Software__Difícil__11",
    "track": "desenvolvimento",
    "category": "Arquitetura de Software",
    "difficulty": "Difícil",
    "question": "O que é o padrão Bulkhead e como previne falhas em cascata em arquiteturas de microsserviços?",
    "options": [
      "Isola recursos (threads, conexões) em pools separados por funcionalidade; falha de um componente não esgota recursos dos outros",
      "Cria réplicas redundantes de cada serviço para failover automático",
      "Implementa retry com backoff exponencial em todas as chamadas entre serviços",
      "Monitora health checks e remove serviços defeituosos do load balancer"
    ],
    "correctIndex": 0,
    "explanation": "Bulkhead: inspirado em compartimentos estanques de navios. Se um inunda, outros ficam intactos. Em software: isola pools de recursos. Sem bulkhead: pool único de 100 threads — se API-A travar, todas bloqueadas, APIs B e C param. Com bulkhead: pool-A=30, pool-B=30, pool-C=30, reserva=10. API-A trava → 30 threads afetadas; B e C normais. Implementações: Resilience4j, Polly.",
    "example": "E-commerce: pool-pagamento=20 threads (Stripe), pool-frete=10 (Correios API), pool-recomendação=5 (ML). Correios fora: 10 threads pendentes mas pagamento continua com suas 20. Sem bulkhead: 100 threads compartilhadas, Correios consome todas → checkout inteiro para."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__1",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "Qual comando SQL é usado para buscar dados de uma tabela filtrando por uma condição específica?",
    "options": [
      "SELECT ... WHERE",
      "INSERT INTO",
      "CREATE TABLE",
      "DROP TABLE"
    ],
    "correctIndex": 0,
    "explanation": "O comando SELECT com cláusula WHERE permite buscar registros de uma tabela que atendam a uma condição. WHERE filtra as linhas antes de retornar o resultado.",
    "example": "SELECT nome, email FROM usuarios WHERE idade >= 18; — retorna nome e email de todos os usuários com 18 anos ou mais."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__2",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "Qual comando SQL é usado para inserir um novo registro em uma tabela?",
    "options": [
      "INSERT INTO",
      "SELECT",
      "UPDATE",
      "CREATE TABLE"
    ],
    "correctIndex": 0,
    "explanation": "O comando INSERT INTO adiciona uma nova linha à tabela especificada. Pode inserir valores explícitos ou dados vindos de um SELECT (INSERT INTO...SELECT). A ordem dos valores deve corresponder à ordem das colunas especificadas.",
    "example": "INSERT INTO usuarios (nome, email, idade) VALUES ('Ana Silva', 'ana@email.com', 28); — insere um novo registro na tabela usuarios."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__3",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "O que é uma chave primária (PRIMARY KEY) em SQL?",
    "options": [
      "Coluna ou conjunto de colunas que identifica cada registro de forma única",
      "Senha de acesso ao banco",
      "Tipo de índice para buscas",
      "Chave de criptografia"
    ],
    "correctIndex": 0,
    "explanation": "A PRIMARY KEY garante que cada registro na tabela seja único e não nulo. Normalmente é uma coluna 'id' com auto-incremento (SERIAL no PostgreSQL, AUTO_INCREMENT no MySQL). Uma tabela só pode ter uma PRIMARY KEY, mas ela pode ser composta (múltiplas colunas).",
    "example": "CREATE TABLE usuarios (id SERIAL PRIMARY KEY, nome VARCHAR(100), email VARCHAR(255) UNIQUE); — 'id' é chave primária auto-incrementada."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__4",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "O que é uma chave estrangeira (Foreign Key) em SQL?",
    "options": [
      "Coluna que referencia a chave primária de outra tabela, criando um relacionamento entre elas",
      "Chave de criptografia do banco",
      "Senha do administrador",
      "Tipo de índice"
    ],
    "correctIndex": 0,
    "explanation": "Foreign Key cria um relacionamento entre tabelas. Garante integridade referencial: o valor da FK deve existir na tabela referenciada. CASCADE delete/update pode propagar alterações. Implementa relações 1:N e N:M (via tabela associativa).",
    "example": "CREATE TABLE pedidos (id SERIAL PRIMARY KEY, usuario_id INTEGER REFERENCES usuarios(id) ON DELETE CASCADE); — cada pedido pertence a um usuário. Deletar usuário deleta seus pedidos."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__5",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre os comandos SQL SELECT, INSERT, UPDATE e DELETE?",
    "options": [
      "SELECT lê dados, INSERT cria, UPDATE modifica e DELETE remove registros",
      "Todos modificam dados",
      "SELECT e INSERT são idênticos",
      "DELETE apaga a tabela inteira"
    ],
    "correctIndex": 0,
    "explanation": "CRUD em SQL: SELECT (Read) busca dados. INSERT (Create) adiciona registros. UPDATE (Update) modifica registros existentes. DELETE (Delete) remove registros. WHERE filtra quais registros são afetados pelo UPDATE/DELETE.",
    "example": "INSERT INTO usuarios (nome) VALUES ('Ana'); SELECT * FROM usuarios WHERE nome='Ana'; UPDATE usuarios SET nome='Ana Silva' WHERE id=1; DELETE FROM usuarios WHERE id=1;"
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__6",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "O que faz o comando GROUP BY em SQL?",
    "options": [
      "Agrupa registros com valores iguais para aplicar funções de agregação como COUNT, SUM, AVG",
      "Ordena os resultados por coluna",
      "Filtra registros duplicados",
      "Cria índices automáticos"
    ],
    "correctIndex": 0,
    "explanation": "GROUP BY agrupa linhas que têm os mesmos valores na(s) coluna(s) especificada(s). Usado com funções de agregação: COUNT (contar), SUM (somar), AVG (média), MIN, MAX. HAVING filtra os grupos (como WHERE para grupos).",
    "example": "SELECT departamento, COUNT(*) as total FROM funcionarios GROUP BY departamento HAVING COUNT(*) > 5; — conta funcionários por departamento, mostrando só os com mais de 5."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__7",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "O que é NULL em SQL e como se compara valores nulos?",
    "options": [
      "NULL representa ausência de valor; comparação usa IS NULL e IS NOT NULL, não = ou !=",
      "NULL é igual a zero",
      "NULL é uma string vazia",
      "NULL é comparado com = normalmente"
    ],
    "correctIndex": 0,
    "explanation": "NULL em SQL não é zero nem string vazia — é ausência de valor. Qualquer operação com NULL resulta em NULL (ex: 5 + NULL = NULL). Comparações com = ou != com NULL sempre resultam em UNKNOWN (nem TRUE nem FALSE). Usar IS NULL / IS NOT NULL.",
    "example": "SELECT * FROM usuarios WHERE telefone IS NULL; — retorna usuários sem telefone. WHERE telefone = NULL NÃO funciona (retorna 0 resultados, sempre). COALESCE(telefone, 'N/A') retorna 'N/A' se NULL."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__8",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "O que faz a cláusula GROUP BY em SQL e como o HAVING a complementa?",
    "options": [
      "GROUP BY agrupa linhas com valores iguais permitindo funções de agregação por grupo; HAVING filtra grupos (como WHERE mas para grupos)",
      "GROUP BY ordena resultado por coluna; HAVING ordena grupos",
      "Ambos filtram linhas antes de qualquer agrupamento",
      "GROUP BY cria subgrupos temporários; HAVING os nomeia"
    ],
    "correctIndex": 0,
    "explanation": "GROUP BY agrupa linhas com mesmo valor, usada com COUNT(), SUM(), AVG(), MAX(), MIN(). WHERE filtra linhas antes do agrupamento. HAVING filtra grupos após agrupamento (pode usar funções de agregação). Ordem: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY.",
    "example": "SELECT departamento, COUNT(*) as total, AVG(salario) as media FROM funcionarios WHERE ativo=1 GROUP BY departamento HAVING COUNT(*) > 5 ORDER BY media DESC — departamentos ativos com mais de 5 funcionários, ordenados por salário médio."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__9",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "O que é uma FOREIGN KEY e como o ON DELETE CASCADE se comporta?",
    "options": [
      "Coluna que referencia a PK de outra tabela garantindo integridade referencial; ON DELETE CASCADE deleta automaticamente os registros filhos ao deletar o pai",
      "Segundo índice de uma tabela para melhorar performance de joins",
      "Restrição de unicidade composta por múltiplas colunas da mesma tabela",
      "Chave criptográfica para segurança dos dados relacionados"
    ],
    "correctIndex": 0,
    "explanation": "Foreign Key: garante integridade referencial — impossível ter pedido de cliente inexistente. ON DELETE CASCADE: ao deletar pai, filhos são deletados automaticamente. ON DELETE RESTRICT (padrão): bloqueia deleção se houver filhos. ON DELETE SET NULL: seta FK para NULL nos filhos. ON DELETE NO ACTION: similar ao RESTRICT mas verificado ao final da transação.",
    "example": "Deletar cliente com pedidos: ON DELETE RESTRICT → ERRO. ON DELETE CASCADE → cliente + todos seus pedidos deletados. ON DELETE SET NULL → pedidos ficam com cliente_id = NULL. Muito comum em relacionamentos pai-filho: blog (posts cascadeiam comments)."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__10",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "O que é uma subquery (subconsulta) em SQL e em quais cláusulas ela pode ser utilizada?",
    "options": [
      "Query aninhada dentro de outra; pode ser usada em WHERE, FROM, SELECT e HAVING para filtrar, calcular ou gerar conjuntos intermediários",
      "Função que cria tabela temporária permanente no banco de dados",
      "Comando para executar múltiplas queries em paralelo",
      "Procedure que aceita parâmetros e retorna resultados"
    ],
    "correctIndex": 0,
    "explanation": "Subquery: SELECT dentro de outro SELECT. Em WHERE: filtro dinâmico. Em FROM: tabela derivada. Em SELECT: valor calculado por row. Tipos: escalar (1 valor), tabela (múltiplas rows). Correlacionada: referencia tabela externa (executa para cada row). EXISTS: testa se subquery retorna resultados. CTEs (WITH) são alternativa mais legível.",
    "example": "Funcionários com salário acima da média: SELECT name FROM employees WHERE salary > (SELECT AVG(salary) FROM employees). Correlacionada: SELECT * FROM departments d WHERE (SELECT COUNT(*) FROM employees e WHERE e.dept_id = d.id) > 5 — executa subquery para cada departamento."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Fácil__11",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Fácil",
    "question": "O que é a cláusula ORDER BY em SQL e como combinar com LIMIT para obter os top-N resultados?",
    "options": [
      "ORDER BY ordena o resultado por colunas (ASC/DESC); LIMIT restringe o número de linhas — juntos permitem consultar os N primeiros ou últimos registros",
      "ORDER BY filtra registros por condição; LIMIT define número máximo de colunas",
      "ORDER BY agrupa registros semelhantes; LIMIT define tamanho de cada grupo",
      "ORDER BY cria índice temporário; LIMIT impede que o índice cresça demais"
    ],
    "correctIndex": 0,
    "explanation": "ORDER BY: ordena resultado. ASC (crescente, padrão), DESC (decrescente). Múltiplas colunas: ORDER BY dept ASC, salary DESC. LIMIT (MySQL/PostgreSQL) ou TOP (SQL Server): restringe rows. OFFSET: pula N rows para paginação. Performance: sem índice, faz filesort (lento). Com índice na coluna de ordenação: mais eficiente.",
    "example": "Top 5 salários: SELECT name, salary FROM employees ORDER BY salary DESC LIMIT 5. Paginação: SELECT * FROM products ORDER BY id LIMIT 20 OFFSET 40 — página 3. SQL Server: SELECT TOP 5 name, salary FROM employees ORDER BY salary DESC."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__1",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "Qual é a diferença entre INNER JOIN e LEFT JOIN em SQL?",
    "options": [
      "INNER JOIN retorna apenas registros com correspondência em ambas tabelas; LEFT JOIN retorna todos da tabela esquerda",
      "LEFT JOIN é mais rápido",
      "INNER JOIN permite NULL e LEFT JOIN não",
      "Não há diferença funcional"
    ],
    "correctIndex": 0,
    "explanation": "INNER JOIN retorna apenas as linhas que têm correspondência nas duas tabelas. LEFT JOIN retorna todas as linhas da tabela da esquerda, preenchendo com NULL os campos da tabela da direita quando não há correspondência.",
    "example": "SELECT u.nome, p.titulo FROM usuarios u LEFT JOIN posts p ON u.id = p.user_id — retorna todos os usuários, inclusive os que não têm posts (titulo será NULL)."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__2",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que são índices (INDEX) em SQL e como eles melhoram performance?",
    "options": [
      "Estruturas que aceleram buscas criando um acesso rápido aos dados sem varrer toda a tabela",
      "Cópias da tabela em memória",
      "Backups automáticos",
      "Tipos de chave primária"
    ],
    "correctIndex": 0,
    "explanation": "Índices criam estruturas auxiliares (geralmente B-trees) que permitem localizar registros rapidamente sem full table scan. Aceleram SELECTs com WHERE e JOINs, mas tornam INSERTs/UPDATEs um pouco mais lentos porque o índice precisa ser atualizado.",
    "example": "CREATE INDEX idx_email ON usuarios(email); — SELECT * FROM usuarios WHERE email = 'ana@email.com' agora usa o índice (~0.1ms) em vez de varrer 1M de linhas (~500ms)."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__3",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que são as propriedades ACID em um banco de dados?",
    "options": [
      "Atomicity, Consistency, Isolation, Durability — garantias de integridade transacional",
      "Tipos de dados SQL",
      "Níveis de acesso",
      "Proto col de rede"
    ],
    "correctIndex": 0,
    "explanation": "ACID: Atomicity (transação é tudo ou nada), Consistency (banco vai de um estado válido para outro), Isolation (transações concorrentes não interferem entre si), Durability (dados confirmados persistem mesmo após falha). Bancos relacionais como PostgreSQL e MySQL garantem ACID por padrão.",
    "example": "Transferência bancária (Atomicity): BEGIN; UPDATE contas SET saldo = saldo - 100 WHERE id = 1; UPDATE contas SET saldo = saldo + 100 WHERE id = 2; COMMIT; — se qualquer UPDATE falhar, ambos são desfeitos."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__4",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que é um índice (INDEX) em SQL e como melhora a performance?",
    "options": [
      "Estrutura que acelera buscas criando uma referência ordenada aos dados, como índice de livro",
      "Cópia de backup da tabela",
      "Cache de queries",
      "Tipo de VIEW"
    ],
    "correctIndex": 0,
    "explanation": "Índice cria estrutura (B-tree, hash) que permite buscar registros sem percorrer toda a tabela (full scan). SELECT com WHERE em coluna indexada: O(log n) ao invés de O(n). Trade-off: INSERT/UPDATE ficam mais lentos pois o índice precisa ser atualizado.",
    "example": "Tabela com 10M registros, busca por email sem índice: 5s (full scan). CREATE INDEX idx_email ON usuarios(email); mesma busca: 5ms. 1000x mais rápido."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__5",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que são JOINs em SQL e qual a diferença entre INNER JOIN e LEFT JOIN?",
    "options": [
      "INNER retorna só registros com correspondência em ambas tabelas; LEFT retorna todos da esquerda",
      "São idênticos",
      "LEFT JOIN é mais rápido",
      "INNER JOIN retorna mais resultados"
    ],
    "correctIndex": 0,
    "explanation": "INNER JOIN: retorna apenas linhas que têm correspondência em ambas as tabelas. LEFT JOIN: retorna TODAS as linhas da tabela à esquerda, com NULL onde não há correspondência na direita. RIGHT JOIN: o oposto. FULL OUTER: tudo de ambas.",
    "example": "usuarios LEFT JOIN pedidos: retorna todos os usuários, mesmo os sem pedidos (pedido_id = NULL). INNER JOIN: retornaria apenas usuários COM pedidos."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__6",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que é uma subquery (subconsulta) em SQL e quando usá-la?",
    "options": [
      "SELECT aninhado dentro de outro SELECT, usado para filtrar ou calcular valores dinamicamente",
      "Query que roda em outro banco de dados",
      "Query agendada para execução futura",
      "Backup parcial de uma tabela"
    ],
    "correctIndex": 0,
    "explanation": "Subquery é um SELECT dentro de outro comando SQL. Pode ser usada no WHERE (filtro), FROM (derived table), SELECT (valor escalar) ou EXISTS. Subqueries correlacionadas (referenciam a query externa) podem ser ineficientes; considerar JOINs como alternativa.",
    "example": "SELECT nome FROM usuarios WHERE id IN (SELECT user_id FROM pedidos WHERE valor > 1000); — retorna nomes de usuários que fizeram pedidos acima de R$1000. A subquery filtra os IDs primeiro."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__7",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que é uma VIEW em SQL e quando utilizá-la?",
    "options": [
      "Consulta salva como tabela virtual que pode ser referenciada como se fosse uma tabela real",
      "Cópia física dos dados em outra tabela",
      "Tipo de índice para consultas",
      "Backup automático de tabela"
    ],
    "correctIndex": 0,
    "explanation": "VIEW é uma query SELECT nomeada e salva no banco. Não armazena dados (apenas a definição). Ao consultar a VIEW, o banco executa a query subjacente. Vantagens: simplificar queries complexas, controlar acesso (expor apenas colunas necessárias), abstrair JOINs.",
    "example": "CREATE VIEW pedidos_resumo AS SELECT u.nome, COUNT(p.id) as total_pedidos, SUM(p.valor) as total_gasto FROM usuarios u JOIN pedidos p ON u.id = p.user_id GROUP BY u.nome; — depois: SELECT * FROM pedidos_resumo WHERE total_gasto > 5000;"
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__8",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que é normalização e o que a Terceira Forma Normal (3NF) requer?",
    "options": [
      "3NF: tabela está na 2NF (sem dependências parciais da PK) e sem dependências transitivas entre atributos não-chave",
      "3NF: todas as colunas são indexadas e não contêm valores nulos",
      "3NF: tabela sem grupos repetitivos e com chave primária simples",
      "3NF: nenhum atributo multivalorado e sem relacionamentos recursivos"
    ],
    "correctIndex": 0,
    "explanation": "1NF: sem grupos repetitivos, valores atômicos. 2NF: sem dependências parciais (todos atributos dependem da PK completa). 3NF: sem dependências transitivas (A→B→C onde B não é chave). Elimina anomalias de insert/update/delete. BCNF: versão mais rígida da 3NF. Desnormalização intencional melhora leitura ao custo de redundância.",
    "example": "Tabela: CodPedido, CodCliente, CidadeCliente, PaisCliente. Problema transitivo: CodCliente→Cidade→País. 3NF: separar em Pedidos(CodPedido, CodCliente) e Clientes(CodCliente, Cidade, País). Atualizar cidade de cliente: 1 lugar, não n pedidos."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__9",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "Qual a diferença entre INNER JOIN, LEFT JOIN e FULL OUTER JOIN no SQL?",
    "options": [
      "INNER: apenas registros com match em ambas as tabelas; LEFT: todos à esquerda + match à direita (NULL se sem match); FULL OUTER: todos de ambas as tabelas com NULL onde não há correspondência",
      "INNER retorna todos os registros; LEFT somente da tabela esquerda; FULL duplica linhas com match",
      "LEFT e RIGHT são equivalentes ao INNER; FULL é a intersecção das tabelas",
      "INNER é o join mais lento; LEFT e FULL têm melhor performance sempre"
    ],
    "correctIndex": 0,
    "explanation": "INNER JOIN: intersecção — linhas presentes em AMBAS as tabelas. LEFT JOIN: todos da esquerda + dados da direita (NULL se sem match) — útil para listar clientes sem pedidos. RIGHT JOIN: oposto. FULL OUTER JOIN: união de LEFT + RIGHT — todos os registros de ambas as tabelas, NULL onde sem correspondência.",
    "example": "Clientes (A, B, C) e Pedidos (A, D). INNER → somente A (match). LEFT clientes → A(com pedido), B(NULL), C(NULL). FULL OUTER → A(pedido), B(NULL), C(NULL) + D(NULL cliente). Relatório 'clientes sem pedido': LEFT JOIN WHERE pedidos.id IS NULL."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__10",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que é um trigger em SQL e em quais cenários seu uso é apropriado ou deve ser evitado?",
    "options": [
      "Bloco de código executado automaticamente em INSERT/UPDATE/DELETE; útil para auditoria e integridade, mas pode causar efeitos colaterais difíceis de rastrear",
      "Comando manual do DBA para limpar dados inconsistentes em massa",
      "Índice especial que acelera queries com condições complexas",
      "Procedure agendada via cron para executar em horários específicos"
    ],
    "correctIndex": 0,
    "explanation": "Trigger: código que executa automaticamente BEFORE ou AFTER DML. INSTEAD OF: substitui operação (em views). Usos legítimos: audit log (quem alterou, quando), campos calculados, validação complexa. Evitar: lógica de negócio complexa (difícil debugar, cascata de triggers). Alternativas modernas: CDC (Debezium), eventos na aplicação.",
    "example": "CREATE TRIGGER audit_salary AFTER UPDATE ON employees FOR EACH ROW INSERT INTO salary_audit(emp_id,old_salary,new_salary,changed_at) VALUES(OLD.id,OLD.salary,NEW.salary,NOW()); — cada UPDATE registra antes/depois. Cuidado: UPDATE em 10K rows = 10K inserts na audit."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Médio__11",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Médio",
    "question": "O que é connection pooling em bancos de dados e por que é essencial para aplicações em produção?",
    "options": [
      "Reutilização de conexões pré-estabelecidas em vez de abrir/fechar a cada request; reduz overhead de handshake TCP/SSL e limita conexões simultâneas",
      "Replicação de dados entre servidores para alta disponibilidade",
      "Cache de queries frequentes na memória do servidor de aplicação",
      "Balanceamento de carga entre múltiplas instâncias de banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "Sem pool: cada request abre conexão (TCP+auth+SSL ~20-50ms) → query → fecha. 1000 req/s = 1000 conexões, esgota max_connections. Com pool: N conexões pré-abertas; request pega do pool → query → devolve. Configuração: min_pool, max_pool, idle_timeout. Ferramentas: PgBouncer, HikariCP (Java), Prisma pool.",
    "example": "Node pg pool: const pool = new Pool({min:5, max:20}); await pool.query('SELECT * FROM users WHERE id=$1',[id]). 100 requests: 20 executam, 80 aguardam na fila. Sem pool: 100 conexões TCP abertas/fechadas + risco de esgotar max_connections (PostgreSQL default: 100)."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__1",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que é um deadlock em banco de dados e como o SGBD tipicamente o resolve?",
    "options": [
      "Duas transações bloqueiam-se mutuamente; o SGBD aborta uma delas (vítima) para liberar a outra",
      "Duas transações leem o mesmo dado simultaneamente",
      "Uma query demora mais que o timeout",
      "O banco fica sem espaço em disco"
    ],
    "correctIndex": 0,
    "explanation": "Deadlock ocorre quando duas transações esperam uma pela outra: T1 bloqueia recurso A e espera B, enquanto T2 bloqueia B e espera A. O SGBD detecta o ciclo de espera e escolhe uma 'vítima' (geralmente a transação com menor custo) para fazer rollback, liberando seus locks.",
    "example": "T1: UPDATE contas SET saldo=100 WHERE id=1 (lock em id=1), depois UPDATE contas SET saldo=200 WHERE id=2 (espera lock em id=2). T2: UPDATE contas SET saldo=300 WHERE id=2 (lock em id=2), depois UPDATE contas SET saldo=400 WHERE id=1 (espera lock em id=1). Deadlock! SGBD aborta T2."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__2",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que é um Execution Plan (EXPLAIN) e como ele ajuda a otimizar queries?",
    "options": [
      "Mostra o plano que o banco usará para executar a query, revelando se usa índices ou full scan",
      "Executa a query mais rápido",
      "Cria índices automaticamente",
      "Backup do resultado da query"
    ],
    "correctIndex": 0,
    "explanation": "EXPLAIN mostra como o optimizer do banco planeja executar a query: se fará Sequential Scan (varredura completa) ou Index Scan, quantas linhas estima processar, ordem de JOINs e custo estimado. EXPLAIN ANALYZE executa de fato e mostra tempos reais. Essencial para identificar queries lentas.",
    "example": "EXPLAIN ANALYZE SELECT * FROM pedidos WHERE status = 'pendente'; → Se mostrar Seq Scan com 1M rows e 500ms, crie índice: CREATE INDEX idx_status ON pedidos(status); → Index Scan com 50 rows e 0.5ms."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__3",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que são níveis de isolamento de transações SQL e quais problemas cada nível previne?",
    "options": [
      "Read Uncommitted, Read Committed, Repeatable Read e Serializable — previnem dirty reads, non-repeatable reads e phantom reads progressivamente",
      "São tipos de lock",
      "São tipos de índice",
      "São tipos de JOIN"
    ],
    "correctIndex": 0,
    "explanation": "Read Uncommitted: permite dirty reads. Read Committed (padrão PostgreSQL): previne dirty reads. Repeatable Read: previne dirty + non-repeatable reads. Serializable: previne todos, incluindo phantom reads, mas com menor concorrência. Trade-off: mais isolamento = menos performance.",
    "example": "Dirty read: T1 lê dado não commitado de T2 (que pode dar rollback). Non-repeatable: T1 lê um dado, T2 altera e commita, T1 lê novamente e vê valor diferente. Phantom: T1 conta rows, T2 insere nova row, T1 conta novamente e vê número diferente."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__4",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que é normalização de banco de dados e qual o objetivo das formas normais?",
    "options": [
      "Processo de organizar dados para eliminar redundância e dependências parciais",
      "Compressão de dados",
      "Criptografia de tabelas",
      "Backup incremental"
    ],
    "correctIndex": 0,
    "explanation": "Normalização: 1NF (eliminar grupos repetidos), 2NF (eliminar dependências parciais da PK), 3NF (eliminar dependências transitivas). Reduz redundância, melhora integridade. Desnormalização: adicionar redundância intencionalmente para performance de leitura.",
    "example": "Não normalizado: pedidos(id, cliente_nome, cliente_email, produto). Normalizado: pedidos(id, cliente_id, produto_id) + clientes(id, nome, email) + produtos(id, nome). Atualizar email do cliente: 1 lugar só."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__5",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que é uma stored procedure e quando usá-la?",
    "options": [
      "Função armazenada no banco que encapsula lógica SQL reutilizável",
      "Backup automático do banco",
      "Tipo de índice",
      "Driver de conexão"
    ],
    "correctIndex": 0,
    "explanation": "Stored procedures são blocos de SQL armazenados no banco, executados com CALL/EXEC. Vantagens: reutilização, performance (compilada), segurança (acesso controlado). Desvantagens: lógica de negócio no banco, difícil versionar, vendor lock-in.",
    "example": "CREATE PROCEDURE transfer(from_id INT, to_id INT, amount DECIMAL) BEGIN; UPDATE contas SET saldo = saldo - amount WHERE id = from_id; UPDATE contas SET saldo = saldo + amount WHERE id = to_id; END; CALL transfer(1, 2, 100);"
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__6",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que é particionamento (sharding) de banco de dados e quando aplicá-lo?",
    "options": [
      "Dividir dados de uma tabela em múltiplos servidores usando uma chave de partição para escalar horizontalmente",
      "Replicar dados em servidores de backup",
      "Comprimir tabelas grandes",
      "Criar índices distribuídos"
    ],
    "correctIndex": 0,
    "explanation": "Sharding distribui dados entre múltiplos nós usando uma shard key (ex: user_id % N). Cada shard contém um subconjunto dos dados. Vantagens: escala horizontal de escrita. Desafios: queries cross-shard, rebalanceamento, transações distribuídas, choice de shard key.",
    "example": "Tabela de pedidos com 1 bilhão de registros. Shard key: user_id. Shard 1: users 1-33M. Shard 2: users 33M-66M. Shard 3: users 66M-100M. Query WHERE user_id=42 vai direto ao Shard 1. Query WHERE status='pendente' precisa consultar os 3 shards."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__7",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que são CTEs (Common Table Expressions) e Window Functions em SQL avançado?",
    "options": [
      "CTEs são subconsultas nomeadas com WITH; Window Functions calculam sobre partições sem agrupar linhas",
      "São tipos de stored procedures",
      "São funções de backup incrementais",
      "São extensões NoSQL para bancos relacionais"
    ],
    "correctIndex": 0,
    "explanation": "CTE: WITH nome AS (SELECT ...) SELECT ... FROM nome — cria resultado temporário nomeado, melhora legibilidade. CTEs recursivas permitem hierarquias. Window Functions: ROW_NUMBER(), RANK(), LAG(), LEAD(), SUM() OVER(PARTITION BY ...) — calculam sobre um 'window' de linhas sem colapsar o resultado como GROUP BY.",
    "example": "WITH top_clientes AS (SELECT user_id, SUM(valor) as total FROM pedidos GROUP BY user_id) SELECT u.nome, t.total, RANK() OVER(ORDER BY t.total DESC) as ranking FROM usuarios u JOIN top_clientes t ON u.id = t.user_id; — CTE calcula totais, Window Function rankeia."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__8",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que é um índice parcial em banco de dados e quando é mais eficiente que um índice completo?",
    "options": [
      "Índice criado com cláusula WHERE cobrindo apenas subconjunto de linhas; mais eficiente quando queries sempre filtram esse subconjunto (menor tamanho, manutenção mais rápida)",
      "Índice que cobre apenas algumas colunas de uma tabela de alta cardinalidade",
      "Índice aplicado somente às linhas com valores nulos em determinada coluna",
      "Índice com menos de 50% das linhas da tabela por definição de seletividade"
    ],
    "correctIndex": 0,
    "explanation": "Índice parcial (PostgreSQL/SQLite): CREATE INDEX ... WHERE condição. Indexa apenas linhas que satisfazem a condição. Vantagens: menor tamanho em disco, manutenção mais rápida em INSERTs/UPDATEs, estatísticas mais precisas. Planner usa o índice apenas quando a query inclui o predicado. Ideal quando subset de dados é muito menor que o total.",
    "example": "Tabela pedidos com 1M linhas: 99% status='concluido', 1% status='pendente'. Queries sempre em pendentes. CREATE INDEX idx_pendentes ON pedidos(criado_em) WHERE status='pendente' — indexa 10k linhas, não 1M. Consulta pedidos pendentes usa índice 100× menor. Manutenção: INSERT de pedido concluído não toca o índice."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__9",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que são os níveis de isolamento de transações SQL e quais anomalias cada um previne?",
    "options": [
      "READ UNCOMMITTED: sem proteção; READ COMMITTED: previne dirty read; REPEATABLE READ: +non-repeatable read; SERIALIZABLE: +phantom reads (protecão máxima)",
      "Todos os níveis garantem isolamento total; diferença é apenas na performance",
      "SERIALIZABLE é o único nível com garantias reais; os outros são equivalentes",
      "READ COMMITTED previne todas as anomalias exceto deadlock entre transações"
    ],
    "correctIndex": 0,
    "explanation": "Anomalias: Dirty Read (ler dados não commitados de outra txn), Non-Repeatable Read (mesma query retorna valores diferentes dentro da txn — UPDATE por outra txn), Phantom Read (nova query retorna linhas diferentes — INSERT/DELETE por outra txn). READ UNCOMMITTED: nenhuma proteção. READ COMMITTED: evita dirty read (padrão PostgreSQL). REPEATABLE READ: evita dirty + non-repeatable (padrão MySQL/InnoDB). SERIALIZABLE: máxima proteção, menor concorrência.",
    "example": "T1 lê saldo=1000 em READ COMMITTED. T2 atualiza para 900 e commita. T1 lê novamente: 900 (non-repeatable read). REPEATABLE READ: T1 sempre vê 1000 até commitar. SERIALIZABLE: bloqueia T2 de modificar enquanto T1 está ativa. Trade-off: mais isolamento = menos throughput."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__10",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que é MVCC (Multi-Version Concurrency Control) e como permite leituras sem bloqueio em bancos de dados?",
    "options": [
      "Mantém múltiplas versões de cada registro; leituras acessam snapshot consistente sem bloquear escritas — cada transação vê a versão válida no seu timestamp",
      "Usa locks de leitura compartilhados para múltiplas leituras simultâneas bloqueando escritas",
      "Replica dados para servidores de leitura dedicados enquanto o primário processa escritas",
      "Armazena dados em cache na memória para evitar acesso ao disco"
    ],
    "correctIndex": 0,
    "explanation": "MVCC: UPDATE não sobrescreve — cria nova versão com novo timestamp. Leituras usam snapshot: veem versão mais recente visível no início da transação. Readers não bloqueiam writers, writers não bloqueiam readers. PostgreSQL: xmin/xmax por tuple, VACUUM limpa versões antigas. MySQL InnoDB: undo log. READ COMMITTED: snapshot por statement; REPEATABLE READ: snapshot por TX.",
    "example": "TX1 (t=100): SELECT balance FROM accounts WHERE id=1 → vê 1000 (versão t=90). TX2 (t=101): UPDATE SET balance=500; COMMIT → cria versão t=101. TX1 (ativa): SELECT novamente → ainda vê 1000 (REPEATABLE READ, snapshot t=100). TX1 nunca bloqueada por TX2."
  },
  {
    "id": "desenvolvimento__Banco de Dados SQL__Difícil__11",
    "track": "desenvolvimento",
    "category": "Banco de Dados SQL",
    "difficulty": "Difícil",
    "question": "O que são índices compostos em SQL e como a ordem das colunas afeta quais queries se beneficiam?",
    "options": [
      "Índice sobre múltiplas colunas; segue a regra do prefixo mais à esquerda — só é usado se a query filtra pelas colunas na mesma ordem a partir da primeira",
      "Índice que combina dois índices simples automaticamente em runtime",
      "Índice que armazena resultado de funções aplicadas às colunas",
      "Índice especial para queries com OR que une resultados de múltiplos índices"
    ],
    "correctIndex": 0,
    "explanation": "Índice composto: CREATE INDEX idx ON orders(customer_id, status, created_at). B-tree ordena: primeiro customer_id → status → created_at. Regra do prefixo: usado se query filtra (customer_id), (customer_id, status) ou (customer_id, status, created_at). NÃO usado se filtrar só por (status) ou (created_at). Covering index: se colunas do SELECT estão no índice, index-only scan (sem acesso à tabela).",
    "example": "INDEX idx ON orders(customer_id, status, created_at). ✓ WHERE customer_id=5 — usa. ✓ WHERE customer_id=5 AND status='paid' — usa. ✓ Todas as 3 — usa totalmente. ✗ WHERE status='paid' — não usa. ✗ WHERE created_at>'2024-01-01' — não usa. Solução: criar índice separado em (status)."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__1",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "Qual tipo de banco de dados NoSQL armazena dados como documentos JSON flexíveis, sem esquema rígido?",
    "options": [
      "Banco de documentos (ex.: MongoDB)",
      "Banco relacional (ex.: PostgreSQL)",
      "Banco de grafos (ex.: Neo4j)",
      "Banco colunar (ex.: Cassandra)"
    ],
    "correctIndex": 0,
    "explanation": "Bancos de documentos como MongoDB armazenam dados como documentos JSON/BSON. Cada documento pode ter estrutura diferente (schema-less), permitindo campos variáveis. Ideal para dados semi-estruturados e desenvolvimento ágil.",
    "example": "db.usuarios.insertOne({ nome: 'Ana', idade: 28, hobbies: ['leitura', 'yoga'] }) — o campo 'hobbies' é um array e outro documento pode não ter esse campo."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__2",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "Qual tipo de banco NoSQL é otimizado para armazenar e consultar relações complexas entre entidades, como redes sociais?",
    "options": [
      "Banco de grafos (ex.: Neo4j)",
      "Banco de documentos (ex.: MongoDB)",
      "Banco chave-valor (ex.: Redis)",
      "Banco colunar (ex.: Cassandra)"
    ],
    "correctIndex": 0,
    "explanation": "Bancos de grafos armazenam nós (entidades) e arestas (relações) de forma nativa, permitindo queries de relacionamento eficientes. Ideal para redes sociais, grafos de conhecimento, detecção de fraude e recomendações.",
    "example": "Neo4j: MATCH (u:User)-[:FOLLOWS]->(friend)-[:LIKES]->(movie) WHERE u.name = 'Ana' RETURN movie.title — encontra filmes que amigos da Ana curtiram, percorrendo o grafo."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__3",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "Para que serve o Redis e qual é sua principal característica?",
    "options": [
      "Banco chave-valor em memória, extremamente rápido, usado para cache e sessões",
      "Banco SQL completo",
      "Banco de documentos como MongoDB",
      "Ferramenta de backup"
    ],
    "correctIndex": 0,
    "explanation": "Redis armazena dados em memória RAM (in-memory), oferecendo latência sub-milissegundo. Suporta estruturas: strings, hashes, listas, sets, sorted sets. Usado como cache, session store, fila de mensagens, rate limiter e leaderboard. Persistência opcional via RDB/AOF.",
    "example": "// Cache de query custosa:\nawait redis.setex('user:42', 3600, JSON.stringify(userData)); // TTL 1h\nconst cached = await redis.get('user:42'); // <1ms vs ~50ms no banco."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__4",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "Qual a principal diferença entre um banco de dados relacional (SQL) e um NoSQL?",
    "options": [
      "SQL usa tabelas com esquema fixo; NoSQL usa modelos flexíveis (documentos, chave-valor, grafo)",
      "NoSQL é sempre mais rápido",
      "SQL não suporta relações",
      "NoSQL não pode armazenar dados"
    ],
    "correctIndex": 0,
    "explanation": "SQL (relacional): tabelas com esquema rígido, JOINs, ACID, SQL como linguagem. NoSQL: modelo flexível (documentos, chave-valor, colunar, grafo), escala horizontal, schema-less. SQL melhor para dados relacionais; NoSQL para dados semi-estruturados e alta escala.",
    "example": "Usuários com endereços: SQL — tabela usuarios + tabela enderecos (JOIN). MongoDB — um documento { nome: 'Ana', enderecos: [{rua: 'A'}] } com tudo embutido."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__5",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "O que é o MongoDB e qual seu modelo de dados?",
    "options": [
      "Banco NoSQL orientado a documentos que armazena dados em formato BSON (similar a JSON)",
      "Banco relacional",
      "Banco de grafos",
      "Banco chave-valor"
    ],
    "correctIndex": 0,
    "explanation": "MongoDB armazena documentos BSON (Binary JSON) em coleções (equivalente a tabelas). Schema flexível: documentos na mesma coleção podem ter campos diferentes. Queries via MQL (MongoDB Query Language). Suporta índices, agregação, replicação e sharding.",
    "example": "db.users.insertOne({ name: 'Ana', age: 28, hobbies: ['coding', 'music'] }); db.users.find({ age: { $gte: 18 } }); — schema flexível, sem migrations."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__6",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "O que é uma coleção (collection) em bancos de documentos como MongoDB?",
    "options": [
      "Agrupamento de documentos equivalente a uma tabela em bancos relacionais, mas sem esquema fixo",
      "Arquivo de backup do banco",
      "Tipo de índice",
      "Linguagem de consulta"
    ],
    "correctIndex": 0,
    "explanation": "Em MongoDB, uma coleção é um grupo de documentos. Diferente de tabelas SQL, não exige que todos os documentos tenham a mesma estrutura (schema-less). Coleções são criadas automaticamente ao inserir o primeiro documento. Análogo: banco SQL (database) → tabela (collection) → linha (document).",
    "example": "db.createCollection('usuarios'); // ou simplesmente: db.usuarios.insertOne({ nome: 'Ana' }); — a coleção 'usuarios' é criada automaticamente na primeira inserção."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__7",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre bancos chave-valor e bancos de documentos?",
    "options": [
      "Chave-valor armazena dados opacos acessados por chave; documentos armazenam JSON estruturado com queries em campos internos",
      "São idênticos",
      "Chave-valor é mais lento",
      "Documentos não suportam JSON"
    ],
    "correctIndex": 0,
    "explanation": "Chave-valor (Redis, DynamoDB): dados são um blob opaco acessado exclusivamente pela chave. Rápido para GET/SET, sem queries em campos internos. Documentos (MongoDB, Firestore): armazena JSON, permite queries em qualquer campo interno (find({ age: { $gt: 18 } })).",
    "example": "Redis: SET user:42 '{\"nome\":\"Ana\"}' → GET user:42 (retorna blob). MongoDB: db.users.find({ nome: 'Ana', idade: { $gte: 18 } }) — consulta por campos internos do documento."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__8",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "Qual é o modelo de dados do MongoDB e o que diferencia BSON de JSON?",
    "options": [
      "MongoDB é orientado a documentos; BSON é Binary JSON com tipos extras como Date, ObjectId, Int64 e dados binários nativos",
      "MongoDB é relacional; BSON é JSON comprimido em Base64",
      "MongoDB é orientado a colunas; BSON é JSON com suporte a XML",
      "MongoDB é chave-valor; BSON é JSON com suporte a tipos genéricos"
    ],
    "correctIndex": 0,
    "explanation": "MongoDB armazena documentos BSON em coleções (análogo a tabelas). BSON estende JSON com tipos: Date (nativo, não string), ObjectId (ID distribuído único de 12 bytes), Int32/Int64/Decimal128, Binary, Regex. Schema flexível: documentos na mesma coleção podem ter campos diferentes. Permite documentos aninhados e arrays nativamente.",
    "example": "Documento: {_id: ObjectId('6af...'), nome: 'Ana', criado: ISODate('2025-01-15'), tags: ['dev', 'js'], endereco: {rua: 'Av Brasil', cep: '01310'}}. ObjectId = timestamp(4)+machine(3)+pid(2)+counter(3). Coleção users pode ter documentos com campos totalmente distintos."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__9",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "Para que o Redis é mais usado e quais estruturas de dados ele suporta nativamente?",
    "options": [
      "Cache em memória e filas; suporta String, List, Hash, Set, Sorted Set (ZSet), Stream e HyperLogLog",
      "Banco de grafos in-memory com vértices e arestas como estruturas nativas",
      "Banco analítico columnar com compressão nativa e alta consulta",
      "Banco de documentos JSON in-memory com índices automáticos"
    ],
    "correctIndex": 0,
    "explanation": "Redis (Remote Dictionary Server): banco in-memory key-value com estruturas ricas. String: cache simples, contadores INCR/DECR. List: fila FIFO/LIFO (LPUSH/RPOP). Hash: objeto com campos (HSET/HGET). Set: conjunto sem duplicatas (SADD/SMEMBERS). Sorted Set: set ordenado por score — leaderboards. Stream: log de eventos. TTL por chave. Persistência: RDB snapshots ou AOF log.",
    "example": "Cache de sessão: SET session:u123 tokenJWT EX 3600. Fila: LPUSH jobs 'email'. Counter: INCR views:home. Leaderboard: ZADD ranking 1500 'playerA'; ZREVRANK ranking 'playerA'. Rate limit: INCR reqs:ip EX 60. Redis Pub/Sub para eventos em tempo real."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__10",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "Quais são os quatro principais tipos de bancos NoSQL e qual o caso de uso ideal de cada um?",
    "options": [
      "Documento (MongoDB), Chave-Valor (Redis), Colunar (Cassandra) e Grafo (Neo4j) — cada um otimizado para padrões de acesso diferentes",
      "Apenas dois tipos existem: documento e chave-valor; os outros são variações SQL",
      "Relacional, Documento, Arquivo e Objeto — todos armazenam dados em tabelas",
      "Texto, Numérico, Binário e Misto — classificados pelo tipo de dado armazenado"
    ],
    "correctIndex": 0,
    "explanation": "1) Documento (MongoDB): JSON flexível, queries ricas. Ideal para catálogos, CMS. 2) Chave-Valor (Redis): acesso por chave, ultra-rápido. Ideal para cache, sessões. 3) Colunar/Wide-Column (Cassandra): escritas massivas. Ideal para IoT, logs, séries temporais. 4) Grafo (Neo4j): nós e arestas. Ideal para redes sociais, recomendações, fraud detection.",
    "example": "Rede social: Neo4j para amigos-de-amigos em 3 níveis (2ms vs minutos em SQL). Cache: Redis SET session:abc '{user:1}' EX 3600. Catálogo: MongoDB — cada produto tem atributos diferentes. IoT logs: Cassandra — 1M escritas/s com replicação multi-datacenter."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Fácil__11",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Fácil",
    "question": "O que é o Redis e quais estruturas de dados ele oferece além de simples chave-valor string?",
    "options": [
      "Banco in-memory que suporta strings, listas, sets, sorted sets, hashes, streams, bitmaps e HyperLogLog",
      "Banco de documentos JSON que suporta apenas strings e números",
      "Cache simples que armazena apenas pares chave-string com expiração",
      "Banco relacional em memória com tabelas, índices e JOINs"
    ],
    "correctIndex": 0,
    "explanation": "Redis: Remote Dictionary Server. In-memory, single-threaded. Estruturas: String (cache, INCR), List (filas, LPUSH/RPOP), Set (unique, SADD), Sorted Set (ranking, ZADD com score), Hash (objetos, HSET/HGET), Stream (event log, XADD), Bitmap (flags, SETBIT), HyperLogLog (contagem aproximada de únicos). Persistência: RDB snapshots + AOF.",
    "example": "Leaderboard: ZADD game:scores 1500 'alice' 1800 'carol'. ZREVRANGE 0 2 WITHSCORES → carol(1800), alice(1500). Sessão: HSET session:abc user_id 1; EXPIRE 3600. Fila: LPUSH queue:emails '{to:ana}'; worker: BRPOP queue:emails 0."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__1",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "No teorema CAP, é impossível que um sistema distribuído garanta simultaneamente quais três propriedades?",
    "options": [
      "Consistency, Availability e Partition Tolerance",
      "Concurrency, Atomicity e Performance",
      "Cache, Authentication e Privacy",
      "Compression, Aggregation e Partitioning"
    ],
    "correctIndex": 0,
    "explanation": "O teorema CAP afirma que um sistema distribuído pode garantir no máximo duas das três propriedades: Consistency (todos os nós veem os mesmos dados), Availability (toda requisição recebe resposta) e Partition Tolerance (funciona mesmo com falhas de rede). Na prática, partições acontecem, então a escolha é entre C e A.",
    "example": "MongoDB (CP): durante partição de rede, o primary pode ficar indisponível até eleger novo primary, garantindo consistência. Cassandra (AP): sempre responde, mas réplicas podem ter dados temporariamente diferentes."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__2",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é eventual consistency e em que cenários ela é aceitável?",
    "options": [
      "Modelo onde réplicas convergem ao mesmo estado eventualmente, sem garantia de leitura imediata do último write",
      "Consistência em tempo real",
      "Backup eventual",
      "Cache invalidation"
    ],
    "correctIndex": 0,
    "explanation": "Na eventual consistency, após um write, réplicas podem retornar dados desatualizados por um breve período até que a propagação se complete. Aceitável para: timeline de redes sociais, contadores de views, feeds de notícias. Inaceitável para: saldo bancário, estoque de produtos.",
    "example": "Ana posta uma foto. Usuários na mesma região veem instantaneamente, mas usuários em outra região podem levar 2-5 segundos para ver. Para um feed social, isso é aceitável."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__3",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é sharding em bancos NoSQL e qual problema ele resolve?",
    "options": [
      "Divisão horizontal de dados entre múltiplos servidores, permitindo escala além de uma única máquina",
      "Backup distribuído",
      "Compressão de dados",
      "Criptografia de dados"
    ],
    "correctIndex": 0,
    "explanation": "Sharding distribui dados entre múltiplos nós usando uma shard key (ex.: hash do userId). Cada shard contém um subconjunto dos dados. Permite escalar horizontalmente: mais dados = mais shards. Desafio: queries que cruzam shards (scatter-gather) são mais lentas.",
    "example": "MongoDB com 3 shards usando userId como shard key: users 1-1M no shard1, 1M-2M no shard2, 2M-3M no shard3. Query por userId é roteada para 1 shard (rápido). Query sem userId vai para todos (lento)."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__4",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é o teorema CAP e como ele se aplica a bancos NoSQL?",
    "options": [
      "Impossível ter simultâneo: Consistência forte, Alta disponibilidade e Tolerância a partições — escolha 2",
      "Three propriedades sempre garantidas",
      "Aplica-se apenas a SQL",
      "Cache, API e Protocolos"
    ],
    "correctIndex": 0,
    "explanation": "CAP: em presença de partição de rede (P), precisa escolher entre Consistência (C) ou Disponibilidade (A). CP: MongoDB (rejeita escrita se primary cair). AP: Cassandra (aceita escrita em qualquer nó, resolução posterior). Na prática: PACELC é modelo mais preciso.",
    "example": "Partição de rede entre nós: CP (MongoDB) → recusa writes até eleger novo primary (consistente, indisponível). AP (Cassandra) → aceita writes em ambos lados, merge depois (disponível, inconsistente temporariamente)."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__5",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é o conceito de embedding vs referencing em MongoDB?",
    "options": [
      "Embedding: documento aninhado no pai; Referencing: armazenar ID para lookup em outra coleção",
      "São idênticos",
      "Referencing é sempre melhor",
      "Embedding só funciona com arrays"
    ],
    "correctIndex": 0,
    "explanation": "Embedding: dados relacionados dentro do mesmo documento (denormalizado). Bom para 1:1, 1:poucos, lidos juntos. Referencing: ObjectId apontando para outro documento. Bom para 1:muitos, N:M, dados acessados independentemente. Trade-off: performance de leitura vs flexibilidade.",
    "example": "Embedding: { post: 'Hello', comments: [{text: 'Nice'}] } — 1 query. Referencing: { post: 'Hello', commentIds: ['id1'] } + comments collection — 2 queries, mas comments podem ter milhões sem estourar o documento (limite 16MB)."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__6",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é um Replica Set no MongoDB e para que serve?",
    "options": [
      "Grupo de instâncias MongoDB que mantêm cópias dos mesmos dados para alta disponibilidade e failover automático",
      "Conjunto de índices replicados",
      "Backup agendado",
      "Cluster de sharding"
    ],
    "correctIndex": 0,
    "explanation": "Replica Set: 1 primary (recebe writes) + N secondaries (replicam dados). Se o primary cair, eleição automática promove um secondary a primary. Vantagens: alta disponibilidade, read scaling (ler de secondaries), disaster recovery. Mínimo recomendado: 3 membros.",
    "example": "Replica Set com 3 nós. Primary recebe write. Secondary1 e Secondary2 replicam via oplog. Primary cai → eleição em ~10s → Secondary1 vira primary. App reconecta automaticamente. Zero downtime."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__7",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é o Aggregation Pipeline no MongoDB?",
    "options": [
      "Sequência de estágios que processam documentos: filtram, agrupam, transformam e calculam resultados",
      "Ferramenta de backup incremental",
      "Driver de conexão",
      "Tipo de índice composto"
    ],
    "correctIndex": 0,
    "explanation": "Aggregation Pipeline: documentos passam por estágios sequenciais ($match, $group, $sort, $project, $lookup, $unwind). Cada estágio transforma os documentos e passa ao próximo. Equivalente NoSQL de queries complexas com GROUP BY, JOIN e subqueries do SQL.",
    "example": "db.pedidos.aggregate([ { $match: { status: 'completo' } }, { $group: { _id: '$userId', total: { $sum: '$valor' } } }, { $sort: { total: -1 } }, { $limit: 10 } ]); — top 10 clientes por valor gasto."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__8",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é o Teorema CAP e como ele impacta a escolha de bancos NoSQL?",
    "options": [
      "Em presença de Partition (falha de rede), sistema distribiudo escolhe entre Consistency e Availability; bancos NoSQL são geralmente AP (Cassandra) ou CP (MongoDB)",
      "Bancos relacionais garantem as 3 propriedades; NoSQL sacrifica as 3",
      "CAP se aplica somente a bancos relacionais com replicação multi-master",
      "Partition Tolerance é sempre opcional em sistemas de produção modernos"
    ],
    "correctIndex": 0,
    "explanation": "CAP Theorem (Brewer): sistema distribuído não pode garantir simultaneamente Consistency (toda leitura retorna dado mais recente), Availability (toda requisição recebe resposta) e Partition Tolerance (continua operando com falha de rede). Como P é inevitável em redes reais, a escolha é C vs A. CP: MongoDB, HBase. AP: Cassandra, CouchDB, DynamoDB (eventual consistency).",
    "example": "Cassandra (AP): durante falha de rede, nó isolado continua respondendo (disponível) com dado possivelmente desatualizado (inconsistente). MongoDB (CP): nó primário cai → elege novo primário, recusa escritas até então (consistente, mas menos disponível). PACELC refina CAP também para o caso sem partição."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__9",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "Quando é mais adequado usar banco de dados orientado a grafos como Neo4j?",
    "options": [
      "Quando relacionamentos entre entidades são centrais e queries envolvem múltiplos graus de conexão (amigos de amigos, recomendações, detecção de fraude)",
      "Quando necessita de alta taxa de escrita com grande volume de dados flatten",
      "Quando dados têm estrutura hierárquica profunda como árvores de diretórios",
      "Quando o esquema muda frequentemente e precisa de flexibilidade de documentos"
    ],
    "correctIndex": 0,
    "explanation": "Bancos de grafos armazenam vértices e arestas como cidadãos de primeira classe, com alta performance em traversal de múltiplos hops. Casos de uso: redes sociais (amigos de amigos), sistemas de recomendação, detecção de fraude (padrões de conexão), autorização RBAC/ABAC complexa, grafos de conhecimento, rotas e logística.",
    "example": "LinkedIn: MATCH (ana:Person)-[:KNOWS*1..3]->(rec:Person) WHERE NOT (ana)-[:KNOWS]->(rec) RETURN rec LIMIT 10 — amigos de amigos de amigos em 1 query. SQL equivalente: 3 JOINs aninhados ou CTE recursiva muito mais lenta e complexa. Neo4j, Amazon Neptune, TigerGraph."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__10",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é o conceito de sharding em bancos NoSQL e como a partition key afeta a distribuição de dados?",
    "options": [
      "Distribuição horizontal entre nós baseada em partition key; chave mal escolhida causa hot spots enquanto boa chave distribui uniformemente",
      "Replicação de todos os dados em todos os nós para redundância total",
      "Compressão de dados para reduzir armazenamento em cada nó",
      "Indexação automática de todos os campos para acelerar qualquer query"
    ],
    "correctIndex": 0,
    "explanation": "Sharding: divide dataset em partições distribuídas entre nós. Key: campo para determinar o shard (hash ou range). Boa key: alta cardinalidade, acesso distribuído (user_id). Má key: baixa cardinalidade (country — 'BR' com 60% tráfego = hot spot). DynamoDB/Cassandra: partition key → hash → shard. Queries devem incluir partition key (scatter-gather é caro).",
    "example": "DynamoDB 'orders': partition key=customer_id→1M customers bem distribuídos. Se fosse status ('pending','shipped','delivered'): 3 partições, 'pending' com 60% = hot spot. Cassandra: PRIMARY KEY((user_id), created_at). Eficiente: WHERE user_id='abc'. Ineficiente: WHERE created_at>'2024-01-01' (full scan)."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Médio__11",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Médio",
    "question": "O que é modelagem por desnormalização em bancos de documentos e quando duplicar dados é vantajoso?",
    "options": [
      "Duplicar dados relacionados no mesmo documento para evitar lookups; vantajoso quando lidos juntos frequentemente e raramente atualizados independentemente",
      "Separar dados em collections normalizadas como em SQL para evitar redundância",
      "Comprimir documentos para reduzir espaço de armazenamento",
      "Criar índices em todos os campos para compensar falta de JOINs"
    ],
    "correctIndex": 0,
    "explanation": "SQL normalizado: pedido referencia cliente via FK, precisa JOIN. NoSQL documental: embutir dados do cliente no pedido (desnormalizar). Vantagem: uma leitura retorna tudo. Desvantagem: atualizar nome do cliente requer update em todos pedidos. Regra: embutir se 1:poucos e dados lidos juntos; referenciar se 1:muitos ou dados mudam frequentemente. Padrão Extended Reference: copiar só campos mais usados.",
    "example": "Blog embedded (poucos comentários): {title:'Post 1', comments:[{user:'Ana',text:'...'}]}. Um read retorna tudo. Referência (milhares): {title:'Post 1', comment_ids:['c1','c2']} + collection separada. Extended Reference: {order_id:1, customer:{name:'Ana',email:'...'}, customer_id:'ref'} — dados de exibição embutidos, id para dados completos."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__1",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "No DynamoDB, como o design de single-table com overloading de atributos e GSIs permite modelar relações complexas em uma única tabela?",
    "options": [
      "Usando PK e SK genéricos com prefixos que representam diferentes entidades, e GSIs invertendo chaves para consultas alternativas",
      "Normalizando dados em múltiplas tabelas com foreign keys",
      "Usando JOINs entre partições",
      "Criando views materializadas SQL"
    ],
    "correctIndex": 0,
    "explanation": "No single-table design, PK e SK usam prefixos (ex.: PK=USER#123, SK=ORDER#456) para armazenar múltiplas entidades na mesma tabela. GSIs (Global Secondary Indexes) com chaves invertidas ou overloaded permitem diferentes padrões de acesso sem tabelas adicionais.",
    "example": "PK=USER#1, SK=PROFILE → dados do usuário. PK=USER#1, SK=ORDER#100 → pedido do usuário. GSI1: PK=ORDER#100, SK=USER#1 → buscar pedido por ID. Tudo em uma tabela."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__2",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "O que é um banco de dados de séries temporais (TSDB) e para que serve?",
    "options": [
      "Banco otimizado para dados com timestamp, como métricas de infraestrutura e IoT",
      "Banco de grafos temporal",
      "Banco SQL com colunas de data",
      "Cache temporal"
    ],
    "correctIndex": 0,
    "explanation": "TSDBs (InfluxDB, TimescaleDB, Prometheus) são otimizados para writes de alta velocidade de dados com timestamp, queries por faixa de tempo, agregações temporais (média por hora/dia) e compressão eficiente de dados sequenciais. Ideal para métricas, IoT, logs financeiros.",
    "example": "InfluxDB: INSERT cpu,host=server01 usage=65.4 1625097600000000000. Query: SELECT mean(usage) FROM cpu WHERE time > now() - 1h GROUP BY time(5m) — média de CPU a cada 5 minutos na última hora."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__3",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre replicação síncrona e assíncrona em bancos NoSQL distribuídos?",
    "options": [
      "Síncrona espera confirmação de todas as réplicas antes de confirmar write; assíncrona confirma imediatamente e replica em background",
      "São idênticas",
      "Síncrona é mais rápida",
      "Assíncrona não replica"
    ],
    "correctIndex": 0,
    "explanation": "Síncrona: write só é confirmado após N réplicas confirmarem (consistência forte, maior latência). Assíncrona: write é confirmado após persistência local, réplicas recebem em background (menor latência, risco de dados não replicados em caso de falha). Muitos bancos oferecem níveis configuráveis.",
    "example": "MongoDB: w: 'majority' (síncrono — espera maioria confirmar). w: 1 (assíncrono — apenas primary confirma). Cassandra: QUORUM (maioria), ONE (1 nó). Trade-off: consistência vs latência."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__4",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "O que é o Firebase Firestore e como difere de um banco NoSQL tradicional?",
    "options": [
      "Banco NoSQL serverless com sincronização em tempo real, SDKs client-side e regras de segurança integradas",
      "Banco SQL gerenciado pelo Google",
      "Clone do MongoDB",
      "Apenas para Android"
    ],
    "correctIndex": 0,
    "explanation": "Firestore: banco de documentos (coleções/documentos) com sync em tempo real (onSnapshot), SDKs para web/mobile, security rules declarativas, escala automática (serverless). Diferenças de MongoDB: sem servidor para gerenciar, security rules no banco, pricing por operação.",
    "example": "Firestore: onSnapshot(collection(db, 'chats'), (snap) => { updateUI(snap.docs) }); — UI atualiza automaticamente quando qualquer usuário envia mensagem. Zero código de polling."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__5",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "O que é uma transação distribuída em NoSQL e quais os desafios?",
    "options": [
      "Operação atômica que abrange múltiplos documentos/nós; desafio de consistência entre partições",
      "Transação SQL normal",
      "Backup simúltaneo de shards",
      "Transferência de dados entre bancos"
    ],
    "correctIndex": 0,
    "explanation": "NoSQL nativamente otimiza operações em documento único. Transações multi-documento foram adicionadas (MongoDB 4.0+, Firestore nativo). Desafios: performance inferior a transações single-doc, timeouts, na maioria é melhor modelar dados para evitar transações multi-doc.",
    "example": "Firestore: await runTransaction(db, async (t) => { const doc = await t.get(ref); t.update(ref, { saldo: doc.data().saldo - 100 }); t.update(ref2, { saldo: doc2.data().saldo + 100 }); }); — atômico."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__6",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "O que é Change Data Capture (CDC) e como é usado com bancos NoSQL?",
    "options": [
      "Captura mudanças em tempo real no banco para propagar a outros sistemas via stream de eventos",
      "Backup incremental agendado",
      "Compressão de dados alterados",
      "Versionamento de esquema"
    ],
    "correctIndex": 0,
    "explanation": "CDC captura INSERT/UPDATE/DELETE em tempo real e propaga como eventos. MongoDB: Change Streams (watch()). DynamoDB: DynamoDB Streams. Firestore: onSnapshot. Usos: sincronizar cache, alimentar Elasticsearch, event sourcing, materializar views, integrar microsserviços.",
    "example": "MongoDB: db.collection('pedidos').watch().on('change', (change) => { if (change.operationType === 'insert') { elasticsearch.index(change.fullDocument); } }); — indexa automaticamente cada novo pedido no Elasticsearch."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__7",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "Quais critérios usar para escolher entre consistência forte e eventual em um banco NoSQL?",
    "options": [
      "Forte para dados financeiros/críticos; eventual para feeds, contadores e dados que toleram atraso de propagação",
      "Sempre usar consistência forte",
      "Sempre usar eventual consistency",
      "Depende apenas do preço do serviço"
    ],
    "correctIndex": 0,
    "explanation": "Consistência forte: toda leitura retorna o último write (saldo bancário, estoque com unidade única, reservas). Eventual: leituras podem estar desatualizadas por ms/s (feeds sociais, contadores de likes, analytics). Trade-off: forte = maior latência e menor throughput; eventual = inverso.",
    "example": "Saldo bancário: forte (ler R$100, sacar R$50, outro nó não pode ler R$100 ainda). Timeline Instagram: eventual (post aparece 2s depois para seguidores em outra região — aceitável). DynamoDB: ConsistentRead: true para forte."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__8",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "O que é consistent hashing e por que é usado em sistemas de sharding de bancos NoSQL?",
    "options": [
      "Mapeia dados e nós em anel circular; adicionar/remover nó redistribui apenas K/n chaves (não todas), minimizando reorganização do cluster",
      "Função hash que garante zero colisões entre shards de diferentes nós",
      "Técnica de replicação que mantém cópias sempre idênticas entre shards",
      "Balanceamento de carga por round-robin aprimorado para clusters de banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "Consistent hashing: nós e chaves mapeados em anel (hash 0 a 2³²). Chave vai ao próximo nó em sentido horário. Adicionar nó: apenas 1/n das chaves migram (não todas). Sem consistent hashing: adicionar nó requer rehash de todas as chaves (indisponibilidade). Virtual nodes (vnodes): cada nó físico = múltiplos pontos no anel para distribuição uniforme e rebalanceamento gradual.",
    "example": "3 nós no anel: N1(0-120°), N2(121-240°), N3(241-360°). Adicionar N4 entre N1 e N2: apenas keys do intervalo N1→N4 migram de N2. Cassandra usa consistent hashing com vnodes por padrão. DynamoDB usa variante. Reduz downtime de rebalanceamento de horas para minutos."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__9",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "O que é a arquitetura LSM-Tree usada por Cassandra e RocksDB e quais seus trade-offs?",
    "options": [
      "Escrita vai para MemTable (in-memory) + WAL, depois flushed como SSTable imutável em disco; compactação periódica mescla SSTables; otimizada para escrita, leitura levemente mais lenta",
      "Árvore B+ que loggeia todas as operações antes de aplicar ao arquivo de dados",
      "Índice invertido para buscas full-text em grandes volumes de documentos",
      "Cache de índices em memória com persistência em disco via checkpoint periódico"
    ],
    "correctIndex": 0,
    "explanation": "LSM-Tree: escrita sequencial no WAL (durabilidade) + MemTable in-memory ordenada. MemTable cheia → flushed como SSTable imutável. Compactação: mescla SSTables periodicamente (elimina versões antigas, garbage collect). Leitura: MemTable → SSTables (Bloom filter evita I/O desnecessário). Trade-off: escritas muito rápidas (sequencial), leituras levemente piores que B+Tree, write amplification na compactação.",
    "example": "Cassandra: escrita em <1ms (MemTable). Bloom filter: 95% de probabilidade de saber se key está na SSTable antes de ler. Compaction strategies: STCS (size-tiered), LCS (leveled, melhor leitura). RocksDB: engine de vários BDs (TiKV, Kafka Streams, MyRocks/MySQL). Read amplification: varrer múltiplas SSTables."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__10",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "O que é o protocolo Raft para consenso distribuído e como garante eleição de líder e replicação de log?",
    "options": [
      "Algoritmo com três papéis (leader, follower, candidate); usa election timeout aleatório e majority quorum para replicação de log consistente",
      "Protocolo de gossip para disseminação eventual entre nós sem líder",
      "Algoritmo de hash consistente para distribuir dados uniformemente",
      "Protocolo de heartbeat para detecção de falhas sem eleição"
    ],
    "correctIndex": 0,
    "explanation": "Raft: consenso compreensível (alternativa a Paxos). Leader processa writes, Followers replicam, Candidate em eleição. Eleição: follower sem heartbeat → timeout aleatório (150-300ms) → candidate → pede votos → maioria = leader. Replicação: client→leader appenda log→ envia AppendEntries→ maioria confirma→ committed. Usado: etcd, CockroachDB, Consul.",
    "example": "Cluster 5 nós: Leader(A), Followers(B,C,D,E). Write x=5: A appenda log → B,C,D confirmam (maioria 4/5) → committed. A morre: B timeout primeiro → candidate → C,D votam → B=novo leader com x=5 preservado. Raft garante: entry committed nunca é perdida."
  },
  {
    "id": "desenvolvimento__Banco de Dados NoSQL__Difícil__11",
    "track": "desenvolvimento",
    "category": "Banco de Dados NoSQL",
    "difficulty": "Difícil",
    "question": "O que são LSM Trees (Log-Structured Merge Trees) e por que bancos como Cassandra e RocksDB as utilizam?",
    "options": [
      "Estrutura otimizada para escritas: dados vão para memtable em RAM, depois flush como SSTables imutáveis no disco; compaction periódica faz merge dos níveis",
      "Árvore B+ que agrupa escritas em batches para reduzir I/O",
      "Índice invertido que mapeia valores para posições no disco",
      "Cache em camadas que armazena dados quentes em SSD e frios em HDD"
    ],
    "correctIndex": 0,
    "explanation": "LSM Tree: write-heavy otimizada. 1) Write → memtable (RAM) + WAL. 2) Memtable cheia → flush como SSTable (Sorted String Table, imutável). 3) SSTables acumulam → compaction: merge em SSTable maior, remove duplicatas/tombstones. Leitura: memtable → SSTables (recente→antigo). Bloom filters evitam reads desnecessários. Write O(1) amortizado; reads mais lentas que B-tree.",
    "example": "Write x=5: memtable.put(x,5) + WAL. Memtable cheia: flush → SSTable-L0.sst (ordenada). Compaction L0→L1: merge-sort SSTables. Read x: memtable(miss) → Bloom filter L0(false) → L1(maybe) → check SSTable(found). LevelDB, RocksDB, Cassandra, ScyllaDB usam LSM."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__1",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "Segundo os princípios de Clean Code, qual prática melhora a legibilidade ao nomear variáveis?",
    "options": [
      "Usar nomes descritivos que revelam a intenção da variável",
      "Usar abreviações de uma letra para economizar espaço",
      "Usar prefixos com o tipo da variável (strNome, intIdade)",
      "Usar nomes genéricos como 'data' e 'info'"
    ],
    "correctIndex": 0,
    "explanation": "Nomes descritivos eliminam a necessidade de comentários e tornam o código auto-explicativo. O leitor entende imediatamente o que a variável representa sem precisar analisar o contexto.",
    "example": "Ruim: const d = new Date(); const n = users.length; Bom: const createdAt = new Date(); const totalUsers = users.length;"
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__2",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "O que é o princípio de Responsabilidade Única (SRP) e por que é importante?",
    "options": [
      "Uma classe/função deve ter apenas uma razão para mudar, ou seja, uma única responsabilidade",
      "Uma função só pode ter um parâmetro",
      "Um arquivo só pode ter uma classe",
      "Uma variável só pode ser usada uma vez"
    ],
    "correctIndex": 0,
    "explanation": "SRP (primeiro princípio do SOLID): cada módulo deve ter uma única razão para mudar. Se uma classe gerencia usuários E envia e-mails, mudanças na lógica de e-mail forçam alterações na classe de usuários. Separe em UserService e EmailService.",
    "example": "Ruim: class UserService { createUser() {...} sendEmail() {...} generateReport() {...} } — 3 razões para mudar. Bom: UserService (crud), EmailService (emails), ReportService (relatórios)."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__3",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "Por que funções devem ser pequenas e fazer apenas uma coisa, segundo Clean Code?",
    "options": [
      "Facilita leitura, teste e manutenção; funções grandes são difíceis de entender e testar",
      "Funções grandes são mais rápidas",
      "O compilador exige funções pequenas",
      "Funções grandes ocupam mais memória"
    ],
    "correctIndex": 0,
    "explanation": "Funções pequenas (5-20 linhas) são mais fáceis de: ler (cabém na tela), entender (fazem uma coisa), testar (menos cenários) e reutilizar. Robert C. Martin (Clean Code) defende que funções devem fazer uma única coisa (one level of abstraction) e ter nomes descritivos.",
    "example": "Ruim: processOrder() com 200 linhas que valida, calcula, cobra e envia e-mail. Bom: processOrder() chama validateOrder(), calculateTotal(), chargePayment(), sendConfirmation() — cada uma faz uma coisa."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__4",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "O que é DRY (Don't Repeat Yourself) e por que é importante?",
    "options": [
      "Princípio de evitar duplicação de código; cada lógica deve existir em um único lugar",
      "Secar o código removendo espaços",
      "Não repetir testes",
      "Deletar código antigo"
    ],
    "correctIndex": 0,
    "explanation": "DRY: cada pedaço de conhecimento deve ter uma única representação no sistema. Código duplicado é bug duplo: se corrigir em um lugar e esquecer no outro, têm-se comportamentos inconsistentes. Extraia funções, constantes e módulos reutilizáveis.",
    "example": "Ruim: validação de email duplicada em registerUser() e updateProfile(). Bom: função validateEmail(email) reutilizada em ambos. Correção de bug: altera em 1 lugar só."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__5",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "O que são nomes descritivos e por que são importantes no Clean Code?",
    "options": [
      "Variáveis e funções com nomes que revelam intenção, eliminando a necessidade de comentários",
      "Nomes curtos de 1-2 caracteres",
      "Nomes em inglês obrigatoriamente",
      "Usar sempre abreviações"
    ],
    "correctIndex": 0,
    "explanation": "Nomes descritivos tornam o código auto-documentável. Ruim: d, temp, data, info (genéricos). Bom: daysUntilExpiration, activeUserCount, isPaymentOverdue. O nome deve responder: o que é, para que serve, por que existe.",
    "example": "Ruim: const d = new Date(); const t = d.getTime(); Bom: const currentDate = new Date(); const timestampMs = currentDate.getTime(); O código se explica sozinho."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__6",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "O que significa 'Early Return' e como melhora a legibilidade do código?",
    "options": [
      "Retornar cedo de uma função quando condições de guarda falham, evitando aninhamento profundo",
      "Retornar sempre null",
      "Encerrar o programa o mais rápido possível",
      "Usar return em todas as linhas"
    ],
    "correctIndex": 0,
    "explanation": "Early return usa cláusulas de guarda no início da função para tratar casos inválidos e retornar imediatamente. Evita múltiplos níveis de if/else aninhados (arrow anti-pattern). O fluxo principal fica no nível mais alto de indentação, facilitando leitura.",
    "example": "Ruim: function process(user) { if (user) { if (user.active) { if (user.verified) { // lógica } } } }\nBom: function process(user) { if (!user) return; if (!user.active) return; if (!user.verified) return; // lógica no nível principal }"
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__7",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "Por que evitar números mágicos (magic numbers) no código?",
    "options": [
      "Porque não transmitem significado; usar constantes nomeadas torna o código auto-explicativo",
      "Porque causam erros de compilação",
      "Porque ocupam mais memória",
      "Porque são mais lentos"
    ],
    "correctIndex": 0,
    "explanation": "Números mágicos são valores literais sem contexto (ex: if (status === 3)). Não revelam a intenção: o que é 3? Extrair para constantes nomeadas (const STATUS_APPROVED = 3) torna o código legível, facilita manutenção e evita erros de digitação.",
    "example": "Ruim: if (days > 30) { charge(amount * 0.02); }\nBom: const OVERDUE_THRESHOLD_DAYS = 30; const LATE_FEE_RATE = 0.02; if (days > OVERDUE_THRESHOLD_DAYS) { charge(amount * LATE_FEE_RATE); }"
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__8",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "O que é o princípio DRY (Don't Repeat Yourself) e como identificar sua violação?",
    "options": [
      "Cada pedaço de conhecimento deve ter representação única no sistema; violação: mesma lógica duplicada em múltiplos lugares exigindo mudanças paralelas",
      "Escrever o menor código possível, mesmo sacrificando legibilidade",
      "Comentários não devem repetir o que o código já diz",
      "Reusar variáveis para não alocar memória desnecessária"
    ],
    "correctIndex": 0,
    "explanation": "DRY: duplicação de código/lógica cria manutenção frágil — mudança precisa ser aplicada em múltiplos lugares, risco de inconsistência. Solução: abstrair em função, classe, constante ou módulo reutilizável. Cuidado: WET (Write Everything Twice) temporariamente pode ser melhor que abstrair prematuramente antes da terceira repetição.",
    "example": "Validação de email duplicada em 3 arquivos: se regra muda, 3 lugares para atualizar (risco de esquecer). DRY: extrair validateEmail() usada em todos os lugares. Uma mudança reflete em todos. Exceção: duplicação acidental (código similar, lógica diferente) não deve ser abstraída."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__9",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "O que é refatoração e o que ela NÃO deve alterar?",
    "options": [
      "Reestruturar código interno sem alterar comportamento observável externamente; NÃO adiciona features, NÃO corrige bugs intencionalmente",
      "Reescrever algoritmos para melhorar performance mantendo a mesma interface",
      "Adicionar funcionalidades mantendo compatibilidade com código legado",
      "Migrar para nova linguagem ou framework preservando a lógica de negócio"
    ],
    "correctIndex": 0,
    "explanation": "Refactoring (Martin Fowler): melhorar estrutura interna (legibilidade, manutenibilidade, reduzir dívida técnica) SEM mudar comportamento observável. Testes garantem que comportamento não mudou — refactor sem testes é arriscado. Catálogo: Extract Method, Rename Variable, Replace Conditional with Polymorphism, Extract Class, Inline Function.",
    "example": "Antes: if (u.s == 1 && u.p > 0) {}. Depois: if (usuario.estaAtivo() && usuario.temPagamento()) {}. Mesma lógica, mais legível. Renomear 'x' para 'totalVendas', extrair método 'calcularDesconto'. Nenhuma mudança funcional — testes verdes antes e depois."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__10",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "O que são guard clauses (cláusulas de guarda) e como simplificam a leitura de funções?",
    "options": [
      "Validações no início da função que retornam cedo em casos inválidos, eliminando aninhamento excessivo de if/else",
      "Blocos try/catch no final da função para capturar exceções",
      "Comentários que documentam pré-requisitos da função",
      "Testes unitários que validam parâmetros de entrada antes da execução"
    ],
    "correctIndex": 0,
    "explanation": "Guard clause: return/throw cedo para cases inválidos no topo da função. Sem: if aninhados profundos (arrow anti-pattern). Com: cada condição inválida sai imediatamente — happy path fica no nível principal sem indentação extra. Princípio: 'fail fast, return early'. Reduz cognitive complexity.",
    "example": "Antes: function process(user) { if(user) { if(user.active) { if(user.age>=18) { /*lógica*/ } } } }. Depois: function process(user) { if(!user) return null; if(!user.active) throw Error('Inactive'); if(user.age<18) throw Error('Minor'); /*lógica sem indentação*/ }."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Fácil__11",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Fácil",
    "question": "O que é formatação consistente de código e por que ferramentas como Prettier e ESLint são importantes em times?",
    "options": [
      "Padrões uniformes de indentação, espaçamento e nomenclatura; ferramentas automatizam a formatação eliminando debates de estilo em code reviews",
      "Maneira pessoal de organizar código que cada desenvolvedor escolhe individualmente",
      "Sistema de compilação que otimiza código para produção",
      "Framework de testes que valida regras de negócio do projeto"
    ],
    "correctIndex": 0,
    "explanation": "Formatação consistente: codebase parece escrito por uma pessoa. Prettier: formatador opinativo (tabs, aspas, trailing commas). ESLint: linter (bugs potenciais, variáveis não usadas). Juntos: ESLint para qualidade, Prettier para estilo. Automação: pre-commit hook (husky + lint-staged) formata antes de cada commit. Zero debates sobre estilo em PRs.",
    "example": "Sem Prettier: dev A usa tabs, dev B usa 2 espaços. PR: diff enorme por formatação. Com: npx prettier --write . .prettierrc: {semi:true, singleQuote:true, tabWidth:2}. ESLint: 'no-unused-vars':'error' → CI falha se variável não usada. Husky: git commit → lint-staged roda ambos automaticamente."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__1",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é o princípio DRY (Don't Repeat Yourself) e qual problema ele resolve?",
    "options": [
      "Eliminar duplicação de lógica, garantindo que cada conhecimento tenha uma única representação no código",
      "Nunca reutilizar código entre projetos",
      "Escrever código sem comentários",
      "Não repetir testes unitários"
    ],
    "correctIndex": 0,
    "explanation": "DRY determina que cada pedaço de conhecimento/lógica deve existir em um único lugar. Duplicação de código leva a inconsistências quando uma cópia é corrigida mas as outras não. A solução é extrair a lógica duplicada para uma função, módulo ou classe reutilizável.",
    "example": "Ruim: cálculo de imposto duplicado em 5 controllers. Bom: função calculateTax(amount, rate) chamada pelos 5 controllers. Corrigir o cálculo exige alterar apenas 1 lugar."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__2",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é o princípio KISS (Keep It Simple, Stupid) aplicado ao código?",
    "options": [
      "Preferir soluções simples e diretas, evitando complexidade desnecessária",
      "Usar apenas uma linguagem de programação",
      "Não usar frameworks",
      "Escrever o mínimo de código possível"
    ],
    "correctIndex": 0,
    "explanation": "KISS defende que a simplicidade deve ser um objetivo central do design. Código simples é mais fácil de entender, manter e debugar. Over-engineering (adicionar abstrações prematuramente, usar patterns complexos para problemas simples) viola KISS.",
    "example": "KISS: usar if/else para 3 casos. Over-engineering: criar Strategy Pattern com factory e DI container para os mesmos 3 casos. Se não vai crescer, KISS ganha."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__3",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é refactoring e quando deve ser feito?",
    "options": [
      "Reestruturar código existente sem alterar seu comportamento externo, melhorando qualidade interna",
      "Reescrever o sistema do zero",
      "Adicionar novas features",
      "Corrigir bugs"
    ],
    "correctIndex": 0,
    "explanation": "Refactoring melhora a estrutura interna (legibilidade, manutenção, performance) sem mudar o comportamento externo. Deve ser feito continuamente (boy scout rule: deixe o código melhor do que encontrou), antes de adicionar features, e quando code smells são identificados.",
    "example": "Code smell: função com 200 linhas. Refactoring: extrair em 5 funções menores. Code smell: duplicação. Refactoring: extrair função reutilizável. Testes passam antes e depois → comportamento preservado."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__4",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é Technical Debt (dívida técnica) e como gerenciá-la?",
    "options": [
      "Custo futuro causado por atalhos ou decisões de design subótimas; gerenciar com refactoring contínuo",
      "Dívida financeira do projeto",
      "Bug no código de produção",
      "Código sem comentários"
    ],
    "correctIndex": 0,
    "explanation": "Dívida técnica: atalhos que aceleram agora mas custam depois (código duplicado, sem testes, arquitetura frágil). Como dívida financeira, acumula juros (cada feature fica mais cara). Gerenciar: reservar % do sprint para refactoring, boy scout rule, tech debt backlog.",
    "example": "Sprint 1: gambiarra rápida para entregar no prazo (1h). Sprint 5: bug causado pela gambiarra leva 8h para resolver + 4h de regressão. Juros da dívida: 12h vs 1h original."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__5",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é code review e quais são as melhores práticas?",
    "options": [
      "Revisão de código por pares antes do merge; buscar clareza, correção e mantenibilidade",
      "Teste automático do código",
      "Reviso do gerente de projeto",
      "Análise de performance"
    ],
    "correctIndex": 0,
    "explanation": "Code review detecta bugs antes de produzir, compartilha conhecimento na equipe, mantém padrões. Boas práticas: PRs pequenas (<400 linhas), comentários construtivos, automatizar lint/formato, focar em lógica (não estilo), responder rápido (<24h).",
    "example": "PR com 50 linhas: revisada em 15 min, 2 sugestões, merge no mesmo dia. PR com 2000 linhas: 3 dias para revisar, 20 comentários, conflitos de merge. Menor = melhor."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__6",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que são os princípios SOLID e por que são importantes no design orientado a objetos?",
    "options": [
      "Cinco princípios de design que reduzem acoplamento e facilitam manutenção: SRP, OCP, LSP, ISP, DIP",
      "Framework de testes",
      "Linguagem de programação",
      "Metodologia ágil"
    ],
    "correctIndex": 0,
    "explanation": "SOLID: S (Single Responsibility), O (Open/Closed), L (Liskov Substitution), I (Interface Segregation), D (Dependency Inversion). Juntos, criam código com baixo acoplamento, alta coesão, fácil de testar, estender e manter. Fundamentais para design orientado a objetos robusto.",
    "example": "Sem SOLID: classe UserService com 2000 linhas que faz CRUD, envia email, gera relatório, valida pagamento. Com SOLID: UserService (CRUD), EmailService, ReportService, PaymentValidator — cada um com responsabilidade única (SRP)."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__7",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é o princípio YAGNI (You Aren't Gonna Need It)?",
    "options": [
      "Não implementar funcionalidades até que sejam realmente necessárias, evitando over-engineering",
      "Nunca usar bibliotecas externas",
      "Não escrever documentação",
      "Sempre implementar o máximo possível"
    ],
    "correctIndex": 0,
    "explanation": "YAGNI: não adicione funcionalidades especulativas. Código não usado é custo sem valor: precisa ser mantido, testado e compreendido. Complementar ao KISS. Origem: Extreme Programming (XP). 'Do the simplest thing that could possibly work.'",
    "example": "YAGNI violado: criar sistema de plugins extensível para app de TODO list que nunca terá plugins. YAGNI respeitado: implementar apenas as features no backlog atual. Se futuramente precisar de plugins, refatore na hora."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__8",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é o princípio de Responsabilidade Única (SRP) do SOLID e como identificar violação?",
    "options": [
      "Classe deve ter apenas um motivo para mudar; violação: classe que muda por razões distintas (lógica de negócio E persistência E apresentação)",
      "Classe deve ter apenas um método público exposto",
      "Módulo deve depender de apenas uma abstração",
      "Função deve realizar no máximo uma operação de I/O"
    ],
    "correctIndex": 0,
    "explanation": "SRP: cada classe/módulo tem responsabilidade única — um único motivo para mudar. Teste: 'por que essa classe mudaria?' — se múltiplas respostas, viola SRP. UserService que valida dados + salva no BD + envia email + gera relatório tem 4 motivos para mudar. Decomponha: UserValidator, UserRepository, UserNotifier, UserReportGenerator.",
    "example": "Classe Report: gera dados + formata HTML + salva arquivo + envia email = 4 responsabilidades. SRP: ReportData, HtmlFormatter, ReportSaver, ReportEmailer. Cada uma muda por uma razão: trocar provedor de email → só ReportEmailer. Trocar formato → só HtmlFormatter."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__9",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é dívida técnica e quais os principais tipos segundo Martin Fowler?",
    "options": [
      "Custo futuro de retrabalho por soluções subótimas hoje; tipos: deliberada prudente (shortcut consciente), deliberada imprudente, inadvertida prudente e inadvertida imprudente",
      "Débito financeiro de licenças de software atrasadas",
      "Backlog de features não implementadas por falta de prazo",
      "Horas extras acumuladas da equipe durante períodos de crunch"
    ],
    "correctIndex": 0,
    "explanation": "Quadrante de Fowler: Reckless/Deliberate (sabemos o que fazemos, não nos importamos), Prudent/Deliberate (prazos, documentamos para pagar depois), Reckless/Inadvertent (não sabíamos de padrões melhores), Prudent/Inadvertent (só descobrimos o design correto após implementar). Cada tipo exige estratégia diferente. 'Juros': cada mudança futura fica mais cara.",
    "example": "Deliberada prudente: 'vamos usar essa solução simples agora, criar ticket para refatorar antes da v2'. Inadvertida prudente: 'só após implementar percebemos que Domain Events era a abordagem certa'. Reckless deliberada: copiar-colar 5 vezes por pressa, sem plano de corrigir."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__10",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que é coesão e acoplamento em design de software e qual a relação ideal entre eles?",
    "options": [
      "Coesão: grau em que elementos de um módulo pertencem juntos (alta=bom); acoplamento: dependência entre módulos (baixo=bom) — ideal: alta coesão e baixo acoplamento",
      "Coesão: número de classes (menos=melhor); acoplamento: métodos públicos (mais=melhor)",
      "Coesão: velocidade de execução; acoplamento: consumo de memória",
      "Ambos devem ser altos para módulos trabalharem juntos eficientemente"
    ],
    "correctIndex": 0,
    "explanation": "Alta coesão: módulo faz uma coisa bem (UserRepository: apenas CRUD de users). Baixa coesão: faz coisas não relacionadas (Utils: email+log+crypto). Baixo acoplamento: depende de interface/abstração. Alto: acessa campos internos, instancia classes concretas. Injeção de dependência inverte acoplamento. Lei de Demeter reduz acoplamento.",
    "example": "Alta coesão + baixo acoplamento: class OrderService { constructor(private repo: OrderRepository) {} create(data) { return this.repo.save(new Order(data)); } } — interface. Baixa coesão: class GodService { sendEmail() {} processPayment() {} generatePDF() {} }. Alto acoplamento: class X { process() { new PostgresDB().query(...); } } — amarrado ao concreto."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Médio__11",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Médio",
    "question": "O que são code reviews efetivas e quais aspectos priorizar ao revisar código de outros desenvolvedores?",
    "options": [
      "Análise de PRs focando em corretude, legibilidade, segurança e aderência a padrões — com feedback construtivo e específico",
      "Revisão focada exclusivamente em bugs de compilação e erros de sintaxe",
      "Reescrever o código do colega no seu próprio estilo",
      "Aprovação automática de PRs que passam nos testes automatizados"
    ],
    "correctIndex": 0,
    "explanation": "Priorizar: 1) Corretude: lógica, edge cases, race conditions. 2) Design: responsabilidades, abstração. 3) Legibilidade: nomes, complexidade. 4) Segurança: SQL injection, XSS. 5) Testes: cenários cobertos. 6) Performance: N+1, loops desnecessários. Feedback específico, elogiar o bom, perguntar ao invés de impor. PRs pequenos (<400 linhas).",
    "example": "Ruim: 'Código confuso'. Bom: 'Esse bloco de 30 linhas poderia ser extraído para calcularDesconto() — mais legível e testável'. Nit: 'nit: renomear d para discount'. Blocking: 'Query dentro do loop causa N+1; use JOIN'. Elogio: 'Boa ideia usar guard clauses, ficou legível!'."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__1",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "No princípio SOLID, o que estabelece a letra 'D' (Dependency Inversion Principle) e como ele impacta a testabilidade do código?",
    "options": [
      "Módulos de alto nível devem depender de abstrações, não de implementações concretas, facilitando mocks em testes",
      "Dependências devem ser instaladas em ordem inversa",
      "Código deve evitar qualquer dependência externa",
      "Módulos devem depender sempre de implementações concretas para performance"
    ],
    "correctIndex": 0,
    "explanation": "O Dependency Inversion Principle (DIP) determina que módulos de alto nível não devem depender de módulos de baixo nível — ambos devem depender de abstrações (interfaces). Isso permite substituir implementações concretas por mocks/stubs nos testes e trocar implementações sem modificar o código consumidor.",
    "example": "class OrderService { constructor(private repo: IOrderRepository) {} } — depende da interface, não do PostgresOrderRepository concreto. No teste: new OrderService(new MockOrderRepository())."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__2",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que são Code Smells e quais são os mais comuns?",
    "options": [
      "Indicadores de problemas no código: funções longas, duplicação, parâmetros excessivos, classes grandes",
      "Erros de compilação",
      "Vulnerabilidades de segurança",
      "Problemas de performance"
    ],
    "correctIndex": 0,
    "explanation": "Code smells são indicadores de design problemático (não são bugs). Comuns: Long Method (função longa), Duplicated Code, Large Class (classe com muitas responsabilidades), Feature Envy (método usa mais dados de outra classe), Primitive Obsession (usar primitivos em vez de Value Objects).",
    "example": "Feature Envy: calculateDiscount(order) acessa order.customer.memberSince, order.customer.totalPurchases, order.customer.tier — deveria estar na classe Customer: customer.calculateDiscount()."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__3",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é o princípio Open/Closed (OCP) do SOLID e como implementá-lo?",
    "options": [
      "Entidades devem estar abertas para extensão mas fechadas para modificação, usando abstrações",
      "Código deve ser open-source",
      "Arquivos devem ficar abertos durante o deploy",
      "Funções devem aceitar qualquer tipo de parâmetro"
    ],
    "correctIndex": 0,
    "explanation": "OCP: você deve poder adicionar novos comportamentos sem modificar código existente. Implementação: usar interfaces, herança, Strategy Pattern ou composição. Novo caso = nova classe que implementa a interface, sem alterar nenhuma classe existente.",
    "example": "Antes (viola OCP): if (shape === 'circle') calcCircle(); else if (shape === 'square') calcSquare(); — adicionar triângulo exige modificar a função. Depois: interface Shape { area(): number } + classes Circle, Square, Triangle — adicionar Triangle não modifica nada."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__4",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é o princípio KISS (Keep It Simple, Stupid) no desenvolvimento?",
    "options": [
      "Manter soluções simples e diretas; evitar complexidade desnecessária",
      "Usar sempre a tecnologia mais avançada",
      "Minimizar número de arquivos",
      "Usar abreviações em todo o código"
    ],
    "correctIndex": 0,
    "explanation": "KISS: a simplicidade deve ser um objetivo-chave. Soluções simples são mais fáceis de entender, manter e debugar. Evite over-engineering: não use design patterns complexos para problemas simples. YAGNI (You Aren't Gonna Need It) é complementar.",
    "example": "Over-engineering: criar AbstractFactoryStrategyObserver para uma feature de TODO list. KISS: uma função addTodo(text) e uma lista. Complexidade só quando a necessidade justificar."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__5",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é o princípio de Separação de Concerns (Separation of Concerns)?",
    "options": [
      "Dividir o sistema em partes distintas, cada uma tratando uma preocupação específica",
      "Separar código frontend e backend em repos diferentes",
      "Usar apenas um padrão de projeto",
      "Manter todo código em um arquivo"
    ],
    "correctIndex": 0,
    "explanation": "Cada módulo/classe/função deve tratar de uma única preocupação. Separação reduz acoplamento e aumenta coesão. Exemplos: MVC, camadas (UI, lógica, dados), módulos por domínio. Misturar concerns cria código difícil de manter e testar.",
    "example": "Violação: componente React que faz fetch, validação, render e logging tudo junto. Separado: custom hook useFetchUsers (dados), validateUser util (lógica), UserList component (UI)."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__6",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é complexidade ciclomática e como ela indica qualidade do código?",
    "options": [
      "Métrica que conta caminhos independentes de execução; alta complexidade indica código difícil de testar e manter",
      "Velocidade de execução do código",
      "Quantidade de linhas por arquivo",
      "Número de dependências externas"
    ],
    "correctIndex": 0,
    "explanation": "Complexidade ciclomática (McCabe) = número de caminhos independentes no fluxo de controle. Cada if, for, while, case, && e || incrementa. CC=1-5: simples. CC=6-10: moderado. CC>10: arriscado (muitos branches = difícil testar todos). Ferramentas: ESLint complexity rule, SonarQube.",
    "example": "function check(a,b,c) { if (a) { if (b) return 1; else return 2; } if (c) return 3; return 4; } — CC=4 (4 caminhos). Para testar 100%: 4 testes. CC=20 → 20 testes mínimos, provavelmente precisa refatorar."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__7",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é o princípio de Liskov Substitution (LSP) do SOLID?",
    "options": [
      "Subtipos devem ser substituíveis por seus tipos base sem alterar a correção do programa",
      "Listar todas as dependências no início do arquivo",
      "Substituir classes por funções",
      "Usar apenas herança, nunca composição"
    ],
    "correctIndex": 0,
    "explanation": "LSP: se S é subtipo de T, objetos de tipo T podem ser substituídos por objetos de tipo S sem quebrar o programa. Violação clássica: Square extends Rectangle — setWidth() em Square altera height também, quebrando expectativas de Rectangle. Solução: modelar corretamente a hierarquia.",
    "example": "Violação: class Bird { fly() {} } class Penguin extends Bird { fly() { throw Error('Não voa!'); } } — código que chama bird.fly() quebra com Penguin. Solução: interface FlyingBird e interface SwimmingBird separadas."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__8",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é o Princípio de Inversão de Dependência (DIP) do SOLID e como Injeção de Dependência o implementa?",
    "options": [
      "Módulos de alto e baixo nível devem depender de abstrações (interfaces), não de implementações concretas; DI fornece implementações em runtime sem que a classe as instancie",
      "Classes de alto nível chamam diretamente classes de baixo nível para maior coesão",
      "Interfaces devem depender das classes que as implementam para garantir contrato",
      "Serviços externos devem ser injetados como parâmetros do construtor sem abstração"
    ],
    "correctIndex": 0,
    "explanation": "DIP: UserService (alto nível) não deve instanciar EmailService (baixo nível) — ambos dependem de IEmailPort (abstração). DI: implementação concreta fornecida externamente (constructor injection, setter, container IoC). Invertente do controle: classe não cria dependências, recebe-as. Facilita testes (mock das interfaces), troca de implementação sem mudar o consumidor.",
    "example": "Sem DIP: class UserService { email = new SendGridEmail(); } — acoplado. Com DIP: class UserService { constructor(private email: IEmailPort) {} }. Em produção: container injeta SendGridEmail(). Em testes: injeta MockEmail(). Trocar para AWS SES: nova classe AwsSesEmail implements IEmailPort — UserService não muda."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__9",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é o Princípio de Substituição de Liskov (LSP) e como identificar violações práticas?",
    "options": [
      "Subclasse deve ser substituível pela superclasse sem alterar o comportamento do programa; violação clássica: Quadrado extends Retangulo onde setLargura() quebra invariante da área",
      "Subclasse deve sobrescrever todos os métodos herdados da superclasse",
      "Interface deve ser mais específica que a classe que a implementa",
      "Herança múltipla sem conflito de método representa aplicação do LSP"
    ],
    "correctIndex": 0,
    "explanation": "LSP (Liskov): se S é subtipo de T, programa usando T deve funcionar com S sem saber. Violações: subclasse lança exceção para método herdado, post-conditions mais fracas, pre-conditions mais fortes. Quadrado herda Retangulo: setLargura(5) em Quadrado também altera altura (invariante área = L×A se L≠A quebra). Pinguim extends Ave com voar() lança exceção.",
    "example": "Violação: class ReadOnlyList extends List { add(item) { throw Error('Somente leitura'); } } — código que chama list.add() quebra com ReadOnlyList. Solução: segregar interfaces — IReadableList e IWritableList. Outro exemplo: Pinguim — interface IAveVoadora vs IAveNaoVoadora ou composição de comportamentos."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__10",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é Cognitive Complexity e como difere de Cyclomatic Complexity para medir legibilidade?",
    "options": [
      "Cognitive penaliza aninhamento proporcionalmente à profundidade; Cyclomatic conta caminhos independentes sem considerar nesting",
      "São sinônimos — ambas contam branches no código",
      "Cognitive mede tempo de execução; Cyclomatic mede uso de memória",
      "Cognitive só se aplica a linguagens OO; Cyclomatic a procedurais"
    ],
    "correctIndex": 0,
    "explanation": "Cyclomatic (McCabe): conta caminhos de execução. if(a) if(b) if(c) = 4. Não penaliza profundidade. Cognitive (SonarSource): incrementa para quebra de fluxo (+1) E adiciona penalidade por nesting. if(a){if(b){if(c)}} = 1+2+3=6. Mais alinhada com percepção humana. Guideline: ≤15 por método. SonarQube mede automaticamente.",
    "example": "function f(a,b,c) {if(a){for(...){if(b){if(c){}}}}}. Cyclomatic: 1+1+1+1=5. Cognitive: if=1, for=1+1(nest), if=1+2(nest), if=1+3(nest) = 10. Cognitive penaliza mais o aninhamento profundo. Refatorar com guard clauses e extração de funções reduz drasticamente o score."
  },
  {
    "id": "desenvolvimento__Clean Code e Boas Práticas__Difícil__11",
    "track": "desenvolvimento",
    "category": "Clean Code e Boas Práticas",
    "difficulty": "Difícil",
    "question": "O que é Immutability by Default e como a imutabilidade reduz bugs em software concorrente e funcional?",
    "options": [
      "Tratar dados como imutáveis por padrão, criando novos objetos ao modificar — elimina race conditions e facilita raciocínio sobre estado",
      "Usar apenas constantes declaradas em tempo de compilação",
      "Impedir reatribuição de qualquer variável durante toda a execução",
      "Congelar objetos na memória para evitar coleta pelo garbage collector"
    ],
    "correctIndex": 0,
    "explanation": "Imutabilidade: dado criado nunca é alterado. 1) Thread-safety: sem mutação compartilhada, sem race conditions (sem locks). 2) Previsibilidade: ninguém modifica objeto em paralelo. 3) Memoização segura. Custo: alocação de novos objetos (mitigado por structural sharing — Immer/Immutable.js). Linguagens: Rust, Haskell, Kotlin val, JS const/Object.freeze.",
    "example": "Mutável (bug): const user={name:'Ana'}; processA(user); processB(user) — A mudou name='Bob', B recebe 'Bob' inesperadamente. Imutável: const updated={...user, name:'Bob'} — user intacto. React: setState({...state, count: state.count+1}). Immer: produce(state, draft=>{draft.count++}) — API mutável, resultado imutável."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__1",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "Qual Design Pattern garante que uma classe tenha apenas uma única instância em toda a aplicação?",
    "options": [
      "Singleton",
      "Factory",
      "Observer",
      "Strategy"
    ],
    "correctIndex": 0,
    "explanation": "O Singleton restringe a instanciação de uma classe a um único objeto. Ele fornece um ponto de acesso global à instância através de um método estático, garantindo que todas as partes do código usem o mesmo objeto.",
    "example": "class Database { static instance; static getInstance() { if (!this.instance) this.instance = new Database(); return this.instance; } } — toda chamada a Database.getInstance() retorna o mesmo objeto."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__2",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "Qual Design Pattern cria objetos sem expor a lógica de criação, delegando a decisão para subclasses ou métodos?",
    "options": [
      "Factory",
      "Singleton",
      "Observer",
      "Decorator"
    ],
    "correctIndex": 0,
    "explanation": "O Factory Method define uma interface para criar objetos, mas deixa subclasses decidirem qual classe instanciar. Abstract Factory cria famílias de objetos relacionados. Ambos encapsulam a lógica de criação, desacoplando o código consumidor das classes concretas.",
    "example": "function createPayment(type) { if (type === 'pix') return new PixPayment(); if (type === 'card') return new CardPayment(); } — consumidor usa createPayment('pix') sem conhecer a classe concreta."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__3",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "Qual Design Pattern permite notificar múltiplos objetos quando o estado de outro objeto muda?",
    "options": [
      "Observer",
      "Singleton",
      "Factory",
      "Adapter"
    ],
    "correctIndex": 0,
    "explanation": "O Observer define uma relação um-para-muitos: quando o 'subject' muda de estado, todos os 'observers' inscritos são notificados automaticamente. Muito usado em eventos de UI, sistemas reativos e padrão pub/sub.",
    "example": "EventEmitter do Node.js é Observer: emitter.on('order-created', sendEmail); emitter.on('order-created', updateInventory); emitter.emit('order-created', order); — ambos handlers são notificados."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__4",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "O que é o padrão Singleton e quando utilizá-lo?",
    "options": [
      "Garante que uma classe tenha apenas uma instância e fornece um ponto de acesso global",
      "Cria múltiplas instâncias simultaneamente",
      "Padrão para criar interfaces",
      "Padrão para herança múltipla"
    ],
    "correctIndex": 0,
    "explanation": "Singleton: a classe controla sua própria instanciação, garantindo que exista apenas uma. Usado para: conexão de banco de dados, logger, configuração global. Cuidado: pode dificultar testes (estado global) e violar SRP.",
    "example": "class Database { static instance; static getInstance() { if (!this.instance) this.instance = new Database(); return this.instance; } } — Database.getInstance() sempre retorna a mesma conexão."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__5",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "O que é o padrão Factory Method?",
    "options": [
      "Define uma interface para criar objetos, mas delega a decisão de qual classe instanciar para subclasses",
      "Método que destrói objetos",
      "Padrão para clonar objetos",
      "Método estático de configuração"
    ],
    "correctIndex": 0,
    "explanation": "Factory Method encapsula a criação de objetos. O código cliente chama o factory sem saber qual classe concreta será instanciada. Vantagem: adicionar novos tipos sem modificar o código existente (Open/Closed Principle).",
    "example": "function createNotification(type) { if (type === 'email') return new EmailNotification(); if (type === 'sms') return new SMSNotification(); } — o cliente não precisa conhecer as classes concretas."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__6",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "O que é o padrão Observer (Observador) e onde é mais utilizado?",
    "options": [
      "Padrão que notifica automaticamente múltiplos objetos quando o estado de um objeto muda",
      "Padrão para observar arquivos no disco",
      "Ferramenta de monitoramento",
      "Plugin de depuração"
    ],
    "correctIndex": 0,
    "explanation": "Observer define relação 1:N. O subject mantém lista de observers e os notifica quando muda. Desacopla emissor de receptores. Usado em: eventos DOM, EventEmitter do Node.js, RxJS Observables, React useState (re-render), Redux subscribe.",
    "example": "button.addEventListener('click', handleClick); — o botão (subject) notifica handlers (observers). Não precisa saber quantos ou quem são os listeners."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__7",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "O que é o padrão Adapter e qual problema ele resolve?",
    "options": [
      "Converte a interface de uma classe existente para outra interface esperada, permitindo integração",
      "Cria novos objetos",
      "Adiciona funcionalidades a objetos",
      "Gerencia ciclo de vida de objetos"
    ],
    "correctIndex": 0,
    "explanation": "Adapter é um wrapper que traduz chamadas de uma interface para outra. Útil quando precisa usar uma biblioteca cujos métodos têm nomes e parâmetros diferentes do que seu código espera. Análogo: adaptador de tomada que converte plug americano para padrão brasileiro.",
    "example": "Seu código usa interface Logger { info(msg), error(msg) }. Lib usa Winston { log('info', msg) }. WinstonAdapter implements Logger { info(msg) { winston.log('info', msg); } } — integração sem alterar seu código."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__8",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "O que é o padrão Singleton e quais são suas desvantagens em aplicações modernas?",
    "options": [
      "Garante uma única instância da classe com acesso global; desvantagens: estado global dificulta testes, viola SRP, acoplamento oculto entre módulos",
      "Cria múltiplas instâncias de forma controlada por uma factory central",
      "Garante uma única implementação de interface sem restrição de instâncias",
      "Cria objetos imutáveis com acesso thread-safe sem estado compartilhado"
    ],
    "correctIndex": 0,
    "explanation": "Singleton: construtor privado + static getInstance() retorna a mesma instância. Usado para: logger, configuração, pool de conexões. Problemas: estado global contamina testes (instância suja entre testes), viola SRP (gerencia próprio ciclo de vida), acoplamento oculto (modules dependem de instância global). Preferir DI de objetos únicos gerenciados pelo container IoC.",
    "example": "class Database { private static instance: Database; static getInstance() { if (!this.instance) this.instance = new Database(); return this.instance; } }. Problema: Database.getInstance() em múltiplos testes compartilha conexões sujas. Alternativa: injetar a instância do banco via DI — mais testável."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__9",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "O que é o padrão Observer e como ele é o núcleo de sistemas reativos?",
    "options": [
      "Define dependência um-para-muitos: Subject notifica automaticamente todos os Observers registrados quando seu estado muda",
      "Um objeto observa e modifica outros objetos diretamente",
      "Cria objetos complexos passo a passo com estado intermediário observável",
      "Encapsula algoritmos intercambiáveis com monitoramento de execução"
    ],
    "correctIndex": 0,
    "explanation": "Observer: Subject mantém lista de Observers e chama update() em todos quando muda. Observer se inscreve (subscribe) e cancela (unsubscribe) dinamicamente. Usado: event listeners DOM, EventEmitter Node.js, RxJS Observables, React useEffect com subscriptions, MVC (View observa Model). Cuidado: memory leaks por não cancelar observadores.",
    "example": "EventEmitter (Node.js): emitter.on('data', handler) — Observer. emitter.emit('data', payload) — Subject notifica todos os handlers registrados em 'data'. RxJS: observable$.subscribe(handler) + takeUntil para cancelamento. Componente React subscreve WebSocket no useEffect e cancela no cleanup."
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__10",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "O que é o padrão Iterator e como ele permite percorrer coleções sem expor a estrutura interna?",
    "options": [
      "Fornece interface padronizada (next/hasNext) para percorrer elementos sequencialmente independente se é array, árvore ou hash — desacopla iteração da implementação",
      "Cria cópia completa da coleção para iterar sem modificar a original",
      "Ordena a coleção antes de iterar para garantir sequência consistente",
      "Converte qualquer coleção em array para usar métodos de array"
    ],
    "correctIndex": 0,
    "explanation": "Iterator: interface para percorrer elementos sem expor representação interna. Métodos: next() retorna próximo elemento, hasNext() verifica se há mais. Em JS: Symbol.iterator + protocolo { done, value }. Permite: for...of em qualquer coleção. Array, Map, Set, String — todos implementam. Custom iterables: qualquer objeto pode ser iterável implementando o protocolo.",
    "example": "JS: const range = { from:1, to:5, [Symbol.iterator]() { let cur=this.from; return { next:()=> cur<=this.to ? {value:cur++,done:false} : {done:true} }; } }; for(const n of range) console.log(n); // 1,2,3,4,5. Java: Iterator<String> it = list.iterator(); while(it.hasNext()) System.out.println(it.next());"
  },
  {
    "id": "desenvolvimento__Design Patterns__Fácil__11",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Fácil",
    "question": "O que é o padrão Template Method e como ele define o esqueleto de um algoritmo delegando passos às subclasses?",
    "options": [
      "Método na classe base define a estrutura do algoritmo com passos abstratos que as subclasses implementam — mesma sequência, diferentes comportamentos",
      "Template genérico que gera código automaticamente a partir de tipos",
      "Método que aceita funções callback como parâmetro para variar comportamento",
      "Padrão que copia objetos existentes como template para criar novos"
    ],
    "correctIndex": 0,
    "explanation": "Template Method: classe base define algoritmo com sequência fixa de passos; alguns passos são abstratos (obrigatórios) ou hooks (opcionais). Subclasses sobrescrevem passos específicos sem alterar a estrutura. Princípio Hollywood: 'Don't call us, we'll call you'. Exemplos: frameworks de teste (setUp → test → tearDown), processadores de dados (read → parse → validate → save).",
    "example": "abstract class DataProcessor { process() { const data=this.read(); const parsed=this.parse(data); this.validate(parsed); this.save(parsed); } abstract read(): string; abstract parse(d:string): any; validate(d:any) {} /* hook opcional */ abstract save(d:any): void; } class CSVProcessor extends DataProcessor { read() { return fs.readFileSync('data.csv'); } ... }"
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__1",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "Qual Design Pattern permite definir uma família de algoritmos intercambiáveis, encapsulando cada um em uma classe separada?",
    "options": [
      "Strategy",
      "Singleton",
      "Adapter",
      "Decorator"
    ],
    "correctIndex": 0,
    "explanation": "O Strategy permite selecionar um algoritmo em tempo de execução. Cada algoritmo é encapsulado em uma classe que implementa uma interface comum. O contexto delega a execução à estratégia selecionada, facilitando adição de novos algoritmos sem modificar código existente.",
    "example": "interface PaymentStrategy { pay(amount: number): void } → classes CreditCardPayment, PixPayment, BoletoPayment. Checkout usa strategy.pay(100) sem conhecer a implementação."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__2",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "Qual Design Pattern adiciona funcionalidades a um objeto dinamicamente sem alterar sua classe?",
    "options": [
      "Decorator",
      "Singleton",
      "Factory",
      "Observer"
    ],
    "correctIndex": 0,
    "explanation": "O Decorator envolve (wraps) um objeto com outro que implementa a mesma interface, adicionando comportamento antes/depois de delegar ao objeto original. Permite combinar funcionalidades em tempo de execução sem explodir o número de subclasses.",
    "example": "const logger = withLogging(baseService); const cached = withCache(logger); — baseService ganha logging e cache sem modificação. Em Java: new BufferedReader(new FileReader(file)) — BufferedReader decora FileReader."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__3",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "Qual Design Pattern converte a interface de uma classe em outra interface esperada pelo cliente?",
    "options": [
      "Adapter",
      "Facade",
      "Proxy",
      "Bridge"
    ],
    "correctIndex": 0,
    "explanation": "O Adapter permite que classes com interfaces incompatíveis trabalhem juntas. Ele cria um wrapper que traduz as chamadas da interface esperada para a interface real do objeto adaptado. Muito útil ao integrar bibliotecas de terceiros ou sistemas legados.",
    "example": "Seu código espera interface Payment { charge(amount) }. Lib externa tem StripeSDK { createCharge(cents) }. StripeAdapter implements Payment { charge(amount) { stripe.createCharge(amount * 100); } } — adapta dólares para centavos."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__4",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "O que é o padrão Decorator e como ele difere de herança?",
    "options": [
      "Adiciona responsabilidades a objetos dinamicamente via composição, sem alterar a classe original",
      "É igual a herança",
      "Substitui métodos existentes",
      "Remove funcionalidades de objetos"
    ],
    "correctIndex": 0,
    "explanation": "Decorator envolve (wraps) um objeto adicionando comportamento. Diferente de herança: é dinâmico (runtime), pode combinar múltiplos decorators, e não cria hierarquia profunda. Herança é estática (compile-time) e pode causar explosão de subclasses.",
    "example": "const logger = new LoggingDecorator(new AuthDecorator(new HttpClient())); — cada chamada passa por logging → auth → http. Composição dinâmica sem criar ClasseLogAuthHttp."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__5",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "O que é o padrão Builder e quando é mais adequado que um construtor com muitos parâmetros?",
    "options": [
      "Constrói objetos complexos passo a passo com uma API fluente, evitando construtores com dezenas de parâmetros",
      "Destrói objetos complexos",
      "Constrói apenas strings",
      "É alternativa ao Factory apenas"
    ],
    "correctIndex": 0,
    "explanation": "Builder separa a construção de um objeto complexo da sua representação. Útil quando: muitos parâmetros opcionais, construção em etapas, ou diferentes representações do mesmo objeto. API fluente: encadear métodos que retornam this.",
    "example": "const query = new QueryBuilder().select('name', 'email').from('users').where('age > 18').orderBy('name').limit(10).build(); — legível e flexível vs new Query('name,email', 'users', 'age>18', 'name', 10)."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__6",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "O que é o padrão Proxy e quais suas variações mais comuns?",
    "options": [
      "Objeto substituto que controla o acesso ao objeto real; variações: virtual, de proteção, de log e remoto",
      "Servidor intermediário de rede",
      "Cache distribuído",
      "Padrão exclusivo para redes"
    ],
    "correctIndex": 0,
    "explanation": "Proxy cria um substituto para outro objeto, controlando acesso. Virtual Proxy: lazy loading (carrega objeto pesado só quando necessário). Protection Proxy: controla acesso por permissões. Logging Proxy: registra chamadas. Remote Proxy: representa objeto em outro servidor.",
    "example": "Proxy para lazy loading de imagem: class ImageProxy { getImage() { if (!this.image) this.image = loadFromDisk(); return this.image; } } — a imagem pesada só é carregada na primeira chamada, não na construção."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__7",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "O que é o padrão Template Method e como difere do Strategy?",
    "options": [
      "Define o esqueleto de um algoritmo na superclasse, delegando passos específicos a subclasses via herança",
      "Permite trocar algoritmos em runtime via composição",
      "Cria objetos dinamicamente",
      "É igual ao Strategy"
    ],
    "correctIndex": 0,
    "explanation": "Template Method usa herança: superclasse define o algoritmo com 'hooks' que subclasses implementam. Strategy usa composição: algoritmo inteiro é substituído em runtime. Template Method: estrutura fixa, passos variáveis. Strategy: algoritmo inteiramente intercambiável.",
    "example": "Template Method: abstract class DataParser { parse(file) { open(file); extract(); validate(); close(); } abstract extract(); } — CSVParser e JSONParser implementam apenas extract(). A sequência open→extract→validate→close é fixa."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__8",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "O que é o padrão Factory Method e como difere do Abstract Factory?",
    "options": [
      "Factory Method: método de criação que subclasses sobrescrevem para instanciar produtos concretos; Abstract Factory: interface para criar famílias de objetos relacionados sem especificar classes concretas",
      "São idênticos — apenas nomes diferentes para o mesmo padrão de criação",
      "Factory Method cria múltiplos objetos; Abstract Factory cria apenas um por família",
      "Abstract Factory usa herança; Factory Method usa composição de objetos"
    ],
    "correctIndex": 0,
    "explanation": "Factory Method: classe base declara createProduct() abstrato, subclasses concretas decidem qual classe instanciar. Abre extensão sem modificar código existente (OCP). Abstract Factory: interface com múltiplos métodos (createButton(), createTextbox(), createDialog()) para família coerente. MacUIFactory vs WindowsUIFactory — garante componentes da mesma família. Abstract Factory compõe Factory Methods.",
    "example": "Factory Method: Notificador base com createChannel() abstrato. EmailNotificador retorna EmailChannel; SMSNotificador retorna SMSChannel. Abstract Factory: GUIFactory { createButton(); createInput() }. DarkTheme retorna DarkButton + DarkInput coerentes. LightTheme retorna LightButton + LightInput coerentes."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__9",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "O que é o padrão Decorator e quando é preferível ao subclassing (herança)?",
    "options": [
      "Adiciona comportamento a objetos em runtime envolvendo-os (composição); herança é estática e gera explosão de subclasses para cada combinação de comportamentos",
      "É idêntico à herança mas sem reaproveitamento de código da superclasse",
      "Decorator é Singleton que adiciona métodos em runtime; herança cria novos tipos em compile-time",
      "Herança adiciona comportamento em runtime; Decorator é sempre estático"
    ],
    "correctIndex": 0,
    "explanation": "Decorator: envolve objeto existente com mesmo interface, adicionando comportamento. Pode encadear múltiplos decorators. Herança: estática, explosão de subclasses para combinações (Coffee + Leite + Açúcar + Canela = 2⁴ subclasses vs 4 decorators combináveis). Runtime: pode adicionar/remover decorators dinamicamente. Java I/O, Express middlewares, Python @decorator.",
    "example": "Java I/O: new GZIPOutputStream(new BufferedOutputStream(new FileOutputStream(file))) — pipeline de decorators sem subclassing. Python: @lru_cache, @staticmethod, @login_required são decorators. TypeScript: @Log() aplicado em método adiciona logging sem alterar o método original."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__10",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "O que é o padrão Facade e como ele simplifica a interação com subsistemas complexos?",
    "options": [
      "Classe que fornece interface unificada e simplificada para um conjunto de interfaces de subsistemas — oculta a complexidade interna expondo operações de alto nível",
      "Classe que herda de múltiplos subsistemas para combinar funcionalidades",
      "Proxy que intercepta chamadas aos subsistemas para adicionar cache",
      "Adaptador que converte interfaces incompatíveis entre subsistemas"
    ],
    "correctIndex": 0,
    "explanation": "Facade: interface simplificada sobre múltiplas classes/serviços complexos. Cliente usa Facade sem conhecer subsistemas internos. Benefícios: desacoplamento (cliente não depende de subsistemas), simplicidade (uma chamada vs múltiplas). Não adiciona funcionalidade — apenas orquestra. Diferença de Adapter: Adapter converte interfaces; Facade simplifica. Diferença de Mediator: Mediator coordena comunicação bidirecional entre objetos.",
    "example": "class HomeTheaterFacade { constructor(private dvd:DVDPlayer, private amp:Amplifier, private lights:Lights) {} watchMovie(title:string) { this.lights.dim(10); this.amp.setVolume(5); this.dvd.play(title); } endMovie() { this.lights.on(); this.amp.off(); this.dvd.stop(); } } — cliente: theater.watchMovie('Matrix') em vez de 3 chamadas."
  },
  {
    "id": "desenvolvimento__Design Patterns__Médio__11",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Médio",
    "question": "O que é o padrão Builder e quando usá-lo em vez de construtores com muitos parâmetros?",
    "options": [
      "Constrói objetos complexos passo a passo com método encadeado (fluent API); evita construtores telescópicos com muitos parâmetros opcionais",
      "Factory que cria famílias de objetos relacionados sem especificar classes concretas",
      "Padrão que clona objetos existentes para criar novos com pequenas modificações",
      "Singleton que controla a criação para garantir apenas uma instância"
    ],
    "correctIndex": 0,
    "explanation": "Builder: separa construção de objeto complexo da representação. Problema: construtor com 10+ parâmetros, muitos opcionais — difícil lembrar ordem. Builder permite chamar apenas métodos necessários em qualquer ordem. Fluent API: retorna this em cada método para encadear. Variante: Director orquestra a sequência de construção. Usos: query builders, configurações, requests HTTP.",
    "example": "const query = new QueryBuilder().select('name','email').from('users').where('active = true').orderBy('name').limit(10).build(); — vs new Query('name,email','users','active=true',null,'name',10,null,null). Java: User.builder().name('Ana').email('ana@x.com').age(25).build();"
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__1",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "Como o padrão Event Sourcing difere do CRUD tradicional na persistência de dados e quais são seus trade-offs?",
    "options": [
      "Armazena eventos imutáveis em vez de estados atuais; ganha auditoria completa mas aumenta complexidade de queries",
      "Armazena o estado final; ganha simplicidade mas perde histórico",
      "É um pattern de UI, não de persistência",
      "Usa bancos de grafos para armazenar estados"
    ],
    "correctIndex": 0,
    "explanation": "No Event Sourcing, cada mudança é registrada como um evento imutável (ex.: 'PedidoCriado', 'ItemAdicionado', 'PagamentoConfirmado'). O estado atual é reconstituído reproduzindo os eventos. Vantagens: histórico completo, auditoria, temporal queries. Trade-offs: complexidade de leitura (precisa de projeções), volume de dados, eventual consistency.",
    "example": "CRUD: UPDATE accounts SET balance=900 WHERE id=1. Event Sourcing: append { type: 'Debited', amount: 100, accountId: 1 }. O saldo atual é calculado somando todos os eventos da conta."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__2",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre o padrão Facade e o padrão Adapter?",
    "options": [
      "Facade simplifica uma interface complexa; Adapter converte uma interface para outra esperada",
      "São idênticos",
      "Adapter simplifica e Facade converte",
      "Facade é para criação e Adapter para comportamento"
    ],
    "correctIndex": 0,
    "explanation": "Facade fornece uma interface simplificada para um subsistema complexo (múltiplas classes). Adapter converte a interface de uma classe existente para a interface que o cliente espera. Facade reduz complexidade; Adapter resolve incompatibilidade.",
    "example": "Facade: OrderFacade.placeOrder(items) internamente chama InventoryService, PaymentService, ShippingService, NotificationService. Adapter: StripeAdapter converte interface Payment para interface Stripe específica."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__3",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão Repository e como ele se relaciona com Domain-Driven Design?",
    "options": [
      "Abstração que encapsula a lógica de acesso a dados, fazendo o domínio ignorar detalhes de persistência",
      "Repositório Git",
      "Cache de armazenamento",
      "Padrão de UI"
    ],
    "correctIndex": 0,
    "explanation": "No DDD, Repository é a fronteira entre domínio e infraestrutura. Define uma interface (port) com métodos como findById(), save(), delete() que o domínio usa sem saber se os dados vêm de PostgreSQL, MongoDB, API ou memória. Implementação concreta fica na camada de infraestrutura.",
    "example": "interface OrderRepository { findById(id: OrderId): Order; save(order: Order): void; } — Domínio depende dessa interface. PostgresOrderRepository implements OrderRepository na camada de infra."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__4",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão Mediator e qual problema ele resolve?",
    "options": [
      "Centraliza a comunicação entre objetos, reduzindo acoplamento direto entre componentes",
      "Cria conexão direta entre todos os objetos",
      "Padrão de persistência de dados",
      "Padrão para criação de objetos"
    ],
    "correctIndex": 0,
    "explanation": "Mediator encapsula a interação entre um conjunto de objetos em um único lugar. Em vez de A falar com B, C, D diretamente (N² conexões), todos falam com o Mediator (N conexões). Exemplos: chat room, controlador de tráfego aéreo, Redux store.",
    "example": "Sem Mediator: ComponentA chama ComponentB.update() e ComponentC.refresh() diretamente. Com Mediator: ComponentA emite evento para Mediator, que notifica B e C. Adicionar ComponentD não muda A."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__5",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão Chain of Responsibility e como ele funciona?",
    "options": [
      "Encadeia handlers onde cada um decide se processa a requisição ou passa para o próximo",
      "Uma única classe processa tudo",
      "Cadeia de herança entre classes",
      "Padrão para paralelizar processamento"
    ],
    "correctIndex": 0,
    "explanation": "Chain of Responsibility: requisição passa por uma cadeia de handlers. Cada handler decide: processar, modificar e passar, ou rejeitar. Desacopla o emissor dos receptores. Exemplos: middlewares Express, pipeline de validação, filtros de servlet.",
    "example": "Express middlewares: app.use(cors()).use(authMiddleware).use(rateLimiter).use(router) — cada middleware decide se continua (next()) ou interrompe (res.status(401)). Adicionar/remover middleware não afeta outros."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__6",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão Visitor e quando utilizá-lo?",
    "options": [
      "Permite adicionar operações a uma hierarquia de classes sem modificá-las, usando double dispatch",
      "Padrão para rastrear visitantes de um site",
      "Contador de acessos a métodos",
      "Padrão de autenticação"
    ],
    "correctIndex": 0,
    "explanation": "Visitor separa algoritmos das estruturas sobre as quais operam. Cada elemento aceita um visitor que executa a operação específica. Double dispatch: elemento chama visitor.visit(this), visitor tem overload por tipo. Útil para AST (Abstract Syntax Tree), serialização, relatórios.",
    "example": "AST de compilador: nodes IfNode, ForNode, AssignNode. PrintVisitor { visitIf(node), visitFor(node) }. OptimizeVisitor { visitIf(node), visitFor(node) }. Adicionar nova operação (novo visitor) sem alterar os nodes."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__7",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão State e como simplifica lógica condicional complexa?",
    "options": [
      "Encapsula cada estado em uma classe separada, delegando comportamento ao objeto de estado atual",
      "Gerenciador de estado global como Redux",
      "Padrão para banco de dados temporal",
      "Variável que armazena configuração"
    ],
    "correctIndex": 0,
    "explanation": "State: em vez de if/switch gigante verificando estado, cada estado é uma classe com seu próprio comportamento. O contexto delega ao estado atual. Transições: estado atual define para qual estado ir. Elimina condicionais complexas e respeita Open/Closed Principle.",
    "example": "Pedido com estados: Rascunho, Pendente, Pago, Enviado, Entregue. Cada classe implementa: confirmar(), cancelar(), enviar(). DraftState.confirmar() → muda para PendingState. PaidState.cancelar() → inicia reembolso. Sem ifs, cada estado sabe seu comportamento."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__8",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão Command e como ele suporta undo/redo e processamento assíncrono?",
    "options": [
      "Encapsula requisição como objeto (execute, undo); histórico em pilha habilita undo/redo; objetos Command podem ser enfileirados para processamento assíncrono",
      "Controla fluxo de execução com comandos if/else encapsulados em classes",
      "Gerencia pool de threads que executam funções em paralelo com controle",
      "Interface de linha de comando encapsulada em objetos de domínio"
    ],
    "correctIndex": 0,
    "explanation": "Command encapsula ação como objeto com execute() e opcionalmente undo(). Invoker não precisa saber o que o Command faz. Undo stack: pilha de Commands executados; Ctrl+Z: pop + undo(). Redo stack: undo vai para redo stack. Job Queue: serializar Commands, processar assincronamente (trabalhadores). Logging: persistir Commands para replay de auditoria ou recuperação de falhas.",
    "example": "Editor: DigitarText(pos, texto), DeletarChar(pos, char), AplicarNegrito(range). Ctrl+Z: undo() de cada comando na pilha. Redux: cada action é um Command; store = replay de actions = Event Sourcing. Job Queue: EmailCommand enfileirado → Worker processa. AWS SQS: mensagens como Commands persistidos."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__9",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão Strategy e como difere do Template Method?",
    "options": [
      "Strategy: composição — delega algoritmo a objeto separado intercambiável em runtime; Template Method: herança — superclasse define esqueleto, subclasses sobrescrevem steps específicos",
      "Strategy usa herança para delegar; Template Method usa composição para sobrescrição",
      "São intercambiáveis; a escolha é apenas preferência de estilo",
      "Template Method é para algoritmos simples; Strategy só para algoritmos de alta complexidade"
    ],
    "correctIndex": 0,
    "explanation": "Strategy (composição): contexto recebe strategy como dependência injetada (SortStrategy: BubbleSort, QuickSort), pode trocar em runtime, testável isoladamente, aberto a extensão. Template Method (herança): classe abstrata define algoritmo completo com hooks que subclasses sobrescrevem — estrutura fixa, pontos de variação definidos. Herança = acoplamento mais forte.",
    "example": "Strategy: PaymentProcessor { strategy: PaymentStrategy }. Usuário escolhe PIX → injetar PixStrategy; cartão → CreditCardStrategy. Troca em runtime. Template Method: DataImporter.importar() define parse→validate→save. CsvImporter sobrescreve parse(). JsonImporter sobrescreve parse(). Estrutura do algoritmo é fixa."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__10",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão Event Sourcing e como ele difere da persistência tradicional baseada em estado?",
    "options": [
      "Armazena a sequência de eventos que levaram ao estado atual em vez do estado final; o estado é reconstruído fazendo replay dos eventos",
      "Padrão de cache que armazena o último estado e sincroniza periodicamente com o banco",
      "Sistema de filas que processa eventos assincronamente entre microsserviços",
      "Log de auditoria que registra mudanças mas armazena apenas o estado final no banco"
    ],
    "correctIndex": 0,
    "explanation": "CRUD: armazena estado final (UPDATE balance=500). Event Sourcing: armazena eventos imutáveis (DepositMade(200), WithdrawMade(100)). Estado atual = replay de todos os eventos. Vantagens: audit trail completo, temporal queries (estado em qualquer ponto no tempo), undo/redo nativo. Desvantagens: complexidade, event schema evolution, eventual consistency. Snapshots: guardam estado periódico para evitar replay completo.",
    "example": "Conta bancária: eventos [AccountCreated(0), Deposited(1000), Withdrawn(200), Deposited(500)]. Estado atual: replay → 0+1000-200+500 = 1300. Query temporal: 'saldo em 10/jan' → replay até data. Snapshot a cada 1000 eventos: {balance:1000, eventId:1000}. Replay apenas eventos após snapshot. Usado: sistemas financeiros, e-commerce, contabilidade."
  },
  {
    "id": "desenvolvimento__Design Patterns__Difícil__11",
    "track": "desenvolvimento",
    "category": "Design Patterns",
    "difficulty": "Difícil",
    "question": "O que é o padrão Specification e como ele encapsula regras de negócio reutilizáveis em objetos compostos?",
    "options": [
      "Encapsula uma regra de negócio em objeto com método isSatisfiedBy(); permite compor specs com AND, OR, NOT para formar regras complexas reutilizáveis",
      "Define especificação técnica de APIs usando OpenAPI/Swagger para gerar código",
      "Padrão de validação que verifica se dados atendem schema JSON antes de persistir",
      "Interface que especifica métodos obrigatórios para implementação em subclasses"
    ],
    "correctIndex": 0,
    "explanation": "Specification: encapsula regra de negócio em objeto reutilizável. Método principal: isSatisfiedBy(candidate): boolean. Composição: spec1.and(spec2), spec1.or(spec2), spec1.not(). Benefícios: regras de negócio desacopladas do domínio, reutilizáveis (filtragem, validação, query building). DDD: parte da camada de domínio. Pode ser traduzida em SQL WHERE para queries eficientes.",
    "example": "class PremiumUser extends Spec { isSatisfiedBy(u:User) { return u.purchases > 10 && u.totalSpent > 1000; } } class ActiveUser extends Spec { isSatisfiedBy(u:User) { return u.lastLogin > thirtyDaysAgo; } } const eligibleForDiscount = new PremiumUser().and(new ActiveUser()); users.filter(u => eligibleForDiscount.isSatisfiedBy(u));"
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__1",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "Qual comando Git é usado para criar uma cópia local de um repositório remoto?",
    "options": [
      "git clone",
      "git init",
      "git pull",
      "git fork"
    ],
    "correctIndex": 0,
    "explanation": "O 'git clone' cria uma cópia completa de um repositório remoto na máquina local, incluindo todo o histórico de commits, branches e tags. Ele também configura automaticamente o remote 'origin' apontando para o repositório de origem.",
    "example": "git clone https://github.com/user/repo.git — cria a pasta 'repo' localmente com todo o histórico e configura origin automaticamente."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__2",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "Qual comando Git cria uma nova branch e muda para ela ao mesmo tempo?",
    "options": [
      "git checkout -b ou git switch -c",
      "git branch",
      "git merge",
      "git stash"
    ],
    "correctIndex": 0,
    "explanation": "'git checkout -b nova-branch' (ou 'git switch -c nova-branch' na sintaxe moderna) cria uma nova branch a partir do commit atual e muda para ela em um único comando. É equivalente a: git branch nova-branch && git checkout nova-branch.",
    "example": "git switch -c feature/login — cria a branch 'feature/login' a partir do commit atual e muda para ela. 'git branch' lista todas as branches; 'git branch -d feature/login' deleta após merge."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__3",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "O que faz o comando 'git add' e qual é a diferença entre working directory, staging area e repository?",
    "options": [
      "git add move alterações para a staging area; os 3 estágios são: arquivos modificados, prontos para commit e commitados",
      "git add faz o commit diretamente",
      "Só existem 2 estágios",
      "git add envia para o servidor remoto"
    ],
    "correctIndex": 0,
    "explanation": "Working Directory: arquivos modificados localmente. Staging Area (index): alterações marcadas com 'git add', prontas para commit. Repository: histórico de commits permanente após 'git commit'. Esse fluxo de 3 estágios permite escolher quais mudanças incluir em cada commit.",
    "example": "Editou a.js e b.js. git add a.js → apenas a.js vai para staging. git commit -m 'fix a' → commita só a.js. b.js continua no working directory, não commitado."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__4",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "O que é um commit no Git e como escrever boas mensagens de commit?",
    "options": [
      "Snapshot do estado dos arquivos no staging; mensagem deve ser imperativa, curta e descritiva",
      "Upload dos arquivos para o servidor",
      "Backup automático do projeto",
      "Sincronização com repositório remoto"
    ],
    "correctIndex": 0,
    "explanation": "Commit é um snapshot imutável do estado dos arquivos no staging area. Cada commit tem um hash SHA-1 único, referência ao pai, autor e mensagem. Boas mensagens: imperativo ('Adiciona feature X'), curtas (50 chars), com corpo explicando o porquê se necessário.",
    "example": "Ruim: 'fix', 'update', 'changes'. Bom: 'fix: corrige cálculo de frete para pedidos internacionais'. Formato: tipo: descrição curta\n\nCorpo opcional com contexto."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__5",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "O que é o .gitignore e para que serve?",
    "options": [
      "Arquivo que lista padrões de arquivos/pastas que o Git deve ignorar e não rastrear",
      "Arquivo de configuração do GitHub",
      "Lista de branches protegidas",
      "Log de erros do Git"
    ],
    "correctIndex": 0,
    "explanation": ".gitignore define quais arquivos/pastas o Git não deve rastrear. Comum: node_modules/, .env, dist/, *.log, .DS_Store. Adicionado na raiz do projeto. Já rastreados antes de adicionar ao .gitignore continuam rastreados (precisa git rm --cached).",
    "example": "# .gitignore\nnode_modules/\n.env\ndist/\n*.log\n.DS_Store\n\nSe node_modules já foi commitado: git rm -r --cached node_modules && git commit -m 'remove node_modules do tracking'."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__6",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "O que mostra o comando git status?",
    "options": [
      "Estado atual do working directory e staging area: arquivos modificados, adicionados e não rastreados",
      "Histórico de commits",
      "Lista de branches remotas",
      "Configurações do repositório"
    ],
    "correctIndex": 0,
    "explanation": "git status mostra: branch atual, relação com remote (ahead/behind), arquivos modificados (vermelho = unstaged, verde = staged), arquivos não rastreados (untracked). É o comando mais usado para saber o estado do repo antes de add/commit.",
    "example": "git status\nOn branch feature/login\nChanges to be committed: (verde)\n  modified: auth.ts\nChanges not staged: (vermelho)\n  modified: utils.ts\nUntracked files: (vermelho)\n  new-file.ts"
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__7",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "O que é o comando git log e como visualizar o histórico?",
    "options": [
      "Mostra o histórico de commits com hash, autor, data e mensagem",
      "Lista arquivos modificados",
      "Mostra branches remotas",
      "Exibe conflitos de merge"
    ],
    "correctIndex": 0,
    "explanation": "git log mostra commits em ordem cronológica reversa. Opções úteis: --oneline (resumido), --graph (visualizar branches), --author='Ana' (filtrar por autor), -n 5 (limitar a 5), --since='2024-01-01'. git log --all --oneline --graph é a visão mais completa.",
    "example": "git log --oneline --graph --all\n* abc1234 (HEAD -> feature) Adiciona login\n| * def5678 (main) Fix header\n|/\n* 789abcd Initial commit — visualização de branches no terminal."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__8",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre git reset e git revert ao desfazer commits?",
    "options": [
      "git reset remove commits do histórico (reescreve historia, perigoso em repo compartilhado); git revert cria novo commit de reversão (seguro, preserva histórico)",
      "São idênticos em efeito, apenas com sintaxe diferente",
      "git revert apaga arquivos do disco; git reset desfaz apenas o stage",
      "git reset funciona somente em branches locais; revert somente em remotas"
    ],
    "correctIndex": 0,
    "explanation": "git reset --hard HEAD~1: move HEAD para commit anterior, apaga o commit do histórico. Perigoso em branches compartilhadas — reescreve histórico público. git revert HEAD: cria novo commit que reverte as mudanças, histórico intacto e rastreável. Em branches públicas sempre use revert. reset --soft: remove commit mas mantém changes staged.",
    "example": "Commit com senha no código: git reset --hard HEAD~1 + git push --force (avisa equipe!). Já no main compartilhado: git revert abc123 cria 'Revert: remove credentials' — histórico preservado, mais seguro. git revert -n: prepara reversão sem commitar (permite revisar antes)."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__9",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "O que é um branch no Git e por que usar branches por feature?",
    "options": [
      "Ponteiro para um commit que avança com novos commits; branches por feature isolam desenvolvimento paralelo sem interferência na linha principal",
      "Cópia completa do repositório para desenvolvimento de feature isolada",
      "Snapshot imutável do código para marcação de versões de release",
      "Tag especial que agrupa commits relacionados a uma feature"
    ],
    "correctIndex": 0,
    "explanation": "Branch: ponteiro leve (um arquivo com SHA do commit HEAD). main/master: linha estável. Feature branch: dev A cria feature/login, dev B cria feature/pagamento — trabalham em paralelo sem interferência. Merge integra de volta ao main após review. Estratégias: Git Flow (feature/release/hotfix), GitHub Flow (feature → main), Trunk-Based (branches curtas < 1 dia).",
    "example": "Dev A trabalha em feature/login, Dev B em feature/pagamento. Ambos fazem push ao mesmo tempo sem conflito (repositórios de branches isolados). Após review: PR feature/login → main (aprovado, merge). Conflito só acontece se editaram os mesmos arquivos — resolvido na hora do merge/rebase."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__10",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "O que é o comando git stash e quando utilizá-lo durante o desenvolvimento?",
    "options": [
      "Salva temporariamente mudanças não commitadas numa pilha para limpar o working directory; útil para trocar de branch sem perder trabalho em progresso",
      "Apaga permanentemente todas as mudanças não commitadas do repositório",
      "Cria um branch temporário com as mudanças atuais para revisão futura",
      "Comprime o histórico de commits para reduzir o tamanho do repositório"
    ],
    "correctIndex": 0,
    "explanation": "git stash: empilha mudanças (staged e unstaged) numa stash list e limpa working directory. stash pop: recupera e remove da pilha. stash apply: recupera sem remover. stash list: mostra todos os stashes. stash drop: remove um stash. Caso de uso: trabalhando em feature, precisa trocar para branch hotfix urgente sem commitar trabalho incompleto.",
    "example": "Trabalhando em feature/login com código incompleto. Precisa consertar bug em main: git stash → working directory limpo. git checkout main → corrigir bug → commit → push. git checkout feature/login → git stash pop → mudanças restauradas. Stash com mensagem: git stash save 'WIP: login form validation'."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Fácil__11",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Fácil",
    "question": "O que é um arquivo .gitignore e como configurá-lo para excluir arquivos do versionamento?",
    "options": [
      "Arquivo que lista padrões de arquivos/diretórios que o Git deve ignorar no rastreamento; suporta wildcards como *, ** e negação com !",
      "Arquivo que define permissões de acesso ao repositório para cada usuário",
      "Configuração que impede push para branches protegidas no servidor remoto",
      "Script que roda antes de cada commit para validar o código automaticamente"
    ],
    "correctIndex": 0,
    "explanation": ".gitignore: arquivo na raiz do repositório listando padrões a ignorar. Regras: node_modules/ (diretório), *.log (todos .log), !important.log (exceto este), build/ (saída de build), .env (variáveis sensíveis). Globais: ~/.gitignore_global para todos os repos. Já rastreado: git rm --cached arquivo para parar de rastrear. Template: github.com/github/gitignore.",
    "example": ".gitignore: node_modules/ | dist/ | .env | *.log | .DS_Store | coverage/ | .idea/ | *.swp. Arquivo já rastreado antes do .gitignore: git rm --cached .env (remove do tracking mas mantém o arquivo local). git status: arquivos ignorados não aparecem. gitignore.io: gera templates por tecnologia."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__1",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "Qual é a diferença entre 'git merge' e 'git rebase' ao integrar alterações de uma branch?",
    "options": [
      "Merge cria um commit de merge preservando o histórico; rebase reaplica commits sobre a branch alvo, linearizando o histórico",
      "Merge apaga a branch e rebase não",
      "Rebase é mais seguro que merge",
      "Não há diferença no resultado final"
    ],
    "correctIndex": 0,
    "explanation": "Git merge cria um commit de merge (com dois pais), preservando a ramificação no histórico. Git rebase move os commits da branch para o topo da branch alvo, criando um histórico linear. Rebase reescreve hashes dos commits, então não deve ser usado em branches públicas compartilhadas.",
    "example": "git checkout feature && git rebase main — reaplica os commits da feature sobre o último commit de main, como se a feature tivesse sido criada a partir do estado atual de main."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__2",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "O que é um conflito de merge no Git e como resolvê-lo?",
    "options": [
      "Ocorre quando mesmas linhas foram alteradas em branches diferentes; deve ser resolvido manualmente editando os arquivos",
      "Erro irrecuperável que deleta o código",
      "Bug causado pelo GitHub",
      "Acontece apenas com git rebase"
    ],
    "correctIndex": 0,
    "explanation": "Conflito ocorre quando duas branches alteram as mesmas linhas de um arquivo. O Git marca com <<<<<<< HEAD (sua versão), ======= e >>>>>>> branch (a outra versão). Você edita manualmente escolhendo o código correto, remove os marcadores e faz git add + git commit.",
    "example": "<<<<<<< HEAD\nconst color = 'blue';\n=======\nconst color = 'red';\n>>>>>>> feature\n\nVocê decide: const color = 'blue'; (remove os marcadores). git add arquivo.js && git commit."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__3",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "O que é git stash e quando usá-lo?",
    "options": [
      "Salva alterações não commitadas temporariamente para limpar o working directory",
      "Deleta mudanças não salvas",
      "Cria um backup remoto",
      "Faz merge automático"
    ],
    "correctIndex": 0,
    "explanation": "git stash salva mudanças não commitadas em uma pilha temporária e limpa o working directory. Útil quando precisa trocar de branch mas não quer commitar trabalho incompleto. git stash pop restaura as alterações.",
    "example": "Trabalhando na feature, surge bug urgente: git stash → git switch main → corrige bug → git commit → git switch feature → git stash pop → continua trabalhando com as mudanças restauradas."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__4",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "O que é uma Pull Request (PR) / Merge Request (MR) e qual seu papel no fluxo de trabalho?",
    "options": [
      "Solicitação para integrar uma branch na branch principal, permitindo revisão de código antes do merge",
      "Comando do Git para baixar código",
      "Requisição HTTP feita pelo Git",
      "Ferramenta de deploy automático"
    ],
    "correctIndex": 0,
    "explanation": "PR/MR é um recurso de plataformas (GitHub/GitLab/Bitbucket) que propõe integrar mudanças de uma branch em outra. Permite: code review, discussão, CI checks automáticos, aprovações antes do merge. Boas práticas: PRs pequenas, descrição clara, linked issues.",
    "example": "Fluxo: git push origin feature/login → Abre PR no GitHub → Reviewer comenta sugestões → Autor corrige → CI passa → Reviewer aprova → Merge → Branch deletada."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__5",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "Qual a diferença entre git fetch e git pull?",
    "options": [
      "fetch baixa referências remotas sem alterar o working directory; pull faz fetch + merge automaticamente",
      "São idênticos",
      "fetch envia e pull recebe",
      "pull é mais seguro"
    ],
    "correctIndex": 0,
    "explanation": "git fetch: baixa commits/branches do remoto para referências locais (origin/main) sem modificar seus arquivos. git pull: faz git fetch + git merge automaticamente. fetch é mais seguro pois permite inspecionar mudanças antes de integrar.",
    "example": "git fetch origin → atualiza origin/main localmente. git log main..origin/main → vê o que tem de novo. git merge origin/main → integra. Vs git pull origin main → faz tudo de uma vez (pode causar conflito inesperado)."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__6",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "O que é Git Flow e como ele organiza branches no desenvolvimento?",
    "options": [
      "Modelo de branching com main, develop, feature/, release/ e hotfix/ para organizar o ciclo de desenvolvimento",
      "Ferramenta de CI/CD",
      "Alternativa ao Git",
      "Plugin do VS Code"
    ],
    "correctIndex": 0,
    "explanation": "Git Flow: main (produção estável), develop (integração), feature/* (novas features, saem de develop), release/* (preparação de versão), hotfix/* (correções urgentes em produção). Alternativas mais simples: GitHub Flow (main + feature branches) e Trunk-Based Development.",
    "example": "Feature: git flow feature start login → trabalha → git flow feature finish login (merge em develop). Release: git flow release start 1.0.0 → testes → finish (merge em main + develop + tag)."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__7",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "O que é squash merge e quando utilizá-lo?",
    "options": [
      "Combina todos os commits de uma branch em um único commit ao fazer merge, simplificando o histórico",
      "Merge que resolve conflitos automaticamente",
      "Merge que deleta a branch de origem",
      "Merge parcial de alguns commits"
    ],
    "correctIndex": 0,
    "explanation": "Squash merge: git merge --squash feature → combina todas as mudanças da branch em um único commit na branch destino. Histórico fica limpo (1 commit por PR em vez de 20 commits WIP). Trade-off: perde o histórico granular dos commits individuais.",
    "example": "Branch feature com 15 commits: 'WIP', 'fix typo', 'refactor', 'WIP 2'... Squash merge: um único commit 'feat: implementa sistema de login com OAuth' em main. Histórico de main fica limpo e legível."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__8",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "Qual a diferença entre git merge --no-ff e git rebase ao integrar branches?",
    "options": [
      "merge --no-ff cria merge commit preservando histórico da branch; rebase reaplica commits sobre a base gerando histórico linear mas com SHAs reescritos",
      "Produzem resultado idêntico no histórico do repositório",
      "rebase é seguro em branches públicas; merge --no-ff deve ser evitado",
      "merge --no-ff só disponível no GitHub; rebase é apenas local"
    ],
    "correctIndex": 0,
    "explanation": "merge --no-ff: mesmo com fast-forward possível, força criação de merge commit com 2 parents — rastreabilidade da feature branch no histórico. Fast-forward merge: histórico linear, sem merge commit (branch aparece integrada). rebase: pega commits da feature e os reaplica sobre o tip do target com novos SHAs — histórico linear limpo. Regra: nunca rebase branches públicas/compartilhadas (reescreve SHA pode conflitar com histórico de outros).",
    "example": "Feature com 3 commits. merge --no-ff: main recebe merge commit + 3 commits visíveis, git log --graph mostra bifurcação. rebase: 3 commits reescritos com novos SHAs no topo da main (histórico linear). git log --oneline: parece que foram feitos diretamente na main. GitHub Squash and Merge: combina os 3 em 1 commit na main."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__9",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "O que é git cherry-pick e quando é apropriado usá-lo?",
    "options": [
      "Aplica commits específicos de outro branch no branch atual; útil para backport de bugfixes em branches de release sem fazer merge completo",
      "Seleciona aleatoriamente commits para resolver conflitos de merge automaticamente",
      "Desfaz commits selecionados mantendo os demais inalterados",
      "Compara diferenças entre commits específicos para análise de mudanças"
    ],
    "correctIndex": 0,
    "explanation": "git cherry-pick <sha>: copia commit específico, cria novo commit com mesmo diff mas novo SHA. Use quando: bugfix critical no main precisa ser backportado em branches de release v1.x e v2.x; commit acidentalmente feito no branch errado. Cuidado: em branches que serão merged eventualmente, cherry-pick cria commits duplicados (mesmo diff, SHAs diferentes).",
    "example": "Bugfix crítico no main (sha: abc123). Release branches v2.5 e v3.0 precisam do fix. git checkout release/v2.5 && git cherry-pick abc123. git checkout release/v3.0 && git cherry-pick abc123. Cada branch recebe cópia do fix. Ferramentas: git cherry em duas bandas para identificar quais commits foram portados."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__10",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "O que é git bisect e como ele ajuda a encontrar o commit que introduziu um bug usando busca binária?",
    "options": [
      "Comando que faz busca binária no histórico de commits, testando pontos médios até encontrar o commit exato que introduziu o problema",
      "Ferramenta que compara dois branches e lista todas as diferenças entre eles",
      "Comando que reverte múltiplos commits simultaneamente para desfazer uma feature",
      "Análise automática de código que detecta bugs potenciais em qualquer commit"
    ],
    "correctIndex": 0,
    "explanation": "git bisect: busca binária no histórico. 1) git bisect start. 2) git bisect bad (commit atual com bug). 3) git bisect good <sha> (commit antigo sem bug). 4) Git faz checkout do commit do meio → você testa → marca good/bad. 5) Repete até encontrar o commit exato. 100 commits entre good e bad: ~7 testes (log₂ 100). Automatizável: git bisect run <script-de-teste>.",
    "example": "Bug detectado na v2.0 (commit 200), v1.5 (commit 100) funcionava. git bisect start; git bisect bad HEAD; git bisect good abc123. Git faz checkout do commit 150. Teste: bug? 'git bisect bad' → testa 125. Sem bug? 'git bisect good' → testa 137. Após ~7 iterações: 'abc456 is the first bad commit'. Automático: git bisect run npm test."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Médio__11",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Médio",
    "question": "O que é git rebase interativo e como usá-lo para limpar o histórico de commits antes de um merge?",
    "options": [
      "Permite reordenar, editar, juntar (squash) ou remover commits de uma branch interativamente; útil para criar histórico limpo antes de abrir um PR",
      "Visualizador gráfico do histórico que permite navegar entre commits",
      "Comando que automaticamente resolve conflitos entre branches",
      "Ferramenta que compara performance entre diferentes commits"
    ],
    "correctIndex": 0,
    "explanation": "git rebase -i HEAD~N: abre editor com N últimos commits. Ações: pick (manter), squash (juntar com anterior), fixup (squash sem mensagem), edit (parar para editar), reword (mudar mensagem), drop (remover). Caso de uso: 5 commits 'WIP' na feature branch → squash em 1-2 commits semânticos antes do PR. Cuidado: nunca rebase em branch pública/compartilhada (reescreve SHAs).",
    "example": "Branch com commits: 'wip', 'fix typo', 'add login form', 'fix test', 'add validation'. git rebase -i HEAD~5: squash 'wip'+'fix typo'+'add login form' → 'feat: add login form'. squash 'fix test'+'add validation' → 'feat: add form validation'. Resultado: 2 commits limpos. Force push: git push --force-with-lease origin feature/login."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__1",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que é o 'git reflog' e em qual cenário ele é essencial para recuperação de dados?",
    "options": [
      "Registra todas as movimentações do HEAD localmente, permitindo recuperar commits após reset --hard ou branch deletada",
      "É um log remoto sincronizado com o GitHub",
      "Registra apenas merges e conflitos",
      "É um alias para git log --oneline"
    ],
    "correctIndex": 0,
    "explanation": "O git reflog registra cada movimentação do ponteiro HEAD no repositório local (commits, resets, checkouts, rebases). Mesmo após um 'git reset --hard' que parece apagar commits, eles permanecem acessíveis via reflog por 90 dias, permitindo recuperação com 'git checkout' ou 'git reset' para o hash encontrado.",
    "example": "Acidentalmente: git reset --hard HEAD~5. Recuperação: git reflog → encontra 'abc1234 HEAD@{1}: commit: feature X'. git reset --hard abc1234 → restaura os 5 commits perdidos."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__2",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que é git bisect e como ele ajuda a encontrar o commit que introduziu um bug?",
    "options": [
      "Busca binária no histórico de commits para encontrar o commit que introduziu a regressão",
      "Divide o repositório em dois",
      "Cria duas branches",
      "Faz merge bissetorial"
    ],
    "correctIndex": 0,
    "explanation": "git bisect usa busca binária no histórico: você marca um commit 'bad' (com bug) e um 'good' (sem bug). O Git faz checkout do commit do meio e pergunta se é bom ou ruim. Repetindo, encontra o commit exato em O(log n) passos, mesmo em históricos com milhares de commits.",
    "example": "git bisect start → git bisect bad (commit atual tem bug) → git bisect good v1.0 (v1.0 não tinha). Git faz checkout do meio. Você testa: git bisect good/bad. Após ~10 passos em 1000 commits, encontra o culpado."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__3",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre git reset, git revert e git restore e quando usar cada um?",
    "options": [
      "reset move HEAD/branch para trás; revert cria commit inverso; restore restaura arquivos do working tree",
      "São sinônimos",
      "Todos desfazem commits igualmente",
      "reset é remoto e revert local"
    ],
    "correctIndex": 0,
    "explanation": "git reset: move HEAD/branch para commit anterior (reescreve histórico, perigoso em branch compartilhada). git revert: cria novo commit que desfaz mudanças de um commit específico (seguro, preserva histórico). git restore: restaura arquivos no working directory ou staging sem alterar commits.",
    "example": "Branch local só sua: git reset --hard HEAD~1 (apaga último commit). Branch compartilhada: git revert abc123 (cria commit que desfaz abc123 sem reescrever histórico). Descartar mudança em arquivo: git restore arquivo.ts."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__4",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que são Git Hooks e como podem ser usados para automação?",
    "options": [
      "Scripts executados automaticamente em eventos Git como pre-commit, pre-push e commit-msg",
      "Webhooks do GitHub",
      "Plugins do VS Code",
      "Atalhos de teclado para Git"
    ],
    "correctIndex": 0,
    "explanation": "Git Hooks: scripts em .git/hooks/ executados em eventos. pre-commit: lint/format antes de commitar. commit-msg: validar formato da mensagem. pre-push: rodar testes antes de push. Husky: ferramenta que facilita configuração de hooks no package.json.",
    "example": "Com Husky + lint-staged: pre-commit hook roda ESLint e Prettier apenas nos arquivos alterados. Commit rejeitado se lint falhar. npx husky add .husky/pre-commit 'npx lint-staged'."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__5",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que é cherry-pick no Git e quando utilizá-lo?",
    "options": [
      "Aplica um commit específico de outra branch na branch atual, sem fazer merge completo",
      "Seleciona arquivos para staging",
      "Remove commits do histórico",
      "Copia uma branch inteira"
    ],
    "correctIndex": 0,
    "explanation": "git cherry-pick: copia um commit específico (pelo hash) para a branch atual, criando um novo commit com as mesmas mudanças. Útil para: aplicar hotfix de uma branch em outra, portar features específicas sem merge completo. Cuidado: pode criar commits duplicados.",
    "example": "Bug fix commitado na branch hotfix (hash abc123). Precisa do fix em develop também: git switch develop && git cherry-pick abc123 → aplica apenas aquele commit, sem trazer tudo da branch hotfix."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__6",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que é interactive rebase (git rebase -i) e como usá-lo para limpar o histórico?",
    "options": [
      "Permite reordenar, editar, combinar (squash) e remover commits interativamente antes de push",
      "Rebase automático sem intervenção",
      "Ferramenta gráfica do GitHub",
      "Modo de resolução de conflitos"
    ],
    "correctIndex": 0,
    "explanation": "git rebase -i HEAD~N abre editor com últimos N commits. Ações: pick (manter), squash (combinar com anterior), fixup (squash sem mensagem), edit (pausar para alterar), reword (mudar mensagem), drop (remover). Reescreve hashes — só usar em commits não pushados.",
    "example": "git rebase -i HEAD~4:\npick abc1234 feat: login page\nsquash def5678 fix typo in login\nsquash ghi9012 WIP login\npick jkl3456 feat: signup page\n→ Resultado: 2 commits limpos em vez de 4."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__7",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que são Git submodules e quando utilizá-los?",
    "options": [
      "Repositórios Git aninhados dentro de outro repositório, referenciados por commit específico",
      "Módulos Node.js gerenciados pelo Git",
      "Branches automatizadas",
      "Plugins do Git para IDEs"
    ],
    "correctIndex": 0,
    "explanation": "Submodules permitem incluir um repositório Git dentro de outro, fixando uma versão específica (commit hash). Útil para: bibliotecas compartilhadas entre projetos, dependências que você precisa modificar, monorepo com repos independentes. Alternativa moderna: Git subtree.",
    "example": "git submodule add https://github.com/org/shared-lib.git libs/shared → cria referência ao repo externo. git submodule update --init --recursive → clona/atualiza. .gitmodules registra URL e path."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__8",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que é git reflog e como ele recupera commits após um reset --hard?",
    "options": [
      "Log de todos os movimentos do HEAD incluindo após reset; permite recuperar SHAs de commits que não aparecem mais no git log mas ainda estão no object store",
      "Log de erros e conflitos de merge registrados pelo Git automaticamente",
      "Histórico de operações de push e pull entre repositório local e remoto",
      "Backup automático de todos os commits antes e depois de qualquer operação destrutiva"
    ],
    "correctIndex": 0,
    "explanation": "git reflog: registra cada posição do HEAD (commit, checkout, reset, rebase, merge). Git não deleta objetos imediatamente — garbage collection ocorre após ~90 dias. Recuperar: git reflog mostra HEAD@{N}: commit ABC. Encontrar SHA anterior ao reset. git reset --hard SHA ou git checkout -b recovery SHA. Objetos 'órfãos' (sem branch apontando) ficam no object store até GC.",
    "example": "git reset --hard HEAD~3 — 3 commits perdidos! git reflog → HEAD@{0}: reset (atual), HEAD@{1}: commit 'feature login', HEAD@{2}: commit 'add tests', HEAD@{3}: commit 'fix bug'. git reset --hard HEAD@{3} ou git checkout -b recovery HEAD@{3}. Commits recuperados. Salvar SHA antes de operações destrutivas!"
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__9",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que são Git Hooks e quais são mais usados em pipelines de CI/CD?",
    "options": [
      "Scripts executados automaticamente em eventos Git; pre-commit (lint/format), commit-msg (valida mensagem), pre-push (testes); post-receive no servidor para deploy",
      "Extensões do GitHub Actions para automação de workflows",
      "Tags especiais que marcam pontos de deploy no histórico",
      "Configurações de branch protection no repositório remoto"
    ],
    "correctIndex": 0,
    "explanation": "Git hooks: scripts em .git/hooks/ executados em eventos. Client-side: pre-commit (ESLint, Prettier, testes rápidos), prepare-commit-msg, commit-msg (Conventional Commits validation), post-commit, pre-push (testes completos). Server-side: pre-receive (validar, rejeitar push), update, post-receive (trigger deploy). Ferramentas de compartilhamento: Husky (Node), pre-commit (Python), lefthook.",
    "example": "Husky + lint-staged: pre-commit roda ESLint e Prettier somente em arquivos staged (rápido). commitlint no commit-msg: valida 'feat: mensagem' (Conventional Commits). pre-push: npm test. post-receive no servidor: docker build + kubectl rollout. Resultado: erros básicos bloqueados localmente antes do push, sem desperdiçar CI."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__10",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "O que são Git worktrees e como permitem trabalhar em múltiplas branches simultaneamente sem stash ou clone?",
    "options": [
      "Cria diretórios de trabalho adicionais vinculados ao mesmo repositório, cada um em branch diferente — permite alternar sem trocar de branch no diretório principal",
      "Cria cópias completas (clones) independentes do repositório para cada branch",
      "Subdiretórios dentro do repositório que contêm submódulos de outros projetos",
      "Branches temporárias criadas automaticamente pelo sistema de CI/CD para testes paralelos"
    ],
    "correctIndex": 0,
    "explanation": "git worktree: múltiplos working directories ligados ao mesmo .git. Cada worktree em branch diferente. Vantagem sobre git stash: não precisa salvar/restaurar; sobre clone: compartilha histórico e objects (economia de espaço). Uso: hotfix urgente enquanto trabalha em feature, code review de PR enquanto desenvolve, comparar versões lado a lado.",
    "example": "Trabalhando em feature/login: git worktree add ../hotfix-branch main → cria diretório ../hotfix-branch na branch main. cd ../hotfix-branch → corrigir bug → commit/push → cd ../meu-projeto (feature/login intacta). git worktree list: mostra todos. git worktree remove ../hotfix-branch: limpa. Cada worktree tem seu HEAD, index e working tree."
  },
  {
    "id": "desenvolvimento__Git e Versionamento__Difícil__11",
    "track": "desenvolvimento",
    "category": "Git e Versionamento",
    "difficulty": "Difícil",
    "question": "Como funciona o modelo de objetos internos do Git (blobs, trees, commits, tags) e o que é o object store?",
    "options": [
      "Git armazena tudo como objetos endereçados por hash SHA-1: blob (conteúdo de arquivo), tree (diretório), commit (snapshot + metadata + parent) e tag (referência nomeada a commit)",
      "Git usa banco de dados SQL interno para armazenar histórico de commits e branches",
      "Git comprime arquivos em formato ZIP e armazena diffs entre versões consecutivas",
      "Git mantém cópia completa de cada versão de cada arquivo em diretórios separados por data"
    ],
    "correctIndex": 0,
    "explanation": "Object store (.git/objects): content-addressable storage. Blob: conteúdo de arquivo (sem nome). Hash (SHA-1) do conteúdo → se dois arquivos são idênticos, mesmo blob. Tree: lista de entradas (mode, name, hash) — representa diretório. Commit: referência a tree (snapshot), author, committer, message, parent(s). Tag: referência nomeada a commit (annotated tag tem mensagem). Pack files: objetos comprimidos com delta compression para economia de espaço.",
    "example": "git cat-file -p HEAD → tree abc123, parent def456, author Ana. git cat-file -p abc123 (tree) → 100644 blob aaa111 README.md, 040000 tree bbb222 src/. git cat-file -p aaa111 (blob) → conteúdo do README.md. Renomear arquivo: novo tree aponta para mesmo blob (conteúdo inalterado). git count-objects: número de objects no store."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__1",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "Qual é a diferença entre 'let' e 'const' na declaração de variáveis em JavaScript?",
    "options": [
      "let permite reatribuição; const cria uma referência que não pode ser reatribuída",
      "let é para números e const para strings",
      "const é mais lento que let",
      "Não há diferença funcional"
    ],
    "correctIndex": 0,
    "explanation": "A palavra-chave 'let' declara uma variável com escopo de bloco que pode ser reatribuída. 'const' declara uma variável com escopo de bloco cuja referência não pode ser reatribuída após a inicialização. Porém, objetos e arrays declarados com const ainda podem ter suas propriedades/elementos modificados.",
    "example": "const arr = [1, 2, 3]; arr.push(4); // OK — modifica conteúdo. arr = [5]; // TypeError — não pode reatribuir a referência."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__2",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que é uma Promise em JavaScript e para que ela serve?",
    "options": [
      "Objeto que representa o resultado futuro de uma operação assíncrona (sucesso ou falha)",
      "Função que executa imediatamente",
      "Tipo de loop",
      "Método de array"
    ],
    "correctIndex": 0,
    "explanation": "Promise é um objeto que pode estar em 3 estados: pending (aguardando), fulfilled (resolvida com valor) ou rejected (rejeitada com erro). Usa .then() para sucesso, .catch() para erro, ou async/await para sintaxe mais legível.",
    "example": "fetch('/api/users').then(res => res.json()).then(users => console.log(users)).catch(err => console.error(err)); // Ou com async/await: const users = await fetch('/api/users').then(r => r.json());"
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__3",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "Qual é a diferença entre '==' e '===' em JavaScript?",
    "options": [
      "=== compara valor e tipo (strict); == converte tipos antes de comparar (loose)",
      "São idênticos",
      "=== é mais lento",
      "== é para strings e === para números"
    ],
    "correctIndex": 0,
    "explanation": "== (igualdade solta) faz coercão de tipos antes de comparar, podendo gerar resultados inesperados. === (igualdade estrita) compara valor E tipo sem coercão. Boas práticas: sempre usar === para evitar bugs subtís.",
    "example": "0 == '' // true (ambos viram 0). 0 === '' // false (number ≠ string). null == undefined // true. null === undefined // false. Sempre use ===!"
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__4",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que é o operador spread (...) em JavaScript e quais seus usos?",
    "options": [
      "Expande elementos de arrays/objetos; usado para cópias, combinação e desestruturação",
      "Operador de divisão",
      "Criação de variáveis globais",
      "Loop infinito"
    ],
    "correctIndex": 0,
    "explanation": "Spread (...) expande itens de arrays ou propriedades de objetos. Usos: cópia rasa ([...arr]), combinação ([...a, ...b]), atualização imutável ({ ...obj, key: newVal }), rest params (function(...args)). Fundamental para imutabilidade em React.",
    "example": "const a = [1,2]; const b = [...a, 3]; // [1,2,3]. const user = { name: 'Ana' }; const updated = { ...user, age: 25 }; // { name: 'Ana', age: 25 }. Original intacto."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__5",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que é async/await em JavaScript e como simplifica código assíncrono?",
    "options": [
      "Sintaxe que permite escrever código assíncrono de forma semelhante a síncrono, usando Promises por baixo",
      "Substitui completamente Promises",
      "Cria threads paralelas",
      "Funciona apenas no Node.js"
    ],
    "correctIndex": 0,
    "explanation": "async marca uma função como assíncrona (retorna Promise). await pausa a execução até a Promise resolver, sem bloquear a thread. Torna o código mais legível que .then() encadeado. Tratamento de erro: try/catch em vez de .catch().",
    "example": "// Com .then():\nfetch(url).then(r => r.json()).then(data => console.log(data));\n// Com async/await:\nconst r = await fetch(url); const data = await r.json(); console.log(data); — muito mais legível."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__6",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que são template literals (template strings) em JavaScript?",
    "options": [
      "Strings delimitadas por crases (`) que suportam interpolação de expressões com ${} e múltiplas linhas",
      "Strings normais com aspas simples",
      "Templates HTML",
      "Funções de formatação"
    ],
    "correctIndex": 0,
    "explanation": "Template literals usam crases (`) e permitem interpolação de expressões com ${expr}. Suportam múltiplas linhas sem \\n. Tagged templates permitem processar a string com uma função (ex: html`<p>${text}</p>`, sql`SELECT * FROM ${table}`).",
    "example": "const name = 'Ana'; const age = 28;\nConcat: 'Olá ' + name + ', você tem ' + age + ' anos.'\nTemplate: `Olá ${name}, você tem ${age} anos.` — mais legível e suporta expressões: ${age + 1}."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__7",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que é desestruturação (destructuring) em JavaScript?",
    "options": [
      "Sintaxe que extrai valores de arrays ou propriedades de objetos em variáveis individuais",
      "Método para destruir objetos da memória",
      "Função para deletar propriedades",
      "Técnica de compressão de dados"
    ],
    "correctIndex": 0,
    "explanation": "Destructuring extrai dados de arrays e objetos de forma concisa. Em objetos: { name, age } = user. Em arrays: [first, second] = arr. Suporta valores padrão ({ name = 'Anônimo' }), renomeação ({ name: userName }) e aninhamento.",
    "example": "const { name, age } = { name: 'Ana', age: 28 }; // name='Ana', age=28\nconst [first, ...rest] = [1, 2, 3, 4]; // first=1, rest=[2,3,4]\nfunction greet({ name, age = 0 }) { } // destructuring em parâmetros."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__8",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que é hoisting em JavaScript e como var, let e const se comportam diferentemente?",
    "options": [
      "Declarações são movidas ao topo do escopo em compilação; var é hoisted e inicializado com undefined; let e const ficam em Temporal Dead Zone (TDZ) até declaração",
      "Nenhuma declaração é hoisted em JavaScript moderno (ES6+)",
      "var, let e const têm comportamento idêntico com hoisting, diferindo apenas em escopo",
      "Somente funções arrow são sofrem hoisting; funções declaration não"
    ],
    "correctIndex": 0,
    "explanation": "Hoisting: engine JS move declarações ao topo (não inicializações). var: hoisted e inicializado com undefined — acessível antes da linha de declaração (retorna undefined). let/const: hoisted mas entram em Temporal Dead Zone (TDZ) — ReferenceError se acessados antes da declaração. Function declaration: hoisted completamente com corpo. Function expression (const fn = ...) segue regras da variável.",
    "example": "console.log(x); var x = 5; → undefined (não ReferenceError). console.log(y); let y = 5; → ReferenceError: Cannot access 'y' before initialization (TDZ). funcao(); function funcao(){} → OK (hoisted). funcaoExpr(); const funcaoExpr = () => {}; → ReferenceError (TDZ de const)."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__9",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que é o event loop do JavaScript e por que setTimeout(fn, 0) não executa imediatamente?",
    "options": [
      "Event loop processa callbacks da task queue somente após a call stack estar vazia; setTimeout(fn, 0) coloca fn na task queue, executada após todo código síncrono atual",
      "setTimeout(fn, 0) executa fn imediatamente em thread separada paralela ao código principal",
      "Event loop é uma thread separada que roda código assíncrono simultâneo ao síncrono",
      "Microtasks (Promises) e tasks (setTimeout) são processadas na mesma fila de forma intercalada"
    ],
    "correctIndex": 0,
    "explanation": "JS é single-threaded (1 call stack). Event loop: Web APIs (timers, fetch) executam em background. Ao terminar, callbacks vão para Task Queue (setTimeout, setInterval) ou Microtask Queue (Promise.then, queueMicrotask). Event loop: call stack vazia → drena TODA microtask queue → processa 1 task. setTimeout(fn, 0) = task, executada após código síncrono atual e promises pendentes.",
    "example": "console.log('A'); setTimeout(() => console.log('B'), 0); Promise.resolve().then(() => console.log('C')); console.log('D'); Ordem: A, D, C, B. A e D: síncrono. C: microtask (Promise). B: task (setTimeout). Microtasks sempre antes de tasks. setTimeout de 100ms também aguarda stack vazia antes de executar."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__10",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que são os operadores spread (...) e rest (...) em JavaScript e como diferenciam pelo contexto de uso?",
    "options": [
      "Spread expande iteráveis em elementos individuais (chamada/literal); rest coleta múltiplos argumentos em um array (declaração de função/desestruturação)",
      "Spread e rest são o mesmo operador e sempre se comportam de forma idêntica",
      "Spread cria deep copy de objetos; rest converte arrays em objetos",
      "Spread só funciona com arrays; rest só com objetos"
    ],
    "correctIndex": 0,
    "explanation": "Spread (...): expande. Em arrays: [...arr1, ...arr2] (concatenar). Em objetos: {...obj, key: 'new'} (copiar e sobrescrever). Em chamadas: func(...args). Rest (...): coleta. Em parâmetros: function f(a, ...rest) {} — rest é array com argumentos restantes. Em desestruturação: const [first, ...others] = [1,2,3] → others=[2,3]. Spread = desempacotar; Rest = empacotar.",
    "example": "Spread: const merged = [...[1,2], ...[3,4]] → [1,2,3,4]. const user2 = {...user, name:'Bob'} → cópia com name alterado. Math.max(...[5,2,8]) → 8. Rest: function sum(...nums) { return nums.reduce((a,b)=>a+b); } sum(1,2,3) → 6. const {a, ...rest} = {a:1,b:2,c:3} → rest={b:2,c:3}."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Fácil__11",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Fácil",
    "question": "O que é o operador ternário em JavaScript e como usá-lo como alternativa concisa ao if/else?",
    "options": [
      "Expressão condicional com sintaxe condição ? valorSeTrue : valorSeFalse; retorna um valor e pode ser usada em atribuições e JSX",
      "Operador que testa três condições sequencialmente e retorna a primeira verdadeira",
      "Função que aceita três argumentos e retorna o maior entre eles",
      "Bloco condicional que substitui switch/case para exatamente três opções"
    ],
    "correctIndex": 0,
    "explanation": "Ternário: expressão (não statement) que avalia condição e retorna um dos dois valores. condição ? exprVerdadeira : exprFalsa. Vantagem: conciso para atribuições condicionais simples. Evitar: aninhamento excessivo (difícil de ler). Em JSX/React: usado diretamente na renderização condicional. Pode ser encadeado mas legibilidade sofre.",
    "example": "const status = age >= 18 ? 'adulto' : 'menor'; const greeting = isLoggedIn ? `Olá, ${name}` : 'Olá, visitante'; JSX: {isLoading ? <Spinner /> : <Content />}. Evitar: const x = a ? b ? c : d : e ? f : g; — use if/else para clareza. Nullish: const val = input ?? 'default'; (melhor que ternário para null/undefined)."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__1",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "No TypeScript, qual é a diferença entre 'interface' e 'type alias' para declarar tipos de objetos?",
    "options": [
      "Interfaces podem ser estendidas com extends e são abertas a declaration merging; types usam interseção e são fechados",
      "Types são mais rápidos em compilação",
      "Interfaces não suportam métodos",
      "Não há diferença alguma desde o TS 4.0"
    ],
    "correctIndex": 0,
    "explanation": "Interfaces usam 'extends' para herança e suportam declaration merging (declarar a mesma interface duas vezes combina os membros). Types usam '&' para interseção e não suportam merging. Types são mais versáteis (unions, mapped types, etc.). Para objetos simples, ambos funcionam de forma equivalente.",
    "example": "interface User { name: string } interface User { age: number } // Merge: User tem name e age. type User2 = { name: string } & { age: number } // Interseção: mesmo resultado, mas sem merging."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__2",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que é o Event Loop no JavaScript e como ele gerencia operações assíncronas?",
    "options": [
      "Mecanismo que executa código síncrono na call stack e processa callbacks assíncronos da fila quando a stack esvazia",
      "Thread pool igual a Java",
      "Compilador JIT",
      "Gerenciador de memória"
    ],
    "correctIndex": 0,
    "explanation": "JavaScript é single-threaded. O Event Loop verifica: 1) a call stack está vazia? 2) Se sim, pega a próxima callback da microtask queue (Promises) ou macrotask queue (setTimeout, I/O). Microtasks têm prioridade. Isso permite assincronismo sem threads.",
    "example": "console.log('1'); setTimeout(() => console.log('2'), 0); Promise.resolve().then(() => console.log('3')); console.log('4'); → Saída: 1, 4, 3, 2. Síncrono primeiro, depois microtask (Promise), depois macrotask (setTimeout)."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__3",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "No TypeScript, o que são Generics e qual problema eles resolvem?",
    "options": [
      "Tipos parametrizáveis que permitem reutilizar lógica mantendo type safety para diferentes tipos",
      "Tipos que aceitam qualquer valor (any)",
      "Classes genéricas de UI",
      "Funções sem retorno"
    ],
    "correctIndex": 0,
    "explanation": "Generics permitem criar funções, classes e interfaces que funcionam com múltiplos tipos mantendo type safety. Ao invés de usar 'any' (perde tipagem), você parametriza o tipo com <T> e o TypeScript infere ou o chamador especifica o tipo concreto.",
    "example": "function first<T>(arr: T[]): T | undefined { return arr[0]; } first([1,2,3]) → retorno é number | undefined. first(['a','b']) → retorno é string | undefined. Type safety preservada!"
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__4",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que é o conceito de hoisting em JavaScript?",
    "options": [
      "Comportamento onde declarações de var e function são movidas para o topo do escopo antes da execução",
      "Otimização do compilador",
      "Método de ordenação",
      "Garbage collection"
    ],
    "correctIndex": 0,
    "explanation": "Hoisting: declarações var e function são 'elevadas' ao topo do escopo durante a compilação. var é hoisted como undefined; function é hoisted inteiramente. let/const são hoisted mas ficam em 'temporal dead zone' até a declaração (ReferenceError se acessar antes).",
    "example": "console.log(x); var x = 5; // undefined (var hoisted, valor não). console.log(y); let y = 5; // ReferenceError (TDZ). greet(); function greet() { } // OK (function hoisted inteira)."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__5",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que são Higher-Order Functions em JavaScript?",
    "options": [
      "Funções que recebem outras funções como argumento ou retornam funções",
      "Funções que rodam mais rápido",
      "Funções com mais de 3 parâmetros",
      "Funções assíncronas"
    ],
    "correctIndex": 0,
    "explanation": "Higher-Order Functions (HOF) tratam funções como valores: recebem como argumento (callback) ou retornam funções. Exemplos nativos: map, filter, reduce, forEach. Padrão funcional que permite composição e reutilização.",
    "example": "const double = (arr) => arr.map(x => x * 2); // map é HOF, recebe função. function multiplier(factor) { return (n) => n * factor; } // retorna função. const triple = multiplier(3); triple(5); // 15."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__6",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que são optional chaining (?.) e nullish coalescing (??) em JavaScript/TypeScript?",
    "options": [
      "?. acessa propriedades de forma segura retornando undefined se nulo; ?? fornece valor padrão apenas para null/undefined",
      "Operadores matemáticos",
      "Operadores de comparação",
      "Operadores de atribuição"
    ],
    "correctIndex": 0,
    "explanation": "Optional chaining (?.) evita erros ao acessar propriedades de objetos potencialmente null/undefined: user?.address?.city retorna undefined em vez de TypeError. Nullish coalescing (??) retorna o lado direito apenas se o esquerdo for null/undefined (diferente de || que trata 0 e '' como falsy).",
    "example": "const city = user?.address?.city ?? 'Não informada'; — se user, address ou city forem null/undefined, retorna 'Não informada'. Com ||: 0 ?? 'default' = 0 (correto), 0 || 'default' = 'default' (errado se 0 é válido)."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__7",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que são Utility Types no TypeScript como Partial, Pick e Omit?",
    "options": [
      "Tipos genéricos nativos que transformam tipos existentes: tornam opcionais, selecionam ou excluem propriedades",
      "Bibliotecas de funções utilitárias",
      "Tipos exclusivos para React",
      "Plugins do TypeScript"
    ],
    "correctIndex": 0,
    "explanation": "Partial<T>: todas as props opcionais. Required<T>: todas obrigatórias. Pick<T,K>: seleciona props específicas. Omit<T,K>: exclui props. Record<K,V>: cria tipo com chaves K e valores V. Readonly<T>: props somente leitura. Evitam duplicação de tipos.",
    "example": "type User = { name: string; email: string; age: number };\ntype UserUpdate = Partial<User>; // tudo opcional\ntype UserPreview = Pick<User, 'name' | 'email'>; // só name e email\ntype UserWithoutAge = Omit<User, 'age'>; // exclui age"
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__8",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que são Generics em TypeScript e como diferem de usar o tipo any?",
    "options": [
      "Generics preservam informação de tipo com parâmetros de tipo <T>; any descarta type safety completamente — generics permitem reuso sem perder verificação em compile-time",
      "Generics são alias de tipo documentais; any é tipo especial que bypassa erros de runtime",
      "São equivalentes em segurança; Generics apenas têm sintaxe mais verbosa",
      "any é mais performático em runtime pois evita checagens de tipo dinâmico"
    ],
    "correctIndex": 0,
    "explanation": "Generics: parâmetros de tipo (<T>) criam código reutilizável com preservação de tipos. TypeScript infere T na maioria dos casos. Com any: inferência de tipos perdida, erros só aparecem em runtime. unknown: tipo seguro para valores desconhecidos (exige type guard antes de usar). Constraints: <T extends Comparable> restringe T a tipos que implementam Comparable.",
    "example": "function primeiro<T>(arr: T[]): T { return arr[0]; }. primeiro([1,2,3]): retorna number. primeiro(['a','b']): retorna string. TypeScript detecta erros em compile-time. Com any: function primeiro(arr: any[]): any — primeiro(['a','b']).toFixed() compila mas falha em runtime. Generic evita esse bug."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__9",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que são Promises e como async/await simplifica o código assíncrono?",
    "options": [
      "Promise representa valor futuro com estados pending/fulfilled/rejected; async/await é açúcar sintático sobre Promises que permite escrever código assíncrono como síncrono com try/catch",
      "Promise é callback avançado síncrono; async/await cria threads reais em paralelo",
      "async/await substitui Promises completamente e são mecanismos independentes",
      "Promises são para I/O de disco; async/await para operações de rede"
    ],
    "correctIndex": 0,
    "explanation": "Promise: estados — pending (aguardando), fulfilled (resolvida), rejected (falhou). .then()/.catch()/.finally() encadeiam operações. async/await: função async retorna Promise implicitamente, await pausa execução até Promise resolver (sem bloquear call stack). try/catch captura rejeições. Promise.all([p1,p2]): executa em paralelo, aguarda todos. Promise.race: primeiro a resolver vence.",
    "example": "Callback hell aninhado: getUser(id, (u) => getPosts(u.id, (p) => getComments(p[0].id, fn))). async/await: const user = await getUser(id); const posts = await getPosts(user.id); const comments = await getComments(posts[0].id). Paralelo: const [user, config] = await Promise.all([getUser(id), getConfig()])."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__10",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que são Map e Set em JavaScript e quando usá-los em vez de objetos simples e arrays?",
    "options": [
      "Map: coleção chave-valor com chaves de qualquer tipo e ordem de inserção preservada; Set: coleção de valores únicos com lookup O(1) — ambos superam objetos/arrays em cenários específicos",
      "Map e Set são wrappers de objetos e arrays sem benefícios de performance",
      "Map aceita apenas strings como chave; Set permite duplicatas mas ordena automaticamente",
      "Map e Set são imutáveis por padrão e não permitem adição de novos elementos"
    ],
    "correctIndex": 0,
    "explanation": "Map vs objeto: chaves de qualquer tipo (objetos, funções), size nativo, iterável com ordem, sem prototype pollution. Set vs array: valores únicos garantidos, has() O(1) vs includes() O(n). Map: new Map([[key,val]]); .set(k,v), .get(k), .has(k), .delete(k), .size. Set: new Set([1,2,2,3]) → {1,2,3}; .add(v), .has(v), .delete(v). WeakMap/WeakSet: chaves com referência fraca (GC-friendly).",
    "example": "Map com chave objeto: const cache = new Map(); const key = {id:1}; cache.set(key, 'data'); cache.get(key) → 'data'. Objeto não aceita chave objeto (converte para '[object Object]'). Set para deduplicar: [...new Set([1,2,2,3,3])] → [1,2,3]. Set para intersecção: new Set([...setA].filter(x => setB.has(x)))."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Médio__11",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Médio",
    "question": "O que são Generics em TypeScript e como eles permitem criar funções e classes reutilizáveis com type safety?",
    "options": [
      "Parâmetros de tipo que permitem definir funções/classes que operam com qualquer tipo mantendo type safety — o tipo concreto é definido no uso, não na declaração",
      "Tipos que aceitam qualquer valor como 'any' mas com melhor performance",
      "Templates de código que geram múltiplas versões de funções em compile-time",
      "Interfaces que definem contratos genéricos para qualquer classe implementar"
    ],
    "correctIndex": 0,
    "explanation": "Generics: <T> é parâmetro de tipo. function identity<T>(val: T): T { return val; } — sem generic, usaria any (perde type safety) ou escreveria uma versão para cada tipo. Com generic: identity<string>('hello') retorna string; identity<number>(42) retorna number. Inferência: identity('hello') — TS infere T=string. Constraints: <T extends HasLength> limita tipos aceitos. Usado em: Array<T>, Promise<T>, Map<K,V>.",
    "example": "function first<T>(arr: T[]): T | undefined { return arr[0]; } first([1,2,3]) → tipo: number. first(['a','b']) → tipo: string. Sem generic: function first(arr: any[]): any — perde tipo de retorno. Constraint: function longest<T extends {length:number}>(a:T, b:T): T { return a.length >= b.length ? a : b; } longest('abc','de') → 'abc' (tipo string preservado)."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__1",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "No TypeScript, como os 'conditional types' com 'infer' permitem extrair tipos de dentro de outros tipos genéricos?",
    "options": [
      "Usam a keyword infer dentro de extends para capturar e reutilizar sub-tipos em tempo de compilação",
      "Usam typeof em runtime para detectar tipos",
      "Dependem de reflection como em Java",
      "Usam decorators para anotar tipos em execução"
    ],
    "correctIndex": 0,
    "explanation": "Conditional types com 'infer' permitem pattern matching em tipos. A sintaxe T extends SomeType<infer U> ? U : never captura o tipo U se T corresponder ao padrão. É computado inteiramente em tempo de compilação sem impacto no runtime.",
    "example": "type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never; type Result = ReturnType<() => string>; // Result = string — extrai o tipo de retorno da função."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__2",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que são closures em JavaScript e como elas funcionam?",
    "options": [
      "Funções que 'lembram' do ambiente léxico onde foram criadas, mantendo acesso a variáveis externas",
      "Funções que se auto-executam",
      "Métodos de array",
      "Tipo de promise"
    ],
    "correctIndex": 0,
    "explanation": "Closure é a combinação de uma função com o ambiente léxico (variáveis do escopo) onde foi criada. Mesmo após a função externa terminar, a função interna mantém acesso às variáveis do escopo pai. Usada em encapsulamento, factories e callbacks.",
    "example": "function counter() { let count = 0; return { inc: () => ++count, get: () => count }; } const c = counter(); c.inc(); c.inc(); c.get(); // 2. 'count' é privada, acessível apenas via closure."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__3",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "No TypeScript, o que são Mapped Types e como eles permitem transformar tipos existentes?",
    "options": [
      "Tipos que iteram sobre propriedades de outro tipo aplicando transformações, gerando novos tipos",
      "Tipos que mapeiam para banco de dados",
      "Tipos de arrays",
      "Tipos de funções"
    ],
    "correctIndex": 0,
    "explanation": "Mapped Types usam 'in keyof' para iterar sobre propriedades de um tipo e aplicar transformações. Utility types nativos como Partial<T>, Required<T>, Readonly<T> e Pick<T,K> são implementados com mapped types. Permitem criar novos tipos derivados de existentes.",
    "example": "type Readonly<T> = { readonly [K in keyof T]: T[K] }; type Partial<T> = { [K in keyof T]?: T[K] }; type ReadonlyUser = Readonly<User>; // Todas as props de User viram readonly."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__4",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que é o padrão Module em JavaScript e como closures são usadas para encapsulamento?",
    "options": [
      "Padrão que usa IIFE e closures para criar escopo privado, expondo apenas uma API pública",
      "Import/export do ES6",
      "Design pattern para banco de dados",
      "Ferramenta de bundling"
    ],
    "correctIndex": 0,
    "explanation": "Module Pattern: IIFE que retorna um objeto com métodos públicos. Variáveis dentro da IIFE são privadas (closure). Antes de ES Modules, era a principal forma de encapsulamento. Hoje usado em configurações e bibliotecas que precisam de estado privado.",
    "example": "const counter = (() => { let count = 0; return { inc: () => ++count, get: () => count }; })(); counter.inc(); counter.get(); // 1. 'count' é privado — inacessível fora da closure."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__5",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que é o TypeScript Discriminated Union e como ele permite narrowing seguro?",
    "options": [
      "Union com campo literal comum (discriminante) que permite ao compilador narrowing automático em switch/if",
      "União de strings",
      "Array de tipos diferentes",
      "Enum numérico"
    ],
    "correctIndex": 0,
    "explanation": "Discriminated Union: cada membro tem um campo literal único (type: 'circle' | type: 'square'). O TS usa esse campo para narrowing em switch/if, sabendo exatamente quais propriedades estão disponíveis. Exhaustiveness check com never no default.",
    "example": "type Shape = { type: 'circle'; radius: number } | { type: 'square'; side: number }; function area(s: Shape) { switch(s.type) { case 'circle': return Math.PI * s.radius ** 2; case 'square': return s.side ** 2; } } — TS sabe que s.radius existe no case 'circle'."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__6",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que é o objeto Proxy em JavaScript e quais seus casos de uso?",
    "options": [
      "Wrapper que intercepta operações fundamentais em objetos (get, set, delete) via handlers chamados traps",
      "Servidor proxy de rede",
      "Cache de requisições HTTP",
      "Design pattern igual ao GoF Proxy"
    ],
    "correctIndex": 0,
    "explanation": "Proxy cria um objeto que intercepta operações em outro objeto alvo. Traps: get (leitura), set (escrita), has (in), deleteProperty, apply (chamada de função). Usos: validação reativa, logging, lazy loading, observabilidade. Vue 3 usa Proxy para reatividade.",
    "example": "const handler = { set(target, prop, value) { console.log(`${prop} mudou para ${value}`); target[prop] = value; return true; } }; const state = new Proxy({}, handler); state.count = 1; // loga: 'count mudou para 1'. Base da reatividade do Vue 3."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__7",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que são Template Literal Types no TypeScript e como criam tipos dinâmicos?",
    "options": [
      "Tipos que usam template string syntax para criar uniões de strings dinâmicas em tempo de compilação",
      "Strings tipadas em runtime",
      "Templates para geração de código",
      "Validação de strings em runtime"
    ],
    "correctIndex": 0,
    "explanation": "Template Literal Types combinam strings literais com uniões para criar novos tipos: `on${Capitalize<Event>}` gera 'onClick' | 'onHover' | 'onFocus'. Poderoso para APIs type-safe com padrões de nomenclatura. Usado em libs como Prisma e tRPC.",
    "example": "type Event = 'click' | 'hover' | 'focus';\ntype Handler = `on${Capitalize<Event>}`; // 'onClick' | 'onHover' | 'onFocus'\ntype CSSProperty = `${string}-${string}`; // aceita 'font-size', 'margin-top', etc.\ntype Getter<T> = `get${Capitalize<T & string>}`;"
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__8",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que são tipos condicionais (Conditional Types) em TypeScript e como NonNullable é implementado?",
    "options": [
      "Tipos que resolvem para diferentes tipos baseado em condição T extends U ? X : Y; NonNullable<T> = T extends null | undefined ? never : T eliminando nulos da union",
      "Operador ternário aplicado a valores em tempo de execução pelo engine TypeScript",
      "Tipos que mudam conforme configurações do strictNullChecks no tsconfig.json",
      "Union types com narrowing de tipo em condicional if/else explícito"
    ],
    "correctIndex": 0,
    "explanation": "Conditional Types: T extends U ? X : Y. Distributive: aplicado a union T distribui — (A|B) extends U ? X : Y = (A extends U ? X : Y) | (B extends U ? X : Y). Infer: extrai tipos dentro da condição. ReturnType<T> = T extends (...args: any) => infer R ? R : never. never em union é absorvido. NonNullable<string | null | undefined> = string.",
    "example": "type Flatten<T> = T extends Array<infer Item> ? Item : T. Flatten<string[]> = string; Flatten<number> = number. type ReturnType<T extends (...a: any) => any> = T extends (...a: any) => infer R ? R : never. ReturnType<() => string> = string. Usado extensivamente em tipos utilitários da lib padrão do TS."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__9",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que é o objeto Proxy em JavaScript e quais são as interceptações (traps) disponíveis?",
    "options": [
      "new Proxy(target, handler) intercepta operações em objetos via traps (get, set, has, apply, construct, deleteProperty...); base de sistemas reativos como Vue 3",
      "Objeto de proxy de rede HTTP para interceptar requisições no browser",
      "Design pattern Proxy criado explicitamente para logging e auditoria de objetos",
      "Método de clonagem profunda de objetos complexos com transformação de propriedades"
    ],
    "correctIndex": 0,
    "explanation": "Proxy ES6: new Proxy(target, handler). Traps: get (leitura), set (escrita), has (operador in), deleteProperty, apply (chamada de função), construct (new), getPrototypeOf, setPrototypeOf, ownKeys, defineProperty, isExtensible, preventExtensions. Vue 3 substituiu Object.defineProperty (Vue 2) por Proxy para melhor reatividade (detecta adição de propriedades, delete, array index).",
    "example": "Validação: const handler = { set(target, prop, value) { if (prop === 'age' && !Number.isInteger(value)) throw TypeError('age deve ser inteiro'); target[prop] = value; return true; } }. Vue 3: reactive({count: 0}) cria Proxy; count++ interceptado por set trap → notifica dependentes → re-render automático dos componentes."
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__10",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que é o padrão de Inversion of Control (IoC) em TypeScript e como decorators facilitam injeção de dependência?",
    "options": [
      "IoC inverte quem cria dependências: em vez da classe instanciar suas deps, um container externo as injeta — decorators (@Injectable, @Inject) marcam classes e parâmetros para resolução automática",
      "IoC é um padrão de controle de fluxo que inverte a ordem de execução de callbacks",
      "Decorators criam instâncias singleton automaticamente sem necessidade de container",
      "IoC substitui imports de módulos por carregamento dinâmico em runtime"
    ],
    "correctIndex": 0,
    "explanation": "IoC: framework/container controla a criação e injeção de dependências. Sem IoC: class UserService { constructor() { this.repo = new PostgresRepo(); } } — acoplado. Com IoC: @Injectable() class UserService { constructor(private repo: UserRepository) {} } — container resolve UserRepository para a implementação registrada. Benefícios: testabilidade (mock fácil), flexibilidade (trocar implementação sem alterar código). Ferramentas TS: TSyringe, InversifyJS, NestJS.",
    "example": "NestJS: @Injectable() class UserService { constructor(private repo: UserRepository) {} } @Module({ providers: [{ provide: UserRepository, useClass: PostgresRepo }] }) class AppModule {}. Em teste: { provide: UserRepository, useClass: MockRepo }. TSyringe: @injectable() class A { constructor(@inject('IRepo') private repo: IRepo) {} }. container.register('IRepo', { useClass: PostgresRepo });"
  },
  {
    "id": "desenvolvimento__JavaScript e TypeScript__Difícil__11",
    "track": "desenvolvimento",
    "category": "JavaScript e TypeScript",
    "difficulty": "Difícil",
    "question": "O que são Branded Types (tipos nominais) em TypeScript e como eles previnem mistura acidental de tipos compatíveis?",
    "options": [
      "Técnica que adiciona uma propriedade phantom (brand) ao tipo para criar tipos estruturalmente distintos — impede usar UserId onde OrderId é esperado mesmo ambos sendo string",
      "Tipos nativos do TypeScript que diferenciam classes por nome ao invés de estrutura",
      "Enums com valores string que servem como identificadores únicos de tipo",
      "Wrappers de classe que encapsulam tipos primitivos para adicionar métodos"
    ],
    "correctIndex": 0,
    "explanation": "TypeScript é estrutural: type UserId = string; type OrderId = string; são intercambiáveis. Branded type: type UserId = string & { __brand: 'UserId' }. Agora UserId ≠ OrderId estruturalmente. Criação: function userId(id: string): UserId { return id as UserId; }. Previne: getUser(orderId) — erro de compilação. Custo zero em runtime (brand não existe em JS). Alternativa: unique symbol como brand.",
    "example": "type UserId = string & { readonly __brand: unique symbol }; type OrderId = string & { readonly __brand: unique symbol }; function createUserId(id: string): UserId { return id as UserId; } function getUser(id: UserId) { ... } const uid = createUserId('u1'); const oid = createOrderId('o1'); getUser(uid); // OK. getUser(oid); // Erro: OrderId não é UserId. getUser('raw'); // Erro: string não é UserId."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__1",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "Qual conceito de POO permite que uma classe filha herde atributos e métodos de uma classe pai?",
    "options": [
      "Herança",
      "Encapsulamento",
      "Polimorfismo",
      "Abstração"
    ],
    "correctIndex": 0,
    "explanation": "Herança é o mecanismo pelo qual uma classe (filha/subclasse) pode reutilizar atributos e métodos de outra classe (pai/superclasse), promovendo reuso de código. A classe filha pode adicionar novos membros ou sobrescrever comportamentos herdados.",
    "example": "class Animal { mover() { } } class Cachorro extends Animal { latir() { } } — Cachorro herda o método mover() de Animal e adiciona latir()."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__2",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que é encapsulamento em POO e qual sua importância?",
    "options": [
      "Ocultar detalhes internos de um objeto, expondo apenas uma interface pública controlada",
      "Colocar tudo em uma única classe",
      "Criptografar atributos",
      "Usar apenas métodos estáticos"
    ],
    "correctIndex": 0,
    "explanation": "Encapsulamento esconde a implementação interna (atributos privados) e expõe apenas métodos públicos controlados. Protege contra uso indevido, permite mudar a implementação sem afetar código externo e garante consistência dos dados (validação no setter).",
    "example": "class ContaBancaria { private saldo = 0; depositar(valor: number) { if (valor > 0) this.saldo += valor; } getSaldo() { return this.saldo; } } — 'saldo' só é acessível via métodos, que validam o valor."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__3",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que é polimorfismo e qual é um exemplo prático?",
    "options": [
      "Capacidade de objetos de tipos diferentes responderem à mesma mensagem de formas distintas",
      "Ter múltiplas heranças",
      "Criar múltiplas instâncias",
      "Usar variáveis globais"
    ],
    "correctIndex": 0,
    "explanation": "Polimorfismo permite que diferentes classes implementem o mesmo método de maneiras diferentes. O código que chama o método não precisa saber o tipo concreto — cada objeto responde conforme sua implementação. Tipos: sobrescrita (override) e sobrecarga (overload).",
    "example": "function calcularArea(forma: Forma): number { return forma.area(); } — funciona com Circle, Rectangle, Triangle. Cada um implementa area() de forma diferente. O código chamador é o mesmo."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__4",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que é abstração em POO e como ela simplifica a complexidade?",
    "options": [
      "Esconder detalhes complexos de implementação e expor apenas o essencial para o usuário",
      "Criar classes vazias",
      "Programar sem variáveis",
      "Usar apenas interfaces"
    ],
    "correctIndex": 0,
    "explanation": "Abstração foca no 'quê' e esconde o 'como'. O usuário de uma classe não precisa saber como ela funciona internamente — só precisa conhecer a interface pública. Reduz complexidade cognitiva e permite mudanças internas sem impactar quem usa.",
    "example": "carro.ligar() — o motorista não precisa saber como função, injeção, ignição funcionam internamente. Mesma ideia: array.sort() — você não precisa saber se usa quicksort ou timsort."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__5",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que é uma classe em POO e qual a relação com objetos?",
    "options": [
      "Classe é o molde/blueprint; objeto é a instância concreta criada a partir da classe",
      "Classe e objeto são a mesma coisa",
      "Objeto é o molde e classe a instância",
      "Classes só existem em Java"
    ],
    "correctIndex": 0,
    "explanation": "Classe: template que define atributos (dados) e métodos (comportamento). Objeto: instância concreta de uma classe com valores específicos. Uma classe pode gerar múltiplos objetos. Analogia: classe = planta da casa; objeto = casa construída.",
    "example": "class User { name: string; constructor(name: string) { this.name = name; } } const user1 = new User('Ana'); const user2 = new User('Bob'); — User é a classe, user1 e user2 são objetos."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__6",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que é um construtor (constructor) em POO e para que serve?",
    "options": [
      "Método especial chamado automaticamente ao criar uma instância, usado para inicializar atributos",
      "Método para destruir objetos",
      "Função estática da classe",
      "Tipo de herança"
    ],
    "correctIndex": 0,
    "explanation": "O constructor é executado automaticamente quando se usa 'new'. Inicializa atributos do objeto com valores passados como parâmetros. Em TypeScript, pode usar atalho: constructor(public name: string) declara e inicializa o atributo em uma linha.",
    "example": "class Car { brand: string; year: number; constructor(brand: string, year: number) { this.brand = brand; this.year = year; } } const car = new Car('Toyota', 2024); // constructor chamado com 'Toyota' e 2024."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__7",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre métodos de instância e métodos estáticos?",
    "options": [
      "Métodos de instância operam sobre o objeto (this); estáticos pertencem à classe e não precisam de instância",
      "São idênticos",
      "Estáticos são mais lentos",
      "Métodos de instância não podem acessar atributos"
    ],
    "correctIndex": 0,
    "explanation": "Método de instância: chamado em um objeto, acessa 'this' (atributos do objeto). Método estático: chamado na classe diretamente (Classe.metodo()), sem acesso a 'this'. Usado para utilitários e factories que não dependem de estado da instância.",
    "example": "class MathUtils { static add(a: number, b: number) { return a + b; } } MathUtils.add(2, 3); // 5, sem new.\nclass User { greet() { return `Olá, ${this.name}`; } } new User('Ana').greet(); // precisa de instância."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__8",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que é encapsulamento em POO e qual o papel dos modificadores de acesso?",
    "options": [
      "Ocultar detalhes de implementação e expor apenas interface pública; private (só na própria classe), protected (classe e subclasses), public (todos)",
      "Técnica de compressão de dados para otimizar uso de memória em objetos",
      "Herdar comportamento do pai mantendo os dados da classe filha privados",
      "Agrupar objetos com mesmo tipo em coleções encapsuladas"
    ],
    "correctIndex": 0,
    "explanation": "Encapsulamento: estado interno escondido, interação apenas via métodos públicos definidos. Benefícios: controle de invariantes (setter valida antes de alterar), liberdade de mudar implementação sem quebrar consumidores, redução de acoplamento. private: inacessível externamente. protected: acessível em subclasses. public: parte da interface pública.",
    "example": "class ContaBancaria { private saldo = 0; depositar(v: number) { if (v <= 0) throw Error('Valor inválido'); this.saldo += v; } sacar(v: number) { if (v > this.saldo) throw Error('Saldo insuficiente'); this.saldo -= v; } getSaldo() { return this.saldo; } }. Saldo nunca fica negativo — invariante garantida pelo encapsulamento."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__9",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que é herança em POO e qual problema a herança profunda pode causar?",
    "options": [
      "Subclasse reutiliza código e tipo da superclasse; herança profunda (muitos níveis) gera fragilidade — mudança na base quebra subclasses distantes (Fragile Base Class Problem)",
      "Subclasse compartilha instâncias com a superclasse para economizar memória",
      "Técnica de copiar métodos de uma classe para outra sem relação hierárquica",
      "Padrão que permite múltiplas superclasses em todas as linguagens OOP"
    ],
    "correctIndex": 0,
    "explanation": "Herança: subclasse herda estado e comportamento da superclasse (relação 'é-um'). Fragilidade: mudança em método da classe base pode quebrar subclasses que dependem do comportamento antigo. Herança profunda (5+ níveis) dificulta rastreamento de onde comportamento vem. Regra: máximo 2-3 níveis; preferir composição para hierarquias mais profundas.",
    "example": "Animal→Mamifero→Animal Domestico→Pet→Cachorro. Adicionar validação no construtor de Animal quebra todos os 5 níveis se não esperada. Änderung em Mamifero.respirar() pode quebrar Cachorro.respirar() silenciosamente. Solução: compor comportamentos (Respiravel, Domesticavel) ao invés de herança profunda."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__10",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que é o conceito de herança em POO e qual a diferença entre herança simples e múltipla?",
    "options": [
      "Herança permite que uma classe filha reutilize atributos e métodos da classe pai; simples herda de uma classe, múltipla de várias — múltipla causa o problema do diamante",
      "Herança é a capacidade de um objeto se transformar em outro tipo em runtime",
      "Herança simples permite apenas métodos; múltipla permite atributos e métodos",
      "Herança só funciona entre interfaces, não entre classes concretas"
    ],
    "correctIndex": 0,
    "explanation": "Herança: classe filha (subclasse) herda comportamentos da classe pai (superclasse) com 'extends'. Simples: uma superclasse (Java, C#, TS). Múltipla: várias superclasses (C++, Python). Problema do diamante: classe herda de B e C que herdam de A — qual versão do método de A usar? Python resolve com MRO (Method Resolution Order, C3 Linearization). Java/C#/TS: interfaces (implements) não causam diamante pois não têm implementação (até default methods).",
    "example": "class Animal { eat() {} } class Dog extends Animal { bark() {} } — Dog herda eat(). Diamante (Python): class A: def greet(): 'A'. class B(A): def greet(): 'B'. class C(A): def greet(): 'C'. class D(B,C): pass. D().greet() → 'B' (MRO: D→B→C→A). C++: class D : public B, public C — ambíguo, requer virtual inheritance."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Fácil__11",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Fácil",
    "question": "O que são métodos getters e setters em POO e por que encapsular acesso a atributos privados?",
    "options": [
      "Métodos que controlam leitura (get) e escrita (set) de atributos privados, permitindo validação, cálculos derivados e proteção da invariante do objeto",
      "Funções estáticas que serializam e desserializam objetos para JSON",
      "Decorators que convertem métodos em propriedades computadas acessíveis diretamente",
      "Constantes que definem os valores padrão iniciais de cada atributo"
    ],
    "correctIndex": 0,
    "explanation": "Getters/Setters: encapsulam acesso a campos internos. Benefícios: 1) Validação: setter verifica se valor é válido antes de atribuir. 2) Computação: getter calcula valor derivado sob demanda. 3) Proteção: invariantes do objeto mantidas (ex: saldo nunca negativo). 4) Evolução: mudar implementação interna sem quebrar API pública. TypeScript/JS: get/set como property accessors. Java: getX()/setX().",
    "example": "class BankAccount { private _balance = 0; get balance() { return this._balance; } set balance(value: number) { if (value < 0) throw Error('Saldo negativo'); this._balance = value; } } const acc = new BankAccount(); acc.balance = 100; // OK via setter. acc.balance = -50; // Error. console.log(acc.balance); // 100 via getter."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__1",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "Qual é a diferença entre classe abstrata e interface em linguagens como Java e TypeScript?",
    "options": [
      "Classe abstrata pode ter métodos implementados e estado; interface define apenas contratos sem implementação",
      "Interface pode ter construtores e abstrata não",
      "Classe abstrata não pode ter métodos abstratos",
      "Não há diferença prática"
    ],
    "correctIndex": 0,
    "explanation": "Uma classe abstrata pode conter métodos implementados (com corpo), atributos com estado e construtores, mas não pode ser instanciada diretamente. Uma interface define apenas a assinatura dos métodos (contrato), sem implementação ou estado. Em Java, uma classe pode implementar múltiplas interfaces mas estender apenas uma classe abstrata.",
    "example": "abstract class Shape { color: string; abstract area(): number; describe() { return `Shape: ${this.color}`; } } interface Drawable { draw(): void; } class Circle extends Shape implements Drawable { area() { ... } draw() { ... } }"
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__2",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que é composição em POO e por que geralmente é preferida sobre herança?",
    "options": [
      "Construir objetos combinando outros objetos como componentes internos, oferecendo mais flexibilidade que herança",
      "Tipo de herança múltipla",
      "Padrão de criação de singletons",
      "Método de otimização"
    ],
    "correctIndex": 0,
    "explanation": "Composição usa relação 'tem-um' (has-a) em vez de 'é-um' (is-a). Vantagens sobre herança: evita hierarquias rígidas, permite trocar comportamentos em runtime, não herda métodos desnecessários, e permite combinar funcionalidades de múltiplas fontes sem herança múltipla.",
    "example": "Herança: class Car extends Engine {} (carro NÃO é motor). Composição: class Car { engine: Engine; gps: GPS; } (carro TEM motor e GPS). Pode trocar Engine por ElectricEngine em runtime."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__3",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que são interfaces em TypeScript/Java e qual seu papel em POO?",
    "options": [
      "Contratos que definem quais métodos uma classe deve implementar, sem fornecer implementação",
      "Classes com todos métodos implementados",
      "Tipo de herança",
      "Templates de UI"
    ],
    "correctIndex": 0,
    "explanation": "Interfaces definem um contrato: quais métodos e propriedades um objeto deve ter. Não contêm implementação. Uma classe que implementa uma interface DEVE fornecer todos os métodos declarados. Permite programar para abstrações em vez de implementações concretas.",
    "example": "interface Notifier { send(message: string): void; } class EmailNotifier implements Notifier { send(msg) { /* envia email */ } } class SMSNotifier implements Notifier { send(msg) { /* envia SMS */ } } — código usa Notifier, não sabe se é email ou SMS."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__4",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que é o princípio DIP (Dependency Inversion Principle) do SOLID?",
    "options": [
      "Módulos de alto nível não devem depender de módulos de baixo nível; ambos devem depender de abstrações",
      "Inverter a ordem de execução das funções",
      "Usar dependência circular",
      "Remover todas as interfaces"
    ],
    "correctIndex": 0,
    "explanation": "DIP: dependa de abstrações (interfaces), não de implementações concretas. O módulo de alto nível (regra de negócio) define a interface que precisa; o módulo de baixo nível (infra) implementa. Injeção de dependência é a técnica para aplicar DIP.",
    "example": "Sem DIP: OrderService cria new MySQLRepository() diretamente. Com DIP: OrderService recebe OrderRepository (interface) no construtor. Pode injetar MySQLRepository ou MongoRepository sem mudar OrderService."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__5",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que é o conceito de coerência (cohesion) e acoplamento (coupling) em POO?",
    "options": [
      "Coesão alta: classe focada em uma responsabilidade. Acoplamento baixo: classes com pouca dependência entre si",
      "São sinônimos",
      "Coesão é sobre UI e acoplamento sobre backend",
      "Ambos devem ser altos"
    ],
    "correctIndex": 0,
    "explanation": "Coesão: quão relacionados são os membros de uma classe entre si (alta = bom). Acoplamento: quão dependente uma classe é de outras (baixo = bom). Meta: alta coesão + baixo acoplamento = classes focadas e independentes, fáceis de manter e testar.",
    "example": "Alta coesão: UserRepository só lida com persistência de User. Baixa coesão: UserManager valida, persiste, envia email e gera relatório. Baixo acoplamento: OrderService depende de interface PaymentGateway, não de Stripe diretamente."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__6",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que é Injeção de Dependência (Dependency Injection) e como funciona?",
    "options": [
      "Técnica onde dependências são fornecidas externamente ao objeto em vez de criadas internamente",
      "Instalar pacotes npm",
      "Importar módulos com import",
      "Criar singleton de banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "DI: em vez da classe criar suas dependências (new MySQLRepo()), ela as recebe por parâmetro do construtor, setter ou interface. Vantagens: testabilidade (injetar mock), flexibilidade (trocar implementação), respeita DIP (SOLID). Frameworks: NestJS, Spring, Angular.",
    "example": "Sem DI: class OrderService { repo = new MySQLRepo(); } — acoplado ao MySQL.\nCom DI: class OrderService { constructor(private repo: OrderRepository) {} } — recebe qq implementação. No teste: new OrderService(new MockRepo())."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__7",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que são mixins em POO e como funcionam em TypeScript?",
    "options": [
      "Padrão que adiciona funcionalidades a uma classe sem herança clássica, combinando múltiplos comportamentos",
      "Tipo de herança múltipla nativa",
      "Método de mesclagem de arrays",
      "Framework de CSS"
    ],
    "correctIndex": 0,
    "explanation": "Mixins permitem compor uma classe com funcionalidades de múltiplas fontes, contornando a limitação de herança simples. Em TypeScript: funções que recebem uma classe base e retornam uma nova classe com comportamento adicional. Alternativa a herança múltipla.",
    "example": "function Timestamped<T extends Constructor>(Base: T) { return class extends Base { createdAt = new Date(); }; }\nfunction Activatable<T extends Constructor>(Base: T) { return class extends Base { active = false; }; }\nclass User extends Timestamped(Activatable(BaseEntity)) {} — User ganha createdAt e active."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__8",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que é composição versus herança e quando preferir composição em POO?",
    "options": [
      "Herança: relação 'é-um' com acoplamento forte; composição: relação 'tem-um' delegando a colaboradores; preferir composição para evitar hierarquias rígidas e explosão de subclasses",
      "Herança é sempre mais reutilizável; composição somente para objetos sem relação de tipo",
      "São equivalentes em todos os aspectos; escolha é puramente estilística",
      "Composição é exclusiva de linguagens funcionais que não suportam herança"
    ],
    "correctIndex": 0,
    "explanation": "'Favoreça composição sobre herança' (GoF): herança expõe internals da superclasse (acoplamento forte), hierarquias rígidas e difíceis de modificar, Fragile Base Class Problem. Composição: objeto contém colaboradores como membros, delega comportamento, pode trocar implementação em runtime (Strategy), mais testável (mock de colaboradores). Herança válida quando relação 'é-um' é semântica e estável.",
    "example": "Explosão de herança: Duck extends Bird; FlyingDuck, SwimmingDuck, FlyingSwimmingDuck. O que herda? Composição: duck = new Duck({ fly: new DroneFlyer(), swim: new DuckSwimmer() }). Pinguin: { fly: new NoFlight(), swim: new DivingSwim() }. Comportamentos trocados injetando implementações."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__9",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "Qual a diferença entre classe abstrata e interface em TypeScript e quando usar cada uma?",
    "options": [
      "Classe abstrata: pode ter estado e implementação parcial, estendida por uma subclasse; interface: só define contrato sem estado, implementada por múltiplas classes",
      "São completamente intercambiáveis no TypeScript moderno",
      "Interface pode ter campos de instância; classe abstrata não pode ter campos",
      "Classe abstrata pode ser instanciada diretamente; interface nunca pode ser implementada por classes concretas"
    ],
    "correctIndex": 0,
    "explanation": "Classe abstrata: campos, construtores, métodos concretos e abstratos. Subclasse usa extends (apenas uma). Use quando há código compartilhado real entre subclasses. Interface: apenas assinaturas de métodos e tipos (TypeScript permite default methods em interfaces? Não — apenas declarações). Classe usa implements (múltiplas). Use para definir capabilities/contratos sem impor hierarquia.",
    "example": "abstract class Conversor { abstract converter(d: any): string; logar(msg: string) { console.log(msg); } } — JsonConversor e CsvConversor herdam log() e implementam converter(). interface Serializavel { serializar(): string; } — User e Product implementam sem herança forçada. TypeScript verifica em compile-time."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__10",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que é o princípio de substituição de Liskov (LSP) e como sua violação causa bugs em hierarquias de classes?",
    "options": [
      "Subclasses devem ser substituíveis por suas superclasses sem alterar a corretude do programa — violação: subclasse muda comportamento esperado ou lança exceções inesperadas",
      "Classes com o mesmo nome em módulos diferentes devem ser intercambiáveis",
      "Superclasses devem poder substituir subclasses em qualquer contexto",
      "Toda classe abstrata deve ter pelo menos uma implementação concreta"
    ],
    "correctIndex": 0,
    "explanation": "LSP (Liskov Substitution Principle): se S é subtipo de T, objetos de T podem ser substituídos por S sem alterar propriedades do programa. Violação clássica: class Retângulo { setLargura(); setAltura(); } class Quadrado extends Retângulo { setLargura(v) { largura=v; altura=v; } } — setLargura num quadrado altera altura, quebrando expectativas de quem usa Retângulo. Solução: evitar herança, usar composição ou interfaces separadas.",
    "example": "function calcularArea(r: Retangulo) { r.setLargura(5); r.setAltura(4); assert(r.area() === 20); } — passa para Retangulo, FALHA para Quadrado (5×5=25 ou 4×4=16). LSP violado: Quadrado não é substituível. Solução: interface Shape { area(): number; } class Retangulo implements Shape {...} class Quadrado implements Shape {...} — sem herança problemática."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Médio__11",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Médio",
    "question": "O que são mixins em POO e como resolvem o problema de reutilização de comportamento sem herança múltipla?",
    "options": [
      "Classes parciais que adicionam comportamentos específicos a outras classes via composição; permitem combinar funcionalidades sem hierarquia rígida de herança",
      "Interfaces com implementação padrão que substituem classes abstratas",
      "Padrão de design que injeta dependências em runtime usando reflection",
      "Funções utilitárias estáticas agrupadas em um namespace compartilhado"
    ],
    "correctIndex": 0,
    "explanation": "Mixins: reutilizar comportamento sem herança. Em TS: função que recebe uma classe base e retorna classe estendida com novos métodos. Em Python: class com métodos a serem 'mixados' via herança múltipla (ordem importa: MRO). Diferença de interface: mixin tem implementação. Diferença de herança: mixin é composição de comportamentos, não relação 'é-um'. Uso: adicionar serialização, logging, timestamping a classes diversas.",
    "example": "TS: function Timestamped<T extends Constructor>(Base: T) { return class extends Base { createdAt = new Date(); updatedAt = new Date(); } } function Serializable<T extends Constructor>(Base: T) { return class extends Base { toJSON() { return JSON.stringify(this); } } } class User extends Timestamped(Serializable(BaseEntity)) {} — User tem createdAt, updatedAt e toJSON()."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__1",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "Qual princípio SOLID é violado quando uma classe pai tem um método que uma subclasse precisa sobrescrever para lançar uma exceção, tornando a substituição insegura?",
    "options": [
      "Liskov Substitution Principle (LSP)",
      "Single Responsibility Principle (SRP)",
      "Open/Closed Principle (OCP)",
      "Interface Segregation Principle (ISP)"
    ],
    "correctIndex": 0,
    "explanation": "O LSP afirma que objetos de uma subclasse devem poder substituir objetos da superclasse sem alterar o comportamento esperado do programa. Se Square herda de Rectangle mas sobrescreve setWidth para lançar exceção ou alterar setHeight junto, o código que espera um Rectangle quebrará ao receber um Square.",
    "example": "class Bird { fly() { } } class Penguin extends Bird { fly() { throw new Error('Não voo'); } } — função feedBird(b: Bird) { b.fly(); } quebra com Penguin. Solução: interface FlyingBird separada."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__2",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é o princípio ISP (Interface Segregation Principle) do SOLID?",
    "options": [
      "Clientes não devem depender de interfaces com métodos que não usam; prefira interfaces específicas e enxutas",
      "Cada interface deve ter o máximo de métodos",
      "Interfaces devem ser herdadas",
      "Segregar significa juntar"
    ],
    "correctIndex": 0,
    "explanation": "ISP: em vez de uma interface 'gorda' com muitos métodos, crie várias interfaces pequenas e específicas. Assim, cada classe implementa apenas os métodos que realmente usa, evitando dependências desnecessárias e implementações vazias.",
    "example": "Ruim: interface Worker { work(); eat(); sleep(); } — robô precisa implementar eat() e sleep() vazios. Bom: interface Workable { work(); } interface Feedable { eat(); } — robô implementa só Workable."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__3",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é o padrão de double dispatch e como ele resolve o problema do polimorfismo bi-dimensional?",
    "options": [
      "Técnica onde o método chamado depende do tipo runtime de dois objetos, usando visitante ou sobrescrita combinada",
      "Chamar um método duas vezes",
      "Criar duas instâncias",
      "Dispatch assíncrono"
    ],
    "correctIndex": 0,
    "explanation": "Linguagens como Java/TypeScript despacham métodos pelo tipo runtime do receptor (single dispatch). Double dispatch exige que o método dependa de DOIS tipos runtime. O padrão Visitor resolve isso: o elemento chama visitor.visit(this), o que dispara o método sobrecarregado correto do visitor.",
    "example": "circle.accept(printer) → printer.visitCircle(this) → imprime círculo. square.accept(printer) → printer.visitSquare(this) → imprime quadrado. O Visitor 'sabe' o tipo concreto porque o accept() resolve o primeiro dispatch."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__4",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é o princípio SRP (Single Responsibility Principle) do SOLID?",
    "options": [
      "Uma classe deve ter apenas um motivo para mudar — uma única responsabilidade",
      "Uma classe deve ter um único método",
      "Cada arquivo deve ter uma classe",
      "Funções devem ter um paramâmetro"
    ],
    "correctIndex": 0,
    "explanation": "SRP: cada classe/módulo deve ter uma única razão para mudar. Se uma classe lida com validação E persistência, mudanças no banco afetam a classe que também valida. Separar responsabilidades = menor risco de efeitos colaterais e mais fácil de testar.",
    "example": "Viola SRP: class User { validate() { } save() { } sendEmail() { } } — 3 motivos para mudar. Correto: UserValidator, UserRepository, EmailService — cada uma com uma responsabilidade."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__5",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é o princípio de Substituição de Liskov (LSP) na prática com TypeScript?",
    "options": [
      "Subtipos devem poder substituir seus tipos base sem alterar a correção do programa",
      "Listas devem ser substituídas por arrays",
      "Subclasses devem ter mais métodos",
      "Tipos genéricos devem ser evitados"
    ],
    "correctIndex": 0,
    "explanation": "LSP: se S é subtipo de T, então objetos de T podem ser substituídos por objetos de S sem quebrar o programa. Pré-condições não podem ser fortalecidas, pós-condições não podem ser enfraquecidas, invariantes devem ser mantidas.",
    "example": "function processPayment(p: Payment) { p.charge(100); } — CreditCard, DebitCard, PIX implementam Payment. Todas devem funcionar se passadas para processPayment(). Se PIX lançar erro em charge(), viola LSP."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__6",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que são os padrões GRASP e quais seus princípios de atribuição de responsabilidade?",
    "options": [
      "Conjunto de 9 padrões que guiam a atribuição de responsabilidades a classes: Creator, Expert, Controller, etc.",
      "Framework de testes",
      "Metodologia ágil",
      "Linguagem de modelagem"
    ],
    "correctIndex": 0,
    "explanation": "GRASP (General Responsibility Assignment Software Patterns): Information Expert (quem tem os dados é responsável), Creator (quem cria instâncias), Controller (quem recebe eventos de sistema), Low Coupling, High Cohesion, Polymorphism, Pure Fabrication, Indirection, Protected Variations.",
    "example": "Information Expert: Pedido calcula seu próprio total (tem os itens). Creator: Pedido cria ItemPedido (contém/agrega itens). Controller: PedidoController recebe requisições HTTP. Cada padrão define QUEM deve ter cada responsabilidade."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__7",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é covariância e contravariância em tipos genéricos?",
    "options": [
      "Covariância preserva a direção do subtipo; contravariância inverte — aplicados em tipos de retorno e parâmetros",
      "Termos de estatística",
      "Tipos de herança múltipla",
      "Métodos de ordenação"
    ],
    "correctIndex": 0,
    "explanation": "Covariante: se Dog extends Animal, então List<Dog> é subtipo de List<Animal> (retornos de função). Contravariante: direção inversa (parâmetros de função). Invariante: nenhuma direção. TypeScript: strictFunctionTypes habilita checagem de contravariância em parâmetros.",
    "example": "type Animal = { name: string }; type Dog = Animal & { bark(): void };\nCovariante (retorno): () => Dog é subtipo de () => Animal ✔\nContravariante (param): (a: Animal) => void é subtipo de (d: Dog) => void ✔\nInvariante: Array<Dog> !subtipo Array<Animal> se mutar (push de Cat em array de Dog)."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__8",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é o Princípio Aberto/Fechado (OCP) do SOLID e como evitar violações em código com múltiplos tipos?",
    "options": [
      "Código aberto para extensão (novos comportamentos) mas fechado para modificação (sem editar existente); violação: switch/if-else que cresce a cada novo tipo",
      "Código open-source (aberto) com API interna fechada ao usuário externo",
      "Módulo sem modificadores de acesso public mas extensível via herança",
      "Classe que não aceita dependências externas mas é extensível internamente"
    ],
    "correctIndex": 0,
    "explanation": "OCP: adicionar comportamento = nova classe/módulo, não editar existente. Violação clássica: switch(forma) { case 'circulo': ...; case 'quadrado': ...; } — adicionar triângulo exige editar sempre. Solução: polimorfismo (interface Forma.calcularArea()), Strategy, Decorator. Paradoxo: toda abstração é um palpite — OCP válido quando ponto de variação é identificado corretamente.",
    "example": "CalculadoraDesconto com switch(tipoCliente) — cada novo tipo = editar classe. OCP: interface DescontoStrategy, VIPStrategy, NormalStrategy. Calculadora recebe strategy — nova estratégia = nova classe, calculadora não muda. Plugin systems: VS Code extensions não editam o editor, apenas implementam interfaces definidas."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__9",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é covariância e contravariância em definição de tipos genéricos e como TypeScript trata?",
    "options": [
      "Covariância: subtipo pode ser substituído em posição de saída (retorno); contravariância: supertipo pode ser substituído em posição de entrada (parâmetro); TypeScript usa structural typing bivariant por default com strictFunctionTypes fixando",
      "São propriedades exclusivas de linguagens com herança múltipla estrita",
      "TypeScript não suporta variância — usa any internamente para todos os genéricos",
      "Covariância e contravariância são idênticas em sistemas de tipos estruturais"
    ],
    "correctIndex": 0,
    "explanation": "Covariante (out): Producer<Cat> é subtipo de Producer<Animal> — retornar Cat onde Animal esperado é seguro. Contravariante (in): Consumer<Animal> é subtipo de Consumer<Cat> — aceitar Animal onde Cat esperado é seguro (aceita mais amplo). Invariante: mutável T<Cat> não pode substituir T<Animal> (nem covariant nem contravariant). TypeScript: métodos de classe são bivariant (histórico), function types são contravariantes em parâmetros com strictFunctionTypes.",
    "example": "Covariante seguro: () => Cat pode ser usada como () => Animal (retorna algo que é Animal). Contravariante seguro: (animal: Animal) => void pode ser usada como (cat: Cat) => void (aceita mais que Cat). Invariante (não seguro): Array<Cat> não é Array<Animal> — push(dog) causaria problema. TypeScript detecta isso com arrays mutáveis."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__10",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é o padrão CQRS (Command Query Responsibility Segregation) em POO e quando ele é justificado?",
    "options": [
      "Separa as operações de leitura (Query) das de escrita (Command) em modelos distintos, permitindo otimizações independentes de cada lado",
      "Padrão que unifica leitura e escrita num único modelo para simplificar o código",
      "Técnica de cache que separa dados quentes (leitura) de frios (escrita)",
      "Framework de testes que separa queries de assertions em steps diferentes"
    ],
    "correctIndex": 0,
    "explanation": "CQRS: modelo de escrita (Command) separado do modelo de leitura (Query). Write model: normalizado, validações complexas, eventos. Read model: desnormalizado, otimizado para queries específicas (views materializadas). Justificado quando: padrões de leitura e escrita são muito diferentes, alta escala, necessidade de modelos de leitura especializados (search, relatórios). Frequentemente combinado com Event Sourcing. Desvantagem: complexidade, eventual consistency entre modelos.",
    "example": "E-commerce: Command side: CreateOrderCommand → validar estoque → persist Order → emit OrderCreated event. Query side: OrderCreated handler → atualiza read DB (desnormalizado: order+customer+items numa tabela/documento). GET /orders → query diretamente no read model (rápido, sem JOINs). Write DB: PostgreSQL normalizado. Read DB: Elasticsearch para busca ou MongoDB desnormalizado."
  },
  {
    "id": "desenvolvimento__Programação Orientada a Objetos__Difícil__11",
    "track": "desenvolvimento",
    "category": "Programação Orientada a Objetos",
    "difficulty": "Difícil",
    "question": "O que é o princípio de covariância e contravariância em tipos genéricos e como afeta hierarquias de classes?",
    "options": [
      "Covariância permite subtipo no retorno (Producer<Dog> é subtipo de Producer<Animal>); contravariância permite supertipo nos parâmetros (Consumer<Animal> é subtipo de Consumer<Dog>)",
      "Covariância e contravariância são sinônimos para polimorfismo paramétrico",
      "Covariância aplica-se apenas a arrays; contravariância apenas a funções",
      "Ambas significam que tipos genéricos são sempre intercambiáveis se os tipos base são compatíveis"
    ],
    "correctIndex": 0,
    "explanation": "Covariância (out): preserva direção da herança. Se Dog extends Animal, Producer<Dog> extends Producer<Animal>. Seguro para retorno/produção. Contravariância (in): inverte direção. Consumer<Animal> extends Consumer<Dog>. Seguro para parâmetros/consumo. Invariância: nenhuma direção (default em Java generics, C# sem in/out). Regra PECS (Java): Producer Extends, Consumer Super. TypeScript: funções são contravariantes nos parâmetros (com strictFunctionTypes).",
    "example": "C#: IEnumerable<out T> (covariante): IEnumerable<Dog> atribuível a IEnumerable<Animal> ✓. Action<in T> (contravariante): Action<Animal> atribuível a Action<Dog> ✓ (quem aceita Animal aceita Dog). Java: List<? extends Animal> (covariante: lê Animal), List<? super Dog> (contravariante: escreve Dog). TS: type Fn<T> = (arg: T) => void; Fn<Animal> atribuível a Fn<Dog>? Sim com --strict (contravariância)."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__1",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "No React, qual hook é utilizado para gerenciar estado local em um componente funcional?",
    "options": [
      "useState",
      "useEffect",
      "useContext",
      "useRef"
    ],
    "correctIndex": 0,
    "explanation": "O hook useState retorna um par [valor, função setter]. Quando o setter é chamado com um novo valor, o React re-renderiza o componente com o estado atualizado. É a forma padrão de gerenciar estado em componentes funcionais.",
    "example": "const [count, setCount] = useState(0); return <Button onPress={() => setCount(count + 1)} title={`Cliques: ${count}`} />;"
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__2",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "No React, o que são props e como elas diferem de state?",
    "options": [
      "Props são dados passados pelo pai (read-only); state são dados internos do componente (mutáveis)",
      "São idênticos",
      "Props são mutáveis e state read-only",
      "Ambos são globais"
    ],
    "correctIndex": 0,
    "explanation": "Props (properties) são dados passados de um componente pai para um filho, são read-only no filho. State é dado gerenciado internamente pelo próprio componente, pode ser alterado via setState/useState, e alterações causam re-renderização.",
    "example": "<UserCard name='Ana' age={28} /> — name e age são props. Dentro de UserCard: const [isExpanded, setIsExpanded] = useState(false); — isExpanded é state interno."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__3",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "Qual componente do React Native é usado para renderizar listas longas de forma eficiente?",
    "options": [
      "FlatList",
      "ScrollView",
      "View",
      "Text"
    ],
    "correctIndex": 0,
    "explanation": "FlatList renderiza apenas os itens visíveis na tela (virtualização), sendo eficiente para listas grandes. ScrollView renderiza TODOS os itens de uma vez (ok para listas curtas <100 items). FlatList exige keyExtractor e renderItem.",
    "example": "<FlatList data={users} keyExtractor={item => item.id} renderItem={({ item }) => <UserCard user={item} />} /> — renderiza eficientemente 10.000 usuários mostrando apenas ~10 visíveis."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__4",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "No React, o que é o hook useEffect e para que ele serve?",
    "options": [
      "Executa efeitos colaterais (chamadas API, subscriptions) após a renderização do componente",
      "Gerencia estado local",
      "Cria componentes",
      "Formata estilos CSS"
    ],
    "correctIndex": 0,
    "explanation": "useEffect roda após o componente renderizar. Com array vazio ([]) roda apenas na montagem. Com dependências ([count]) roda quando count muda. Sem array, roda a cada renderização. Retorno opcional é função de cleanup.",
    "example": "useEffect(() => { fetchUsers().then(setUsers); }, []); — busca usuários uma vez ao montar o componente. O [] garante que não repete a cada renderização."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__5",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre componentes funcionais e componentes de classe no React?",
    "options": [
      "Funcionais são funções que usam hooks; de classe usam this.state e métodos de ciclo de vida",
      "São idênticos",
      "Classes são mais rápidas",
      "Funcionais não têm estado"
    ],
    "correctIndex": 0,
    "explanation": "Componentes funcionais: funções que recebem props e retornam JSX. Desde React 16.8, usam hooks (useState, useEffect) para estado e efeitos. Classes: usam this.state, this.setState, e lifecycle methods (componentDidMount etc). Funcionais são o padrão moderno.",
    "example": "Funcional: function Counter() { const [n, setN] = useState(0); return <button onClick={() => setN(n+1)}>{n}</button>; } Classe: class Counter extends Component { state = {n:0}; render() { return <button onClick={() => this.setState({n: this.state.n+1})}>{this.state.n}</button>; } }"
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__6",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "O que é JSX e por que o React o utiliza?",
    "options": [
      "Extensão de sintaxe que permite escrever estrutura de UI similar a HTML dentro do JavaScript",
      "Linguagem de programação separada",
      "Template engine do Node.js",
      "Substituto do CSS"
    ],
    "correctIndex": 0,
    "explanation": "JSX (JavaScript XML) é uma extensão sintática que permite escrever elementos de UI de forma declarativa dentro do JS. Babel transpila JSX para React.createElement() calls. Permite interpolação com {}, condições e map(). Não é HTML: usa className em vez de class, htmlFor em vez de for.",
    "example": "const element = <h1 className='title'>Olá, {user.name}</h1>; → transpila para: React.createElement('h1', { className: 'title' }, 'Olá, ', user.name). JSX é açúcar sintático."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__7",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "O que é o hook useRef e quando utilizá-lo?",
    "options": [
      "Cria uma referência mutável que persiste entre renderizações sem causar re-render ao mudar",
      "Substituto do useState",
      "Hook para efeitos colaterais",
      "Método de estilização"
    ],
    "correctIndex": 0,
    "explanation": "useRef retorna um objeto { current: valor } que persiste durante todo o ciclo de vida do componente. Mutar .current NÃO causa re-render. Usos: acessar elementos DOM diretamente, armazenar timers/intervals, guardar valor anterior, contar renders.",
    "example": "const inputRef = useRef<TextInput>(null); <TextInput ref={inputRef} /> <Button onPress={() => inputRef.current?.focus()} /> — foca o input programáticamente. Também: const renderCount = useRef(0); renderCount.current++ em cada render (sem causar loop)."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__8",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "O que é o hook useState e qual a regra crítica de imutabilidade do estado?",
    "options": [
      "Hook para estado local em componentes funcionais; estado NUNCA deve ser mutado diretamente — sempre usar setter para criar novo valor e triggerar re-render",
      "Variável global compartilhada entre todos os componentes da aplicação",
      "Cache de dados remotos fetch com invalidação automática",
      "Equivalente ao this.state de class component sem restrições de mutação"
    ],
    "correctIndex": 0,
    "explanation": "useState(initial) retorna [state, setState]. setState(novoValor) ou setState(prev => novoValor). React detecta mudança por referência — mutar objeto/array existente não triggera re-render (mesma referência). Regra: sempre criar novo objeto/array: setList([...list, item]), setObj({...obj, key: valor}). Batching: múltiplos setStates em event handler são batched (React 18 em todos os contexts).",
    "example": "ERRADO: state.items.push('novo'); setItems(state.items); → mesma referência, sem re-render. CORRETO: setItems([...state.items, 'novo']); → nova referência, re-render. Para objetos: setUser({...user, nome: 'Ana'}) — spread preserva outros campos. Uso com função updater: setCount(prev => prev + 1) — seguro para múltiplos updates rápidos."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__9",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "O que é JSX e por que React usa className em vez de class?",
    "options": [
      "JSX é açúcar sintático transformado em React.createElement(); usa className porque class é palavra reservada em JavaScript",
      "JSX é arquivo JSON para configurar componentes React de forma declarativa",
      "JSX é linguagem de template separada compilada independentemente do JavaScript",
      "JSX é substituição do HTML que roda diretamente no browser sem transpilação"
    ],
    "correctIndex": 0,
    "explanation": "JSX: <Button color='red'>Click</Button> → React.createElement(Button, {color:'red'}, 'Click'). Transpilado por Babel/SWC. Atributos seguem o DOM JavaScript, não HTML: class→className (class é reserved keyword), for→htmlFor, tabindex→tabIndex, onclick→onClick (camelCase). Eventos são SyntheticEvents gerenciados pelo React.",
    "example": "<div className='box' onClick={fn} htmlFor='id'>...</div> → React.createElement('div', {className:'box', onClick:fn, htmlFor:'id'}). Fragment: <></> evita div wrapper. JSX permite expressões: {list.map(i => <li key={i.id}>{i.name}</li>)}. Compilado pelo Babel com @babel/plugin-transform-react-jsx."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__10",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "O que são props em React e como elas permitem passar dados de componentes pais para filhos?",
    "options": [
      "Propriedades somente-leitura passadas de pai para filho via atributos JSX; permitem configurar e customizar componentes de forma declarativa",
      "Variáveis globais compartilhadas entre todos os componentes da aplicação",
      "Estado interno do componente que pode ser modificado por qualquer outro componente",
      "Eventos disparados pelo componente filho que o pai pode interceptar"
    ],
    "correctIndex": 0,
    "explanation": "Props: dados passados de pai para filho como atributos HTML. Somente leitura no filho (unidirecional). Tipagem: interface Props { name: string; age?: number; }. Desestruturação: function User({ name, age = 18 }: Props). Children: prop especial para conteúdo aninhado. Callback props: função passada como prop para comunicação filho→pai. Props são a base do modelo declarativo do React.",
    "example": "<UserCard name='Ana' age={25} onDelete={() => handleDelete(id)} /> — componente filho: function UserCard({ name, age, onDelete }: Props) { return <div>{name}, {age} anos <button onClick={onDelete}>X</button></div>; }. Children: <Card><h1>Título</h1></Card> → function Card({children}) { return <div className='card'>{children}</div>; }."
  },
  {
    "id": "desenvolvimento__React e React Native__Fácil__11",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Fácil",
    "question": "O que é renderização condicional em React e quais são as formas mais comuns de implementá-la?",
    "options": [
      "Exibir ou ocultar elementos baseado em condições usando operador ternário, && lógico, ou early return — cada abordagem adequada para cenários diferentes",
      "Usar CSS display:none para esconder componentes condicionalmente",
      "Criar dois componentes separados e trocar entre eles via roteamento",
      "Usar setTimeout para atrasar a renderização até a condição ser verdadeira"
    ],
    "correctIndex": 0,
    "explanation": "Formas de renderização condicional: 1) Ternário: {isLoggedIn ? <Dashboard /> : <Login />} — quando há ambos os caminhos. 2) && lógico: {isAdmin && <AdminPanel />} — quando só há caminho verdadeiro. Cuidado: {count && <List />} renderiza '0' se count=0 (use count > 0). 3) Early return: if (loading) return <Spinner />; — melhor para múltiplas condições. 4) Variável: let content; if (...) content = <A/>; else content = <B/>; return {content};",
    "example": "{isLoading ? <Spinner /> : <DataTable data={data} />}. {error && <ErrorBanner message={error} />}. function Page({user, loading, error}) { if (loading) return <Spinner />; if (error) return <Error msg={error} />; if (!user) return <Login />; return <Dashboard user={user} />; } — guard clauses para renderização."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__1",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "No React, para que serve o hook useEffect e quando a função de cleanup é executada?",
    "options": [
      "Executa efeitos colaterais após a renderização; cleanup roda antes do próximo efeito e na desmontagem do componente",
      "Cria estado persistente; cleanup roda na montagem",
      "Substitui o useState; cleanup nunca é chamado",
      "Renderiza condicionalmente; cleanup roda a cada clique"
    ],
    "correctIndex": 0,
    "explanation": "useEffect executa efeitos colaterais (chamadas API, subscriptions, timers) após o DOM ser atualizado. A função de cleanup (retorno do useEffect) executa antes de cada re-execução do efeito e quando o componente é desmontado, evitando memory leaks.",
    "example": "useEffect(() => { const sub = api.subscribe(onData); return () => sub.unsubscribe(); // cleanup: cancela subscription }, []) — subscribe na montagem, unsubscribe na desmontagem."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__2",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "No React, o que é o hook useCallback e quando usá-lo?",
    "options": [
      "Memoriza uma função para evitar recriação a cada renderização, útil quando passada como prop a componentes memorizados",
      "Chama uma API",
      "Cria estado global",
      "Substitui useEffect"
    ],
    "correctIndex": 0,
    "explanation": "useCallback retorna uma versão memorizada da função que só muda se as dependências mudarem. Sem useCallback, cada renderização cria uma nova referência de função, potencialmente causando re-renderizações desnecessárias em componentes filhos que usam React.memo.",
    "example": "const handlePress = useCallback(() => { setCount(c => c + 1); }, []); <MemoizedChild onPress={handlePress} /> — MemoizedChild não re-renderiza porque handlePress mantém a mesma referência."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__3",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "No React, para que serve o hook useMemo e como difere de useCallback?",
    "options": [
      "useMemo memoriza um VALOR calculado; useCallback memoriza uma FUNÇÃO",
      "São idênticos",
      "useMemo é para efeitos colaterais",
      "useCallback memoriza valores"
    ],
    "correctIndex": 0,
    "explanation": "useMemo(fn, deps) executa fn e memoriza o RESULTADO (valor). Só recalcula quando deps mudam. useCallback(fn, deps) memoriza a própria FUNÇÃO fn. Na prática: useCallback(fn, deps) === useMemo(() => fn, deps). Use useMemo para cálculos custosos e useCallback para callbacks passados a filhos.",
    "example": "const sortedItems = useMemo(() => items.sort((a,b) => a.name.localeCompare(b.name)), [items]); — só reordena quando items muda, não a cada renderização."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__4",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "No React, o que é Context API e quando usá-la em vez de prop drilling?",
    "options": [
      "Mecanismo para compartilhar dados entre componentes sem passar props manualmente por cada nível",
      "API de rede do React",
      "Substituto do Redux",
      "Banco de dados local"
    ],
    "correctIndex": 0,
    "explanation": "Context API resolve o prop drilling (passar props por 5+ níveis). Crie um Context com createContext, forneça valor com Provider no topo, e consuma com useContext nos filhos. Ideal para: tema, lang, auth. Não ideal para estado que muda frequentemente (causa re-renders).",
    "example": "const ThemeContext = createContext('light'); <ThemeContext.Provider value='dark'> <App /> </ThemeContext.Provider>. Em qualquer componente filho: const theme = useContext(ThemeContext); // 'dark' — sem passar por props."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__5",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "No React Native, qual a diferença entre StyleSheet e estilos inline?",
    "options": [
      "StyleSheet.create otimiza estilos criando-os uma vez; inline cria novo objeto a cada renderização",
      "São idênticos",
      "Inline é mais rápido",
      "StyleSheet só aceita cores"
    ],
    "correctIndex": 0,
    "explanation": "StyleSheet.create: cria estilos uma vez (referenciados por ID numérico), validação em dev, melhor performance. Inline (style={{color:'red'}}): cria novo objeto a cada render, sem validação. NativeWind/Tailwind: alternativa que compila classes para StyleSheet.",
    "example": "const styles = StyleSheet.create({ container: { flex: 1, padding: 16 } }); <View style={styles.container} /> — otimizado. Vs <View style={{ flex: 1, padding: 16 }} /> — novo objeto a cada render."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__6",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "No React, o que é React.memo e quando utilizá-lo?",
    "options": [
      "HOC que memoriza o componente, evitando re-render se as props não mudaram",
      "Função para memorizar estado",
      "Substituto do useMemo",
      "Método de cache de API"
    ],
    "correctIndex": 0,
    "explanation": "React.memo envolve um componente funcional e faz shallow comparison das props. Se as props não mudaram, reutiliza o resultado da renderização anterior. Útil para componentes que re-renderizam frequentemente com as mesmas props. Combinar com useCallback para callbacks.",
    "example": "const UserCard = React.memo(({ name, avatar }: Props) => { return <View><Image source={avatar} /><Text>{name}</Text></View>; }); — só re-renderiza se name ou avatar mudarem. Pai re-renderiza → UserCard pula se props iguais."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__7",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "O que é um Custom Hook no React e como criá-lo?",
    "options": [
      "Função que começa com 'use' e encapsula lógica reutilizável com hooks, extraindo lógica de componentes",
      "Componente especial do React",
      "Plugin de terceiros",
      "Método de classe"
    ],
    "correctIndex": 0,
    "explanation": "Custom Hooks são funções que começam com 'use' e podem chamar outros hooks. Extraem lógica stateful reutilizável de componentes. Cada instância tem seu próprio estado isolado. Padrão para: fetch de dados, formulários, timers, media queries.",
    "example": "function useDebounce<T>(value: T, delay: number): T { const [debounced, setDebounced] = useState(value); useEffect(() => { const timer = setTimeout(() => setDebounced(value), delay); return () => clearTimeout(timer); }, [value, delay]); return debounced; } — reutilizável em qualquer componente."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__8",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "Como funciona o array de dependências do useEffect e quais são os 3 comportamentos possíveis?",
    "options": [
      "Sem array: executa após todo render; [] vazio: só na montagem; [a,b]: quando a ou b muda; cleanup function executada antes do próximo effect e no unmount",
      "Array vazio: nunca executa; com deps: executa no unmount; sem array: uma única vez na montagem",
      "Controla quantidade máxima de renderers por segundo para throttling",
      "Define quais estados são serializados para persistência entre sessões"
    ],
    "correctIndex": 0,
    "explanation": "useEffect(fn, deps): 1) sem deps → roda após CADA render. 2) [] → roda só na montagem (componentDidMount equivalent). 3) [a, b] → roda quando a ou b muda (comparação por referência com Object.is). Cleanup: função retornada pela fn roda antes do próximo effect e no unmount — essencial para cancelar subscriptions, clearInterval, removeEventListener para evitar memory leaks.",
    "example": "[]: buscar dados uma vez. [userId]: rebuscar ao trocar usuário. Cleanup crítico: useEffect(() => { const timer = setInterval(tick, 1000); return () => clearInterval(timer); }, []). Sem cleanup: timer continua rodando após unmount (memory leak). Dependências exaustivas: eslint-plugin-react-hooks detecta deps faltantes."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__9",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "O que é o Context API no React e qual a principal limitação de performance?",
    "options": [
      "Evita prop drilling compartilhando estado via Provider/useContext; limitação: qualquer mudança no valor do context re-renderiza TODOS os consumers, mesmo os que usam apenas partes não alteradas",
      "Substituto completo de Redux com gerenciamento de estado global sem desvantagens",
      "Cache de componentes React para evitar re-renders via memoização automática",
      "Sistema de roteamento sem dependências externas baseado em contexto de URL"
    ],
    "correctIndex": 0,
    "explanation": "Context: Provider fornece value, useContext(MyContext) acessa em qualquer descendente. Evita prop drilling. Limitação: quando value do Provider muda, todos os useContext(MyContext) re-renderizam — mesmo que componente use apenas parte não alterada. Soluções: dividir em múltiplos contextos granulares, useMemo no value, Zustand/Jotai/Redux para estado frequentemente mutável.",
    "example": "Context {user, theme, notifications}: trocar theme → componentes que usam só user re-renderizam. Dividir: UserContext, ThemeContext, NotificationContext. UserProvider: value={useMemo(() => ({user}), [user])} — só re-renderiza consumers de UserContext quando user muda. Context bom para: tema, locale, auth (mudam raramente)."
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__10",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "O que são custom hooks em React e quais as regras para criá-los corretamente?",
    "options": [
      "Funções prefixadas com 'use' que encapsulam lógica stateful reutilizável usando outros hooks; devem seguir as Rules of Hooks (só no top level, só em componentes/hooks)",
      "Classes que estendem React.Component com estado e ciclo de vida customizados",
      "Componentes de ordem superior (HOC) escritos como funções arrow",
      "Plugins do React que adicionam funcionalidades ao core da biblioteca"
    ],
    "correctIndex": 0,
    "explanation": "Custom hook: função useXxx que usa hooks internamente para extrair e reutilizar lógica. Regras: 1) Prefixo 'use' (ESLint plugin detecta violações). 2) Chamar hooks apenas no top level (nunca em condicionais/loops). 3) Chamar apenas em componentes React ou outros hooks. Cada componente que usa o hook tem seu próprio estado (isolado). Padrões: useFormField, useFetch, useDebounce, useLocalStorage, useMediaQuery.",
    "example": "function useFetch<T>(url: string) { const [data, setData] = useState<T|null>(null); const [loading, setLoading] = useState(true); const [error, setError] = useState<Error|null>(null); useEffect(() => { fetch(url).then(r=>r.json()).then(setData).catch(setError).finally(()=>setLoading(false)); }, [url]); return { data, loading, error }; } — Uso: const { data, loading } = useFetch<User[]>('/api/users');"
  },
  {
    "id": "desenvolvimento__React e React Native__Médio__11",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Médio",
    "question": "O que é React.memo e quando usá-lo para otimizar re-renders de componentes funcionais?",
    "options": [
      "HOC que memoriza o resultado da renderização e só re-renderiza se as props mudarem (shallow compare); útil para componentes puros que recebem as mesmas props frequentemente",
      "Função que salva o componente em cache do navegador para carregamento mais rápido",
      "Hook que memoriza valores computados dentro do componente",
      "Método que comprime a árvore de componentes para reduzir uso de memória"
    ],
    "correctIndex": 0,
    "explanation": "React.memo: wrapa componente funcional, compara props com shallow equality antes de re-renderizar. Se props iguais → pula render (usa output anterior). Útil quando: componente é puro, pai re-renderiza frequentemente mas props do filho não mudam, renderização é custosa. Cuidado: props com objetos/arrays/funções criados inline → nova referência a cada render → memo inútil. Solução: useMemo/useCallback nas props do pai. Custom comparator: React.memo(Comp, (prev, next) => comparison).",
    "example": "const ExpensiveList = React.memo(function({ items }: { items: Item[] }) { return items.map(i => <li key={i.id}>{i.name}</li>); }); — pai re-renderiza mas items não mudou → ExpensiveList não re-renderiza. Problema: <Child onClick={() => doSomething()} /> → nova função toda render → memo inútil. Fix: const handleClick = useCallback(() => doSomething(), []); <Child onClick={handleClick} />."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__1",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "No React 18+, qual é o comportamento do Concurrent Rendering com Suspense para data fetching e como ele difere do modelo síncrono?",
    "options": [
      "React pode pausar a renderização de uma subárvore, mostrar fallback e retomar quando os dados estiverem prontos, sem bloquear a UI",
      "Suspense apenas exibe spinners e não afeta a renderização",
      "Concurrent Rendering bloqueia toda a UI até os dados chegarem",
      "Suspense só funciona com lazy loading de componentes, não com dados"
    ],
    "correctIndex": 0,
    "explanation": "No Concurrent Rendering, quando um componente 'suspende' (lança uma Promise), o React pausa a renderização daquela subárvore e exibe o fallback do Suspense mais próximo. Enquanto isso, a UI existente permanece interativa. Quando a Promise resolve, o React retoma a renderização sem bloquear o thread principal.",
    "example": "<Suspense fallback={<Skeleton />}><UserProfile /></Suspense> — enquanto UserProfile busca dados, Skeleton é exibido. A barra de navegação e outros componentes continuam responsivos durante o loading."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__2",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "No React, o que é o Virtual DOM e como ele otimiza a performance de renderização?",
    "options": [
      "Representação em memória do DOM real; React compara diferenças (diffing) e aplica apenas as mudanças necessárias",
      "DOM mais rápido que o real",
      "Cache do HTML",
      "Servidor que renderiza HTML"
    ],
    "correctIndex": 0,
    "explanation": "O Virtual DOM é uma árvore de objetos JavaScript que espelha o DOM real. Quando o state muda, React cria uma nova árvore virtual, compara com a anterior (diffing/reconciliation) e calcula o mínimo de operações DOM necessárias (batching). Evita manipulações DOM custosas e desnecessárias.",
    "example": "State muda: lista de 100 items, 1 foi editado. React compara as 2 árvores virtuais, detecta que apenas item 42 mudou, e faz uma única operação DOM para atualizar o texto daquele único elemento."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__3",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "No React Native, como o bridge (antigo) e o New Architecture (JSI/Fabric/TurboModules) diferem na comunicação JS-nativo?",
    "options": [
      "Bridge usa serialização JSON assíncrona; New Architecture usa JSI para acesso direto síncrono a objetos nativos",
      "São idênticos",
      "New Architecture é mais lento",
      "Bridge é síncrono"
    ],
    "correctIndex": 0,
    "explanation": "Bridge (antigo): JS e nativo em threads separadas, comunicação via mensagens JSON serializadas assíncronas (gargalo em operações frequentes). New Architecture: JSI (JavaScript Interface) permite JS acessar objetos C++ diretamente, sem serialização. Fabric (novo renderer) e TurboModules (módulos nativos lazy-loaded) usam JSI.",
    "example": "Bridge: JS envia { type: 'scroll', offset: 100 } como JSON para a thread nativa → 100 mensagens/s de scroll = gargalo. JSI: JS chama nativeModule.scroll(100) diretamente como função C++ → zero serialização, performance nativa."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__4",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "No React, como funciona o Reconciliation (algoritmo de diff) e quais são suas heurísticas?",
    "options": [
      "Compara árvores virtual DOM usando heurísticas: elementos de diferentes tipos geram subárvores novas; keys identificam elementos em listas",
      "Compara pixel a pixel",
      "Renderiza tudo do zero",
      "Usa machine learning para otimizar"
    ],
    "correctIndex": 0,
    "explanation": "Reconciliation: React compara old e new virtual DOM trees. Heurísticas: 1) Elementos de tipos diferentes são subárvores completamente novas (div→span = rebuild). 2) Keys em listas permitem identificar quais items foram adicionados/removidos/reordenados. Sem keys, React re-renderiza toda a lista.",
    "example": "Lista sem key: adicionar item no início re-renderiza TODOS os items (React acha que todos mudaram). Com key={item.id}: React sabe que items existentes não mudaram e apenas insere o novo. O(n) vs O(n²)."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__5",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "No React, o que são Server Components e como diferem dos Client Components?",
    "options": [
      "Server Components renderizam no servidor sem JS no bundle do cliente; Client Components são interativos no navegador",
      "São idênticos",
      "Server Components são mais lentos",
      "Client Components rodam no servidor"
    ],
    "correctIndex": 0,
    "explanation": "React Server Components (RSC): renderizam no servidor, acesso direto a banco/APIs, zero JS enviado ao cliente (menor bundle). Client Components: marcados com 'use client', têm interatividade (useState, onClick). Composição: Server Components podem importar Client Components, mas não vice-versa.",
    "example": "// UserList é Server Component (sem 'use client')\nasync function UserList() { const users = await db.query('SELECT * FROM users'); return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>; } — zero JS no cliente, query direta no banco."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__6",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "O que é React Fiber e como melhorou a renderização do React?",
    "options": [
      "Reimplementação do algoritmo de reconciliação que permite renderização incremental e priorização de tarefas",
      "Biblioteca de fibra óptica para React",
      "Framework CSS-in-JS",
      "Compilador JIT para React"
    ],
    "correctIndex": 0,
    "explanation": "React Fiber (React 16+) substituiu o reconciliador síncrono por um assíncrono. Divide o trabalho de renderização em unidades (fibers) que podem ser pausadas, priorizadas e canceladas. Permite: concurrent rendering, Suspense, transições, renderização interruptível sem bloquear a UI.",
    "example": "Antes (Stack Reconciler): renderizar 10.000 itens bloqueia a thread ~500ms → UI congela. Com Fiber: divide em fatias de 5ms, cede controle ao browser para processar inputs entre fatias → UI permanece responsiva durante renderização pesada."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__7",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "Quando usar useReducer em vez de useState no React?",
    "options": [
      "Quando o estado é complexo com múltiplas sub-valores ou quando a próxima ação depende do estado anterior",
      "Sempre, pois é mais rápido",
      "Apenas para estado global",
      "Nunca, useState é sempre melhor"
    ],
    "correctIndex": 0,
    "explanation": "useReducer é prefirível quando: estado complexo (objeto com várias props), lógica de transição clara (switch/case), múltiplas ações (ADD, REMOVE, TOGGLE, RESET), ou quando o próximo estado depende do anterior. Padrão similar ao Redux. dispatch(é estável (não precisa de useCallback).",
    "example": "const [state, dispatch] = useReducer(reducer, { items: [], filter: 'all', loading: false }); dispatch({ type: 'ADD_ITEM', payload: item }); dispatch({ type: 'SET_FILTER', payload: 'active' }); — lógica centralizada no reducer, ações descritivas."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__8",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "O que é o algoritmo de reconciliação do React e como o Virtual DOM otimiza atualizações?",
    "options": [
      "React mantém VDOM em memória; ao setState cria novo VDOM, faz diff (O(n) com heurísticas de tipo e key) com anterior e aplica apenas patches mínimos ao DOM real",
      "React serializa componentes em JSON para comparação antes de atualizar o DOM",
      "Novo DOM real criado a cada render e substituído completamente pelo anterior",
      "VDOM sincroniza automaticamente com servidor via SSR sem algoritmo de diff"
    ],
    "correctIndex": 0,
    "explanation": "VDOM: representação JS leve do DOM. Diffing O(n) com heurísticas: mesmos tipos → atualiza props; tipos diferentes → destrói e recria subárvore; listas → key para identificar elementos. Sem key: inserir no início reordena todos os elementos (O(n) mutations). Com key: React identifica que elementos existentes mantiveram identidade. Fiber (16+): reconciliador interrompível permite priorização de updates.",
    "example": "setState({count: 1}) → novo VDOM diff com anterior → apenas textContent do span muda. Sem VDOM: innerHTML repintaria toda a página. Keys em list: <li key={item.id}> — inserir no início move os existentes em vez de recriar. key={Math.random()} é anti-pattern: recria tudo. Profiler DevTools: identifica renders desnecessários."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__9",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "Quando useMemo e useCallback causam problemas de performance ao invés de resolver?",
    "options": [
      "Usados desnecessariamente adicionam overhead de closure, comparação de deps e alocação de memória — piores para operações baratas do que computar diretamente a cada render",
      "Sempre melhoram performance pois evitam qualquer recalculação de valor ou função",
      "useCallback é para componentes; useMemo é para valores primitivos simples",
      "Eliminam completamente re-renders desnecessários em qualquer cenário do React"
    ],
    "correctIndex": 0,
    "explanation": "useMemo e useCallback têm custo: criar closure, manter deps array, comparação por Object.is a cada render. Para operações baratas, é mais caro do que recomputar. useMemo correto: cálculo custoso (sort de lista grande, filtragem complexa). useCallback correto: função passada como prop a React.memo ou dep de useEffect. Prematuro: useMemo(() => a + b, [a,b]) — soma é barata.",
    "example": "useMemo ERRADO: useMemo(() => items.length, [items]) — .length é O(1), overhead de useMemo maior. CERTO: useMemo(() => items.filter(complexPredicate).sort(complexSort), [items]) — evita O(n log n) a cada render. useCallback necessário: <Chart onHover={cb}/> onde Chart é React.memo — sem useCallback, cb recria toda render e Chart re-renderiza de qualquer forma."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__10",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "O que é o React Reconciliation Algorithm e como a heurística de keys otimiza a diferenciação de listas?",
    "options": [
      "Algoritmo que compara árvores virtual DOM antiga e nova em O(n) usando heurísticas: elementos de tipos diferentes são recriados, e keys identificam elementos estáveis em listas",
      "Algoritmo que compara DOMs reais para detectar mudanças manuais feitas via JavaScript",
      "Sistema de cache que armazena renderizações anteriores para reutilizar em componentes idênticos",
      "Processo de compilação que otimiza JSX em instruções DOM mínimas"
    ],
    "correctIndex": 0,
    "explanation": "Reconciliation: diffing entre árvore virtual anterior e nova. Heurísticas (O(n) vs O(n³) ótimo): 1) Elementos de tipos diferentes → destruir subárvore e recriar (div→span: remonta tudo). 2) Mesmo tipo → compara atributos, atualiza apenas mudanças. 3) Listas: sem key → compara por posição (inserção no início re-renderiza todos). Com key estável → identifica movimentos, inserções, remoções eficientemente. Anti-pattern: key={Math.random()} ou key={index} com reordenação.",
    "example": "Lista [A,B,C] → [X,A,B,C]. Sem key: React compara posição: A→X (update), B→A (update), C→B (update), null→C (insert) = 4 operações. Com key: React identifica que A,B,C continuam, X é novo = 1 insert. key={item.id} ✓. key={index} com reorder: React confunde quem é quem → estado vindovinculado ao item errado."
  },
  {
    "id": "desenvolvimento__React e React Native__Difícil__11",
    "track": "desenvolvimento",
    "category": "React e React Native",
    "difficulty": "Difícil",
    "question": "O que é Suspense e React Server Components (RSC) e como mudam o modelo de data fetching e renderização?",
    "options": [
      "Suspense permite mostrar fallback enquanto componente carrega dados/código; RSC renderiza no servidor sem enviar JS ao client — juntos eliminam waterfalls e reduzem bundle size",
      "Suspense é um error boundary para erros de rede; RSC são componentes que rodam apenas no cliente",
      "Suspense é um hook para gerenciar loading state; RSC compilam JSX em HTML estático",
      "Suspense substitui useEffect para side effects; RSC são Web Components nativos do browser"
    ],
    "correctIndex": 0,
    "explanation": "Suspense: componente React que mostra fallback (<Suspense fallback={<Spinner/>}>) enquanto children suspendem (lazy loading, data fetching). React 'pausa' a renderização, mostra fallback, resume quando dados prontos. RSC: componentes async que rodam no servidor (podem acessar DB, filesystem diretamente). Output: serializado como payload (não HTML puro). Não enviam JS ao client (zero bundle). Composição: Server Component pode conter Client Component ('use client'). Next.js App Router usa RSC por default.",
    "example": "RSC: async function UserProfile({id}) { const user = await db.query('SELECT * FROM users WHERE id=?', [id]); return <div>{user.name}</div>; } — roda no servidor, zero JS no client. Client Component: 'use client'; function LikeButton() { const [liked, setLiked] = useState(false); return <button onClick={()=>setLiked(true)}>Like</button>; }. <Suspense fallback={<Skeleton/>}><UserProfile id={1}/></Suspense>."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__1",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que é um teste unitário e qual é seu principal objetivo?",
    "options": [
      "Testar uma unidade isolada de código (função/método) para verificar se ela produz o resultado esperado",
      "Testar o sistema inteiro em produção",
      "Testar a interface gráfica manualmente",
      "Testar o desempenho sob carga"
    ],
    "correctIndex": 0,
    "explanation": "Testes unitários verificam o comportamento de uma unidade isolada (função, método ou classe), usando inputs controlados e comparando com outputs esperados. São rápidos, determinísticos e formam a base da pirâmide de testes.",
    "example": "test('soma 2 + 3 retorna 5', () => { expect(soma(2, 3)).toBe(5); }); — testa a função soma isoladamente com valores conhecidos."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__2",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que é um teste de integração e como ele difere do teste unitário?",
    "options": [
      "Testa a interação entre múltiplos componentes juntos; unitário testa componentes isolados",
      "São idênticos",
      "Integração é mais rápido",
      "Unitário testa mais componentes"
    ],
    "correctIndex": 0,
    "explanation": "Testes unitários isolam uma função/classe mockando dependências. Testes de integração validam que múltiplos componentes funcionam juntos (ex: API + banco de dados). São mais lentos e complexos que unitários, mas encontram problemas de integração que unitários não detectam.",
    "example": "Unitário: testa UserService.create() com banco mockado. Integração: testa POST /api/users que passa por Router → Controller → Service → PostgreSQL real (ou container Docker). Verifica toda a cadeia."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__3",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que é a pirâmide de testes e quais são suas camadas?",
    "options": [
      "Base: muitos testes unitários (rápidos); meio: integração; topo: poucos testes e2e (lentos)",
      "Apenas testes end-to-end",
      "Apenas testes unitários",
      "Testes manuais na base"
    ],
    "correctIndex": 0,
    "explanation": "Pirâmide de testes (Martin Fowler): base larga de testes unitários (rápidos, muitos, baratos), camada intermediária de testes de integração, e topo estreito de testes end-to-end (lentos, poucos, caros). Anti-padrão: cone de sorvete (muitos e2e, poucos unitários).",
    "example": "Projeto saudável: 500 testes unitários (2 min), 50 testes de integração (5 min), 10 testes e2e (15 min). Anti-padrão: 10 unitários, 5 integração, 200 e2e (3 horas, instbáveis)."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__4",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que é um teste end-to-end (e2e) e quando utilizá-lo?",
    "options": [
      "Testa o fluxo completo do usuário, simulando interações reais do início ao fim",
      "Testa funções isoladas",
      "Testa apenas o backend",
      "Substitui testes unitários"
    ],
    "correctIndex": 0,
    "explanation": "Testes e2e simulam o comportamento real do usuário: abrir app, clicar botões, preencher formulários, verificar resultados. Ferramentas: Cypress, Playwright, Detox (RN). São lentos e frágeis, por isso devem cobrir apenas fluxos críticos (login, checkout, cadastro).",
    "example": "Cypress: cy.visit('/login'); cy.get('#email').type('ana@email.com'); cy.get('#password').type('123'); cy.get('button').click(); cy.url().should('include', '/dashboard'); — simula login real."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__5",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que é o framework Jest e quais seus principais recursos?",
    "options": [
      "Framework de testes JS/TS com assertions, mocking, coverage e snapshot testing integrados",
      "Linter de código",
      "Bundler de módulos",
      "Framework de UI"
    ],
    "correctIndex": 0,
    "explanation": "Jest: framework de testes all-in-one do Meta. Inclui: test runner, assertions (expect/toBe), mocking (jest.fn, jest.mock), coverage (--coverage), snapshot testing, watch mode, paralelização. Funciona com TypeScript via ts-jest ou babel.",
    "example": "test('cria usuário', () => { const mockSave = jest.fn().mockResolvedValue({ id: 1 }); const service = new UserService(mockSave); await service.create('Ana'); expect(mockSave).toHaveBeenCalledWith({ name: 'Ana' }); });"
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__6",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que são assertions (asserções) em testes automatizados?",
    "options": [
      "Verificações que comparam o resultado real com o esperado; se diferem, o teste falha",
      "Comentários no código de teste",
      "Configurações do ambiente",
      "Logs de execução"
    ],
    "correctIndex": 0,
    "explanation": "Assertions são a parte do teste que verifica se o resultado é o esperado. Se a asserção falhar, o teste falha. Jest: expect(valor).toBe(esperado), .toEqual(), .toBeTruthy(), .toThrow(), .toContain(). Cada teste deve ter pelo menos uma assertion relevante.",
    "example": "expect(soma(2, 3)).toBe(5); // passa ✔\nexpect(soma(2, 3)).toBe(6); // falha ✘: Expected 6, Received 5\nexpect(users).toHaveLength(3);\nexpect(response.status).toBe(200);\nexpect(() => divide(1, 0)).toThrow('Divisão por zero');"
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__7",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que são testes determinísticos e por que são importantes?",
    "options": [
      "Testes que produzem o mesmo resultado independente de quando ou onde são executados",
      "Testes que rodam apenas uma vez",
      "Testes que dependem de dados de produção",
      "Testes que precisam de conexão com internet"
    ],
    "correctIndex": 0,
    "explanation": "Testes determinísticos sempre dão o mesmo resultado. Testes não-determinísticos (flaky) falham intermitentemente: dependem de tempo (Date.now), rede, ordem de execução ou estado compartilhado. Flaky tests corroem confiança na suite. Solução: mockar tempo, isolar estado, seed fixo para random.",
    "example": "Flaky: test depende de Date.now() → falha à meia-noite quando muda o dia. Determinístico: jest.useFakeTimers(); jest.setSystemTime(new Date('2024-06-15')); → sempre mesmo resultado. Isolamento total."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__8",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que é um teste unitário e qual a regra FIRST para boas práticas?",
    "options": [
      "Testa unidade isolada (função/classe) sem dependências externas reais; FIRST: Fast, Isolated, Repeatable, Self-validating, Timely",
      "Testa toda a aplicação de ponta a ponta incluindo banco e APIs externas",
      "Verifica integração entre múltiplos módulos do sistema em cenários reais",
      "Simula interações do usuário em interface gráfica com browser real"
    ],
    "correctIndex": 0,
    "explanation": "Teste unitário: menor unidade testável isolada de dependências (mocks para banco, APIs). FIRST: Fast (milissegundos, não segundos), Isolated (sem dependência entre testes — ordem não importa), Repeatable (mesmo resultado em qualquer ambiente/hora), Self-validating (pass/fail automático sem inspeção manual), Timely (escrito junto ao código, não após meses).",
    "example": "test('soma(2,3) = 5', () => expect(soma(2,3)).toBe(5)) — unitário, puro, sem dependências. Não é unitário: test que faz SELECT no banco, chama API real, depende de arquivo no disco ou de outro test ter rodado antes. Jest/Vitest: 100 testes unitários em < 1s. 10 testes E2E: 30+ segundos."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__9",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que é TDD e qual é o ciclo Red-Green-Refactor?",
    "options": [
      "Test-Driven Development: escrever teste que falha (Red), implementar código mínimo para passar (Green), melhorar código mantendo testes verdes (Refactor)",
      "Escrever todos os testes ao final do desenvolvimento como documentação",
      "Gerar testes automaticamente a partir do código de produção via reflection",
      "QA escreve testes antes dos devs como especificação formal do sistema"
    ],
    "correctIndex": 0,
    "explanation": "TDD: ciclo curto de feedback guiado por testes. Red: escrever teste para comportamento desejado (falha porque código não existe). Green: implementar código MÍNIMO para passar (pode ser feio). Refactor: melhorar sem quebrar funcionalidade (testes como rede de segurança). Benefícios: design emergente, documentação viva (testes), confiança em mudanças, debugging mais fácil.",
    "example": "Red: test('juros(1000, 0.01, 12) = 126.83') → CompileError/Fail. Green: function juros(p,r,n) { return p*((1+r)**n-1); } → Pass. Refactor: renomear parâmetros, extrair constante, melhorar arredondamento → testes ainda passam. Ciclo dura minutos, não horas."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__10",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que é o padrão AAA (Arrange-Act-Assert) em testes unitários e por que seguir essa estrutura?",
    "options": [
      "Estrutura que organiza testes em três fases: preparar dados (Arrange), executar ação (Act), verificar resultado (Assert) — torna testes legíveis e previsíveis",
      "Framework de teste que executa Arrange e Assert automaticamente, requerendo apenas Act",
      "Técnica de mock que substitui todas as dependências em três camadas",
      "Padrão de nomenclatura para arquivos de teste: Arrange.test.ts, Act.test.ts, Assert.test.ts"
    ],
    "correctIndex": 0,
    "explanation": "AAA: 1) Arrange: configurar dados, mocks, estado inicial. 2) Act: executar a ação/método testado (geralmente uma linha). 3) Assert: verificar resultado esperado. Benefícios: legibilidade (qualquer dev entende a estrutura), separação (setup vs execução vs verificação). Variação: Given-When-Then (BDD). Anti-pattern: múltiplos Acts e Asserts misturados (dividir em testes separados).",
    "example": "test('calcula desconto de 10% para compras acima de R$100', () => { // Arrange const cart = new Cart(); cart.addItem({ price: 200 }); // Act const total = cart.calculateTotal(); // Assert expect(total).toBe(180); }); — um teste, uma responsabilidade, três fases claras."
  },
  {
    "id": "desenvolvimento__Testes de Software__Fácil__11",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Fácil",
    "question": "O que são testes de regressão e por que são importantes quando se adiciona novas funcionalidades?",
    "options": [
      "Testes que garantem que funcionalidades existentes continuam funcionando após mudanças no código; previnem que correções ou features novas quebrem comportamento anterior",
      "Testes que verificam performance em carga alta para detectar degradação gradual",
      "Testes executados apenas uma vez na primeira implantação para validar requisitos",
      "Testes manuais feitos pelo QA antes de cada release para aprovação"
    ],
    "correctIndex": 0,
    "explanation": "Regressão: re-executar suite de testes após cada mudança para detectar quebras. Cenário: dev corrige bug X, inadvertidamente quebra feature Y. Sem regressão: bug Y só descoberto em produção. Com regressão: CI roda toda suite → teste de Y falha → dev corrige antes do merge. Automação é essencial: suites grandes (centenas/milhares de testes) rodam em minutos no CI. Quanto mais testes, maior a rede de segurança.",
    "example": "Sprint 5: dev adiciona feature de cupom de desconto. Suite CI: 500 testes →  1 falha: 'test_checkout_total' espera total=100.00, recebeu 90.00 (desconto aplicado indevidamente sem cupom). Bug detectado antes do merge. Fix: condição if (hasCoupon) antes de aplicar desconto. 500 testes passam → merge seguro."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__1",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "Qual é a diferença entre mock, stub e spy em testes de software?",
    "options": [
      "Stub retorna valores fixos; Mock verifica interações; Spy envolve a implementação real registrando chamadas",
      "São todos sinônimos",
      "Mock é para APIs e Stub para bancos",
      "Spy é usado apenas em testes end-to-end"
    ],
    "correctIndex": 0,
    "explanation": "Stub: substitui dependência com retorno fixo (ex.: retorna sempre status 200). Mock: substitui dependência e verifica se foi chamada corretamente (quantas vezes, com quais parâmetros). Spy: mantém a implementação real mas registra todas as chamadas para verificação posterior.",
    "example": "const emailStub = { send: () => true }; // Stub: retorno fixo. const emailMock = jest.fn(); expect(emailMock).toHaveBeenCalledWith('ana@email.com'); // Mock: verifica chamada. jest.spyOn(service, 'send'); // Spy: registra mas executa real."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__2",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que é TDD (Test-Driven Development) e quais são seus passos?",
    "options": [
      "Red-Green-Refactor: escrever teste que falha, implementar código mínimo para passar, refatorar",
      "Testar depois de codificar",
      "Apenas testes manuais",
      "Refatorar antes de testar"
    ],
    "correctIndex": 0,
    "explanation": "TDD segue 3 passos em ciclo: 1) RED: escreva um teste que falha (o código ainda não existe). 2) GREEN: escreva o código mínimo para o teste passar. 3) REFACTOR: melhore o código mantendo os testes passando. Cada ciclo leva minutos. Garante cobertura desde o início.",
    "example": "Red: test('soma 2+3=5') → FAIL (function soma não existe). Green: function soma(a,b) { return a+b; } → PASS. Refactor: extrair para módulo math.ts. Testes continuam passando."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__3",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que é code coverage e qual é um percentual considerado bom?",
    "options": [
      "Percentual de código executado pelos testes; 80% é geralmente considerado um bom alvo",
      "Número total de testes",
      "Velocidade de execução",
      "Quantidade de bugs encontrados"
    ],
    "correctIndex": 0,
    "explanation": "Code coverage mede quanto % do código é exercitado pelos testes: statements, branches, functions, lines. 80% é um alvo pragmático. 100% não garante ausência de bugs (cobertura não é qualidade). Mais importante: cobrir caminhos críticos e edge cases.",
    "example": "npx jest --coverage: Statements: 85%, Branches: 72%, Functions: 90%, Lines: 85%. O branch coverage de 72% indica que 28% dos caminhos if/else não são testados — foco de melhoria."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__4",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que é BDD (Behavior-Driven Development) e como difere de TDD?",
    "options": [
      "Foco no comportamento do sistema descrito em linguagem natural (Given/When/Then); TDD foca em código",
      "São idênticos",
      "BDD não usa testes automatizados",
      "TDD descreve comportamento e BDD testa código"
    ],
    "correctIndex": 0,
    "explanation": "BDD: testes escritos em linguagem de negócio (Given/When/Then ou Dado/Quando/Então). Facilitam comunicação com stakeholders não-técnicos. Ferramentas: Cucumber, Jest (describe/it semantics). TDD: foco na unidade de código. BDD: foco no comportamento do sistema.",
    "example": "BDD: Given('usuário logado') When('clica em sair') Then('redireciona para login'). TDD: test('logout volta para /login', () => { logout(); expect(location).toBe('/login'); }). BDD é mais legível para não-devs."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__5",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que são fixtures e factories em testes e por que são úteis?",
    "options": [
      "Dados predefinidos (fixtures) ou geradores de dados (factories) para setup de testes, evitando duplicação",
      "Ferramentas de deploy",
      "Padrões de arquitetura",
      "Tipos de assertions"
    ],
    "correctIndex": 0,
    "explanation": "Fixtures: dados estáticos reutilizáveis (JSON, seed data) para setup de testes. Factories: funções que geram objetos de teste com valores padrão e sobrescrevíveis. Evitam duplicação de setup e tornam testes mais legíveis e manuteníveis.",
    "example": "const userFactory = (overrides = {}) => ({ id: faker.string.uuid(), name: faker.person.firstName(), email: faker.internet.email(), ...overrides }); const admin = userFactory({ role: 'admin' }); — gera usuário com defaults e permite customizar."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__6",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que é isolamento de testes (test isolation) e por que é importante?",
    "options": [
      "Cada teste deve ser independente, sem dependar de outros testes ou de estado compartilhado",
      "Testes devem rodar em servidor isolado",
      "Testes devem ser escritos por uma única pessoa",
      "Isolar testes significa deletá-los"
    ],
    "correctIndex": 0,
    "explanation": "Test isolation: cada teste cria seu próprio estado, executa e limpa após si. Testes não devem depender da ordem de execução nem de estado deixado por outros. Violação: teste B só passa se teste A rodar antes. Ferramentas: beforeEach/afterEach, cleanup automático.",
    "example": "beforeEach(() => { db = createTestDatabase(); }); afterEach(() => { db.destroy(); }); — cada teste começa com banco limpo. Sem isso: teste 'criar usuário' polui o estado para teste 'listar usuários' (deveria estar vazio)."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__7",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que é CI/CD com testes automatizados no pipeline?",
    "options": [
      "Integração e entrega contínua onde testes rodam automaticamente a cada push, bloqueando merge se falharem",
      "Compilador de código",
      "Ferramenta de design",
      "Banco de dados de testes"
    ],
    "correctIndex": 0,
    "explanation": "CI (Continuous Integration): a cada push, testes rodam automaticamente (unit, integration, lint). Se falharem, PR não pode ser mergeado. CD (Continuous Delivery/Deployment): após testes passarem, deploy automático para staging/produção. Ferramentas: GitHub Actions, GitLab CI, Jenkins.",
    "example": "GitHub Actions: push → lint (1min) → unit tests (2min) → integration tests (5min) → build (2min) → deploy staging (1min). Se qualquer step falhar, pipeline para e PR fica com ✘ vermelho. Só merge com ✔ verde."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__8",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "Qual a diferença entre mock, stub e spy em testes?",
    "options": [
      "Stub: retorna valores pré-definidos sem verificar chamadas; Mock: verifica se foi chamado corretamente (comportamento); Spy: envolve implementação real registrando chamadas",
      "São sinônimos — termos diferentes para o mesmo conceito de substituição",
      "Mock substitui banco; Stub substitui APIs externas; Spy monitora logs do sistema",
      "Spy é para testes unitários; Mock para integração; Stub para E2E"
    ],
    "correctIndex": 0,
    "explanation": "Test Doubles (Meszaros): Stub — retorna dados fixos, controla estado, sem assertions sobre chamadas. Mock — pre-programado com expectations: expect(mock.metodo).toHaveBeenCalledWith(arg). Spy — wraps implementação real, registra chamadas para verificação posterior. Fake — implementação simplificada (in-memory DB). Dummy — preenche parâmetros obrigatórios sem uso real.",
    "example": "Stub: jest.fn().mockReturnValue({id:1}) — retorna dados sem verificar. Mock: emailService.send = jest.fn(); ... expect(emailService.send).toHaveBeenCalledWith('ana@mail.com', 'Boas-vindas'). Spy: const spy = jest.spyOn(cache, 'get'); cache.get(key); expect(spy).toHaveBeenCalledTimes(1) — implementação real rodou mas registrou."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__9",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que é a pirâmide de testes e como equilibrar unitários, integração e E2E?",
    "options": [
      "Base: muitos unitários (rápidos/baratos); meio: alguns de integração; topo: poucos E2E (lentos/caros/frágeis); proporção recomendada evita a anti-pattern 'ice cream cone'",
      "Todos os tipos em proporções iguais para cobertura balanceada e justa",
      "Maioria de testes E2E pois simulam o usuário real com maior confiança",
      "Apenas testes E2E são suficientes para garantir qualidade de software"
    ],
    "correctIndex": 0,
    "explanation": "Pirâmide (Mike Cohn): unitários = base (muitos, ms, baratos, isolados), integração = meio (alguns, segundos, verificam módulos juntos), E2E = topo (poucos, minutos, frágeis, alto valor). Anti-pattern ice cream cone: maioria E2E (lento, caro, frágil). Testing Trophy (Kent Dodds para React): mais integração que unitário (componentes com DOM). Suite típica: 70% unitários, 20% integração, 10% E2E.",
    "example": "Suite 500u+50int+10e2e: < 3 minutos. 100 E2E: 30+ minutos, falhas intermitentes por timing. React Testing Library: testa componentes com DOM real (integração) — mais valor que só funções unitárias. Cypress/Playwright: 10 jornadas críticas do usuário. E2E cobre o que unitários não conseguem (routing, auth, fluxo completo)."
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__10",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que são testes de integração e como diferem de testes unitários e end-to-end em escopo e velocidade?",
    "options": [
      "Testam a interação entre módulos reais (ex: serviço + banco de dados); mais lentos que unitários mas mais rápidos que E2E, cobrindo cenários que mocks não capturam",
      "Testam cada função isoladamente com mocks; são os mais lentos pois cobrem todos os caminhos",
      "Testam a aplicação inteira do ponto de vista do usuário via browser automatizado",
      "Testam apenas a interface visual comparando screenshots entre versões"
    ],
    "correctIndex": 0,
    "explanation": "Unitário: testa função/classe isolada com mocks. Rápido (~ms). Integração: testa interação real entre módulos (API + DB real, serviço A chama serviço B). Médio (~s). Descobre: queries SQL erradas, serializações, configurações. E2E: testa fluxo completo como usuário (Cypress/Playwright). Lento (~min). Pirâmide: muitos unitários, menos integração, poucos E2E. Testcontainers: sobe DB real em Docker para testes de integração.",
    "example": "Unitário: test('createUser valida email', () => { expect(() => createUser({email:'invalid'})).toThrow(); }); — mock do repo. Integração: test('createUser persiste no banco', async () => { await createUser({email:'a@b.com'}); const user = await db.query('SELECT * FROM users'); expect(user).toHaveLength(1); }); — banco real (Testcontainers). E2E: test('signup flow', () => { cy.visit('/signup'); cy.type('#email','a@b.com'); cy.click('Submit'); cy.contains('Welcome'); });"
  },
  {
    "id": "desenvolvimento__Testes de Software__Médio__11",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Médio",
    "question": "O que é Test-Driven Development (TDD) e quais são os três passos do ciclo Red-Green-Refactor?",
    "options": [
      "Red: escrever teste que falha para comportamento desejado; Green: implementar código mínimo para passar; Refactor: melhorar código mantendo testes verdes",
      "Red: detectar bugs em produção; Green: corrigir; Refactor: otimizar performance",
      "Red: código com erros de compilação; Green: compilação bem-sucedida; Refactor: adicionar testes",
      "Red: branch com conflitos; Green: merge resolvido; Refactor: limpar histórico"
    ],
    "correctIndex": 0,
    "explanation": "TDD: testes guiam o design do código. Red: escrever teste para funcionalidade que não existe ainda (falha porque código não foi escrito). Green: implementar código MÍNIMO para passar (pode ser feio). Refactor: melhorar estrutura sem quebrar testes (rede de segurança). Ciclo curto: poucos minutos. Benefícios: design emergente, documentação viva, confiança em mudanças, debugging mais fácil. Código testável by design.",
    "example": "Funcionalidade: calcular desconto. Red: test('aplica 10% acima de R$100', () => expect(calcDesconto(200)).toBe(20)); → FAIL (calcDesconto não existe). Green: function calcDesconto(v) { return v > 100 ? v*0.1 : 0; } → PASS. Refactor: extrair constantes THRESHOLD=100, RATE=0.1. Testes continuam verdes. Próximo ciclo: test('sem desconto abaixo de R$100', ...)."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__1",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "Na estratégia de testes 'Contract Testing' entre microsserviços, como o Pact framework garante que producer e consumer estejam compatíveis?",
    "options": [
      "Consumer gera um contrato com requisições esperadas; Producer verifica que suas respostas atendem ao contrato",
      "Producer define a API e Consumer adapta",
      "Ambos rodam o mesmo teste end-to-end",
      "Usa snapshots de JSON para comparação manual"
    ],
    "correctIndex": 0,
    "explanation": "No Pact, o Consumer define expectativas (quais requests fará e quais respostas espera) que são salvas como 'contratos' (Pact files). O Producer roda esses contratos contra sua API real, verificando que todas as respostas atendem às expectativas. Contratos são versionados e publicados em um Pact Broker.",
    "example": "Consumer cria contrato: GET /users/1 espera { name: string, email: string }. Producer testa: roda GET /users/1 na sua API e verifica que a resposta inclui name e email. Se Producer remover o campo email, o contrato do Consumer falha."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__2",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que são property-based tests e como diferem de example-based tests?",
    "options": [
      "Geram centenas de inputs aleatórios testando propriedades matemáticas do código, em vez de exemplos fixos",
      "Testes com configurações de ambiente",
      "Testes de propriedades CSS",
      "Testes de performance"
    ],
    "correctIndex": 0,
    "explanation": "Example-based: você escolhe inputs específicos (soma(2,3) === 5). Property-based: você define propriedades que devem valer para QUALQUER input válido (ex: sort(arr).length === arr.length). O framework (fast-check, QuickCheck) gera centenas de inputs aleatórios e verifica a propriedade.",
    "example": "fc.assert(fc.property(fc.array(fc.integer()), (arr) => { const sorted = sort(arr); return sorted.length === arr.length && isSorted(sorted); })); — testa com 100 arrays aleatórios. Encontra edge cases que você não pensaria."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__3",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que é mutation testing e como ele avalia a qualidade dos testes?",
    "options": [
      "Introduz mutações (bugs) no código e verifica se os testes detectam; mutações não detectadas indicam testes fracos",
      "Testes que mudam frequentemente",
      "Testes de modificação de banco",
      "Testes genéticos"
    ],
    "correctIndex": 0,
    "explanation": "Mutation testing modifica o código fonte (troca > por <, remove return, inverte booleanos) e roda os testes. Se os testes PASSAM com o código mutado, significa que os testes são fracos (não detectam o bug). Mutation score = mutantes mortos/total. Complementa code coverage.",
    "example": "Mutação: trocar 'if (age >= 18)' por 'if (age > 18)'. Se testes passam, nenhum teste verifica o caso age=18 (boundary). Ferramentas: Stryker (JS/TS), PITest (Java). Mutation score alvo: >80%."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__4",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que é snapshot testing e quais são seus prós e contras?",
    "options": [
      "Captura a saída renderizada e compara com versão salva; detecta mudanças inesperadas mas pode gerar falsos positivos",
      "Screenshot da tela",
      "Backup do banco de dados",
      "Teste de performance"
    ],
    "correctIndex": 0,
    "explanation": "Snapshot testing: primeira execução salva a saída (JSON/HTML). Execuções seguintes comparam com o snapshot salvo. Se diferir, teste falha. Prós: detecta regressões visuais, fácil de criar. Contras: falsos positivos frequentes, snapshots grandes são ignorados, cultura de 'update all'.",
    "example": "test('renders correctly', () => { const tree = renderer.create(<UserCard name='Ana' />).toJSON(); expect(tree).toMatchSnapshot(); }); — gera arquivo .snap. Se UserCard mudar, teste falha até rodar: jest --updateSnapshot."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__5",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que é o conceito de test doubles e como se aplicam na arquitetura hexagonal?",
    "options": [
      "Substitutos para dependências reais nos testes; na hexa, ports são facilmente substituídos por adapters falsos",
      "Testes executados duas vezes",
      "Cópias do banco de produção",
      "Duplicação de código de teste"
    ],
    "correctIndex": 0,
    "explanation": "Test doubles (termo genérico para mocks, stubs, fakes, spies, dummies) substituem dependências reais em testes. Na arquitetura hexagonal, ports (interfaces) permitem injetar adapters falsos facilmente. Fakes: implementação funcional simplificada (ex: InMemoryRepository).",
    "example": "interface UserRepo { save(u: User): Promise<void>; } class InMemoryUserRepo implements UserRepo { users = []; async save(u) { this.users.push(u); } } — fake completo para testes sem banco. Mesma interface, implementação trivial."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__6",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que é Chaos Engineering e como difere de testes tradicionais?",
    "options": [
      "Prática de injetar falhas controladas em produção para verificar resiliência do sistema",
      "Testes unitários com dados aleatórios",
      "Testes de performance com carga alta",
      "Debugging em ambiente local"
    ],
    "correctIndex": 0,
    "explanation": "Chaos Engineering: 'quebre coisas de propósito para provar que o sistema resiste'. Injeta falhas controladas: matar instâncias (Chaos Monkey), latência artificial, partições de rede. Verifica se redundancy, failover e graceful degradation funcionam. Difere de testes: roda em produção com tráfego real.",
    "example": "Netflix Chaos Monkey: mata instâncias EC2 aleatórias em produção durante horário comercial. Se o sistema não se recuperar automáticamente, há um problema de resiliência antes que um incidente real ocorra."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__7",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que são testes de carga e performance e quais métricas monitorar?",
    "options": [
      "Simulam alto volume de usuários para medir throughput, latência, error rate e identificar gargalos",
      "Testes de funcionalidade com muitos dados",
      "Testes de UI em diferentes resoluções",
      "Testes de segurança com ataques DDoS"
    ],
    "correctIndex": 0,
    "explanation": "Load testing: simula carga esperada. Stress testing: aumenta além do limite. Spike testing: picos súbitos. Soak testing: carga constante por longo período. Métricas: throughput (req/s), latência (p50, p95, p99), error rate, CPU/memória. Ferramentas: k6, Artillery, JMeter, Locust.",
    "example": "k6: 100 VUs (virtual users) durante 5 min. Resultado: p95 latência = 250ms, throughput = 500 req/s, error rate = 0.1%. Stress: 1000 VUs → p95 sobe para 2s, errors 5% → gargalo no banco (pool de conexões esgotado)."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__8",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que é property-based testing e como ele difere de example-based testing?",
    "options": [
      "Property-based define propriedades lógicas que devem valer para qualquer input; geradores aleatórios encontram edge cases que testes manuais não cobrem; shrinking minimiza o caso falho",
      "Property-based documenta o sistema; example-based garante cobertura de linhas",
      "São a mesma técnica com nomes diferentes em linguagens distintas",
      "Property-based testa somente tipos primitivos; example-based é para objetos complexos"
    ],
    "correctIndex": 0,
    "explanation": "Example-based: test('reverse([1,2,3]) = [3,2,1]') — casos escolhidos manualmente. Property-based: define propriedade (reverso do reverso = original, sort preserva elementos, append incrementa length) e gerador cria centenas de inputs aleatórios buscando falsificar a propriedade. Shrinking: ao achar input falho, minimiza para o menor caso. Encontra edge cases (vazio, null, overflow) que humanos não pensam.",
    "example": "fast-check: fc.assert(fc.property(fc.array(fc.integer()), (arr) => { const rev = [...arr].reverse(); return [...rev].reverse().join(',') === arr.join(','); })). Roda 100 arrays aleatórios. Se falha: shrinking produz o menor array que quebra. Hypothesis (Python), QuickCheck (Haskell), Jqwik (Java). Propriedade de encode/decode: decode(encode(x)) === x."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__9",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que é mutation testing e como ele avalia a qualidade real dos testes?",
    "options": [
      "Introduz bugs intencionais (mutantes) no código e verifica se testes os detectam; mutation score = % mutantes mortos; 100% cobertura de linhas não garante alta mutation score",
      "Testa automaticamente código que manipula dados mutáveis vs imutáveis",
      "Gera automaticamente testes unitários a partir de análise estática do código",
      "Verifica se testes são determinísticos eliminando dependências de estado mutável"
    ],
    "correctIndex": 0,
    "explanation": "Mutation testing (Stryker, PIT): gera mutantes (troca > por >=, remove return, inverte condicionais, altera operadores aritméticos). Executa suite para cada mutante. Morto: algum teste falhou (mutante detctado). Sobrevivente: nenhum teste falhou (lacuna na suite). Mutation score = mortos / (mortos + sobreviventes). 100% line coverage pode ter mutation score baixo se assertions são fracas.",
    "example": "Código: if (saldo >= valor). Mutante: if (saldo > valor). Test1: sacar(100) com saldo=200 → passa com ambos. Test2: sacar(100) com saldo=100 → passa com >=, falha com > → mata mutante. Test1 sobrevive com mutante = lacuna. Stryker para JS/TS: stryker run. Mutation score 80%+ indica testes que realmente testam lógica."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__10",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que são Contract Tests e como eles garantem compatibilidade entre serviços em arquiteturas de microsserviços?",
    "options": [
      "Testes que verificam se a interface entre consumer e provider segue um contrato acordado; Pact é a ferramenta mais popular, gerando contratos do lado do consumer que o provider valida",
      "Testes que validam termos legais de uso da API junto com termos de serviço",
      "Testes de integração entre todos os microsserviços executados em ambiente de staging",
      "Documentação OpenAPI/Swagger que descreve endpoints e serve como contrato estático"
    ],
    "correctIndex": 0,
    "explanation": "Contract Testing: verifica que comunicação entre serviços segue acordo. Consumer-driven (Pact): 1) Consumer gera contrato (expect: GET /users/1 → {id:1, name:string}). 2) Contrato compartilhado via Pact Broker. 3) Provider valida: roda testes contra contrato, garante que implementação atende. Benefício vs integration test: não precisa de ambos os serviços rodando simultaneamente. Detecta: campos removidos, tipos alterados, endpoints renomeados antes do deploy.",
    "example": "Consumer (frontend): pact.addInteraction({ uponReceiving: 'get user by id', withRequest: { method: 'GET', path: '/users/1' }, willRespondWith: { status: 200, body: { id: integer(1), name: string('Ana') } } }). Provider (API): verifyPact({ providerBaseUrl: 'http://localhost:3000', pactUrls: ['pact-broker/consumer-provider.json'] }). Provider altera name→fullName: contract test FALHA → breaking change detectada."
  },
  {
    "id": "desenvolvimento__Testes de Software__Difícil__11",
    "track": "desenvolvimento",
    "category": "Testes de Software",
    "difficulty": "Difícil",
    "question": "O que é Chaos Engineering e como experimentos controlados de falha melhoram a resiliência de sistemas?",
    "options": [
      "Disciplina de injetar falhas controladas em produção/staging para descobrir fraquezas antes que causem outages reais; segue hipótese → experimento → análise",
      "Testes de carga que simulam milhares de usuários para encontrar limites de capacidade",
      "Processo de code review focado em encontrar vulnerabilidades de segurança",
      "Automação de rollback que reverte deploys automaticamente quando métricas degradam"
    ],
    "correctIndex": 0,
    "explanation": "Chaos Engineering (Netflix): princípios — 1) Definir estado estável (SLIs normais). 2) Hipótese: 'sistema continua estável se nó X cair'. 3) Injetar falha: matar instância, simular latência, corromper rede. 4) Observar: métricas, logs, alertas. 5) Se hipótese falha → descobrir e corrigir fraqueza antes de outage real. Ferramentas: Chaos Monkey (Netflix), LitmusChaos (Kubernetes), AWS FIS. Blast radius: começar pequeno, escalar gradualmente.",
    "example": "Hipótese: 'Se 1 de 3 réplicas do serviço de pagamento cair, latência p99 fica abaixo de 500ms'. Experimento: Chaos Monkey mata 1 container. Observação: latência subiu para 2s porque auto-scaling demorou 3min. Insight: health check interval muito longo (30s → reduzir para 5s) + readiness probe mal configurada. Fix aplicado. Re-teste: latência p99 = 350ms. Resiliência comprovada."
  },
  {
    "id": "linguagens-de-programacao__C__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Fácil",
    "question": "Em C, qual função da biblioteca padrão é usada para alocar memória dinamicamente no heap?",
    "options": [
      "malloc",
      "alloc",
      "new",
      "heap"
    ],
    "correctIndex": 0,
    "explanation": "A função malloc (memory allocation) reserva um bloco contíguo de bytes no heap e retorna um ponteiro void* para o início do bloco. O programador é responsável por liberar a memória com free() para evitar memory leaks.",
    "example": "int *arr = (int *)malloc(10 * sizeof(int)); — aloca espaço para 10 inteiros. Após uso: free(arr);"
  },
  {
    "id": "linguagens-de-programacao__C__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Fácil",
    "question": "Em C, qual é a diferença entre 'printf' e 'scanf'?",
    "options": [
      "printf exibe dados na tela; scanf lê dados do teclado",
      "São idênticos",
      "printf lê e scanf exibe",
      "Ambos escrevem em arquivo"
    ],
    "correctIndex": 0,
    "explanation": "printf (print formatted) envia saída formatada para stdout (tela). scanf (scan formatted) lê entrada formatada de stdin (teclado). Ambos usam format specifiers como %d para inteiros, %s para strings, %f para floats.",
    "example": "printf('Idade: %d', idade); // Exibe 'Idade: 25'. scanf('%d', &idade); // Lê um inteiro do teclado e armazena em 'idade'. Note o & para passar o endereço."
  },
  {
    "id": "linguagens-de-programacao__C__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Fácil",
    "question": "Em C, qual é a diferença entre um array e um ponteiro?",
    "options": [
      "Array é bloco contíguo de tamanho fixo; ponteiro é variável que armazena endereço de memória",
      "São exatamente a mesma coisa",
      "Ponteiro é mais rápido",
      "Array pode mudar de tamanho"
    ],
    "correctIndex": 0,
    "explanation": "Um array em C é um bloco contíguo de memória de tamanho fixo definido em tempo de compilação. Um ponteiro é uma variável que armazena um endereço. Arrays 'decaem' para ponteiros em expressões, mas sizeof(array) retorna o tamanho total, enquanto sizeof(ponteiro) retorna o tamanho do ponteiro.",
    "example": "int arr[5]; sizeof(arr) == 20 (5×4 bytes). int *p = arr; sizeof(p) == 8 (tamanho do ponteiro em 64-bit). arr[2] é equivalente a *(p+2)."
  },
  {
    "id": "linguagens-de-programacao__C__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Fácil",
    "question": "O que são os tipos de dados básicos em C e quantos bytes cada um ocupa?",
    "options": [
      "char (1 byte), int (4 bytes), float (4 bytes), double (8 bytes) — tamanhos típicos em 64-bit",
      "Todos ocupam 4 bytes",
      "C não tem tipos definidos",
      "char (8 bytes), int (1 byte)"
    ],
    "correctIndex": 0,
    "explanation": "Em C, os tipos básicos incluem: char (1 byte, -128 a 127 ou 0-255), int (tipicamente 4 bytes), float (4 bytes, ~7 dígitos), double (8 bytes, ~15 dígitos). Tamanhos podem variar por plataforma — usar sizeof() para confirmar. stdint.h fornece tipos com tamanho exato (int32_t).",
    "example": "printf('%zu %zu %zu %zu', sizeof(char), sizeof(int), sizeof(float), sizeof(double)); // 1 4 4 8 (típico 64-bit). Use int32_t do stdint.h para garantir 4 bytes em qualquer plataforma."
  },
  {
    "id": "linguagens-de-programacao__C__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Fácil",
    "question": "O que é a diferença entre stack e heap em C?",
    "options": [
      "Stack: alocação automática e rápida, tamanho limitado; Heap: alocação manual (malloc/free), maior mas mais lenta",
      "São iguais",
      "Heap é mais rápido",
      "Stack precisa de malloc"
    ],
    "correctIndex": 0,
    "explanation": "Stack: variáveis locais, alocação/desalocação automática (LIFO), muito rápida, tamanho limitado (~1-8MB). Heap: alocação dinâmica via malloc/free, maior, mais lenta, risco de memory leaks se não fizer free. Variáveis globais ficam no data segment.",
    "example": "void foo() { int x = 10; // stack (liberado ao sair). int *p = malloc(100); // heap (precisa de free). } Se esquecer free(p) → memory leak. Se acessar x fora de foo → undefined behavior."
  },
  {
    "id": "linguagens-de-programacao__C__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Fácil",
    "question": "O que é um header file (.h) em C e por que usamos a diretiva #include?",
    "options": [
      "Arquivo com declarações de funções/tipos que #include copia textualmente para o .c, permitindo reutilização",
      "Arquivo compilado separadamente",
      "Biblioteca binária",
      "Arquivo de configuração do compilador"
    ],
    "correctIndex": 0,
    "explanation": "#include faz o pré-processador copiar o conteúdo do header no arquivo .c. Headers declaram protótipos de funções, tipos, macros e constantes. Usa-se #ifndef/#define/#endif (include guards) para evitar inclusão dupla que causaria erros de redefinição.",
    "example": "// math_utils.h\n#ifndef MATH_UTILS_H\n#define MATH_UTILS_H\nint soma(int a, int b);\n#endif\n// main.c\n#include \"math_utils.h\"\nint main() { printf(\"%d\", soma(2,3)); }"
  },
  {
    "id": "linguagens-de-programacao__C__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre 'const' e '#define' para declarar constantes em C?",
    "options": [
      "const cria variável tipada respeitando escopo; #define faz substituição textual sem tipo nem escopo",
      "São a mesma coisa",
      "#define é mais moderno",
      "const só funciona com inteiros"
    ],
    "correctIndex": 0,
    "explanation": "const: variável com tipo, respeitada pelo compilador (type checking), tem escopo. #define: substituição textual pelo pré-processador, sem tipo, sem escopo, sem debug symbol. const é preferido em C99+ por segurança. Enum também é alternativa para inteiros.",
    "example": "#define PI 3.14159 // sem tipo, global. const double pi = 3.14159; // tipo double, escopo respeitado, visível no debugger. Em C, const não cria constante de compilação (diferente de C++)."
  },
  {
    "id": "linguagens-de-programacao__C__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Fácil",
    "question": "O que são ponteiros em C e qual o operador para obter o endereço de uma variável?",
    "options": [
      "Ponteiro armazena o endereço de memória de outra variável; '&' obtém o endereço e '*' acessa o valor apontado (dereference)",
      "Ponteiro é um array de bytes que armazena o valor de outra variável",
      "'@' obtém endereço e '->' acessa o valor em C padrão",
      "Ponteiros em C são iguais a referências em Java, sem aritmeticá de endereços"
    ],
    "correctIndex": 0,
    "explanation": "int x = 10; int *p = &x; *p = 20; // x agora vale 20. '&x' retorna o endereço de x na memória. '*p' acessa o valor naquele endereço (54321 por exemplo). Aritmética de ponteiros: p+1 avança sizeof(int) bytes. Ponteiros nulos: NULL; dereferenciar NULL causa segfault.",
    "example": "Trocar dois valores sem retorno: void swap(int *a, int *b) { int tmp=*a; *a=*b; *b=tmp; }. Chamar: swap(&x, &y). Sem ponteiro: swap(x,y) receberia cópias, original não mudaria (pass by value). Ponteiro para ponteiro: int **pp = &p; — usado em allocações de matrizes dinâmicas."
  },
  {
    "id": "linguagens-de-programacao__C__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Médio",
    "question": "Em C, qual é a diferença entre um ponteiro para array e um array de ponteiros?",
    "options": [
      "Ponteiro para array aponta para o array inteiro; array de ponteiros é um array onde cada elemento é um ponteiro",
      "São a mesma coisa",
      "Ponteiro para array usa ** e array de ponteiros usa *",
      "Não existe ponteiro para array em C"
    ],
    "correctIndex": 0,
    "explanation": "int (*p)[10] é um ponteiro para um array de 10 ints — p aponta para o bloco inteiro. int *p[10] é um array de 10 ponteiros para int — cada p[i] aponta para um int diferente. A diferença é na precedência: (*p) vs *p[].",
    "example": "int arr[10]; int (*p)[10] = &arr; // p aponta para o array completo. int *ptrs[3] = {&a, &b, &c}; // array com 3 ponteiros independentes."
  },
  {
    "id": "linguagens-de-programacao__C__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Médio",
    "question": "Em C, o que são structs e como elas permitem agrupar dados de tipos diferentes?",
    "options": [
      "Tipo composto que agrupa variáveis de tipos diferentes sob um único nome",
      "São classes como em Java",
      "São apenas arrays nomeados",
      "Só agrupam dados do mesmo tipo"
    ],
    "correctIndex": 0,
    "explanation": "Structs em C permitem criar tipos de dados compostos que agrupam variáveis (membros/campos) de tipos diferentes em uma única unidade. Diferente de classes em OOP, structs em C não têm métodos, herança ou encapsulamento — são apenas agrupamento de dados.",
    "example": "struct Ponto { int x; int y; }; struct Ponto p1 = {10, 20}; printf('%d', p1.x); // 10. Com ponteiro: struct Ponto *pp = &p1; pp->x; // 10 (operador seta)."
  },
  {
    "id": "linguagens-de-programacao__C__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Médio",
    "question": "Em C, qual é a diferença entre passar argumentos por valor e por referência (via ponteiro)?",
    "options": [
      "Por valor copia o dado (original inalterado); por ponteiro passa o endereço (permite modificar o original)",
      "São a mesma coisa",
      "C só permite passagem por valor",
      "Por referência é mais lento"
    ],
    "correctIndex": 0,
    "explanation": "C sempre passa argumentos por valor (cópia). Para simular passagem por referência, passa-se o endereço da variável (ponteiro). A função recebe o ponteiro e pode modificar o valor original através de desreferenciação (*ptr).",
    "example": "void dobrar(int *p) { *p = *p * 2; } int x = 5; dobrar(&x); // x agora é 10. Sem ponteiro: void dobrar(int n) { n = n * 2; } — x continua 5 (cópia)."
  },
  {
    "id": "linguagens-de-programacao__C__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Médio",
    "question": "O que é uma struct em C e como ela difere de um array?",
    "options": [
      "Struct agrupa variáveis de tipos diferentes sob um nome; array armazena elementos do mesmo tipo",
      "São idênticos",
      "Array pode ter tipos diferentes",
      "Struct só aceita inteiros"
    ],
    "correctIndex": 0,
    "explanation": "Struct: tipo definido pelo usuário que agrupa membros de tipos diferentes (como classe sem métodos). Array: sequência de elementos do MESMO tipo. Structs permitem modelar entidades complexas (ponto, usuário). Acessam membros com . (dot) ou -> (ponteiro).",
    "example": "struct Point { int x; int y; }; struct Point p = {10, 20}; p.x = 30; // acesso direto. struct Point *pp = &p; pp->y = 40; // acesso via ponteiro."
  },
  {
    "id": "linguagens-de-programacao__C__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Médio",
    "question": "O que é um macro com #define em C e quais são seus riscos?",
    "options": [
      "Substituição textual feita pelo pré-processador antes da compilação; risco de efeitos colaterais sem type safety",
      "Função optimizada pelo compilador",
      "Variável global",
      "Comentário especial"
    ],
    "correctIndex": 0,
    "explanation": "#define cria macros resolvidas pelo pré-processador (substituição textual). Não tem type checking, escopo, ou debug fácil. Riscos: efeitos colaterais (#define SQUARE(x) x*x → SQUARE(a+1) = a+1*a+1). Inline functions são alternativa type-safe em C99+.",
    "example": "#define MAX(a,b) ((a)>(b)?(a):(b)) — parece função mas é texto. MAX(i++,j++) pode incrementar i ou j duas vezes! Solução C99: static inline int max(int a, int b) { return a>b?a:b; }"
  },
  {
    "id": "linguagens-de-programacao__C__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Médio",
    "question": "O que são variáveis 'static' em C e como se comportam dentro e fora de funções?",
    "options": [
      "Dentro de função: mantém valor entre chamadas; fora de função: restringe visibilidade ao arquivo",
      "Sempre são constantes",
      "Equivalem a variáveis globais",
      "São alocadas no heap"
    ],
    "correctIndex": 0,
    "explanation": "static dentro de função: variável local que persiste entre chamadas (inicializada uma vez). static fora de função/em função global: limita o escopo ao translation unit (arquivo .c), impedindo acesso por outros arquivos — internal linkage.",
    "example": "void counter() { static int n = 0; n++; printf('%d ', n); } counter(); counter(); counter(); // 1 2 3 (n persiste). static int x = 10; // em escopo de arquivo, invisível para outros .c."
  },
  {
    "id": "linguagens-de-programacao__C__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Médio",
    "question": "O que é 'typedef' em C e como melhora a legibilidade do código?",
    "options": [
      "Cria alias para tipos existentes, simplificando declarações complexas de ponteiros, structs e function pointers",
      "Define novas variáveis",
      "Cria macros de pré-processador",
      "Declara funções inline"
    ],
    "correctIndex": 0,
    "explanation": "typedef cria sinônimos para tipos. Simplifica structs (typedef struct { int x; } Point; — sem repetir 'struct'), function pointers (typedef void (*Callback)(int);) e tipos complexos. Melhora portabilidade e legibilidade.",
    "example": "typedef unsigned long ulong; typedef struct { int x, y; } Vec2; typedef int (*Comparator)(const void*, const void*); Comparator cmp = compare; // muito mais legível que int (*cmp)(const void*, const void*)."
  },
  {
    "id": "linguagens-de-programacao__C__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Médio",
    "question": "O que é undefined behavior em C e cite dois exemplos clássicos que o causam?",
    "options": [
      "Comportamento não definido pela norma C; exemplos: acessar array fora dos limites e ler variável não inicializada — compilador pode gerar qualquer resultado",
      "Resultado sempre previsível mas não especificado; ponteiros nulos causam UB por definição",
      "Erro de compilação gerado quando o compilador detecta comportamento indefinido",
      "Apenas overflow de inteiro signed é UB; outros casos são implementation-defined"
    ],
    "correctIndex": 0,
    "explanation": "Undefined Behavior (UB): a norma C não especifica o resultado. O compilador pode: crash, resultado incorreto, remover o código completamente (otimização). Exemplos: int arr[3]; arr[5]=1 (buffer overflow), int x; printf('%d', x) (leitura de lixo), signed integer overflow i=INT_MAX; i++, dereferenciar NULL. Ferramentas: Valgrind, AddressSanitizer (-fsanitize=address) detectam em runtime.",
    "example": "arr[10] em array de 5: pode 'funcionar' em debug (memória válida ali por acaso), crash em release (otimização muda layout). UB permite GCC assumir que ponteiros não são nulos e remover checks de nulidade. 'Nasal demons': expressão da comunidade C para UB que faz qualquer coisa. Compile com -Wall -Wextra -fsanitize=address para detectar."
  },
  {
    "id": "linguagens-de-programacao__C__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Difícil",
    "question": "Em C, o que é 'undefined behavior' causado por 'strict aliasing violation' e como evitá-lo?",
    "options": [
      "Acessar um objeto via ponteiro de tipo incompatível; usar memcpy ou union em vez de casting direto",
      "Usar variáveis sem inicializar",
      "Acessar array fora dos limites",
      "Usar goto em loops aninhados"
    ],
    "correctIndex": 0,
    "explanation": "Strict aliasing rule determina que um ponteiro de tipo T* só pode acessar objetos do tipo T (com exceções para char*). Violar isso (ex.: ler um float via int*) é undefined behavior pois o compilador assume que ponteiros de tipos diferentes não apontam para o mesmo endereço, otimizando agressivamente.",
    "example": "float f = 3.14; int i = *(int*)&f; // UB! strict aliasing violation. Correto: int i; memcpy(&i, &f, sizeof(i)); // OK, memcpy é safe."
  },
  {
    "id": "linguagens-de-programacao__C__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Difícil",
    "question": "Em C, o que são function pointers e qual sua utilidade prática?",
    "options": [
      "Ponteiros que armazenam o endereço de funções, permitindo chamar funções indiretamente e implementar callbacks",
      "Ponteiros para variáveis globais",
      "Funções que retornam ponteiros",
      "Não existem em C"
    ],
    "correctIndex": 0,
    "explanation": "Function pointers armazenam o endereço de funções, permitindo: callbacks (qsort usa comparator), tabelas de dispatch (simulando polimorfismo), e carregamento dinâmico de funções (dlsym). A sintaxe é: tipo_retorno (*nome)(parâmetros).",
    "example": "int compare(const void *a, const void *b) { return *(int*)a - *(int*)b; } qsort(arr, n, sizeof(int), compare); — 'compare' é passada como function pointer para qsort."
  },
  {
    "id": "linguagens-de-programacao__C__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Difícil",
    "question": "Em C, o que é 'volatile' e quando essa keyword deve ser usada?",
    "options": [
      "Indica ao compilador que a variável pode mudar a qualquer momento fora do controle do programa, impedindo otimizações",
      "Torna variável imutável",
      "Aloca na stack",
      "Marca variável para garbage collection"
    ],
    "correctIndex": 0,
    "explanation": "volatile informa ao compilador que o valor da variável pode mudar inesperadamente (hardware registers, variáveis modificadas por ISR ou outra thread). O compilador não pode otimizar acessos (cache em registrador, reordenar, eliminar leituras 'redundantes'). Crucial em embedded e device drivers.",
    "example": "volatile uint32_t *status_reg = (uint32_t*)0x40001000; while (*status_reg & 0x01) {} // Sem volatile, compilador poderia ler uma vez e cachear, criando loop infinito."
  },
  {
    "id": "linguagens-de-programacao__C__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Difícil",
    "question": "O que é undefined behavior (UB) em C e por que é perigoso?",
    "options": [
      "Comportamento não definido pelo padrão C; o compilador pode fazer qualquer coisa, incluindo otimizar o código de formas inesperadas",
      "Apenas um warning",
      "Erro de compilação",
      "Bug do sistema operacional"
    ],
    "correctIndex": 0,
    "explanation": "UB: o padrão C não define o que acontece. Exemplos: acesso fora do array, dereferenciar NULL, integer overflow com signed int, usar variável não inicializada. O compilador pode: ignorar, otimizar removendo código, ou gerar código que funciona em debug mas falha em release.",
    "example": "int a[3]; a[5] = 42; // UB: acesso fora do array. int *p = NULL; *p = 1; // UB: seg fault provável. int x = INT_MAX; x++; // UB: signed overflow. Pode funcionar em -O0 e crashar em -O2."
  },
  {
    "id": "linguagens-de-programacao__C__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Difícil",
    "question": "O que é memory alignment em C e por que importa para performance?",
    "options": [
      "Dados alinhados em endereços múltiplos do seu tamanho para acesso eficiente pela CPU; desalinhamento causa penalidade",
      "Ordenação de bytes no arquivo",
      "Alocação contígua de arrays",
      "Compactação de memória pelo OS"
    ],
    "correctIndex": 0,
    "explanation": "CPUs acessam memória mais eficientemente quando dados estão alinhados (int de 4 bytes em endereço múltiplo de 4). Structs podem ter padding para manter alinhamento. sizeof(struct) pode ser maior que a soma dos membros. #pragma pack reduz padding.",
    "example": "struct A { char c; int i; }; // sizeof = 8 (não 5! 3 bytes de padding após char). struct B { int i; char c; }; // sizeof = 8 também. struct C { char c; char d; int i; }; // sizeof = 8 (2 bytes padding após d)."
  },
  {
    "id": "linguagens-de-programacao__C__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Difícil",
    "question": "O que são operadores bitwise em C e quais os principais usos de bit manipulation?",
    "options": [
      "Operadores &, |, ^, ~, <<, >> manipulam bits individuais; usados em flags, máscaras e otimizações de baixo nível",
      "Operadores aritméticos padrão",
      "Operadores de comparação",
      "Funções de string"
    ],
    "correctIndex": 0,
    "explanation": "& (AND), | (OR), ^ (XOR), ~ (NOT), << (shift left), >> (shift right). Usados para: flags (permissions |= WRITE), máscaras (valor & 0xFF extrai byte), toggle (flag ^= BIT), teste (if (flags & READ)), multiplicação/divisão por 2 (n << 1).",
    "example": "#define READ 0x01\n#define WRITE 0x02\n#define EXEC 0x04\nint perms = READ | WRITE; // 0x03. if (perms & EXEC) {} // false. perms |= EXEC; // adiciona. perms &= ~WRITE; // remove WRITE."
  },
  {
    "id": "linguagens-de-programacao__C__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Difícil",
    "question": "O que é o qualificador 'restrict' em C99 e como ajuda o compilador a otimizar?",
    "options": [
      "Garante que um ponteiro é o único acesso àquela memória, permitindo otimizações de aliasing",
      "Torna o ponteiro constante",
      "Limita o tamanho do array",
      "Impede alocação no heap"
    ],
    "correctIndex": 0,
    "explanation": "restrict informa ao compilador que o ponteiro é o ÚNICO meio de acessar aquela memória no escopo. Sem restrict, o compilador assume que ponteiros podem apontar para o mesmo endereço (aliasing), impedindo otimizações como vetorização SIMD e reordenação de loads/stores.",
    "example": "void add(int * restrict a, int * restrict b, int * restrict c, int n) { for (int i=0; i<n; i++) c[i] = a[i] + b[i]; } // Com restrict, compilador pode vetorizar com SIMD. memcpy usa restrict; memmove não (permite overlap)."
  },
  {
    "id": "linguagens-de-programacao__C__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "C",
    "difficulty": "Difícil",
    "question": "Como funcionam as funções variadic em C (tipo printf) usando stdarg.h?",
    "options": [
      "Usam va_list, va_start, va_arg, va_end para acessar argumentos extras em runtime; o número e tipo dos args deve ser inferido de outro argumento (ex: string de formato)",
      "Recebem array explícito com tamanho e ponteiro; stdarg.h apenas documenta a interface",
      "Compilador empacota todos os args em struct automático acessível por índice",
      "Somente o compilador usa va_list internamente; programadores usam `...` sem stdarg.h"
    ],
    "correctIndex": 0,
    "explanation": "Variadic: int soma(int n, ...) { va_list args; va_start(args, n); int tot=0; for(int i=0;i<n;i++) tot+=va_arg(args,int); va_end(args); return tot; }. va_start inicializa após o último parâmetro fixo. va_arg extrai próximo arg com o tipo especificado. va_end limpa. Sem informação de tipo em runtime: printf usa format string para saber tipos. Type mismatch = UB.",
    "example": "soma(3, 10, 20, 30) = 60. printf utiliza format string '%d %s %f' para extrair int, char*, double nessa ordem. Dar tipo errado: printf('%d', 3.14) — UB (doubles passam diferente de ints na ABI x86-64). __attribute__((format(printf, 1, 2))) no GCC valida a format string em compile-time. C23 introduz typeof para variadic mais seguro."
  },
  {
    "id": "linguagens-de-programacao__C++__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Fácil",
    "question": "Em C++, qual a diferença entre 'new' e 'malloc' para alocação de memória?",
    "options": [
      "new chama o construtor do objeto e retorna o tipo correto; malloc apenas aloca bytes brutos",
      "São equivalentes",
      "malloc é mais rápido que new",
      "new não pode ser usado com arrays"
    ],
    "correctIndex": 0,
    "explanation": "O operador 'new' em C++ aloca memória E chama o construtor do objeto, retornando um ponteiro tipado. malloc() apenas reserva bytes brutos sem chamar construtores e retorna void*. Para liberar: delete para new, free() para malloc.",
    "example": "std::string *s = new std::string(\"hello\"); // aloca + chama construtor. delete s; // chama destrutor + libera memória."
  },
  {
    "id": "linguagens-de-programacao__C++__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Fácil",
    "question": "Em C++, o que é RAII (Resource Acquisition Is Initialization) e por que é importante?",
    "options": [
      "Princípio onde recursos são adquiridos no construtor e liberados no destrutor, garantindo cleanup automático",
      "Um tipo de garbage collector",
      "Técnica de otimização",
      "Padrão de design de UI"
    ],
    "correctIndex": 0,
    "explanation": "RAII amarra a vida de um recurso (memória, arquivo, lock, conexão) ao tempo de vida de um objeto. O recurso é adquirido no construtor e liberado no destrutor. Como destructors são chamados automaticamente ao sair do escopo, o cleanup é garantido mesmo com exceções.",
    "example": "{ std::lock_guard<std::mutex> lock(mtx); // adquire lock no construtor. doWork(); // se lançar exceção... } // destrutor de lock_guard libera o mutex automaticamente."
  },
  {
    "id": "linguagens-de-programacao__C++__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Fácil",
    "question": "Em C++, qual a diferença entre referência (&) e ponteiro (*) ?",
    "options": [
      "Referência é alias imutável para um objeto existente; ponteiro é variável que armazena endereço e pode ser reatribuído",
      "São idênticos",
      "Referência pode ser nula",
      "Ponteiro não pode ser reatribuído"
    ],
    "correctIndex": 0,
    "explanation": "Referência (&): alias para um objeto, deve ser inicializada na declaração, não pode ser nula, não pode ser reatribuída. Ponteiro (*): variável com endereço, pode ser nulo, pode ser reatribuído, exige desreferenciação (*ptr). Referências são mais seguras; ponteiros mais flexíveis.",
    "example": "int x = 10; int &ref = x; ref = 20; // x agora é 20. int *ptr = &x; *ptr = 30; // x agora é 30. ptr = &y; // OK. &ref = y; // ERRO, não pode reatribuir referência."
  },
  {
    "id": "linguagens-de-programacao__C++__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Fácil",
    "question": "O que é RAII (Resource Acquisition Is Initialization) em C++?",
    "options": [
      "Padrão onde recursos são adquiridos no construtor e liberados no destrutor, garantindo cleanup automático",
      "Técnica de alocação dinâmica",
      "Padrão de inicialização de arrays",
      "Garbage collection em C++"
    ],
    "correctIndex": 0,
    "explanation": "RAII vincula o ciclo de vida de um recurso (memória, arquivo, mutex) ao ciclo de vida de um objeto. Construtor adquire, destrutor libera. Ao sair do escopo, destrutor é chamado automaticamente. Smart pointers (unique_ptr, shared_ptr) são RAII para memória.",
    "example": "{ std::unique_ptr<int> p = std::make_unique<int>(42); // aloca. use(*p); } // destrutor chamado automaticamente, memória liberada. Sem RAII: int *p = new int(42); use(*p); delete p; // esqueceu delete = leak."
  },
  {
    "id": "linguagens-de-programacao__C++__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Fácil",
    "question": "O que são templates em C++ e como diferem de generics em outras linguagens?",
    "options": [
      "Mecanismo de metaprogramação que gera código em tempo de compilação para cada tipo usado",
      "São idênticos a generics Java",
      "Só funcionam com classes",
      "São interpretados em runtime"
    ],
    "correctIndex": 0,
    "explanation": "Templates C++: o compilador gera código específico para cada tipo (monomorphization). vector<int> e vector<string> são classes completamente separadas no binário. Generics Java: type erasure em runtime (List<Integer> e List<String> são o mesmo bytecode). Templates permitem metaprogramação.",
    "example": "template<typename T> T max(T a, T b) { return a > b ? a : b; } max(3, 5); // gera função max<int>. max(3.14, 2.71); // gera função max<double>. Duas funções separadas no binário."
  },
  {
    "id": "linguagens-de-programacao__C++__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Fácil",
    "question": "O que é um namespace em C++ e por que 'using namespace std' pode ser problemático?",
    "options": [
      "Namespace agrupa identificadores para evitar conflitos; 'using namespace std' expõe todos os nomes e pode causar ambiguidades",
      "Namespace é uma classe especial",
      "using namespace é obrigatório",
      "Namespaces só existem em headers"
    ],
    "correctIndex": 0,
    "explanation": "Namespaces evitam colisões de nome (std::vector vs custom::vector). 'using namespace std;' importa TODOS os nomes de std para o escopo global, podendo conflitar com seu código (ex.: count, distance, size). Em headers é especialmente perigoso pois polui o namespace de quem inclui.",
    "example": "namespace math { double pi = 3.14; } math::pi; // acesso qualificado. using math::pi; // importa só pi. using namespace std; // EVITE em headers! std::cout é preferível a 'using namespace std; cout;'."
  },
  {
    "id": "linguagens-de-programacao__C++__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Fácil",
    "question": "O que são construtores e destrutores em C++ e quando são chamados automaticamente?",
    "options": [
      "Construtor inicializa o objeto na criação; destrutor limpa recursos quando o objeto sai de escopo ou é deletado",
      "São funções normais chamadas manualmente",
      "Construtores são opcionais em todas as classes",
      "Destrutores só existem com herança"
    ],
    "correctIndex": 0,
    "explanation": "Construtor: mesmo nome da classe, sem tipo de retorno, chamado na criação. Destrutor: ~NomeClasse(), chamado automaticamente ao sair do escopo (stack) ou com delete (heap). Pode ter múltiplos construtores (overload), mas apenas um destrutor. Essenciais para RAII.",
    "example": "class File { FILE* f; public: File(const char* name) { f = fopen(name, 'r'); } ~File() { if(f) fclose(f); } }; { File f('data.txt'); // construtor abre. } // destrutor fecha automaticamente."
  },
  {
    "id": "linguagens-de-programacao__C++__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Fácil",
    "question": "O que é RAII (Resource Acquisition Is Initialization) em C++ e como evita memory leaks?",
    "options": [
      "Padrão onde recurso é adquirido no construtor e liberado no destrutor automaticamente ao sair do escopo; smart pointers (unique_ptr, shared_ptr) implementam RAII",
      "Inicializar todas as variáveis antes de usadas para evitar UB e memory leak",
      "Alocar memória somente na inicialização do programa para evitar fragmentação",
      "Padrão de código que exige construtor e destrutor em toda classe que usa heap"
    ],
    "correctIndex": 0,
    "explanation": "RAII: ligar ciclo de vida do recurso ao ciclo de vida do objeto. Construtor: open file / alloc memory. Destrutor: close file / free memory. Destrutor é chamado automaticamente ao sair do escopo (stack unwinding), mesmo em exceções. unique_ptr<T>: destrutor chama delete. shared_ptr<T>: contagem de referências, delete quando chega a 0. Elimina new/delete explícito.",
    "example": "Sem RAII: int *p = new int[100]; if(erro) return; // LEAK! delete[] p; Com RAII: auto p = std::make_unique<int[]>(100); if(erro) return; // destrutor chama delete[] automaticamente. std::ifstream file('dados.txt'); // fecha automaticamente no destrutor. lock_guard<mutex> lk(mtx); // libera mutex ao sair do escopo, mesmo com exceção."
  },
  {
    "id": "linguagens-de-programacao__C++__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Médio",
    "question": "Em C++11, qual smart pointer garante propriedade exclusiva de um recurso e não permite cópia?",
    "options": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ],
    "correctIndex": 0,
    "explanation": "std::unique_ptr mantém propriedade exclusiva do recurso. Não pode ser copiado (copy constructor deletado), apenas movido com std::move(). Quando o unique_ptr sai de escopo, o recurso é automaticamente liberado pelo destrutor, implementando RAII.",
    "example": "auto p = std::make_unique<int>(42); auto p2 = std::move(p); // OK: transfere propriedade. // auto p3 = p2; // Erro de compilação: cópia proibida."
  },
  {
    "id": "linguagens-de-programacao__C++__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Médio",
    "question": "Em C++11, o que é move semantics e como 'std::move' melhora a performance?",
    "options": [
      "Transfere recursos de um objeto para outro sem copiar, usando rvalue references (&&)",
      "Move arquivos no filesystem",
      "Otimiza loops for",
      "Equivalente a memcpy"
    ],
    "correctIndex": 0,
    "explanation": "Move semantics permite transferir a propriedade de recursos internos (heap memory, file handles) de um objeto temporário para outro, evitando cópias custosas. std::move() converte um lvalue em rvalue reference (&&), permitindo que o move constructor/assignment seja chamado em vez do copy.",
    "example": "std::vector<int> v1 = {1,2,3,4,5}; std::vector<int> v2 = std::move(v1); // v2 'rouba' o buffer interno de v1. v1 agora está vazio. Zero cópia de elementos."
  },
  {
    "id": "linguagens-de-programacao__C++__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Médio",
    "question": "Em C++, quando usar 'virtual' em métodos e o que é o vtable?",
    "options": [
      "virtual habilita polimorfismo runtime; vtable é tabela de ponteiros para funções virtuais usada para dispatch dinâmico",
      "virtual é para templates",
      "vtable é uma tabela SQL",
      "virtual torna métodos mais rápidos"
    ],
    "correctIndex": 0,
    "explanation": "Métodos 'virtual' permitem que subclasses sobrescrevam o comportamento, com a versão correta sendo chamada em runtime baseada no tipo real do objeto (não do ponteiro). O compilador cria uma vtable (tabela de ponteiros para funções) por classe, e cada objeto tem um vptr para sua vtable.",
    "example": "class Animal { virtual void speak() { cout << 'Animal'; } }; class Dog : public Animal { void speak() override { cout << 'Woof'; } }; Animal *a = new Dog(); a->speak(); // 'Woof' via vtable lookup."
  },
  {
    "id": "linguagens-de-programacao__C++__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Médio",
    "question": "O que são smart pointers em C++ e quais os principais tipos?",
    "options": [
      "Objetos que gerenciam memória automaticamente via RAII: unique_ptr (exclusivo), shared_ptr (compartilhado), weak_ptr (não-owner)",
      "Ponteiros mais rápidos",
      "Ponteiros para funções",
      "Alias para void*"
    ],
    "correctIndex": 0,
    "explanation": "unique_ptr: ownership exclusivo, não copiável, movível. shared_ptr: ownership compartilhado via reference counting. weak_ptr: referência não-owner para shared_ptr (evita ciclos). Todos liberam memória automaticamente. Substituem new/delete manuais.",
    "example": "auto p = std::make_unique<Widget>(); // unique_ptr, 1 dono. auto s1 = std::make_shared<Widget>(); auto s2 = s1; // ref count = 2. s1.reset(); // ref count = 1. s2.reset(); // ref count = 0, Widget destruido."
  },
  {
    "id": "linguagens-de-programacao__C++__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Médio",
    "question": "O que é move semantics em C++ e qual problema resolve?",
    "options": [
      "Permite transferir recursos de um objeto temporário em vez de copiar, evitando alocações desnecessárias",
      "Mover arquivos no disco",
      "Reordenar elementos de array",
      "Mover variáveis entre escopos"
    ],
    "correctIndex": 0,
    "explanation": "Move semantics (C++11): ao invés de copiar dados de um objeto temporário (cópia profunda), transfere (steal) os recursos internos. O objeto original fica em estado válido mas vazio. Usa rvalue references (&&). Essencial para performance com containers grandes.",
    "example": "std::vector<int> create() { std::vector<int> v(1000000); return v; } auto data = create(); // Move semantics: ponteiro interno transferido, zero cópia dos 1M elementos. Sem move: copiaria 4MB."
  },
  {
    "id": "linguagens-de-programacao__C++__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Médio",
    "question": "O que são lambda expressions em C++11 e como capturam variáveis do escopo?",
    "options": [
      "Funções anônimas inline com captura de variáveis por valor [=] ou por referência [&]",
      "Macros do pré-processador",
      "Funções template especiais",
      "Ponteiros de função simplificados"
    ],
    "correctIndex": 0,
    "explanation": "Lambdas: [capture](params) -> ret { body }. Capture list: [=] copia tudo, [&] referência tudo, [x, &y] misto. Compilador gera classe anônima com operator(). Útil para callbacks, STL algorithms, e código inline sem definir função separada.",
    "example": "int x = 10; auto add = [x](int y) { return x + y; }; add(5); // 15, x capturado por valor. std::sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // ordena decrescente."
  },
  {
    "id": "linguagens-de-programacao__C++__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Médio",
    "question": "O que é herança múltipla em C++ e qual é o 'problema do diamante'?",
    "options": [
      "Classe herda de múltiplas bases; diamante ocorre quando duas bases têm ancestral comum, gerando ambiguidade",
      "C++ não permite herança múltipla",
      "Diamante é erro de compilação sem solução",
      "Herança múltipla é idêntica a interfaces"
    ],
    "correctIndex": 0,
    "explanation": "Herança múltipla: class C : public A, public B {}. Problema do diamante: A->B, A->C, D herda B e C — D tem duas cópias de A. Solução: virtual inheritance (class B : virtual public A), garantindo uma única cópia do ancestral comum.",
    "example": "class Animal { public: int age; }; class Dog : virtual public Animal {}; class Pet : virtual public Animal {}; class PetDog : public Dog, public Pet {}; // Uma só cópia de age. Sem virtual: ambiguidade — PetDog::Dog::age vs PetDog::Pet::age."
  },
  {
    "id": "linguagens-de-programacao__C++__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Médio",
    "question": "O que são templates em C++ e como o compilador realiza template instantiation?",
    "options": [
      "Código genérico parametrizado por tipo; o compilador gera código específico para cada tipo usado (monomorfização em compile-time), sem overhead de runtime",
      "Macros de pré-processador tipadas que geram código com substituição textual",
      "Interfaces genéricas que o linker resolve dinamicamente com virtual dispatch",
      "Apenas templates de classe existem; funções genéricas usam virtual functions"
    ],
    "correctIndex": 0,
    "explanation": "Templates: template<typename T> T max(T a, T b) { return a>b?a:b; }. Compiler: ao ver max(3,4) gera max<int>; ao ver max(3.0,4.0) gera max<double>. Cada instanciação é código separado. Template specialization: implementação específica para tipo concreto. Concepts (C++20): restringem o tipo (requires Comparable). SFINAE: substituição que falha silenciosamente para seleção de overload.",
    "example": "std::vector<int> e std::vector<string>: dois conjuntos de código separados gerados. Vantagem: sem overhead de boxin/unboxing como Java generics (erasure). Desvantagem: tempos de compilação maiores, binários maiores (code bloat). Concepts C++20: template<Numeric T> elimina erros de template cripíticos de N páginas de SFINAE."
  },
  {
    "id": "linguagens-de-programacao__C++__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Difícil",
    "question": "Em C++, o que é SFINAE (Substitution Failure Is Not An Error) e como ele é usado em template metaprogramming?",
    "options": [
      "Quando a substituição de template falha, o compilador descarta silenciosamente o candidato em vez de gerar erro",
      "É um tipo de exceção do compilador",
      "É uma forma de polimorfismo dinâmico",
      "É um mecanismo de garbage collection"
    ],
    "correctIndex": 0,
    "explanation": "SFINAE permite que o compilador descarte overloads de template cuja substituição de tipos resulte em expressões inválidas, sem gerar erro de compilação. Isso é usado com std::enable_if, concepts (C++20) e if constexpr para selecionar implementações baseadas em propriedades dos tipos.",
    "example": "template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>> void print(T val) { /* só para inteiros */ } — se T=double, SFINAE descarta este overload silenciosamente."
  },
  {
    "id": "linguagens-de-programacao__C++__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Difícil",
    "question": "Em C++20, o que são 'concepts' e como eles melhoram os templates?",
    "options": [
      "Restrições nomeadas sobre tipos em templates que fornecem erros claros e substituem SFINAE",
      "São classes abstratas",
      "Interfaces como em Java",
      "Macros avançadas"
    ],
    "correctIndex": 0,
    "explanation": "Concepts definem restrições nomeadas para parâmetros de template. Em vez de SFINAE complexo e erros de compilação incompreensíveis, concepts fornecem mensagens claras ('T does not satisfy Sortable'). São part of the interface do template, não hack de implementação.",
    "example": "template<typename T> concept Sortable = requires(T a, T b) { { a < b } -> std::convertible_to<bool>; }; template<Sortable T> void sort(vector<T>& v); sort(vec_of_ints); // OK. sort(vec_of_non_comparable); // Erro claro: tipo não satisfaz Sortable."
  },
  {
    "id": "linguagens-de-programacao__C++__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Difícil",
    "question": "Em C++, o que é o 'Rule of Five' e quando deve ser implementado?",
    "options": [
      "Se definir destrutor, copy/move constructor ou copy/move assignment, deve definir todos os 5",
      "Regra de 5 threads",
      "Limite de 5 herança",
      "Máximo de 5 templates"
    ],
    "correctIndex": 0,
    "explanation": "Se uma classe gerencia recursos (memória, handles), o comportamento default de cópia/move pode causar double-free ou leaks. Rule of Five: definir destrutor, copy constructor, copy assignment, move constructor e move assignment — ou deletar os que não devem ser usados. Rule of Zero: preferir classes que não gerenciam recursos diretamente (usar smart pointers).",
    "example": "class Buffer { int* data; size_t size; public: ~Buffer(); Buffer(const Buffer&); Buffer& operator=(const Buffer&); Buffer(Buffer&&) noexcept; Buffer& operator=(Buffer&&) noexcept; }; // Ou Rule of Zero: class Buffer { std::vector<int> data; }; // tudo automático."
  },
  {
    "id": "linguagens-de-programacao__C++__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Difícil",
    "question": "O que é CRTP (Curiously Recurring Template Pattern) em C++?",
    "options": [
      "Classe base template parametrizada pela classe derivada, permitindo polimorfismo estático em tempo de compilação",
      "Template que se auto-referencia infinitamente",
      "Padrão para criação de singletons",
      "Recursividade em templates"
    ],
    "correctIndex": 0,
    "explanation": "CRTP: class Derived : public Base<Derived> {}. Permet polimorfismo estático (sem vtable, sem overhead de virtual). A base conhece o tipo derivado em compile-time. Usado para: mixin patterns, contadores de instâncias, operações genéricas (operator< gera >, <=, >=).",
    "example": "template<typename T> class Counter { static int count; public: Counter() { ++count; } static int getCount() { return count; } }; class Dog : public Counter<Dog> {}; class Cat : public Counter<Cat> {}; // Contadores separados por tipo."
  },
  {
    "id": "linguagens-de-programacao__C++__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Difícil",
    "question": "O que são concepts em C++20 e como melhoram templates?",
    "options": [
      "Restrições nomeadas para parâmetros de template que geram mensagens de erro claras e documentam requisitos",
      "Conceitos abstratos de POO",
      "Sinônimo de interfaces",
      "Comentários especiais para templates"
    ],
    "correctIndex": 0,
    "explanation": "Concepts (C++20): definem requisitos que tipos devem satisfazer para serem usados com um template. Substituem SFINAE complexo. Geram mensagens de erro legíveis (em vez de páginas de erros de template). Concepts standard: std::integral, std::floating_point, std::sortable.",
    "example": "template<typename T> concept Addable = requires(T a, T b) { a + b; }; template<Addable T> T sum(T a, T b) { return a + b; } sum(1, 2); // OK. sum(\"a\", \"b\"); // Erro claro: string não satisfaz Addable."
  },
  {
    "id": "linguagens-de-programacao__C++__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Difícil",
    "question": "O que são variadic templates em C++ e como funcionam com parameter packs?",
    "options": [
      "Templates que aceitam número variável de argumentos de tipos diferentes, expandidos recursivamente em compilação",
      "Templates com número fixo de parâmetros",
      "Variáveis globais template",
      "Arrays de templates"
    ],
    "correctIndex": 0,
    "explanation": "Variadic templates (C++11): template<typename... Args> aceita 0 ou mais tipos. Parameter pack Args... é expandido recursivamente ou com fold expressions (C++17). sizeof...(Args) retorna a contagem. Base case termina a recursão. Usado em std::tuple, std::make_shared, printf type-safe.",
    "example": "template<typename T> void print(T val) { std::cout << val; } template<typename T, typename... Rest> void print(T first, Rest... rest) { std::cout << first << ' '; print(rest...); } print(1, 'hello', 3.14); // 1 hello 3.14"
  },
  {
    "id": "linguagens-de-programacao__C++__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Difícil",
    "question": "O que é constexpr em C++ e como difere de const?",
    "options": [
      "constexpr garante avaliação em tempo de compilação; const apenas impede modificação mas pode ser inicializado em runtime",
      "São sinônimos exatos",
      "constexpr é para strings apenas",
      "const é avaliado em compilação"
    ],
    "correctIndex": 0,
    "explanation": "const: valor não muda após inicialização, mas pode ser inicializado em runtime (const int x = rand()). constexpr: DEVE ser avaliável em compile-time. constexpr functions podem ser executadas em compilação se inputs são constexpr. C++20: consteval (obrigatório em compile-time).",
    "example": "constexpr int fib(int n) { return n <= 1 ? n : fib(n-1) + fib(n-2); } constexpr int f10 = fib(10); // calculado em compilação! static_assert(f10 == 55); // validação compile-time. const int x = rand(); // OK. constexpr int y = rand(); // ERRO."
  },
  {
    "id": "linguagens-de-programacao__C++__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "C++",
    "difficulty": "Difícil",
    "question": "O que é move semantics em C++11 e como rvalue references (&& ) e std::move otimizam transferência de recursos?",
    "options": [
      "Move semantics transfere propriedade de recursos (sem cópia profunda) via rvalue reference; std::move converte lvalue em rvalue; destrutor do original fica em estado válido mas indeterminado",
      "std::move copia o objeto e libera a memória do original imediatamente",
      "Move semantics é otimização do compilador que elimina cópias; o programador não tem controle",
      "Rvalue references são ponteiros temporários sem dono que o GC libera após o uso"
    ],
    "correctIndex": 0,
    "explanation": "Sem move: vector<string> b = a; copia todos os bytes de cada string. Com move: vector<string> b = std::move(a); transfere ponteiro interno de a para b, a fica em estado válido mas vazio. Construtor de move: String(String&& src) { data=src.data; src.data=nullptr; }. RVO/NRVO: compilador elide cópias em retornos. Perfect forwarding: template<T&&> forward<T>(t) preserva lvalue/rvalue.",
    "example": "std::vector<std::string> v; v.push_back(std::string(10000, 'x')); // rvalue: move, não copia. std::string s(10000,'z'); v.push_back(std::move(s)); // s virou rvalue, move ocorre. Benchmark: mover vector com 100k strings: 10μs. Copiar: 500ms. emplace_back(args...) constrói diretamente no lugar — ainda melhor que move."
  },
  {
    "id": "linguagens-de-programacao__C#__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Fácil",
    "question": "Em C#, qual keyword é usada para definir uma classe que não pode ser instanciada e serve apenas como base para herança?",
    "options": [
      "abstract",
      "sealed",
      "static",
      "virtual"
    ],
    "correctIndex": 0,
    "explanation": "A keyword 'abstract' define uma classe que não pode ser instanciada diretamente — só pode ser usada como classe base. Pode conter métodos abstratos (sem corpo) que subclasses são obrigadas a implementar, e métodos concretos com implementação.",
    "example": "abstract class Shape { public abstract double Area(); public void Print() { Console.WriteLine(Area()); } } class Circle : Shape { public override double Area() => Math.PI * r * r; }"
  },
  {
    "id": "linguagens-de-programacao__C#__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Fácil",
    "question": "Em C#, qual a diferença entre 'value types' e 'reference types'?",
    "options": [
      "Value types (struct, int) ficam na stack e são copiados; reference types (class, string) ficam no heap e usam referências",
      "São iguais",
      "Value types são mais lentos",
      "Reference types não podem ser nulos"
    ],
    "correctIndex": 0,
    "explanation": "Value types (int, bool, struct, enum) são armazenados na stack e a atribuição copia o valor. Reference types (class, interface, delegate, array) são armazenados no heap e a atribuição copia a referência (ponteiro). Value types são mais eficientes para dados pequenos e imutáveis.",
    "example": "int a = 5; int b = a; b = 10; // a continua 5 (cópia). var list1 = new List<int>{1}; var list2 = list1; list2.Add(2); // list1 também tem 2 (mesma referência)."
  },
  {
    "id": "linguagens-de-programacao__C#__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Fácil",
    "question": "Em C#, o que é LINQ e como ele simplifica consultas em coleções?",
    "options": [
      "Language Integrated Query: sintaxe de consulta integrada à linguagem para filtrar, ordenar e transformar dados",
      "Framework de banco de dados",
      "Biblioteca de UI",
      "Tipo de loop"
    ],
    "correctIndex": 0,
    "explanation": "LINQ permite escrever consultas sobre coleções (arrays, listas, XML, bancos de dados) usando sintaxe integrada à linguagem. Oferece métodos como Where(), Select(), OrderBy(), GroupBy() (method syntax) ou from/where/select (query syntax). Funciona com qualquer IEnumerable<T>.",
    "example": "var adultos = pessoas.Where(p => p.Idade >= 18).OrderBy(p => p.Nome).Select(p => p.Nome); // Ou: var adultos = from p in pessoas where p.Idade >= 18 orderby p.Nome select p.Nome;"
  },
  {
    "id": "linguagens-de-programacao__C#__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Fácil",
    "question": "O que são value types e reference types em C#?",
    "options": [
      "Value types (struct, int) armazenam dados na stack; reference types (class, string) armazenam referência na stack e dados no heap",
      "São idênticos",
      "Value types são imutáveis",
      "Reference types são mais rápidos"
    ],
    "correctIndex": 0,
    "explanation": "Value types (int, bool, struct, enum): armazenados diretamente (stack ou inline). Cópia copia o valor. Reference types (class, string, array): variável contém referência (ponteiro) para dados no heap. Cópia copia a referência (ambos apontam para o mesmo objeto).",
    "example": "int a = 5; int b = a; b = 10; // a ainda é 5 (value type, cópia). var list1 = new List<int>{1}; var list2 = list1; list2.Add(2); // list1 também tem {1,2} (reference type, mesma referência)."
  },
  {
    "id": "linguagens-de-programacao__C#__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Fácil",
    "question": "O que é o operador null-conditional (?.) e null-coalescing (??) em C#?",
    "options": [
      "?. acessa membros só se não for null; ?? fornece valor padrão quando a expressão é null",
      "Operadores matemáticos",
      "Operadores de comparação",
      "Operadores bit a bit"
    ],
    "correctIndex": 0,
    "explanation": "?. (null conditional): user?.Address?.City retorna null se qualquer parte for null, sem NullReferenceException. ?? (null coalescing): name ?? 'Unknown' retorna 'Unknown' se name for null. ??= (null coalescing assignment): name ??= 'Default' atribui só se null.",
    "example": "string? city = user?.Address?.City ?? 'N/A'; // Se user ou Address for null, city = 'N/A'. int length = name?.Length ?? 0; // Se name for null, length = 0."
  },
  {
    "id": "linguagens-de-programacao__C#__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Fácil",
    "question": "O que é um namespace em C# e qual sua função na organização do código?",
    "options": [
      "Agrupamento lógico de tipos que evita conflitos de nome entre bibliotecas e módulos",
      "Pasta física no disco",
      "Tipo de classe abstrata",
      "Modo de compilação"
    ],
    "correctIndex": 0,
    "explanation": "Namespaces organizam tipos (classes, structs, enums, interfaces) hierarquicamente. Evitam conflitos: System.IO.File vs MyApp.IO.File. Acessados com 'using System.Collections.Generic;'. C# 10+: file-scoped namespace (namespace MyApp; sem chaves) simplifica o arquivo.",
    "example": "namespace MyApp.Models { public class User { } } // Acesso: MyApp.Models.User ou using MyApp.Models; User u = new User(); // C# 10: namespace MyApp.Models; (sem chaves, 1 por arquivo)."
  },
  {
    "id": "linguagens-de-programacao__C#__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Fácil",
    "question": "O que são propriedades (properties) em C# e como diferem de campos públicos?",
    "options": [
      "Membros com get/set que encapsulam acesso a dados, permitindo validação e lógica customizada",
      "São idênticos a campos públicos",
      "Só existem em interfaces",
      "São variáveis estáticas"
    ],
    "correctIndex": 0,
    "explanation": "Properties usam accessors get/set para encapsular campos. Vantagens sobre campos: validação no set, lógica computada no get, data binding em UI, serialização configurável. Auto-properties (public string Name { get; set; }) geram backing field automaticamente.",
    "example": "public class User { private string _name; public string Name { get => _name; set => _name = value ?? throw new ArgumentNullException(); } public int Age { get; set; } // auto-property. public string Display => $\"{Name} ({Age})\"; // read-only computed. }"
  },
  {
    "id": "linguagens-de-programacao__C#__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Fácil",
    "question": "O que é LINQ (Language Integrated Query) em C# e quais são os dois estilos de sintaxe?",
    "options": [
      "LINQ permite consultas tipadas em coleões e fontes de dados usando sintaxe de query (SQL-like) ou sintaxe de método (fluent com lambda), integrada na linguagem com verificação de tipos em compile-time",
      "Biblioteca para acesso a banco de dados SQL sem ORM, integrada no compilador",
      "Apenas sintaxe de query existe; métodos LINQ são apenas wrappers internos",
      "LINQ só funciona com IList e Array; para outras coleções requer adapters externos"
    ],
    "correctIndex": 0,
    "explanation": "LINQ (Language Integrated Query): opera sobre IEnumerable<T> / IQueryable<T>. Query syntax: from p in products where p.Price > 100 select p.Name. Method syntax: products.Where(p => p.Price > 100).Select(p => p.Name). Query syntax é convertida pelo compilador para method syntax. Providers: LINQ to Objects (memória), EF Core (SQL gerado), LINQ to XML.",
    "example": "var nomes = from p in pessoas where p.Idade >= 18 orderby p.Nome select p.Nome; // query syntax. var nomes2 = pessoas.Where(p => p.Idade >= 18).OrderBy(p => p.Nome).Select(p => p.Nome); // fluent. EF Core: Where() gera WHERE em SQL (deferred execution). ToList() executa a query. AsNoTracking() para queries read-only."
  },
  {
    "id": "linguagens-de-programacao__C#__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Médio",
    "question": "Em C#, o que são os modificadores 'async' e 'await' e como eles facilitam programação assíncrona?",
    "options": [
      "async marca um método como assíncrono que retorna Task; await pausa a execução até a Task completar sem bloquear a thread",
      "async cria uma nova thread; await a encerra",
      "São usados apenas para operações de banco de dados",
      "async torna o código mais lento por segurança"
    ],
    "correctIndex": 0,
    "explanation": "O modificador 'async' indica que o método contém operações assíncronas e retorna Task ou Task<T>. O 'await' pausa a execução do método naquele ponto, liberando a thread para outras tarefas. Quando a operação assíncrona completa, a execução retoma a partir do await. Não cria threads extras.",
    "example": "async Task<string> FetchDataAsync() { var response = await httpClient.GetAsync(url); // thread liberada durante I/O return await response.Content.ReadAsStringAsync(); }"
  },
  {
    "id": "linguagens-de-programacao__C#__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Médio",
    "question": "Em C#, o que são 'extension methods' e como eles permitem adicionar métodos a tipos existentes?",
    "options": [
      "Métodos estáticos que aparecem como métodos de instância em types existentes, sem modificar a classe original",
      "Herança múltipla",
      "Métodos que estendem a RAM",
      "Overloads de operadores"
    ],
    "correctIndex": 0,
    "explanation": "Extension methods são métodos estáticos em classes estáticas cujo primeiro parâmetro usa 'this'. Permitem 'adicionar' métodos a qualquer tipo (inclusive sealed classes e interfaces) sem herança. LINQ é implementado inteiramente com extension methods sobre IEnumerable<T>.",
    "example": "static class StringExtensions { public static bool IsEmail(this string s) => s.Contains('@'); } // Uso: 'ana@email.com'.IsEmail(); // true — parece método de string, mas é extension."
  },
  {
    "id": "linguagens-de-programacao__C#__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Médio",
    "question": "Em C#, o que são delegates e events e como eles implementam o padrão Observer?",
    "options": [
      "Delegates são tipos que referenciam métodos; events são delegates encapsulados que permitem inscrição/notificação",
      "São classes abstratas",
      "São threads",
      "São tipos de exceção"
    ],
    "correctIndex": 0,
    "explanation": "Delegates são objetos type-safe que referenciam métodos com assinatura específica (como function pointers tipados). Events usam delegates com encapsulamento: só a classe declarante pode disparar (Invoke), outros podem apenas inscrever (+=) ou desinscrever (-=). Base do padrão Observer em C#.",
    "example": "public event EventHandler<OrderEventArgs> OrderCreated; // Inscrever: orderService.OrderCreated += OnOrderCreated; // Disparar (dentro da classe): OrderCreated?.Invoke(this, args);"
  },
  {
    "id": "linguagens-de-programacao__C#__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Médio",
    "question": "O que é async/await em C# e como funciona o Task?",
    "options": [
      "async marca método como assíncrono que retorna Task; await pausa execução até Task completar sem bloquear thread",
      "Cria threads novas",
      "Só funciona em console apps",
      "Substitui try/catch"
    ],
    "correctIndex": 0,
    "explanation": "async/await em C# usa state machine para suspender e retomar execução sem bloquear a thread (diferente de Thread.Sleep que bloqueia). Task<T> é o tipo de retorno para operações assíncronas. Uso com I/O (rede, disco) libera a thread para processar outras requisições.",
    "example": "async Task<string> FetchDataAsync() { var response = await httpClient.GetAsync(url); return await response.Content.ReadAsStringAsync(); } // Thread liberada durante rede. Vs FetchData() bloqueante: thread presa esperando."
  },
  {
    "id": "linguagens-de-programacao__C#__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Médio",
    "question": "O que são extension methods em C# e quando usá-los?",
    "options": [
      "Métodos estáticos que parecem métodos de instância de outra classe, adicionando funcionalidade sem modificá-la",
      "Métodos que estendem a memória",
      "Herança múltipla",
      "Métodos abstratos"
    ],
    "correctIndex": 0,
    "explanation": "Extension methods: métodos estáticos em classe estática com 'this' no primeiro parâmetro. Chamados como se fossem métodos de instância. LINQ é construído inteiramente com extension methods (Where, Select, OrderBy são extensions de IEnumerable<T>).",
    "example": "public static class StringExtensions { public static bool IsEmail(this string s) => s.Contains('@'); } 'ana@email.com'.IsEmail(); // true — parece método de string, mas é extension."
  },
  {
    "id": "linguagens-de-programacao__C#__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Médio",
    "question": "O que são generics em C# e qual a vantagem sobre usar 'object'?",
    "options": [
      "Tipos parametrizados que garantem type safety em compilação e evitam boxing/unboxing de value types",
      "São mais lentos que object",
      "Só funcionam com reference types",
      "Geram reflection em runtime"
    ],
    "correctIndex": 0,
    "explanation": "Generics: List<int> vs ArrayList (object). Vantagens: type safety em compilação (erro antes de runtime), sem boxing/unboxing de value types (int→object custa alocação no heap), melhor performance. Constraints: where T : IComparable, where T : class, where T : new().",
    "example": "List<int> nums = new List<int>(); nums.Add(42); // sem boxing. int n = nums[0]; // sem casting. ArrayList old = new ArrayList(); old.Add(42); // boxing int→object. int x = (int)old[0]; // unboxing + cast."
  },
  {
    "id": "linguagens-de-programacao__C#__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Médio",
    "question": "O que é Dependency Injection nativa no ASP.NET Core e como funciona?",
    "options": [
      "Container IoC built-in que injeta dependências via construtor, com lifetimes Transient, Scoped e Singleton",
      "Injeção de SQL",
      "Pattern exclusivo de testes",
      "Técnica de otimização de memória"
    ],
    "correctIndex": 0,
    "explanation": "ASP.NET Core tem container DI nativo. Lifetimes: Transient (nova instância por injeção), Scoped (uma por request HTTP), Singleton (uma por app). Registra serviços em Program.cs. Injeção via construtor é o padrão. Promove testabilidade e desacoplamento.",
    "example": "builder.Services.AddScoped<IUserRepo, UserRepo>(); builder.Services.AddSingleton<ICacheService, RedisCacheService>(); // Controller: public class UsersController(IUserRepo repo) { } // repo injetado automaticamente."
  },
  {
    "id": "linguagens-de-programacao__C#__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Médio",
    "question": "O que é async/await em C# e como difere de Task.Run para operações I/O-bound vs CPU-bound?",
    "options": [
      "async/await libera thread durante I/O-bound (sem thread ocupada); Task.Run delega trabalho CPU-bound para thread pool; não usar Task.Run para I/O pois desperdiça thread",
      "async/await cria novas threads para cada operação; Task.Run reutiliza threads do pool",
      "São equivalentes; escolha é apenas estilística para qualquer tipo de operação",
      "Task.Run deve ser usado para I/O; async/await é apenas para CPU para não bloquear a UI"
    ],
    "correctIndex": 0,
    "explanation": "await HttpClient.GetAsync(): thread retorna ao pool enquanto aguarda rede. Sem thread bloqueada. Task.Run(() => PesadoCalculo()): envia para thread do pool para cálculo pesado (não bloquear main thread/UI). Anti-pattern: await Task.Run(async () => await httpClient.GetAsync()) — ocupa thread do pool esperando I/O. ConfigureAwait(false): não captura SynchronizationContext (libs).",
    "example": "ASP.NET Core: public async Task<IActionResult> Get() { var data = await _db.Usuarios.ToListAsync(); return Ok(data); } — thread liberada durante query ao banco, suporta mais requisições simultâneas. Blazor/WinForms: Task.Run(() => calcularHash(bytes)) move CPU-bound para background, não trava UI. CancellationToken: cancela operação assíncrona em andamento."
  },
  {
    "id": "linguagens-de-programacao__C#__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Difícil",
    "question": "Em C#, qual é a diferença entre 'Span<T>' e 'Memory<T>' e quando usar cada um?",
    "options": [
      "Span<T> vive na stack e não pode ser usado em async; Memory<T> vive no heap e pode ser armazenado e usado em async",
      "São sinônimos",
      "Memory<T> é mais rápido que Span<T>",
      "Span<T> é para strings e Memory<T> para arrays"
    ],
    "correctIndex": 0,
    "explanation": "Span<T> é um ref struct que vive na stack, fornecendo acesso zero-copy a regiões contíguas de memória (arrays, strings, memória nativa). Por ser ref struct, não pode ser boxed, armazenado em campos de classe ou usado em métodos async. Memory<T> é similar mas vive no heap, podendo ser armazenado e usado em contextos async.",
    "example": "void Process(Span<byte> data) { /* OK, sincrono */ } async Task ProcessAsync(Memory<byte> data) { var span = data.Span; /* usa span localmente dentro do await */ }"
  },
  {
    "id": "linguagens-de-programacao__C#__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Difícil",
    "question": "Em C#, o que são Records (C# 9+) e como diferem de classes tradicionais?",
    "options": [
      "Tipos imutáveis por padrão com igualdade por valor, with-expressions e deconstruction embutidos",
      "São tabelas de banco de dados",
      "São arrays tipados",
      "São idênticos a classes"
    ],
    "correctIndex": 0,
    "explanation": "Records são tipos de referência (record class) ou valor (record struct) otimizados para dados imutáveis. Fornecem: igualdade por valor (Equals compara propriedades, não referência), ToString legível, with-expression para cópias com modificações, e deconstruction automática.",
    "example": "record Person(string Name, int Age); var p1 = new Person('Ana', 25); var p2 = p1 with { Age = 26 }; // cópia com Age modificado. p1 == new Person('Ana', 25); // true — igualdade por valor."
  },
  {
    "id": "linguagens-de-programacao__C#__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Difícil",
    "question": "Em C#, o que é o pattern matching avançado (C# 8-11) e quais padrões estão disponíveis?",
    "options": [
      "Expressões que testam forma e conteúdo de dados: type, property, relational, logical, list patterns",
      "Regex embutido",
      "Switch tradicional apenas",
      "Apenas instanceof"
    ],
    "correctIndex": 0,
    "explanation": "Pattern matching em C# evoluiu para incluir: type patterns (is string s), property patterns ({ Length: > 5 }), relational (>= 18), logical (and, or, not), tuple patterns, positional patterns, list patterns ([_, .., last]). Usado com is, switch expression e switch statement.",
    "example": "var desc = person switch { { Age: < 13 } => 'criança', { Age: >= 13 and < 18 } => 'adolescente', { Age: >= 18 } => 'adulto' }; int[] arr = {1,2,3}; if (arr is [1, .., var last]) // list pattern."
  },
  {
    "id": "linguagens-de-programacao__C#__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Difícil",
    "question": "O que são records em C# e como diferem de classes?",
    "options": [
      "Tipos imutáveis por padrão com igualdade por valor, deconstruction e with-expression para cópias modificadas",
      "São idênticos a classes",
      "Só podem ter strings",
      "Não suportam herança"
    ],
    "correctIndex": 0,
    "explanation": "Records (C# 9+): reference types com semântica de valor. Geram automaticamente: Equals/GetHashCode por valor, ToString formatado, Deconstruct, e with-expression para cópia com modificação. Record struct (C# 10): value type com mesmos benefícios.",
    "example": "record Person(string Name, int Age); var p1 = new Person('Ana', 25); var p2 = p1 with { Age = 26 }; // cópia com Age alterado. p1 == new Person('Ana', 25); // true (igualdade por valor)."
  },
  {
    "id": "linguagens-de-programacao__C#__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Difícil",
    "question": "O que é Source Generators em C# e como difere de reflection?",
    "options": [
      "Geram código C# em tempo de compilação analisando o código existente, evitando overhead de reflection em runtime",
      "Geradores de código em runtime",
      "Ferramentas de refactoring",
      "Templates de projeto"
    ],
    "correctIndex": 0,
    "explanation": "Source Generators (C# 9+): análogos a macros procedurais de Rust. Analisam o código fonte e geram código C# adicional durante a compilação. Eliminam reflection para serialização (System.Text.Json), logging, DI. Zero overhead em runtime.",
    "example": "[JsonSerializable(typeof(User))] partial class MyContext : JsonSerializerContext { } // Source generator cria serializador otimizado em compile-time. Sem reflection: 10x mais rápido que Newtonsoft.Json, AOT-friendly."
  },
  {
    "id": "linguagens-de-programacao__C#__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Difícil",
    "question": "O que é ref struct em C# e por que Span<T> é implementado como um?",
    "options": [
      "Struct que só pode existir na stack, impedindo boxing e captura em closures; Span<T> precisa disso para segurança de memória",
      "Struct passada por referência",
      "Struct com garbage collection especial",
      "Struct imutável"
    ],
    "correctIndex": 0,
    "explanation": "ref struct é alocado exclusivamente na stack. Restrições: não pode ser campo de classe, boxed, capturado em lambda/async, ou implementar interfaces. Span<T> é ref struct porque contém managed pointer — se fosse para o heap, o GC poderia mover o target e invalidar o ponteiro.",
    "example": "ref struct MySpan { Span<byte> data; } // OK. class Container { Span<byte> data; } // ERRO: ref struct não pode ser campo de classe. async Task ProcessAsync() { Span<byte> s = ...; await ...; // ERRO: Span não pode cruzar await. Use Memory<T>. }"
  },
  {
    "id": "linguagens-de-programacao__C#__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Difícil",
    "question": "O que é IAsyncEnumerable<T> em C# e como combina streaming com async?",
    "options": [
      "Interface para produzir sequências de dados assincronamente item a item, com await foreach",
      "Lista assíncrona que carrega tudo de uma vez",
      "Versão async de List<T>",
      "Stream de bytes para rede"
    ],
    "correctIndex": 0,
    "explanation": "IAsyncEnumerable<T> (C# 8) permite yield return assíncrono. Produz items sob demanda (lazy) com awaits entre cada item. Ideal para streaming de dados de banco, APIs paginadas, processamento de arquivos grandes. Consumido com 'await foreach'. Suporta cancelamento.",
    "example": "async IAsyncEnumerable<User> GetUsersAsync([EnumeratorCancellation] CancellationToken ct = default) { await foreach (var row in db.StreamAsync(sql, ct)) { yield return Map(row); } } // Consumo: await foreach (var user in GetUsersAsync()) { Process(user); }"
  },
  {
    "id": "linguagens-de-programacao__C#__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "C#",
    "difficulty": "Difícil",
    "question": "Como funcionam os Channels em C# (.NET 5+) para comunicação entre producers e consumers assíncronos?",
    "options": [
      "Channel<T> é fila assíncrona thread-safe; ChannelWriter.WriteAsync produz; ChannelReader.ReadAsync consume; suporta bounded (backpressure) e unbounded; mais eficiente que BlockingCollection",
      "Channels são streams de rede TCP encapsulados para comunicação entre processos",
      "Equivalente a ConcurrentQueue com await; possui exatamente os mesmos trade-offs",
      "Channels exigem lock explícito; WriteAsync e ReadAsync não são thread-safe por padrão"
    ],
    "correctIndex": 0,
    "explanation": "Channel<T>: pipeline assíncrono eficiente. Bounded: Channel.CreateBounded<T>(capacity) — WriteAsync faz await se cheio (backpressure automático). Unbounded: nunca bloqueia escrita. ReadAsync: await se vazio. IAsyncEnumerable<T>: reader.ReadAllAsync() itera com await foreach. Cancelamento: CancellationToken em todas as operações. Multiple consumers: cada reader recebe item único (fan-out via múltiplos channels).",
    "example": "var ch = Channel.CreateBounded<string>(100); // producer Task.Run(async () => { await ch.Writer.WriteAsync('item'); ch.Writer.Complete(); }); // consumer await foreach (var item in ch.Reader.ReadAllAsync()) { Process(item); }. Backpressure: producer pausa quando ch cheio até consumer consumir. Pipeline de processamento de imagens: decode → channel → resize → channel → encode."
  },
  {
    "id": "linguagens-de-programacao__Go__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Fácil",
    "question": "Em Go, qual construção da linguagem é usada para executar uma função concorrentemente?",
    "options": [
      "goroutine (keyword go)",
      "thread",
      "async/await",
      "fork"
    ],
    "correctIndex": 0,
    "explanation": "Em Go, adicionar a keyword 'go' antes de uma chamada de função cria uma goroutine — uma thread leve gerenciada pelo runtime do Go. Goroutines são multiplexadas sobre threads do SO, permitindo milhões de goroutines concorrentes com baixo overhead de memória (~2KB de stack inicial).",
    "example": "go processarPedido(pedido) — executa processarPedido concorrentemente. A função chamadora continua imediatamente sem esperar."
  },
  {
    "id": "linguagens-de-programacao__Go__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Fácil",
    "question": "Em Go, qual é a função da keyword 'defer' e em que ordem as chamadas deferidas são executadas?",
    "options": [
      "defer adia a execução de uma função até o retorno da função envolvente; ordem LIFO (pilha)",
      "Executa imediatamente",
      "Executa em paralelo",
      "Ordem FIFO (fila)"
    ],
    "correctIndex": 0,
    "explanation": "defer agenda uma função para executar quando a função envolvente retornar (normalmente ou por panic). Múltiplos defers são empilhados em LIFO (Last In, First Out). É idiomático para cleanup: fechar arquivos, liberar locks, liberar conexões.",
    "example": "func read() { f, _ := os.Open('file.txt'); defer f.Close(); // garantido mesmo com panic. // ... usa o arquivo. } // f.Close() executado automaticamente aqui."
  },
  {
    "id": "linguagens-de-programacao__Go__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Fácil",
    "question": "Em Go, como o tratamento de erros funciona sem exceções?",
    "options": [
      "Funções retornam o valor e um error como segundo retorno; o chamador verifica if err != nil",
      "Usa try/catch",
      "Ignora erros automaticamente",
      "Usa panic para tudo"
    ],
    "correctIndex": 0,
    "explanation": "Go não tem exceções. Funções retornam (resultado, error). O chamador verifica 'if err != nil' e trata o erro explicitamente. panic/recover existem mas são reservados para erros irrecuperáveis. Essa abordagem torna o fluxo de erros explícito e visível.",
    "example": "data, err := os.ReadFile('config.json'); if err != nil { return fmt.Errorf('falha ao ler config: %w', err); } // 'err' é verificado a cada operação que pode falhar."
  },
  {
    "id": "linguagens-de-programacao__Go__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Fácil",
    "question": "O que são slices em Go e como diferem de arrays?",
    "options": [
      "Slices são referências dinâmicas para arrays com length e capacity; arrays têm tamanho fixo",
      "São idênticos",
      "Arrays são dinâmicos em Go",
      "Slices são imutáveis"
    ],
    "correctIndex": 0,
    "explanation": "Arrays Go: tamanho fixo ([5]int), parte do tipo ([5]int ≠ [3]int). Slices: referência para array subjacente com len e cap dinâmicos ([]int). Slices são usados 99% das vezes. append() pode alocar novo array se cap for excedida.",
    "example": "arr := [3]int{1,2,3} // array fixo. s := arr[:] // slice apontando para arr. s = append(s, 4) // cap excedida: Go aloca novo array, copia dados. len(s)==4, cap(s)==6 (dobrou)."
  },
  {
    "id": "linguagens-de-programacao__Go__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Fácil",
    "question": "O que é defer em Go e quando usá-lo?",
    "options": [
      "Adia a execução de uma função para quando a função atual retornar; útil para cleanup (fechar arquivo, unlock mutex)",
      "Adia para o próximo goroutine",
      "Cancela a função",
      "Executa em outra thread"
    ],
    "correctIndex": 0,
    "explanation": "defer garante que uma função será chamada quando a função atual retornar (mesmo em caso de panic). Múltiplos defers executam em ordem LIFO (pilha). Uso comum: fechar arquivos, unlock mutexes, flush buffers, log de duração.",
    "example": "func readFile(path string) { f, err := os.Open(path); if err != nil { return; } defer f.Close(); // garante fechamento mesmo com erro. data := read(f); process(data); } // f.Close() roda aqui."
  },
  {
    "id": "linguagens-de-programacao__Go__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Fácil",
    "question": "O que é o operador ':=' em Go e como difere da declaração com 'var'?",
    "options": [
      ":= declara e inicializa com tipo inferido (short declaration); var declara explicitamente, podendo omitir inicialização",
      "São idênticos",
      ":= é para constantes",
      "var não existe em Go"
    ],
    "correctIndex": 0,
    "explanation": ":= (short variable declaration): só dentro de funções, infere tipo do valor. var: funciona em qualquer escopo (inclusive pacote), pode declarar sem inicializar (zero value). var x int = 5 vs x := 5. := não pode ser usado em escopo de pacote.",
    "example": "x := 42 // int inferido. name := 'Go' // string inferido. var count int // zero value = 0. var msg string // zero value = ''. // No escopo de pacote: var Version = '1.0' // OK. Version := '1.0' // ERRO: := não permitido fora de funções."
  },
  {
    "id": "linguagens-de-programacao__Go__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Fácil",
    "question": "O que é a keyword 'range' em Go e como usá-la em loops?",
    "options": [
      "Itera sobre slices, arrays, maps, strings e channels retornando índice/chave e valor",
      "Gera números sequenciais",
      "Define limites de variáveis",
      "Cria intervalos numéricos como em Python"
    ],
    "correctIndex": 0,
    "explanation": "range retorna (índice, valor) para slices/arrays, (chave, valor) para maps, (índice, rune) para strings, e (valor) para channels. Use _ para ignorar um retorno. For sem range usa sintaxe C-like: for i := 0; i < n; i++.",
    "example": "nums := []int{10, 20, 30}; for i, v := range nums { fmt.Println(i, v) } // 0 10, 1 20, 2 30. m := map[string]int{'a': 1}; for k, v := range m { fmt.Println(k, v) } // a 1. for _, v := range nums { } // ignora índice."
  },
  {
    "id": "linguagens-de-programacao__Go__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Fácil",
    "question": "O que são goroutines em Go e como diferem de threads do sistema operacional?",
    "options": [
      "Goroutines são tarefas leves gerenciadas pelo runtime Go com stack inicial de 2KB; milhares podem coexistir; mapeadas em poucas threads do OS via scheduler M:N",
      "Goroutines são aliases para threads POSIX com sintaxe simplificada",
      "Cada goroutine tem uma thread do OS dedicada, ideal para paralelismo CPU",
      "Goroutines são callbacks assíncronos sem stack próprio executados no event loop"
    ],
    "correctIndex": 0,
    "explanation": "Goroutine: go func() {}(). Stack: começa em 2KB, cresce dinamicamente até 1GB. Thread OS: 1-8MB de stack fixo. Scheduler Go (GMP): G=goroutines, M=OS threads, P=processors (GOMAXPROCS). M:N multiplexing: N goroutines em M threads. Context switch goroutine: ~100ns; thread OS: ~10μs. 1 milhão de goroutines: factível (2TB de stack total máx).",
    "example": "Servidor HTTP com 10k conexões simultâneas: Go → 10k goroutines (~20MB stack total). Node.js: event loop single-thread. Java (virtual threads Java 21: semelhante). go func() { http.Serve(conn) }(); // nova goroutine por conexão. GOMAXPROCS: default = número de CPUs. runtime.NumGoroutine() inspeciona goroutines ativas."
  },
  {
    "id": "linguagens-de-programacao__Go__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Médio",
    "question": "Em Go, qual é o mecanismo padrão para comunicação segura entre goroutines?",
    "options": [
      "Channels (canais)",
      "Mutex global",
      "Variáveis compartilhadas",
      "Callbacks"
    ],
    "correctIndex": 0,
    "explanation": "Channels são o mecanismo padrão de comunicação entre goroutines em Go, seguindo o princípio 'não comunique compartilhando memória; compartilhe memória comunicando'. Channels podem ser unbuffered (síncronos) ou buffered, e enviar/receber são operações thread-safe.",
    "example": "ch := make(chan int, 10) // channel buffered. go func() { ch <- 42 }() // envia. valor := <-ch // recebe: 42."
  },
  {
    "id": "linguagens-de-programacao__Go__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Médio",
    "question": "Em Go, o que são slices e como diferem de arrays?",
    "options": [
      "Arrays têm tamanho fixo em tempo de compilação; slices são visões dinâmicas sobre arrays que podem crescer",
      "São idênticos",
      "Slices são mais lentos",
      "Arrays podem crescer"
    ],
    "correctIndex": 0,
    "explanation": "Em Go, arrays têm tamanho fixo definido em tempo de compilação ([5]int). Slices ([]int) são referências a arrays com tamanho dinâmico. Slices têm length (len) e capacity (cap). append() cria novo array subjacente se cap for excedido. Slices são muito mais usados.",
    "example": "s := []int{1, 2, 3} // slice, len=3, cap=3. s = append(s, 4) // len=4, cap=6 (dobrou). arr := [3]int{1, 2, 3} // array fixo, não pode crescer."
  },
  {
    "id": "linguagens-de-programacao__Go__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Médio",
    "question": "Em Go, o que é o 'select' statement e como ele funciona com channels?",
    "options": [
      "Permite esperar em múltiplas operações de channel simultaneamente, executando a primeira que estiver pronta",
      "Switch para strings",
      "Loop infinito",
      "Import de pacotes"
    ],
    "correctIndex": 0,
    "explanation": "select é como switch, mas para channels. Bloqueia até um dos cases ter um channel pronto para enviar/receber. Se múltiplos estão prontos, escolhe aleatoriamente. Com default, não bloqueia. É essencial para multiplexar operações de I/O e timeouts.",
    "example": "select { case msg := <-ch1: fmt.Println(msg); case ch2 <- 42: fmt.Println('enviado'); case <-time.After(5*time.Second): fmt.Println('timeout'); } // espera o primeiro channel pronto."
  },
  {
    "id": "linguagens-de-programacao__Go__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Médio",
    "question": "O que é o conceito de interfaces implícitas em Go?",
    "options": [
      "Um tipo implementa uma interface automaticamente ao ter todos os métodos necessários, sem declaração explícita",
      "Precisa da keyword implements",
      "Interfaces são herdadas",
      "Só structs implementam interfaces"
    ],
    "correctIndex": 0,
    "explanation": "Em Go, não existe 'implements'. Se um tipo tem os métodos da interface, ele a satisfaz automaticamente (duck typing estático). io.Reader exige Read([]byte) (int, error). Qualquer tipo com esse método é um Reader. Permite desacoplamento sem dependência explícita.",
    "example": "type Stringer interface { String() string }. type Dog struct{}; func (d Dog) String() string { return 'Woof' }. var s Stringer = Dog{} // compila sem 'implements'. fmt.Println(s) // 'Woof'."
  },
  {
    "id": "linguagens-de-programacao__Go__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Médio",
    "question": "O que é o context package em Go e por que é importante?",
    "options": [
      "Pacote para propagar cancelamento, deadlines e valores entre goroutines e chamadas de função",
      "Contexto de execução do OS",
      "Gerenciador de memória",
      "Pacote de logging"
    ],
    "correctIndex": 0,
    "explanation": "context.Context é passado como primeiro argumento de funções. Permite: cancelamento (WithCancel), timeout (WithTimeout), deadline (WithDeadline), valores (WithValue). Essencial para: HTTP handlers, queries de banco, chamadas entre serviços. Previne goroutine leaks.",
    "example": "ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second); defer cancel(); result, err := db.QueryContext(ctx, sql); // Se query demorar >5s, ctx cancela automaticamente."
  },
  {
    "id": "linguagens-de-programacao__Go__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Médio",
    "question": "O que são goroutine leaks em Go e como preveni-las?",
    "options": [
      "Goroutines que ficam bloqueadas para sempre em channel/IO, consumindo memória; previne-se com context e timeouts",
      "Memory leaks no garbage collector",
      "Erros de sintaxe em goroutines",
      "Leaks de file descriptors"
    ],
    "correctIndex": 0,
    "explanation": "Goroutine leak: goroutine bloqueada em channel sem writer/reader, ou esperando I/O sem timeout. Cada goroutine consome ~2-8KB. Milhares de leaks = OOM. Prevenção: use context com timeout/cancel, feche channels quando terminar, use select com case <-ctx.Done().",
    "example": "// LEAK: func fetch(url string) { ch := make(chan string); go func() { resp := http.Get(url); ch <- resp }(); // se ninguém lê ch, goroutine fica presa para sempre. } // FIX: ctx, cancel := context.WithTimeout(ctx, 5*time.Second); defer cancel(); select { case r := <-ch: ... case <-ctx.Done(): return }"
  },
  {
    "id": "linguagens-de-programacao__Go__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Médio",
    "question": "O que é sync.WaitGroup em Go e para que serve?",
    "options": [
      "Mecanismo para esperar um grupo de goroutines terminar, usando Add, Done e Wait",
      "Mutex para sincronização",
      "Pool de goroutines",
      "Canal com buffer"
    ],
    "correctIndex": 0,
    "explanation": "WaitGroup: contador de goroutines pendentes. Add(n) incrementa, Done() decrementa (defer wg.Done()), Wait() bloqueia até contador = 0. Mais simples que channels para 'fire-and-wait'. Não propaga erros — para isso use errgroup.",
    "example": "var wg sync.WaitGroup; for _, url := range urls { wg.Add(1); go func(u string) { defer wg.Done(); fetch(u); }(url); } wg.Wait(); // bloqueia até todas as goroutines terminarem. fmt.Println('todas prontas');"
  },
  {
    "id": "linguagens-de-programacao__Go__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Médio",
    "question": "Como channels em Go implementam comunicação entre goroutines e o que é select?",
    "options": [
      "Channel: fila tipada thread-safe; unbuffered bloqueia sender/receiver até ambos prontos; buffered não bloqueia até encher; select aguarda múltiplos channels simultaneamente",
      "Channels são shared memory com mutex embutido; select é switch para tipos de channel",
      "Channels só transmitem ponteiros; valores primitivos requerem sync.Mutex",
      "select executa todos os cases simultaneamente em goroutines separadas"
    ],
    "correctIndex": 0,
    "explanation": "Unbuffered: ch := make(chan int) — send bloqueia até receive, synchronization ponto a ponto. Buffered: ch := make(chan int, 10) — send não bloqueia até buffer cheio. Direcionais: chan<- (send only), <-chan (receive only). select: como switch para channels — executa o case cujo channel está pronto; se mútiplos prontos, escolhe aleatoriamente. default: não bloqueia.",
    "example": "select { case msg := <-ch1: fmt.Println(msg) case ch2 <- 'ok': // enviou case <-time.After(1*time.Second): fmt.Println('timeout') }. Pipeline: producer → ch1 → transformer → ch2 → consumer. close(ch): receiver recebe zero value + ok=false. for v := range ch { } lê até fechar. Fan-out: várias goroutines lendo do mesmo channel."
  },
  {
    "id": "linguagens-de-programacao__Go__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Difícil",
    "question": "Em Go, como a implementação de interfaces difere de linguagens como Java e qual é a implicação para design de código?",
    "options": [
      "Go usa 'structural typing' implícito: um tipo satisfaz uma interface se implementar seus métodos, sem declarar explicitamente",
      "Go requer implements explícito como Java",
      "Go não suporta interfaces",
      "Interfaces em Go são idênticas a classes abstratas em Java"
    ],
    "correctIndex": 0,
    "explanation": "Em Go, interfaces são satisfeitas implicitamente (structural/duck typing). Se um tipo implementa todos os métodos de uma interface, ele a satisfaz sem usar 'implements'. Isso permite definir interfaces no pacote consumidor, não no pacote implementador, promovendo desacoplamento e interfaces menores.",
    "example": "type Writer interface { Write([]byte) (int, error) } // Qualquer tipo com método Write([]byte)(int,error) satisfaz Writer automaticamente — inclusive os.File, bytes.Buffer, http.ResponseWriter."
  },
  {
    "id": "linguagens-de-programacao__Go__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Difícil",
    "question": "Em Go, o que é o 'context' package e por que é essencial para aplicações de servidor?",
    "options": [
      "Propaga deadlines, cancelamento e valores request-scoped através da cadeia de chamadas entre goroutines",
      "Gerencia conexões de banco",
      "Cache de dados",
      "Logging framework"
    ],
    "correctIndex": 0,
    "explanation": "context.Context propaga sinais de cancelamento e deadlines pela árvore de goroutines. Quando um request HTTP é cancelado (cliente desconectou), o context cancela todas as operações derivadas (queries DB, chamadas a serviços externos). É o primeiro parâmetro idiomático em Go.",
    "example": "func handler(w http.ResponseWriter, r *http.Request) { ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second); defer cancel(); result, err := db.QueryContext(ctx, 'SELECT ...'); // cancela automaticamente se timeout ou cliente desconectar. }"
  },
  {
    "id": "linguagens-de-programacao__Go__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Difícil",
    "question": "Em Go, como o garbage collector funciona e quais são suas características de latência?",
    "options": [
      "GC concorrente, tri-color mark-and-sweep com pausas sub-milissegundo, focado em baixa latência",
      "GC stop-the-world como Java antigo",
      "Não tem GC, é manual como C",
      "Reference counting como Python"
    ],
    "correctIndex": 0,
    "explanation": "O GC do Go usa mark-and-sweep concorrente com tri-color marking. Roda CONCORRENTEMENTE com o programa, com pausas STW (stop-the-world) tipicamente < 1ms. Prioriza latência sobre throughput. O compilador faz escape analysis para alocar na stack quando possível, reduzindo pressão no GC.",
    "example": "O GC roda em 3 fases: 1) Mark Setup (STW ~10µs). 2) Marking (concorrente, marca objetos alcançáveis). 3) Mark Termination (STW ~10µs). GOGC=100 (default) dispara GC quando heap dobra. GOMEMLIMIT (Go 1.19+) permite controle por memória."
  },
  {
    "id": "linguagens-de-programacao__Go__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Difícil",
    "question": "O que são generics em Go (1.18+) e como funcionam?",
    "options": [
      "Parâmetros de tipo com constraints que permitem escrever funções/tipos genéricos type-safe",
      "São interfaces",
      "Casting automático",
      "Macros de código"
    ],
    "correctIndex": 0,
    "explanation": "Generics Go (1.18): func Max[T constraints.Ordered](a, b T) T {}. Constraints são interfaces que restringem tipos aceitáveis. any = interface{}, comparable = tipos que suportam ==. Monomorphization: compilador gera código específico por tipo (como C++ templates).",
    "example": "func Map[T, U any](s []T, f func(T) U) []U { r := make([]U, len(s)); for i, v := range s { r[i] = f(v) }; return r }. Map([]int{1,2,3}, func(n int) string { return fmt.Sprint(n) }) // []string{'1','2','3'}."
  },
  {
    "id": "linguagens-de-programacao__Go__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Difícil",
    "question": "O que é o padrão errgroup em Go para concorrência estruturada?",
    "options": [
      "Pacote que gerencia um grupo de goroutines, coletando erros e cancelando as demais se uma falhar",
      "Grupo de erros de compilação",
      "Agrupamento de log de erros",
      "Padrão de retry"
    ],
    "correctIndex": 0,
    "explanation": "errgroup.Group: gerencia goroutines com propagação de erro e cancelamento. g.Go(func() error {...}): lança goroutine. g.Wait(): espera todas e retorna primeiro erro. Com WithContext: se uma goroutine falhar, ctx é cancelado, sinalizando as demais.",
    "example": "g, ctx := errgroup.WithContext(ctx); g.Go(func() error { return fetchUser(ctx) }); g.Go(func() error { return fetchOrders(ctx) }); if err := g.Wait(); err != nil { // primeiro erro de qualquer goroutine }."
  },
  {
    "id": "linguagens-de-programacao__Go__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Difícil",
    "question": "O que é escape analysis em Go e como afeta alocação e performance?",
    "options": [
      "Análise do compilador que decide se variável fica na stack (rápido) ou escapa para o heap (requer GC)",
      "Análise de segurança de código",
      "Verificação de SQL injection",
      "Análise de complexidade de algoritmo"
    ],
    "correctIndex": 0,
    "explanation": "O compilador Go analisa se uma variável 'escapa' do escopo da função (ex: retornada via ponteiro, capturada por goroutine). Se escapa → heap (GC gerencia). Se não → stack (liberação automática, zero custo). go build -gcflags='-m' mostra decisões. Reduzir escapes = menos pressão no GC.",
    "example": "func noEscape() int { x := 42; return x } // x na stack. func escapes() *int { x := 42; return &x } // x escapa para heap (ponteiro retornado). // go build -gcflags='-m' → 'moved to heap: x'. Dica: retornar valor em vez de ponteiro quando possível."
  },
  {
    "id": "linguagens-de-programacao__Go__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Difícil",
    "question": "O que são channels direcionais em Go e como impõem segurança em compilação?",
    "options": [
      "chan<- T (send-only) e <-chan T (receive-only) restringem uso do channel, prevenindo erros de comunicação",
      "Channels com prioridade",
      "Channels que ordenam mensagens",
      "Channels com timeout embutido"
    ],
    "correctIndex": 0,
    "explanation": "Channels direcionais: chan<- int (só envia), <-chan int (só recebe). O compilador impede operações inválidas. Um chan bidirecional pode ser passado como direcional (conversão implícita). Melhora a documentação da API e previne bugs.",
    "example": "func producer(out chan<- int) { out <- 42 } // só pode enviar. func consumer(in <-chan int) { v := <-in } // só pode receber. ch := make(chan int); go producer(ch); go consumer(ch); // chan convertido implicitamente para direcional."
  },
  {
    "id": "linguagens-de-programacao__Go__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "Go",
    "difficulty": "Difícil",
    "question": "O que é o modelo de concorrência de Go e como defer, panic e recover formam o mecanismo de tratamento de erros?",
    "options": [
      "defer: executa função ao retornar (LIFO); panic: interrompe execução normal e desempilha defers; recover: captura o panic dentro de defer e permite recuperação graceful",
      "panic é equivalente a throw; recover é catch; defer é finally; modelo igual a try-catch-finally Java",
      "recover pode ser chamado em qualquer ponto para capturar panics pendentes",
      "defer executa imediatamente antes da linha que o segue; não ao retornar"
    ],
    "correctIndex": 0,
    "explanation": "defer: empilha função para executar quando função atual retorna. LIFO: múltiplos defers em ordem inversa. Captura variáveis por referência. panic: como throw mas raramente usado — preferível retornar error. stack unwinding executa defers. recover(): só válido dentro de defer; captura o valor do panic e interrompe unwinding. Idioma: Go usa retorno de error explícito para fluxo normal, panic/recover para invariantes violadas.",
    "example": "func safeDiv(a, b int) (result int, err error) { defer func() { if r := recover(); r != nil { err = fmt.Errorf('panic: %v', r) } }(); return a/b, nil }. safeDiv(10, 0): division by zero → panic → recover captura → retorna err='panic: runtime error: integer divide by zero'. Cleanup com defer: defer file.Close(); defer mu.Unlock(); ordem reversa garantida mesmo com panic."
  },
  {
    "id": "linguagens-de-programacao__Java__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Fácil",
    "question": "Em Java, qual é a diferença entre '==' e o método '.equals()' ao comparar Strings?",
    "options": [
      "== compara referências na memória; .equals() compara o conteúdo dos caracteres",
      "São equivalentes para Strings",
      "== é mais seguro que .equals()",
      ".equals() compara referências e == compara conteúdo"
    ],
    "correctIndex": 0,
    "explanation": "O operador == em Java compara se duas referências apontam para o mesmo objeto na memória. O método .equals() compara o conteúdo (valor) das Strings caractere por caractere. Duas Strings diferentes na memória podem ter o mesmo conteúdo.",
    "example": "String a = new String(\"hello\"); String b = new String(\"hello\"); a == b // false (objetos diferentes). a.equals(b) // true (mesmo conteúdo)."
  },
  {
    "id": "linguagens-de-programacao__Java__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Fácil",
    "question": "Em Java, qual é a diferença entre 'ArrayList' e 'LinkedList'?",
    "options": [
      "ArrayList usa array dinâmico (acesso O(1)); LinkedList usa nós encadeados (inserção/remoção O(1) nas extremidades)",
      "São idênticas",
      "LinkedList é mais rápida em tudo",
      "ArrayList não permite duplicatas"
    ],
    "correctIndex": 0,
    "explanation": "ArrayList: baseada em array dinâmico, acesso por índice O(1), inserção/remoção no meio O(n). LinkedList: nós duplamente encadeados, acesso por índice O(n), inserção/remoção nas pontas O(1). Na prática, ArrayList é melhor na maioria dos casos por cache locality.",
    "example": "ArrayList<String> al = new ArrayList<>(); al.get(500); // O(1). LinkedList<String> ll = new LinkedList<>(); ll.get(500); // O(n), percorre 500 nós. ll.addFirst('x'); // O(1)."
  },
  {
    "id": "linguagens-de-programacao__Java__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Fácil",
    "question": "Em Java, o que a keyword 'final' faz quando usada em variáveis, métodos e classes?",
    "options": [
      "Variável: não reatribuível; método: não pode ser sobrescrito; classe: não pode ser estendida (herdada)",
      "Torna tudo privado",
      "Deleta após uso",
      "Só funciona em variáveis"
    ],
    "correctIndex": 0,
    "explanation": "final em variável: a referência não pode ser reatribuída (o objeto pode ser mutado). final em método: subclasses não podem sobrescrever (override). final em classe: não pode ser estendida (ex: String é final). Promove imutabilidade e segurança.",
    "example": "final int MAX = 100; MAX = 200; // Erro. final List<String> list = new ArrayList<>(); list.add('ok'); // OK (objeto mutado). class Util extends String {} // Erro: String é final."
  },
  {
    "id": "linguagens-de-programacao__Java__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Fácil",
    "question": "O que é o JVM (Java Virtual Machine) e por que Java é multiplataforma?",
    "options": [
      "Bytecode Java roda em qualquer plataforma que tenha uma JVM; 'Write Once, Run Anywhere'",
      "Java é compilado para código nativo",
      "JVM é um editor de código",
      "Java só roda em Linux"
    ],
    "correctIndex": 0,
    "explanation": "O compilador Java (javac) compila .java para bytecode (.class). A JVM interpreta e/ou compila JIT o bytecode para código nativo da plataforma. Cada OS tem sua JVM, mas o bytecode é o mesmo. JVM também gerencia memória (GC), threads e segurança.",
    "example": "javac App.java → App.class (bytecode). java App → JVM carrega bytecode, JIT compila hot methods para código nativo. Mesmo .class roda em Windows, Linux, macOS."
  },
  {
    "id": "linguagens-de-programacao__Java__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Fácil",
    "question": "O que são collections em Java e quais as principais interfaces?",
    "options": [
      "Framework de estruturas de dados: List (ordenada), Set (sem duplicatas), Map (chave-valor), Queue (FIFO)",
      "Apenas arrays",
      "Banco de dados em memória",
      "Tipo de variável"
    ],
    "correctIndex": 0,
    "explanation": "Collections Framework: List (ArrayList, LinkedList — ordenada, duplicatas OK). Set (HashSet, TreeSet — sem duplicatas). Map (HashMap, TreeMap — chave-valor). Queue (LinkedList, PriorityQueue — FIFO). Todas usam generics para type safety.",
    "example": "List<String> names = new ArrayList<>(); names.add('Ana'); Set<Integer> ids = new HashSet<>(List.of(1,2,2)); // {1,2}. Map<String,Integer> ages = Map.of('Ana',25); ages.get('Ana'); // 25."
  },
  {
    "id": "linguagens-de-programacao__Java__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Fácil",
    "question": "O que é o operador 'instanceof' em Java e para que serve?",
    "options": [
      "Verifica se um objeto é instância de uma classe ou interface em runtime, retornando boolean",
      "Cria uma nova instância",
      "Compara valores de strings",
      "Verifica se uma classe existe"
    ],
    "correctIndex": 0,
    "explanation": "instanceof verifica o tipo real do objeto em runtime. Retorna true se o objeto é da classe especificada ou de uma subclasse/implementação. Java 16+: pattern matching com instanceof permite cast automático (if (obj instanceof String s) — s já é String).",
    "example": "Object obj = 'hello'; if (obj instanceof String s) { System.out.println(s.length()); // 5 — cast automático (Java 16+) } // Antes: if (obj instanceof String) { String s = (String) obj; }"
  },
  {
    "id": "linguagens-de-programacao__Java__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Fácil",
    "question": "O que são interfaces em Java e como diferem de classes abstratas?",
    "options": [
      "Interfaces definem contrato (métodos sem estado); classes abstratas podem ter estado e implementação parcial",
      "São idênticas",
      "Interfaces têm construtores",
      "Classes abstratas não têm métodos"
    ],
    "correctIndex": 0,
    "explanation": "Interface: contrato puro (métodos abstratos), sem estado (só constantes), suporta múltipla implementação. Classe abstrata: pode ter estado (campos), construtores, métodos concretos, só herança única. Java 8+: interfaces podem ter default methods (implementação padrão).",
    "example": "interface Drawable { void draw(); default void reset() { /* impl padrão */ } } abstract class Shape { int x, y; abstract double area(); void move(int dx, int dy) { x += dx; y += dy; } } class Circle extends Shape implements Drawable { }"
  },
  {
    "id": "linguagens-de-programacao__Java__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Fácil",
    "question": "O que é o Java Garbage Collector e quais as gerações (Young, Old, Metaspace)?",
    "options": [
      "GC gerencia memória automaticamente; Young generation (objetos novos, GC frequente e rápido); Old generation (objetos longevos, GC menos frequente); Metaspace (metadados de classes)",
      "GC usa contagem de referências como Python; Young/Old são níveis de prioridade de coleta",
      "Java não tem gerações; todo GC varre toda a heap uniformemente",
      "Young generation só para arrays; Old generation para objetos com campos de instância"
    ],
    "correctIndex": 0,
    "explanation": "Heap generacional: Young (Eden + S0 + S1) — objetos novos alocados em Eden, Minor GC rápido (stop-the-world ms). Objetos que sobrevivem vaó para Survivor spaces, depois promovidos para Old gen. Old gen (Tenured): Major GC/Full GC mais lento. Metaspace (Java 8+, substitui PermGen): bytecode de classes, crescimento dinâmico.",
    "example": "G1GC (default Java 9+): divide heap em regiões, GC incremental. ZGC (Java 11+): pause < 1ms mesmo em heaps de TB. GraalVM: ahead-of-time compilation elimina GC de JVM em native image. -Xms512m -Xmx4g: heap mínimo e máximo. jstat -gcutil PID: monitorar GC em runtime. OOM Error: heap esgotada após GC."
  },
  {
    "id": "linguagens-de-programacao__Java__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Médio",
    "question": "Em Java, qual é a finalidade dos Generics e como eles garantem type safety em tempo de compilação?",
    "options": [
      "Permitem parametrizar tipos em classes/métodos, detectando erros de tipo em compilação em vez de runtime",
      "Permitem herança múltipla",
      "São usados apenas para coleções",
      "Adicionam checagem de tipos em runtime"
    ],
    "correctIndex": 0,
    "explanation": "Generics permitem definir classes, interfaces e métodos com tipos parametrizados. O compilador verifica a consistência dos tipos, evitando ClassCastException em runtime. Devido ao type erasure, as informações de tipo são removidas após compilação, mantendo compatibilidade com versões anteriores.",
    "example": "List<String> nomes = new ArrayList<>(); nomes.add(\"Ana\"); // OK. nomes.add(123); // Erro de compilação! Sem generics: List nomes = new ArrayList(); nomes.add(123); // Compila, mas ClassCastException em runtime ao fazer (String) nomes.get(0)."
  },
  {
    "id": "linguagens-de-programacao__Java__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Médio",
    "question": "Em Java, o que são Streams (java.util.stream) e como diferem de loops tradicionais?",
    "options": [
      "API funcional para processar coleções com operações como filter/map/reduce de forma declarativa e poss. paralela",
      "São streams de I/O",
      "Substituem ArrayList",
      "São threads"
    ],
    "correctIndex": 0,
    "explanation": "Streams API (Java 8+) permite processar coleções de forma funcional e declarativa. Operações intermediárias (filter, map, sorted) são lazy. Operações terminais (collect, forEach, reduce) disparam o processamento. parallelStream() paraleliza automaticamente.",
    "example": "List<String> nomes = pessoas.stream().filter(p -> p.getIdade() >= 18).map(Person::getNome).sorted().collect(Collectors.toList()); // Declarativo vs for loop com if/add."
  },
  {
    "id": "linguagens-de-programacao__Java__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Médio",
    "question": "Em Java, o que é a diferença entre 'checked' e 'unchecked' exceptions?",
    "options": [
      "Checked devem ser declaradas/tratadas em compile time; unchecked (RuntimeException) não exigem tratamento explícito",
      "São idênticas",
      "Unchecked são mais graves",
      "Checked são mais rápidas"
    ],
    "correctIndex": 0,
    "explanation": "Checked exceptions (IOException, SQLException) herdam de Exception e DEVEM ser tratadas com try-catch ou declaradas com throws — o compilador exige. Unchecked (NullPointerException, IllegalArgumentException) herdam de RuntimeException e não exigem tratamento explícito. Erros de programação geralmente são unchecked.",
    "example": "// Checked: void readFile() throws IOException { FileReader f = new FileReader('x'); } // Compilador exige throws. // Unchecked: int x = list.get(99); // IndexOutOfBoundsException — não exige try-catch."
  },
  {
    "id": "linguagens-de-programacao__Java__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Médio",
    "question": "O que são Streams em Java 8+ e como diferem de collections?",
    "options": [
      "Pipeline funcional para processar sequências de dados com operações lazy; não armazenam dados como collections",
      "Tipo de I/O",
      "Collections mais rápidas",
      "Threads paralelas"
    ],
    "correctIndex": 0,
    "explanation": "Streams: pipeline de operações funcionais (filter, map, reduce) sobre dados. Lazy: operações intermediárias só executam quando terminal é chamada. Não modificam a fonte. parallelStream() para paralelismo. Collections armazenam; Streams processam.",
    "example": "List<String> names = users.stream().filter(u -> u.getAge() >= 18).map(User::getName).sorted().collect(Collectors.toList()); // Pipeline: filtra adultos → extrai nomes → ordena → coleta."
  },
  {
    "id": "linguagens-de-programacao__Java__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Médio",
    "question": "O que é o Spring Framework e por que é usado em Java?",
    "options": [
      "Framework enterprise com IoC/DI, MVC, data access e segurança; Spring Boot simplifica configuração",
      "Framework de UI",
      "Compilador Java",
      "Banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "Spring: framework mais popular para Java enterprise. Core: IoC container + DI. Spring MVC: APIs REST. Spring Data: abstrai persistência. Spring Security: autenticação/autorização. Spring Boot: convenção sobre configuração, auto-config, servidor embutido.",
    "example": "@RestController class UserController { @Autowired UserService service; @GetMapping('/users') List<User> list() { return service.findAll(); } } // DI injeta service, @GetMapping mapeia endpoint. Zero XML."
  },
  {
    "id": "linguagens-de-programacao__Java__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Médio",
    "question": "O que são annotations em Java e como @Override funciona?",
    "options": [
      "Metadados em código processados pelo compilador ou runtime; @Override valida que o método sobrescreve o da superclasse",
      "Comentários especiais",
      "Decoradores como em Python",
      "Macros de pré-processador"
    ],
    "correctIndex": 0,
    "explanation": "Annotations: @NomeAnotacao são metadados processados em compile-time ou runtime. @Override: compilador verifica que o método realmente sobrescreve um método da superclasse — erro de compilação se não. Outras: @Deprecated, @SuppressWarnings, @FunctionalInterface. Custom annotations com @interface.",
    "example": "class Animal { void speak() {} } class Dog extends Animal { @Override void speak() { System.out.println('Woof'); } // OK @Override void spek() {} // ERRO de compilação: spek não existe na superclasse }"
  },
  {
    "id": "linguagens-de-programacao__Java__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Médio",
    "question": "O que é Optional<T> em Java 8+ e por que evitar retornar null?",
    "options": [
      "Container que pode ou não conter um valor, forçando tratamento explícito de ausência e evitando NullPointerException",
      "Tipo de coleção",
      "Wrapper para primitivos",
      "Substituto de try-catch"
    ],
    "correctIndex": 0,
    "explanation": "Optional<T> encapsula um valor possivelmente ausente. Métodos: isPresent(), ifPresent(consumer), orElse(default), orElseThrow(), map(), flatMap(). Evita NullPointerException tornando a ausência explícita. Não usar para campos ou parâmetros — apenas retorno.",
    "example": "Optional<User> user = repo.findById(id); String name = user.map(User::getName).orElse('Anônimo'); // Sem Optional: User u = repo.findById(id); if (u != null) { return u.getName(); } else { return 'Anônimo'; }"
  },
  {
    "id": "linguagens-de-programacao__Java__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Médio",
    "question": "O que são Optional<T> e Stream<T> em Java 8+ e como compostos resolvem null checks e iterações verbosas?",
    "options": [
      "Optional evita NullPointerException encapsulando valor possivelmente ausente com map/flatMap/orElse; Stream processa coleções de forma declarativa com operações encadeadas lazy",
      "Optional e Stream são wrappers de sincronização para thread-safety",
      "Stream substitui for loops mas executa ansiosamente (eagerly) gerando lista imediata",
      "Optional é apenas para retorno de métodos; usar null internamente ainda é correto"
    ],
    "correctIndex": 0,
    "explanation": "Optional.of/ofNullable/empty. map(): transforma valor se presente. flatMap(): evita Optional<Optional<T>>. orElse(default): valor alternativo. orElseGet(supplier): lazy. orElseThrow(): exceção se vazio. Stream: lazy (operações intermediárias: filter, map, sorted) + eager (terminais: collect, count, findFirst). Parallel streams: .parallelStream() para CPU-bound com Fork/Join pool.",
    "example": "Verboso: String cidade = null; if(user != null && user.getAddress() != null) cidade = user.getAddress().getCidade(); Com Optional: String cidade = Optional.ofNullable(user).map(User::getAddress).map(Address::getCidade).orElse('N/D'). Stream: lista.stream().filter(p -> p.getAtivo()).mapToInt(Pedido::getValor).average().orElse(0.0)."
  },
  {
    "id": "linguagens-de-programacao__Java__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Difícil",
    "question": "Em Java, o que é o 'happens-before' relationship no Java Memory Model e por que é crucial para código multithread?",
    "options": [
      "Garante que alterações de memória feitas por uma thread sejam visíveis para outra em pontos de sincronização definidos",
      "Garante que threads executem em ordem alfabética",
      "É uma regra de garbage collection",
      "Define a prioridade de execução das threads"
    ],
    "correctIndex": 0,
    "explanation": "O Java Memory Model define 'happens-before' como garantia de visibilidade: se ação A happens-before ação B, os efeitos de A são visíveis para B. Exemplos: unlock de monitor HB lock subsequente, write em volatile HB read subsequente, Thread.start() HB primeira ação da thread. Sem essas garantias, threads podem ver valores stale por cache/reordering.",
    "example": "volatile boolean ready = false; Thread 1: data = 42; ready = true; Thread 2: if (ready) use(data); // Sem volatile, Thread 2 pode ver ready=true mas data=0 (reordering). Com volatile, write-ready HB read-ready, garantindo data=42 visível."
  },
  {
    "id": "linguagens-de-programacao__Java__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Difícil",
    "question": "Em Java, o que é o class loading mechanism e como funciona o classloader hierarchy?",
    "options": [
      "Sistema hierárquico de classloaders que carregam classes sob demanda seguindo delegação parent-first",
      "Compilador JIT",
      "Garbage collector",
      "Thread scheduler"
    ],
    "correctIndex": 0,
    "explanation": "Java usa 3 classloaders em hierarquia: 1) Bootstrap (carrega java.lang, rt.jar). 2) Extension/Platform (ext jars). 3) Application (classpath do usuário). Seguem parent delegation: Application delega para Extension, que delega para Bootstrap. Apenas se o pai não encontrar, o filho carrega.",
    "example": "Class.forName('com.app.MyService') → Application CL pergunta ao Extension CL → pergunta ao Bootstrap CL → Bootstrap não tem → Extension não tem → Application carrega de target/classes/. Custom classloaders permitem hot-reload."
  },
  {
    "id": "linguagens-de-programacao__Java__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Difícil",
    "question": "Em Java 21+, o que são Virtual Threads (Project Loom) e como diferem de platform threads?",
    "options": [
      "Threads leves gerenciadas pela JVM que podem criar milhões de instâncias, ideal para I/O-bound concorrente",
      "Threads do sistema operacional",
      "São coroutines como Kotlin",
      "Substituem completamente platform threads"
    ],
    "correctIndex": 0,
    "explanation": "Virtual Threads (Java 21) são threads leves montadas sobre um pool de platform threads (carrier threads). Custam ~1KB vs ~1MB de platform threads. Ideais para I/O-bound: milhões de virtual threads podem esperar I/O simultaneamente. O scheduler da JVM desmonta/remonta virtual threads nos carriers automaticamente.",
    "example": "try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { IntStream.range(0, 1_000_000).forEach(i -> executor.submit(() -> { Thread.sleep(Duration.ofSeconds(1)); return i; })); } // 1 milhão de threads virtuais — impossível com platform threads."
  },
  {
    "id": "linguagens-de-programacao__Java__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Difícil",
    "question": "O que é o GC (Garbage Collector) em Java e quais os principais coletores?",
    "options": [
      "Gerenciador automático de memória que libera objetos inalcançáveis; G1, ZGC e Shenandoah são coletores modernos",
      "Compilador de código",
      "Ferramenta de profiling",
      "Otimizador de queries"
    ],
    "correctIndex": 0,
    "explanation": "GC Java: identifica e libera objetos sem referências. Gerações: Young (Eden + Survivors) e Old. G1 (default): pausas previsíveis. ZGC (Java 15+): pausas <1ms para heaps de TB. Shenandoah: pausas ultra-baixas. Tuning: -Xmx, -XX:+UseZGC.",
    "example": "App com 32GB heap: G1 → pausas de ~50ms. ZGC → pausas <1ms (concurrent compaction). Shenandoah → similar a ZGC. Serial → pausas de segundos (só para apps pequenos single-thread)."
  },
  {
    "id": "linguagens-de-programacao__Java__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Difícil",
    "question": "O que são sealed classes em Java 17+ e qual problema resolvem?",
    "options": [
      "Classes que restringem quais outras classes podem estendê-las, permitindo hierarquias fechadas e exaustivas",
      "Classes encapsuladas",
      "Classes sem construtor",
      "Classes imutáveis"
    ],
    "correctIndex": 0,
    "explanation": "sealed classes (Java 17): a classe base declara quais subclasses são permitidas (permits). O compilador garante que todas as subclasses são conhecidas. Combina com pattern matching e switch exaustivo. Modelagem de domínio com ADTs (Algebraic Data Types).",
    "example": "sealed interface Shape permits Circle, Rectangle, Triangle {} record Circle(double r) implements Shape {} record Rectangle(double w, double h) implements Shape {} // switch exaustivo: case Circle c -> ...; case Rectangle r -> ...; case Triangle t -> ..."
  },
  {
    "id": "linguagens-de-programacao__Java__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Difícil",
    "question": "O que são record types em Java 14+ e como simplificam DTOs?",
    "options": [
      "Classes imutáveis com construtor, getters, equals, hashCode e toString gerados automaticamente",
      "Tabelas de banco de dados",
      "Tipos primitivos especiais",
      "Classes com métodos estáticos"
    ],
    "correctIndex": 0,
    "explanation": "Records (Java 14+): declaração compacta para data carriers imutáveis. O compilador gera: construtor canônico, getters (name(), age()), equals/hashCode por valor, toString. Não podem ter campos mutáveis. Ideais para DTOs, value objects e retornos múltiplos.",
    "example": "record Point(int x, int y) {} // Gera automaticamente: construtor Point(int x, int y), métodos x(), y(), equals, hashCode, toString. var p1 = new Point(1, 2); var p2 = new Point(1, 2); p1.equals(p2); // true."
  },
  {
    "id": "linguagens-de-programacao__Java__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Difícil",
    "question": "O que é o pattern matching para switch em Java 21+ e como melhora o código?",
    "options": [
      "Switch expressions que testam tipo, valor e estrutura do objeto, com guards e exaustividade verificada pelo compilador",
      "Regex em switch",
      "Switch com strings apenas",
      "Substituto de if-else"
    ],
    "correctIndex": 0,
    "explanation": "Pattern matching switch (Java 21): case String s → testa tipo e vincula variável. Guarded patterns: case Integer i when i > 0. Sealed classes: compilador verifica exaustividade. Record patterns: case Point(int x, int y). Elimina cascatas de instanceof.",
    "example": "String describe(Object obj) { return switch (obj) { case Integer i when i > 0 -> 'positivo: ' + i; case String s -> 'string len=' + s.length(); case Point(var x, var y) -> 'ponto(' + x + ',' + y + ')'; case null -> 'nulo'; default -> 'outro'; }; }"
  },
  {
    "id": "linguagens-de-programacao__Java__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "Java",
    "difficulty": "Difícil",
    "question": "Como o Java Virtual Threads (Project Loom, Java 21) altera o modelo de concorrência e qual o impacto para servidores web?",
    "options": [
      "Virtual threads são threads leves gerenciadas pela JVM montadas sobre carrier threads; operacoess bloqueantes (I/O, sleep) desmontam o carrier; permite thread-per-request sem overhead de 10k+ threads OS",
      "Virtual threads são apenas coroutines Kotlin compiladas para JVM",
      "Substituem CompletableFuture; código assíncrono com async/await é eliminado",
      "Cada virtual thread tem JVM própria isolada, similar a processos OS"
    ],
    "correctIndex": 0,
    "explanation": "Project Loom (Java 21 LTS): Thread.ofVirtual().start(() -> ...). Stack: KB vs MB de platform thread. JVM scheduler: ao encontrar op. bloqueante (socket read, sleep), desmonta a virtual thread do carrier thread, carrier continua com outra virtual thread. Nenhuma mudança de código: JDBC, HttpURLConnection, bloqueantes funcionam sem callback. Throughput: 10k conexões HTTP simultâneas com 10k virtual threads vs 200 platform threads (limite prático).",
    "example": "Servlet com virtual threads: cada requisição em Thread.ofVirtual(). db.query() bloqueia → carrier segue outra virtual thread. Spring Boot 3.2: virtual threads por default em Tomcat com Loom. Antes: CompletableFuture.supplyAsync() necessário para não bloquear. Agora: código síncrono simples com throughput assíncrono. Pinning: synchronized block prende virtual thread ao carrier (evitar em hot paths)."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Fácil",
    "question": "No JavaScript, qual método de array retorna um novo array contendo apenas os elementos que passam em um teste (callback)?",
    "options": [
      "filter()",
      "map()",
      "reduce()",
      "forEach()"
    ],
    "correctIndex": 0,
    "explanation": "O método filter() cria um novo array com todos os elementos para os quais a função callback retorna true. Não modifica o array original (é imutável). Se nenhum elemento passar no teste, retorna um array vazio.",
    "example": "const maiores = [1, 5, 3, 8, 2].filter(n => n > 3); // [5, 8] — apenas elementos maiores que 3."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Fácil",
    "question": "No JavaScript, qual a diferença entre 'null' e 'undefined'?",
    "options": [
      "undefined: variável declarada mas sem valor; null: valor intencionalmente vazio atribuído pelo programador",
      "São idênticos",
      "null é para números e undefined para strings",
      "undefined não existe"
    ],
    "correctIndex": 0,
    "explanation": "undefined indica que uma variável foi declarada mas não recebeu valor, ou um parâmetro/propriedade não existe. null é atribuído explicitamente para indicar 'sem valor intencional'. typeof undefined === 'undefined', typeof null === 'object' (bug histórico).",
    "example": "let x; console.log(x); // undefined. let y = null; // intencionalmente vazio. obj.prop // undefined se prop não existe. null == undefined // true. null === undefined // false."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Fácil",
    "question": "No JavaScript, o que é destructuring e como usá-lo com arrays e objetos?",
    "options": [
      "Sintaxe que extrai valores de arrays/objetos em variáveis individuais de forma concisa",
      "Método para deletar propriedades",
      "Forma de clonar objetos",
      "Operação de banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "Destructuring permite extrair valores de arrays ([a, b] = [1, 2]) e propriedades de objetos ({ name, age } = person) em variáveis separadas. Suporta valores default, renomeação, rest operator e aninhamento. Muito usado em imports e parâmetros de função.",
    "example": "const { name, age = 0 } = user; // extrai name e age (default 0). const [first, ...rest] = [1,2,3]; // first=1, rest=[2,3]. function greet({ name }) { } // destructuring no parâmetro."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Fácil",
    "question": "O que são arrow functions em JavaScript e como diferem de funções tradicionais?",
    "options": [
      "Sintaxe curta () => {}; não têm 'this' próprio, herdam do escopo léxico pai",
      "São idênticas a function(){}",
      "Só funcionam com callbacks",
      "Não podem retornar valores"
    ],
    "correctIndex": 0,
    "explanation": "Arrow functions: sintaxe compacta, não possuem 'this' próprio (herdam do escopo externo), não podem ser usadas como construtores (new), não têm 'arguments' object. Ideais para callbacks curtos. Funções tradicionais: têm 'this' dinâmico baseado em como são chamadas.",
    "example": "const obj = { name: 'Ana', greet: function() { setTimeout(() => { console.log(this.name); }, 100); } }; // Arrow herda 'this' de greet(). Com function() dentro do setTimeout, 'this' seria undefined."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Fácil",
    "question": "O que são módulos ES (ESM) em JavaScript?",
    "options": [
      "Sistema nativo de módulos com import/export para organizar código em arquivos independentes",
      "Bibliotecas externas",
      "Plugins do Node.js",
      "Funções globais"
    ],
    "correctIndex": 0,
    "explanation": "ES Modules (ESM): sistema de módulos nativo do JS (import/export). Cada arquivo é um módulo com escopo próprio. Named export: export function foo() {}. Default export: export default class X {}. Import: import { foo } from './mod'. Substituem CommonJS (require) no ecossistema moderno.",
    "example": "// math.js: export const PI = 3.14; export function sum(a, b) { return a+b; }. // app.js: import { PI, sum } from './math.js'; sum(1, 2); // 3. import * as math from './math.js'; math.PI; // 3.14."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Fácil",
    "question": "O que é o spread operator (...) em JavaScript e quais seus usos?",
    "options": [
      "Expande arrays/objetos em elementos individuais; usado para cópias, merge e passagem de argumentos",
      "Operador de divisão",
      "Declaração de variáveis múltiplas",
      "Operador de comparação"
    ],
    "correctIndex": 0,
    "explanation": "Spread (...): expande iteráveis em elementos. Em arrays: [...a, ...b] concatena. Em objetos: {...obj, key: val} faz shallow copy com override. Em funções: func(...args) recebe como array (rest). Shallow copy: não clona objetos aninhados.",
    "example": "const a = [1, 2]; const b = [...a, 3, 4]; // [1, 2, 3, 4]. const obj = { x: 1 }; const obj2 = { ...obj, y: 2 }; // { x: 1, y: 2 }. Math.max(...[5, 3, 8]); // 8."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Fácil",
    "question": "O que são template literals em JavaScript e como diferem de strings normais?",
    "options": [
      "Strings com crase (`) que suportam interpolação ${expr}, múltiplas linhas e tagged templates",
      "Strings com aspas duplas",
      "Templates HTML",
      "Constantes de texto"
    ],
    "correctIndex": 0,
    "explanation": "Template literals usam crase (`). Interpolação: ${expression} avalia qualquer expressão JS. Multi-line: quebras de linha preservadas. Tagged templates: func`text ${val}` — a função recebe strings e valores separados (usado em styled-components, GraphQL).",
    "example": "const name = 'Ana'; const msg = `Olá, ${name}! Você tem ${2+1} msgs.`; // 'Olá, Ana! Você tem 3 msgs.' // Tagged: const html = tag`<p>${name}</p>`; // tag recebe strings e valores para sanitizar."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Fácil",
    "question": "O que é o operador de optional chaining (?.) e o nullish coalescing (??) em JavaScript moderno?",
    "options": [
      "?. acessa propriedade sem lancar erro se o objeto é null/undefined (retorna undefined); ?? retorna lado direito somente se lado esquerdo é null/undefined (diferente de || que considera 0 e string vazia falsy)",
      "?. é o operador ternário curto; ?? é o operador de coalescência OR lógico",
      "Ambos são equivalentes ao operador || com checagem de tipo explícita",
      "?. é usado somente com métodos; ?? somente com primitivos"
    ],
    "correctIndex": 0,
    "explanation": "Optional chaining: user?.address?.city — curto-circuito se null/undefined, retorna undefined sem TypeError. ?. com método: arr?.map(fn). ?. com índice: arr?.[0]. Nullish coalescing: a ?? b — retorna b só se a é null ou undefined. || retorna b para qualquer falsy (0, '', false) o que pode ser indesejado. Combinação: user?.settings?.theme ?? 'dark'.",
    "example": "const cidade = usuario?.endereço?.cidade; // undefined se usuario ou endereço for null, sem crash. const port = config.port ?? 3000; // 3000 somente se config.port for null/undefined. config.port = 0: ?? retorna 0 (correto); || retornaria 3000 (bug!). Logical assignment: x ??= 'default'; x ||= 'fallback'; x &&= transform(x)."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Médio",
    "question": "No JavaScript, o que são closures e como elas afetam o escopo de variáveis?",
    "options": [
      "Uma closure é uma função que retém acesso ao escopo léxico onde foi criada, mesmo após esse escopo ter encerrado",
      "Closures são funções anônimas sem escopo",
      "Closures impedem o garbage collector de funcionar",
      "Closures só existem em classes ES6"
    ],
    "correctIndex": 0,
    "explanation": "Uma closure é criada quando uma função interna captura referências a variáveis da função externa. Mesmo após a função externa retornar, a função interna mantém acesso a essas variáveis, que permanecem vivas na memória. É a base para data privacy, módulos e fábricas de funções.",
    "example": "function counter() { let count = 0; return () => ++count; } const inc = counter(); inc(); // 1. inc(); // 2. — a variável 'count' persiste via closure."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Médio",
    "question": "No JavaScript, o que são Promises e como async/await simplificam código assíncrono?",
    "options": [
      "Promises representam valores futuros; async/await é syntax sugar sobre Promises para escrita síncrona-like",
      "Promises são variáveis globais",
      "async cria threads",
      "São exclusivas do Node.js"
    ],
    "correctIndex": 0,
    "explanation": "Promise encapsula operação assíncrona com 3 estados: pending, fulfilled, rejected. .then() e .catch() encadeiam operações. async/await (ES2017) permite escrever código assíncrono que parece síncrono, sem callbacks aninhados (callback hell).",
    "example": "// Sem async/await: fetch(url).then(r => r.json()).then(data => process(data)).catch(err => handle(err)); // Com async/await: const r = await fetch(url); const data = await r.json(); process(data);"
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Médio",
    "question": "No JavaScript, o que é o prototype chain e como a herança prototpíca funciona?",
    "options": [
      "Cada objeto tem um __proto__ que aponta para outro objeto; propriedades são buscadas subindo a cadeia até null",
      "Herança clássica como Java",
      "Apenas classes ES6 têm herança",
      "Não existe herança em JS"
    ],
    "correctIndex": 0,
    "explanation": "JavaScript usa herança prototípica: cada objeto tem um [[Prototype]] (acessível via __proto__). Ao acessar uma propriedade, JS busca no objeto, depois no prototype, depois no prototype do prototype... até Object.prototype (cujo __proto__ é null). Classes ES6 são syntax sugar sobre prototypes.",
    "example": "const animal = { speak() { return 'som'; } }; const dog = Object.create(animal); dog.bark = () => 'woof'; dog.speak(); // 'som' — encontrado em animal via prototype chain. dog.bark(); // 'woof' — encontrado no próprio dog."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Médio",
    "question": "O que é o Event Loop no JavaScript e por que é importante?",
    "options": [
      "Mecanismo single-threaded que processa call stack, microtasks (Promises) e macrotasks (setTimeout) em ordem",
      "Thread pool de workers",
      "Gerenciador de memória",
      "Compilador JIT"
    ],
    "correctIndex": 0,
    "explanation": "JS é single-threaded. Event Loop: executa call stack até esvaziar → processa todas microtasks (Promise.then, queueMicrotask) → processa uma macrotask (setTimeout, I/O) → repete. Microtasks têm prioridade sobre macrotasks.",
    "example": "console.log('1'); setTimeout(() => console.log('2'), 0); Promise.resolve().then(() => console.log('3')); console.log('4'); // Output: 1, 4, 3, 2. Síncrono → microtask → macrotask."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Médio",
    "question": "O que é WeakMap/WeakSet em JavaScript e quando usar?",
    "options": [
      "Coleções com referências fracas que não impedem garbage collection das chaves/valores",
      "Maps/Sets menores",
      "Versões mais rápidas de Map/Set",
      "Coleções imutáveis"
    ],
    "correctIndex": 0,
    "explanation": "WeakMap: chaves são referências fracas (só objetos). Se a única referência ao objeto for a chave do WeakMap, o GC pode coletar. Não iterável (sem .keys(), .size). Uso: metadata associada a objetos DOM, caches que não causam memory leaks.",
    "example": "const cache = new WeakMap(); function process(obj) { if (cache.has(obj)) return cache.get(obj); const result = expensiveCalc(obj); cache.set(obj, result); return result; } // Se obj for coletado, entry no WeakMap some automaticamente."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Médio",
    "question": "O que é optional chaining (?.) e nullish coalescing (??) em JavaScript?",
    "options": [
      "?. acessa propriedades de forma segura retornando undefined se null/undefined; ?? fornece fallback só para null/undefined",
      "Operadores matemáticos",
      "Operadores de atribuição",
      "Operadores de comparação"
    ],
    "correctIndex": 0,
    "explanation": "?. (optional chaining): obj?.prop?.sub retorna undefined em vez de lançar TypeError. Funciona com métodos (obj?.method()) e índices (arr?.[0]). ?? (nullish coalescing): retorna o operando direito SOU se o esquerdo for null ou undefined (diferente de || que trata 0, '' e false como falsy).",
    "example": "const city = user?.address?.city ?? 'N/A'; // Se user ou address for null/undefined, city = 'N/A'. const count = data?.length ?? 0; // 0 se data for null. // Diferença de ||: 0 ?? 42 = 0, mas 0 || 42 = 42."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Médio",
    "question": "O que são Map e Set em JavaScript e como diferem de objetos e arrays?",
    "options": [
      "Map: coleção chave-valor com qualquer tipo de chave; Set: coleção de valores únicos. Ambos mantêm ordem de inserção",
      "Sinônimos de {} e []",
      "Estruturas imutáveis",
      "Coleções exclusivas do Node.js"
    ],
    "correctIndex": 0,
    "explanation": "Map vs Object: chaves podem ser qualquer tipo (objetos, funções), .size integrado, iteração na ordem de inserção, sem poluição de prototype. Set vs Array: valores únicos automaticamente, has() O(1). Ambos são iteráveis com for...of.",
    "example": "const map = new Map(); map.set({id:1}, 'user1'); map.size; // 1. const set = new Set([1,2,2,3]); set.size; // 3 (sem duplicatas). set.has(2); // true, O(1). [...new Set(array)]; // remove duplicatas de array."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Médio",
    "question": "O que são WeakMap e WeakSet em JavaScript e quando usar ao invés de Map e Set?",
    "options": [
      "WeakMap/WeakSet mantm referências fracas (não impedem GC); chave/elemento deve ser objeto; útil para metadados privados e caches sem memory leak quando objetos são removidos",
      "WeakMap tem performance melhor que Map para qualquer uso; preferível sempre",
      "São versões thread-safe de Map/Set para ambientes com Web Workers",
      "WeakMap permite chaves primitivas; WeakSet permite valores mistos com GC"
    ],
    "correctIndex": 0,
    "explanation": "WeakMap: chaves = objetos, valores = qualquer. Se não há outra referência ao objeto-chave, o GC pode coletar a entrada. Não é iterável (sem .keys(), não tem size). WeakSet: colecção de objetos sem duplicatas, GC pode coletar. Uso: armazenar metadados privados de objetos, cache por objeto, marcar objetos processados sem impedir GC.",
    "example": "Cache por DOM element: const cache = new WeakMap(); function getMetadata(el) { if(!cache.has(el)) cache.set(el, computeExpensive(el)); return cache.get(el); }. Quando el é removido do DOM (sem outra referência), GC coleta automaticamente a entrada. Map guardé el como chave — memory leak. WeakRef (ES2021): referência fraca com deref() explicit."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Difícil",
    "question": "No JavaScript, como o Event Loop processa microtasks (Promises) e macrotasks (setTimeout) e qual tem prioridade?",
    "options": [
      "Microtasks têm prioridade: todas são processadas antes da próxima macrotask; macrotasks executam uma por ciclo",
      "Macrotasks têm prioridade sobre microtasks",
      "São processadas alternadamente sem prioridade",
      "Microtasks e macrotasks são a mesma coisa"
    ],
    "correctIndex": 0,
    "explanation": "O Event Loop executa: 1) uma macrotask (setTimeout, I/O). 2) esvazia TODA a fila de microtasks (Promise.then, queueMicrotask, MutationObserver). 3) renderiza (se necessário). 4) próxima macrotask. Microtasks criadas durante a execução de microtasks também são processadas antes de qualquer macrotask.",
    "example": "setTimeout(() => console.log(1), 0); Promise.resolve().then(() => console.log(2)); console.log(3); // Output: 3, 2, 1 — síncrono primeiro, depois microtask (Promise), depois macrotask (setTimeout)."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Difícil",
    "question": "No JavaScript, o que são WeakMap e WeakRef e como ajudam no gerenciamento de memória?",
    "options": [
      "Referências fracas que não impedem garbage collection dos objetos referenciados",
      "Maps mais rápidos",
      "Caches permanentes",
      "Substitutos para localStorage"
    ],
    "correctIndex": 0,
    "explanation": "WeakMap: chaves são referências fracas a objetos — se não houver outra referência ao objeto-chave, ele pode ser coletado pelo GC (e a entrada some). WeakRef (ES2021): referência fraca a qualquer objeto. Úteis para caches que não devem prevenir GC e evitar memory leaks.",
    "example": "const cache = new WeakMap(); function process(obj) { if (cache.has(obj)) return cache.get(obj); const result = expensiveCalc(obj); cache.set(obj, result); return result; } // Quando obj não tem mais referência forte, GC coleta obj e a entrada do cache."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Difícil",
    "question": "No JavaScript, como Proxy e Reflect permitem interceptar e customizar operações fundamentais de objetos?",
    "options": [
      "Proxy envolve objetos com traps que interceptam get/set/delete/etc; Reflect fornece métodos default para essas operações",
      "São para requisições HTTP",
      "São tipos de Promise",
      "Servem para criptografia"
    ],
    "correctIndex": 0,
    "explanation": "Proxy cria um wrapper com 'traps' (handlers) que interceptam operações como get, set, has, deleteProperty, apply. Reflect fornece os métodos padrão correspondentes. Juntos permitem: validação, logging, observabilidade reativa (como Vue.js 3), e virtualização de objetos.",
    "example": "const reactive = new Proxy(obj, { set(target, key, value) { console.log(`${key} changed to ${value}`); Reflect.set(target, key, value); trigger(key); return true; } }); reactive.name = 'Ana'; // loga e dispara re-render (como Vue 3)."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Difícil",
    "question": "O que é SharedArrayBuffer e Atomics em JavaScript para concorrência real?",
    "options": [
      "Memória compartilhada entre threads (Workers) com operações atômicas para sincronização",
      "Array compartilhado entre tabs",
      "Buffer de rede",
      "Compactação de arrays"
    ],
    "correctIndex": 0,
    "explanation": "SharedArrayBuffer: memória compartilhada entre main thread e Web Workers (verdadeira concorrência). Atomics: operações atômicas (load, store, compareExchange, wait, notify) para evitar race conditions. Requer cross-origin isolation (COOP/COEP headers).",
    "example": "const sab = new SharedArrayBuffer(4); const view = new Int32Array(sab); worker.postMessage(sab); // Worker compartilha mesma memória. Atomics.store(view, 0, 42); Atomics.notify(view, 0); // Sinaliza worker."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Difícil",
    "question": "O que são Generators e Iterators em JavaScript?",
    "options": [
      "Generators (function*) produzem valores sob demanda com yield; Iterators implementam protocolo next()",
      "Funções que geram números aleatórios",
      "Loops avançados",
      "Funções assíncronas"
    ],
    "correctIndex": 0,
    "explanation": "Generator: function* que pausa execução em cada yield e retoma quando next() é chamado. Retorna um Iterator. Lazy evaluation: gera valores sob demanda (memória O(1) vs O(n)). Usado internamente por for...of, spread, destructuring.",
    "example": "function* range(start, end) { for (let i = start; i < end; i++) yield i; } for (const n of range(0, 1000000)) { if (n > 5) break; } // Só gera 6 valores, não 1M. Memória constante."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Difícil",
    "question": "O que é o padrão Module em JavaScript e como closures criam encapsulamento?",
    "options": [
      "IIFE ou closure que expõe API pública mantendo estado privado inacessível externamente",
      "Classe com métodos privados",
      "Arquivo com export default",
      "Namespace global"
    ],
    "correctIndex": 0,
    "explanation": "Module Pattern: usa IIFE + closure para criar escopo privado. Variáveis internas são inacessíveis de fora. Apenas o que é retornado é público. Pré-ESM, era o principal mecanismo de encapsulamento. Hoje ESM fornece escopo de módulo nativamente.",
    "example": "const counter = (() => { let count = 0; // privado return { inc: () => ++count, get: () => count }; })(); counter.inc(); counter.get(); // 1. counter.count; // undefined (privado via closure)."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Difícil",
    "question": "O que é structuredClone() e como difere de JSON.parse(JSON.stringify())?",
    "options": [
      "Clonagem profunda nativa que suporta Date, Map, Set, ArrayBuffer e referências circulares; JSON não",
      "São equivalentes",
      "JSON é mais completo",
      "structuredClone é só para strings"
    ],
    "correctIndex": 0,
    "explanation": "structuredClone() (ES2022): deep clone nativo que serializa com o algoritmo structured clone. Suporta: Date, Map, Set, RegExp, ArrayBuffer, Error, referências circulares. Não suporta: funções, DOM nodes, Symbol. JSON perde Date (vira string), Map/Set, e lança em circulares.",
    "example": "const obj = { date: new Date(), map: new Map([['a',1]]) }; const clone = structuredClone(obj); clone.date instanceof Date; // true. clone.map instanceof Map; // true. // JSON: JSON.parse(JSON.stringify(obj)).date — seria string, não Date."
  },
  {
    "id": "linguagens-de-programacao__JavaScript__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "JavaScript",
    "difficulty": "Difícil",
    "question": "Como funcionam os Iterators e Generators em JavaScript e qual a relação com o protocolo Symbol.iterator?",
    "options": [
      "Iterator: objeto com next() que retorna {value, done}; Generator: função* que produz valores lazy via yield; Symbol.iterator torna qualquer objeto iterável com for...of e spread",
      "Generators criam threads assíncronas; Symbol.iterator é apenas para arrays nativas",
      "Iterator é igual a Promise; yield é equivalente a await em funções generator",
      "Symbol.iterator só funciona com classes ES6; funcões factory não podem ser iteráveis"
    ],
    "correctIndex": 0,
    "explanation": "Iterator protocol: { next() { return {value: T, done: boolean} } }. Iterable: objeto com [Symbol.iterator]() retornando iterator. for...of, spread [...], destructuring usam Symbol.iterator. Generator: function* gen() { yield 1; yield 2; }. Lazy: valores calculados sob demanda. Infinite sequence: function* naturais() { let n=0; while(true) yield n++; }. Async generator: async function* para streams assíncronos.",
    "example": "Sequencia de fibonacci lazy: function* fib() { let [a,b]=[0,1]; while(true) { yield a; [a,b]=[b,a+b]; } }. [...take(fib(), 10)] → primeiros 10. Custom iterable: class Range { [Symbol.iterator]() { let i=this.start; return { next: () => i<=this.end ? {value:i++,done:false} : {done:true} }; } }. for(const n of new Range(1,5)) — itera 1,2,3,4,5."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Fácil",
    "question": "Em Kotlin, qual keyword é usada para declarar variáveis imutáveis (que não podem ser reatribuídas)?",
    "options": [
      "val",
      "var",
      "const",
      "let"
    ],
    "correctIndex": 0,
    "explanation": "A keyword 'val' declara uma variável de somente leitura cuja referência não pode ser reatribuída após inicialização (equivalente a 'final' em Java). 'var' declara variáveis mutáveis. 'const val' é para constantes de tempo de compilação.",
    "example": "val nome = \"Ana\" // imutável. nome = \"Bob\" // Erro de compilação. var idade = 25 // mutável. idade = 26 // OK."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Fácil",
    "question": "Em Kotlin, o que é null safety e como os operadores '?' e '!!' funcionam?",
    "options": [
      "O tipo sistema distingue nullable (T?) de non-null (T); ? acessa seguro, !! força non-null (pode crashar)",
      "São operadores matemáticos",
      "? cria variável e !! deleta",
      "Não existe null em Kotlin"
    ],
    "correctIndex": 0,
    "explanation": "Kotlin distingue String (nunca null) de String? (pode ser null) em tempo de compilação. ?. (safe call) retorna null se o receptor for null. ?: (elvis) fornece valor default. !! (non-null assertion) lança NullPointerException se for null — deve ser evitado.",
    "example": "val name: String? = null; name?.length // null (safe). name?.length ?: 0 // 0 (elvis). name!!.length // NullPointerException! val safe: String = getName() ?: 'default';"
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Fácil",
    "question": "Em Kotlin, o que são 'data classes' e o que elas geram automaticamente?",
    "options": [
      "Classes que geram equals(), hashCode(), toString(), copy() e componentN() automaticamente a partir das propriedades",
      "Classes de banco de dados",
      "Classes abstratas",
      "Classes sem métodos"
    ],
    "correctIndex": 0,
    "explanation": "Data classes são declaradas com 'data class' e geram automaticamente: equals()/hashCode() baseados nas propriedades do construtor primário, toString() legível, copy() para cópia com modificações, e componentN() para destructuring. Equivalente a Records do Java 16+.",
    "example": "data class User(val name: String, val age: Int); val u1 = User('Ana', 25); val u2 = u1.copy(age = 26); // User(name=Ana, age=26). val (name, age) = u1; // destructuring."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre val e var em Kotlin?",
    "options": [
      "val é imutável (read-only); var é mutável (pode ser reatribuído)",
      "São idênticos",
      "val é para números e var para strings",
      "var é imutável"
    ],
    "correctIndex": 0,
    "explanation": "val (value): referência imutável (como final em Java ou const em JS). Não pode ser reatribuído, mas o objeto referenciado pode ser mutável. var (variable): pode ser reatribuído. Preferência: usar val por padrão, var somente quando necessário.",
    "example": "val name = 'Ana'; name = 'Bob'; // ERRO. var age = 25; age = 26; // OK. val list = mutableListOf(1,2); list.add(3); // OK (lista é mutável, referência não)."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Fácil",
    "question": "O que é null safety em Kotlin e como funciona?",
    "options": [
      "O tipo sistema distingue variáveis que podem ser null (String?) das que não podem (String)",
      "Kotlin não tem null",
      "Null é tratado como 0",
      "Todas variáveis podem ser null"
    ],
    "correctIndex": 0,
    "explanation": "Kotlin elimina NullPointerException em compile-time: String não pode ser null; String? pode. Operadores: ?. (safe call), ?: (elvis — valor padrão), !! (assert não-null, perigoso). Smart cast: após null check, compilador sabe que não é null.",
    "example": "var name: String? = null; name.length // ERRO de compilação. name?.length // null (safe call). name?.length ?: 0 // 0 (elvis). name!!.length // NPE em runtime (evitar)."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Fácil",
    "question": "O que é string interpolation em Kotlin e como usar template expressions?",
    "options": [
      "Strings com $ para variáveis e ${} para expressões, embutidas diretamente na string",
      "Concatenação com +",
      "Método format() como Java",
      "Template literals com crase"
    ],
    "correctIndex": 0,
    "explanation": "Kotlin suporta string templates: $variavel insere o valor; ${expressao} avalia expressões complexas. Strings multilinha usam triple quotes (raw strings). Muito mais legível que concatenação manual ou String.format().",
    "example": "val name = 'Ana'; val age = 25; println(\"$name tem $age anos\") // 'Ana tem 25 anos'. println(\"${name.length} letras\") // '3 letras'. val json = \"\"\"{ \"name\": \"$name\" }\"\"\"; // raw string multilinha."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Fácil",
    "question": "O que são when expressions em Kotlin e como diferem de switch/case?",
    "options": [
      "Expressão que substitui switch com pattern matching, ranges, type checks e retorno de valor",
      "Loop condicional",
      "Bloco try-catch",
      "Idêntico ao switch de Java"
    ],
    "correctIndex": 0,
    "explanation": "when: substituto poderoso do switch. Pode ser expressão (retorna valor). Suporta: valores múltiplos (1, 2 ->), ranges (in 1..10), type checks (is String), condições arbitrárias. Com sealed classes, o compilador verifica exaustividade. Sem argumento: substitui if-else chains.",
    "example": "val desc = when(x) { 0 -> 'zero'; in 1..9 -> 'um dígito'; is String -> 'texto'; else -> 'outro' }. // Sem argumento: when { temp > 30 -> 'quente'; temp > 15 -> 'ameno'; else -> 'frio' }."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Fácil",
    "question": "O que são data classes em Kotlin e quais métodos são gerados automaticamente?",
    "options": [
      "Classes para guardar dados; geram automaticamente equals, hashCode, toString, copy e componentN (destructuring) baseados nas propriedades do construtor primário",
      "Classes imutáveis sem métodos gerados; apenas síntaxe compacta de declaração",
      "Geram somente toString() e hashCode(); os demais precisam ser implementados",
      "São exclusivas para modelos de banco de dados com Room; não úteis em geral"
    ],
    "correctIndex": 0,
    "explanation": "data class Person(val name: String, val age: Int). Gerado: equals() (compara por valor dos campos), hashCode() (consistente com equals), toString() 'Person(name=Ana, age=25)', copy(age=26) (cria cópia com campos alterados), component1() retorna name, component2() retorna age. Destructuring: val (nome, idade) = person.",
    "example": "val p1 = Person('Ana', 25); val p2 = Person('Ana', 25); p1 == p2 // true (valor, não referência). val p3 = p1.copy(age=26); // p3.name='Ana', p3.age=26. val (n, i) = p1; // destructuring. Kotlin sealed class + data class: ADT (algebraic data types) para when expressions exaustivas. Ideal para DTOs, eventos de domínio, estados de UI."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Médio",
    "question": "Em Kotlin, o que são 'coroutines' e como diferem de threads tradicionais?",
    "options": [
      "Coroutines são computações suspensíveis e leves que podem pausar e retomar sem bloquear threads",
      "Coroutines são threads com nomes diferentes",
      "Coroutines só funcionam em Android",
      "Coroutines são mais pesadas que threads"
    ],
    "correctIndex": 0,
    "explanation": "Coroutines em Kotlin são computações que podem ser suspensas em pontos de suspensão (suspend functions) e retomadas posteriormente, potencialmente em outra thread. São extremamente leves (~centenas de bytes vs ~1MB por thread), permitindo milhões de coroutines concorrentes.",
    "example": "suspend fun fetchData(): Data { val response = httpClient.get(url) // suspende sem bloquear thread return response.body() } launch { val data = fetchData() // coroutine leve, não thread }"
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Médio",
    "question": "Em Kotlin, o que são 'sealed classes' e quando usá-las?",
    "options": [
      "Hierarquias restritas onde todas as subclasses são conhecidas em compile-time, permitindo when exaustivo",
      "Classes que não podem ter métodos",
      "Classes criptografadas",
      "Sinônimo de abstract"
    ],
    "correctIndex": 0,
    "explanation": "Sealed classes limitam quais classes podem herdá-las (todas definidas no mesmo módulo). O compilador Kotlin sabe todas as subclasses, permitindo 'when' exaustivo sem cláusula 'else'. Ideal para modelar estados, resultados (Success/Error) e eventos.",
    "example": "sealed class Result { data class Success(val data: String) : Result(); data class Error(val msg: String) : Result(); } fun handle(r: Result) = when(r) { is Result.Success -> show(r.data); is Result.Error -> show(r.msg); } // sem else!"
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Médio",
    "question": "Em Kotlin, o que são 'extension functions' e como diferem de herança?",
    "options": [
      "Funções que adicionam métodos a classes existentes sem modificá-las ou herdá-las; resolvidas em compile-time",
      "Herança múltipla",
      "Funções globais",
      "Métodos protegidos"
    ],
    "correctIndex": 0,
    "explanation": "Extension functions adicionam 'virtualmente' métodos a qualquer classe (inclusive String, Int, classes de terceiros). São compiladas como funções estáticas com o receiver como primeiro parâmetro. Não são polimórficas (resolvidas em compile-time, não runtime).",
    "example": "fun String.isPalindrome(): Boolean = this == this.reversed(); 'aba'.isPalindrome() // true. fun Int.isEven(): Boolean = this % 2 == 0; 4.isEven() // true — parece método de Int."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Médio",
    "question": "O que são sealed classes em Kotlin e quando usá-las?",
    "options": [
      "Classes com subclasses restritas conhecidas em compile-time; permitem when exaustivo",
      "Classes que não podem ser instanciadas",
      "Classes criptografadas",
      "Classes globais"
    ],
    "correctIndex": 0,
    "explanation": "sealed class: hierarquia fechada — todas subclasses devem ser definidas no mesmo arquivo/módulo. O compilador garante when exaustivo (sem else). Ideal para modelar estados, resultados (Success/Error), e navegação. Similar a enum mas com dados diferentes por subtipo.",
    "example": "sealed class Result { data class Success(val data: User) : Result(); data class Error(val msg: String) : Result(); object Loading : Result() } when(result) { is Success -> show(result.data); is Error -> show(result.msg); Loading -> showSpinner() } // Sem else!"
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Médio",
    "question": "O que são higher-order functions e lambdas em Kotlin?",
    "options": [
      "Funções que recebem ou retornam outras funções; lambdas são funções anônimas curtas",
      "Funções mais rápidas",
      "Funções recursivas",
      "Funções globais"
    ],
    "correctIndex": 0,
    "explanation": "Kotlin trata funções como cidadãos de primeira classe. HOF: fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>. Lambda: { x: Int -> x * 2 }. Trailing lambda: list.filter { it > 5 }. Inline funções eliminam overhead de lambda object.",
    "example": "val numbers = listOf(1, 2, 3, 4, 5); val evens = numbers.filter { it % 2 == 0 }; // [2, 4]. val doubled = numbers.map { it * 2 }; // [2, 4, 6, 8, 10]. 'it' é o parâmetro implícito de lambdas com 1 param."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Médio",
    "question": "O que são scope functions (let, run, apply, also, with) em Kotlin?",
    "options": [
      "Funções que executam um bloco de código no contexto de um objeto, diferindo em como acessam o objeto e o que retornam",
      "Funções de escopo de variáveis",
      "Funções de criação de singleton",
      "Funções matemáticas"
    ],
    "correctIndex": 0,
    "explanation": "let: it + retorna resultado. run: this + retorna resultado. apply: this + retorna o próprio objeto. also: it + retorna o próprio objeto. with: não-extension, this + retorna resultado. let com ?. é idiomático para null checks. apply para configurar objetos.",
    "example": "user?.let { println(it.name) } // só executa se não for null. val dialog = Dialog().apply { title = 'Confirmar'; message = 'OK?'; show() } // retorna dialog configurado. list.also { println('size: ${it.size}') } // log sem alterar."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Médio",
    "question": "O que é o operador de delegação 'by' em Kotlin e quais padrões habilita?",
    "options": [
      "Delega implementação de interface ou propriedade para outro objeto, implementando delegation pattern nativamente",
      "Operador de divisão",
      "Criação de alias",
      "Import de módulos"
    ],
    "correctIndex": 0,
    "explanation": "'by' delega: 1) implementação de interface (class Wrapper(val inner: List<Int>) : List<Int> by inner). 2) propriedades (by lazy, by Delegates.observable). Property delegates: lazy (inicialização lazy), observable (reage a mudanças), map (propriedades de mapa).",
    "example": "val name: String by lazy { fetchName() } // inicializa só no primeiro acesso. var age: Int by Delegates.observable(0) { _, old, new -> println('$old -> $new') }. class CountingSet<T>(val inner: MutableSet<T> = mutableSetOf()) : MutableSet<T> by inner."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Médio",
    "question": "Como funcionam as coroutines em Kotlin e qual a diferença entre launch, async e runBlocking?",
    "options": [
      "Coroutines: concorrência leve; launch: fire-and-forget (retorna Job); async: retorna Deferred<T> para resultado futuro com await(); runBlocking: bloqueia thread atual para testes ou main()",
      "launch e async são idênticos; runBlocking cria nova thread OS",
      "Coroutines Kotlin são alias de threads; suspend apenas documenta que a função é lenta",
      "async é fire-and-forget; launch retorna Deferred<T>; são trocados na documentação"
    ],
    "correctIndex": 0,
    "explanation": "Coroutine builders precisam de CoroutineScope. launch { ... } retorna Job (cancel, join). async { ... } retorna Deferred<T>; val r = async { calc() }; r.await() obtém resultado (suspende até pronto). Dispatchers: Main (UI), IO (I/O-bound), Default (CPU-bound). Structured concurrency: child coroutines são canceladas quando scope pai é cancelado. suspend fun: pode suspender sem bloquear thread.",
    "example": "val job = launch(Dispatchers.IO) { fetchData() }. val deferred = async { calcularTotal() }; val total = deferred.await(). coroutineScope { val a = async { fetch('A') }; val b = async { fetch('B') }; a.await() + b.await() } // paralelo. viewModelScope.launch {}: lifecycle-aware. withContext(Dispatchers.IO) { ... } dentro de suspend fun para troca de dispatcher."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Difícil",
    "question": "Em Kotlin, como os 'inline functions' com 'reified type parameters' superam a limitação de type erasure da JVM?",
    "options": [
      "O compilador insere o corpo da função no call site, preservando o tipo real como parâmetro em vez de apagá-lo",
      "Usam reflection em runtime que é mais lento",
      "Criam uma classe anônima para cada tipo",
      "Não existem em Kotlin, apenas em Scala"
    ],
    "correctIndex": 0,
    "explanation": "Funções inline têm seu corpo copiado para o call site em tempo de compilação. Com 'reified', o parâmetro de tipo é preservado como tipo real no código inlined, permitindo operações como 'is T', 'T::class' e 'Gson().fromJson<T>()' que seriam impossíveis com type erasure normal da JVM.",
    "example": "inline fun <reified T> parse(json: String): T = Gson().fromJson(json, T::class.java) // T::class funciona porque é reified. val user = parse<User>(jsonStr) // compila para Gson().fromJson(jsonStr, User.class)"
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Difícil",
    "question": "Em Kotlin, o que são 'Kotlin Flows' e como diferem de Sequences?",
    "options": [
      "Flows são streams assíncronas frias baseadas em coroutines; Sequences são lazy e síncronas",
      "São idênticos",
      "Sequences são assíncronas",
      "Flows são síncronos"
    ],
    "correctIndex": 0,
    "explanation": "Sequences são iteradores lazy síncronos (processam item a item sem criar coleções intermediárias). Flows são o equivalente assíncrono: cold streams que emitem valores ao longo do tempo usando coroutines. Suportam operadores como map, filter, collect, e backpressure.",
    "example": "fun temperatures(): Flow<Double> = flow { while(true) { emit(readSensor()); delay(1000); } } // Emite temperatura a cada segundo. lifecycleScope.launch { temperatures().collect { temp -> updateUI(temp) } }"
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Difícil",
    "question": "Em Kotlin, como o 'structured concurrency' das coroutines garante que não haja vazamento de resources?",
    "options": [
      "Todo coroutine filho está vinculado a um escopo pai; se o pai for cancelado, todos os filhos são cancelados automaticamente",
      "Coroutines nunca podem ser canceladas",
      "Usam garbage collector",
      "Funcionam como threads daemon"
    ],
    "correctIndex": 0,
    "explanation": "Structured concurrency: coroutines são lançadas em um CoroutineScope (viewModelScope, lifecycleScope). O escopo pai NÃO completa até todos os filhos completarem. Se o pai for cancelado (tela fechada), todos os filhos são cancelados. Se um filho falhar, o pai propaga a exceção (ou usa SupervisorJob).",
    "example": "viewModelScope.launch { val a = async { fetchUserProfile() }; val b = async { fetchUserOrders() }; updateUI(a.await(), b.await()); } // Se viewModel.onCleared() → scope cancela → ambos async cancelam → zero leak."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Difícil",
    "question": "O que é o Kotlin Multiplatform (KMP) e como funciona?",
    "options": [
      "Permite compartilhar lógica de negócio entre Android, iOS, web e desktop com código Kotlin comum",
      "Emulador de Android",
      "Framework de UI multiplataforma",
      "Compilador para Java"
    ],
    "correctIndex": 0,
    "explanation": "KMP: código em commonMain é compilado para cada target (JVM, iOS/Native, JS, WASM). expect/actual: declara API em common, implementa por plataforma. Compose Multiplatform: UI compartilhada. Usado para: lógica de negócio, networking, serialization compartilhados.",
    "example": "// commonMain: expect fun platformName(): String. // androidMain: actual fun platformName() = 'Android'. // iosMain: actual fun platformName() = 'iOS'. // Código de negócio em common usa platformName() transparentemente."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Difícil",
    "question": "O que são inline functions em Kotlin e por que são importantes para performance?",
    "options": [
      "Funções cujo código é copiado no call site em compile-time, eliminando overhead de alocação de lambda object",
      "Funções mais curtas",
      "Funções que rodam em linha de comando",
      "Otimização de runtime"
    ],
    "correctIndex": 0,
    "explanation": "Sem inline: cada lambda cria um objeto Function + closure (alocação). Com inline: compilador copia o corpo da função e do lambda no call site. Zero alocação. Essencial para funções HOF usadas em hot paths. Kotlin stdlib: filter, map, let, apply são inline.",
    "example": "inline fun <T> measure(block: () -> T): T { val start = System.nanoTime(); val result = block(); println(System.nanoTime() - start); return result; } // block() é inlined: zero alocação de Function object."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Difícil",
    "question": "O que são type aliases em Kotlin e quando são úteis?",
    "options": [
      "Nomes alternativos para tipos existentes, simplificando tipos genéricos complexos e function types",
      "Novos tipos criados em runtime",
      "Cast entre tipos incompatíveis",
      "Apelidos de variáveis"
    ],
    "correctIndex": 0,
    "explanation": "typealias cria sinônimo para tipo existente. Não cria tipo novo (intercompatível). Útil para: tipos genéricos longos (typealias UserMap = Map<String, List<User>>), function types (typealias Predicate<T> = (T) -> Boolean), e classes internas (typealias NodeSet = Set<Network.Node>).",
    "example": "typealias StringMap = Map<String, String>; typealias Predicate<T> = (T) -> Boolean; fun filter(list: List<Int>, pred: Predicate<Int>): List<Int> = list.filter(pred); // Mais legível que (Int) -> Boolean."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Difícil",
    "question": "O que são contracts em Kotlin e como ajudam o compilador em smart casts?",
    "options": [
      "Declarações que informam ao compilador efeitos de uma função, habilitando smart casts após custom checks",
      "Contratos legais de API",
      "Validações em runtime",
      "Testes automatizados"
    ],
    "correctIndex": 0,
    "explanation": "Contracts (experimental): função declara ao compilador que se retornar true, o argumento é de determinado tipo. Permite smart cast após funções custom (isNullOrEmpty, require, check). callsInPlace garante que lambda executa exatamente uma vez (permite val em blocos).",
    "example": "fun String?.isValid(): Boolean { contract { returns(true) implies (this@isValid != null) }; return this != null && isNotEmpty() } val s: String? = ...; if (s.isValid()) { s.length // smart cast! compilador sabe que não é null }."
  },
  {
    "id": "linguagens-de-programacao__Kotlin__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "Kotlin",
    "difficulty": "Difícil",
    "question": "O que é Kotlin Flow e como difere de LiveData e RxJava para streams reativos no Android?",
    "options": [
      "Flow é stream frio (lazy, só executa com coletor), integrado com coroutines, cancelamento automático, backpressure por suspensão; LiveData: lifecycle-aware mas limitado; RxJava: poderoso mas complexo sem coroutines",
      "Flow é hot por padrão; LiveData é cold; ambos requerem Disposable para cancelamento",
      "Flow substitui todas as coroutines; launch e async tornam-se obsoletos",
      "LiveData suporta backpressure nativo via subscription; Flow não tem backpressure"
    ],
    "correctIndex": 0,
    "explanation": "Cold Flow: flow { emit(1); delay(100); emit(2) } — execução só ao coletar. SharedFlow: hot, múltiplos coletores. StateFlow: hot, tem valor atual (substitui LiveData sem lifecycle coupling). Operators: map, filter, debounce, flatMapLatest (cancela upstream ao novo evento). collectAsState() em Compose. Cancelamento: flowCollect cancela ao sair do scope. Backpressure: collector suspende emitter implicitamente.",
    "example": "Search autocomplete: searchFlow.debounce(300).filter { it.length > 2 }.flatMapLatest { query -> flow { emit(api.search(query)) } }.collect { updateUI(it) }. flatMapLatest cancela requisição anterior ao digitar novo caractere. StateFlow para UI state: val uiState = MutableStateFlow<UiState>(Loading). viewModel.uiState.collectAsStateWithLifecycle() no Compose. Room retorna Flow<List<T>> diretamente."
  },
  {
    "id": "linguagens-de-programacao__PHP__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Fácil",
    "question": "Em PHP, como se declara uma variável e qual é o prefixo obrigatório?",
    "options": [
      "Com o símbolo $ antes do nome: $variavel",
      "Com # antes do nome: #variavel",
      "Com @ antes do nome: @variavel",
      "Sem prefixo, como em JavaScript"
    ],
    "correctIndex": 0,
    "explanation": "Em PHP, todas as variáveis são prefixadas com o símbolo $. Não é necessário declarar o tipo explicitamente (tipagem dinâmica). A variável é criada na primeira atribuição e seu tipo é determinado pelo valor atribuído.",
    "example": "$nome = 'Ana'; $idade = 25; $ativo = true; echo $nome; // Ana"
  },
  {
    "id": "linguagens-de-programacao__PHP__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Fácil",
    "question": "Em PHP, o que são arrays associativos e como diferem de arrays indexados?",
    "options": [
      "Arrays associativos usam chaves nomeadas (strings); indexados usam índices numéricos",
      "São idênticos",
      "Associativos são mais lentos",
      "Indexados usam strings"
    ],
    "correctIndex": 0,
    "explanation": "Arrays indexados usam índices numéricos automáticos ($arr = [1, 2, 3]; $arr[0]). Arrays associativos usam chaves string definidas pelo programador ($user = ['name' => 'Ana', 'age' => 25]; $user['name']). Internamente, todos os arrays PHP são hashmaps ordenados.",
    "example": "$frutas = ['maçã', 'banana']; echo $frutas[0]; // maçã (indexado). $user = ['nome' => 'Ana', 'idade' => 25]; echo $user['nome']; // Ana (associativo)."
  },
  {
    "id": "linguagens-de-programacao__PHP__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Fácil",
    "question": "Em PHP, qual é a diferença entre 'echo' e 'print'?",
    "options": [
      "echo aceita múltiplos argumentos e não retorna valor; print aceita 1 argumento e retorna 1",
      "São idênticos",
      "print é mais rápido",
      "echo retorna string"
    ],
    "correctIndex": 0,
    "explanation": "echo é um language construct que aceita múltiplos parâmetros separados por vírgula e não retorna valor. print também é language construct, aceita apenas 1 argumento e sempre retorna 1 (pode ser usado em expressões). echo é marginalmente mais rápido.",
    "example": "echo 'Olá', ' ', 'mundo'; // vários args. $x = print 'ok'; // $x = 1 (retorna 1). echo 'ok'; // não retorna nada."
  },
  {
    "id": "linguagens-de-programacao__PHP__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Fácil",
    "question": "O que são arrays em PHP e como diferem de arrays em outras linguagens?",
    "options": [
      "Arrays PHP são na verdade mapas ordenados que funcionam como array, lista, hash table, pilha e fila",
      "São idênticos a arrays C",
      "Só aceitam números como índice",
      "Têm tamanho fixo"
    ],
    "correctIndex": 0,
    "explanation": "Arrays PHP: estrutura versátil que combina array indexado e array associativo (hash map). Chaves: int ou string. Valores: qualquer tipo. Funções úteis: array_map, array_filter, array_merge, in_array, array_push. Sintaxe curta: $a = [1, 2, 'key' => 'val'].",
    "example": "$frutas = ['maçã', 'banana']; $user = ['name' => 'Ana', 'age' => 25]; $frutas[] = 'laranja'; // push. echo $user['name']; // 'Ana'. foreach ($user as $key => $val) { echo \"$key: $val\"; }"
  },
  {
    "id": "linguagens-de-programacao__PHP__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Fácil",
    "question": "O que são as diferenyas entre require, include, require_once e include_once em PHP?",
    "options": [
      "require causa fatal error se falhar; include causa warning; _once garante inclusão única",
      "São todos idênticos",
      "require é para classes e include para funções",
      "_once é mais lento"
    ],
    "correctIndex": 0,
    "explanation": "require: inclui arquivo, fatal error se não encontrar (para execução). include: warning se não encontrar (continua). require_once/include_once: garante que o arquivo só é incluído uma vez (evita redeclaração). Na prática, autoload do Composer substituiu todos.",
    "example": "require 'config.php'; // fatal error se não existir. include 'optional.php'; // warning, continua. require_once 'Database.php'; require_once 'Database.php'; // segundo call é ignorado."
  },
  {
    "id": "linguagens-de-programacao__PHP__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Fácil",
    "question": "O que são os tipos de dados em PHP e como verificar o tipo de uma variável?",
    "options": [
      "PHP tem tipos escalar (int, float, string, bool), compostos (array, object) e especiais (null, resource); gettype() e is_* verificam",
      "PHP só tem strings",
      "Todos são objects",
      "Não existe verificação de tipo"
    ],
    "correctIndex": 0,
    "explanation": "PHP é dinamicamente tipado. Escalares: int, float, string, bool. Compostos: array, object, callable, iterable. Especiais: null, resource. Verificação: gettype($x), is_int($x), is_array($x), instanceof para objetos. PHP 7+: type declarations para parâmetros e retorno.",
    "example": "$x = 42; gettype($x); // 'integer'. is_int($x); // true. is_string($x); // false. $arr = [1,2]; is_array($arr); // true. function add(int $a, int $b): int { return $a + $b; } // tipo declarado (PHP 7+)."
  },
  {
    "id": "linguagens-de-programacao__PHP__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre == e === em PHP e por que importa?",
    "options": [
      "== compara com coercção de tipo (loose); === compara valor E tipo (strict), sem conversão",
      "São idênticos",
      "=== é mais lento",
      "== é para objetos e === para strings"
    ],
    "correctIndex": 0,
    "explanation": "== (loose): converte tipos antes de comparar (0 == 'foo' era true antes do PHP 8). === (strict): compara valor e tipo sem coercção (0 === '' é false). Best practice: sempre usar === para evitar bugs de coercção. in_array($val, $arr, true) usa strict.",
    "example": "0 == 'foo'; // false (PHP 8+), era true em PHP 7. '' == false; // true (ambos falsy). '' === false; // false (tipos diferentes). null == false; // true. null === false; // false."
  },
  {
    "id": "linguagens-de-programacao__PHP__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Fácil",
    "question": "O que são arrays associativos em PHP e como diferem de arrays indexados?",
    "options": [
      "Arrays associativos usam chaves string definidas pelo usuário como índice; arrays indexados usam inteiros automáticos; PHP unifica os dois no mesmo tipo array",
      "Arrays associativos são objetos stdClass; arrays indexados são o tipo array nativo",
      "PHP distingue array e hashmap como tipos distintos na engine",
      "Arrays associativos só aceitam chaves string; não pode misturar com índices numéricos"
    ],
    "correctIndex": 0,
    "explanation": "PHP array é ordenado, misto: $a = ['nome' => 'Ana', 'idade' => 25]; $a['nome'] retorna 'Ana'. Indexado: $b = [10, 20, 30]; $b[0] = 10. Misturado: ['a', 'chave' => 'valor', 1]. array_keys(), array_values(), foreach($arr as $k => $v). list() / [] para destructuring. array_merge(), array_combine(), array_flip(). Arrays PHP são sempre HashMap+OrderedMap internamente.",
    "example": "$config = ['db_host' => 'localhost', 'db_port' => 3306, 'debug' => true]; echo $config['db_host']; foreach($config as $key => $val) echo '$key=$val\n'. in_array('debug', array_keys($config)): verifica existência de chave. array_key_exists() mais preciso (distingue null). compact() e extract() para trabalhar com escopo."
  },
  {
    "id": "linguagens-de-programacao__PHP__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Médio",
    "question": "Em PHP, qual é a diferença entre 'include' e 'require' ao carregar arquivos?",
    "options": [
      "require gera erro fatal (E_COMPILE_ERROR) se o arquivo não existir; include gera apenas warning e continua a execução",
      "São idênticos",
      "include é mais rápido",
      "require carrega o arquivo duas vezes"
    ],
    "correctIndex": 0,
    "explanation": "require para a execução com erro fatal se o arquivo não for encontrado, sendo indicado para dependências essenciais. include gera um warning (E_WARNING) e a execução continua, adequado para conteúdo opcional. Variantes _once evitam inclusões duplicadas.",
    "example": "require 'config.php'; // Fatal error se não existir — sem config, o app não funciona. include 'sidebar.php'; // Warning se não existir — página renderiza sem sidebar."
  },
  {
    "id": "linguagens-de-programacao__PHP__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Médio",
    "question": "Em PHP, o que são namespaces e por que são importantes?",
    "options": [
      "Organizam classes/funções em espaços nomeados para evitar colisões de nomes entre bibliotecas",
      "São pastas no servidor",
      "São tipos de variável",
      "São comments especiais"
    ],
    "correctIndex": 0,
    "explanation": "Namespaces (PHP 5.3+) permitem organizar código em hierarquias lógicas, evitando conflitos de nomes quando múltiplas bibliotecas definem classes com mesmo nome. Seguem a convenção PSR-4 para autoloading, onde namespace mapeia para diretório.",
    "example": "namespace App\\Models; class User { } // App\\Models\\User. namespace App\\Controllers; use App\\Models\\User; class UserController { function show() { $u = new User(); } } // Sem conflito com outra lib que tenha classe User."
  },
  {
    "id": "linguagens-de-programacao__PHP__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Médio",
    "question": "Em PHP, o que é o Composer e qual seu papel no gerenciamento de dependências?",
    "options": [
      "Gerenciador de dependências que instala pacotes, resolve versões e gera autoloader PSR-4",
      "Editor de código",
      "Servidor web",
      "Framework PHP"
    ],
    "correctIndex": 0,
    "explanation": "Composer é o gerenciador de dependências padrão do PHP. Usa composer.json para declarar dependências, resolve conflitos de versão, baixa pacotes do Packagist (repositório central) e gera autoloader PSR-4. composer.lock garante versões reproduzíveis.",
    "example": "composer require guzzlehttp/guzzle // Instala Guzzle HTTP. composer install // Instala tudo do composer.lock. require 'vendor/autoload.php'; // Autoload gerado pelo Composer, carrega todas as classes."
  },
  {
    "id": "linguagens-de-programacao__PHP__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Médio",
    "question": "O que são traits em PHP e qual problema resolvem?",
    "options": [
      "Mecanismo de reutilização de código em classes sem herança múltipla; similar a mixins",
      "Tipo de interface",
      "Classes abstratas",
      "Funções globais"
    ],
    "correctIndex": 0,
    "explanation": "Traits: grupos de métodos reutilizáveis que podem ser inclusos em múltiplas classes via 'use'. PHP não suporta herança múltipla, então traits resolvem isso. Uma classe pode usar múltiplos traits. Conflitos de métodos são resolvidos com insteadof/as.",
    "example": "trait Timestampable { public function getCreatedAt() { } } trait SoftDeletable { public function softDelete() { } } class User { use Timestampable, SoftDeletable; } // User tem ambos os métodos."
  },
  {
    "id": "linguagens-de-programacao__PHP__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Médio",
    "question": "O que é o padrão MVC no contexto de frameworks PHP como Laravel?",
    "options": [
      "Model (dados/lógica), View (apresentação), Controller (intermedia requisições) — separação de concerns",
      "Padrão de banco de dados",
      "Tipo de API",
      "Framework de testes"
    ],
    "correctIndex": 0,
    "explanation": "MVC em Laravel: Model (Eloquent ORM — mapeamento de tabelas para classes). View (Blade templates — HTML + diretivas). Controller (recebe request, chama model, retorna view/JSON). Routes mapeiam URLs para controller methods.",
    "example": "Route::get('/users', [UserController::class, 'index']); class UserController { function index() { return view('users.index', ['users' => User::all()]); } } // Route → Controller → Model → View."
  },
  {
    "id": "linguagens-de-programacao__PHP__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Médio",
    "question": "O que são match expressions em PHP 8.0 e como diferem de switch?",
    "options": [
      "Expressão que retorna valor, usa comparação strict (===) e não tem fall-through; switch usa loose (==)",
      "São idênticos a switch",
      "match só funciona com strings",
      "match é mais lento"
    ],
    "correctIndex": 0,
    "explanation": "match (PHP 8.0): expressão (retorna valor), comparação strict (===), sem fall-through (sem break necessário), deve ser exaustivo (UnhandledMatchError se nenhum caso casar). Mais seguro e conciso que switch.",
    "example": "$result = match($status) { 'active' => 'Ativo', 'inactive', 'suspended' => 'Inativo', default => 'Desconhecido', }; // Retorna valor, sem break, strict comparison. switch usa == e precisa de break em cada case."
  },
  {
    "id": "linguagens-de-programacao__PHP__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Médio",
    "question": "O que são union types em PHP 8.0 e por que são importantes?",
    "options": [
      "Permitem declarar que parâmetro/retorno aceita múltiplos tipos: int|string, aumentando a type safety",
      "Tipos de banco de dados",
      "União de arrays",
      "Herança múltipla"
    ],
    "correctIndex": 0,
    "explanation": "Union types (PHP 8.0): function foo(int|string $id): User|null {}. Antes: @param int|string no PHPDoc (sem enforce). Agora o engine valida em runtime. ?Type é atalho para Type|null. PHP 8.1+: intersection types (A&B). PHP 8.2: DNF types ((A&B)|C).",
    "example": "function find(int|string $id): User|null { return match(true) { is_int($id) => User::find($id), is_string($id) => User::findBySlug($id), }; } // Engine lança TypeError se receber bool, array, etc."
  },
  {
    "id": "linguagens-de-programacao__PHP__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Médio",
    "question": "O que é o Composer em PHP e como o autoloading PSR-4 funciona?",
    "options": [
      "Composer é o gerenciador de dependências PHP; PSR-4 mapeia namespace para diretório automaticamente (App\\Models\\User → src/Models/User.php) via autoloader gerado no vendor/",
      "Composer é um framework PHP; PSR-4 é bundle de segurança",
      "PSR-4 exige que todas as classes tenham o mesmo namespace independente do diretório",
      "Autoloading só funciona com classes estáticas; instâncias requerem require explícito"
    ],
    "correctIndex": 0,
    "explanation": "composer.json: {\"require\": {\"monolog/monolog\": \"^3.0\"}, \"autoload\": {\"psr-4\": {\"App\\\\\": \"src/\"}}}. composer install: baixa dependências e gera vendor/autoload.php. PSR-4: App\\Controllers\\UserController mapeia para src/Controllers/UserController.php. Lazy loading: como não carregada até ser usada. composer update (atualiza semver), composer require, composer dump-autoload (regenera map).",
    "example": "require 'vendor/autoload.php'; use App\\Models\\User; $u = new User(); // autoloader inclui src/Models/User.php automaticamente. spl_autoload_register(): mecanismo interno que Composer usa. Sem Composer: require_once em cada arquivo. Semantic versioning: ^3.0 aceita 3.x.x mas não 4.0. composer.lock: versões exatas para reprodução do ambiente."
  },
  {
    "id": "linguagens-de-programacao__PHP__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Difícil",
    "question": "Em PHP 8.1+, o que são Fibers e como elas habilitam concorrência cooperativa?",
    "options": [
      "Fibers são threads leves que podem pausar e retomar execução em pontos arbitrários do código, sem callbacks",
      "Fibers são threads do sistema operacional",
      "Fibers são específicas para banco de dados",
      "Fibers substituem completamente o modelo request-response"
    ],
    "correctIndex": 0,
    "explanation": "Fibers em PHP 8.1 permitem criar coroutines: blocos de código que podem ser pausados (Fiber::suspend()) e retomados (->resume()) em qualquer ponto da stack, sem reestruturar o código com callbacks ou generators. São a base para I/O assíncrono em frameworks como Amp e ReactPHP.",
    "example": "$fiber = new Fiber(function(): void { $value = Fiber::suspend('paused'); echo $value; }); $result = $fiber->start(); // 'paused'. $fiber->resume('hello'); // imprime 'hello'."
  },
  {
    "id": "linguagens-de-programacao__PHP__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Difícil",
    "question": "Em PHP, o que são 'Enums' (PHP 8.1+) e quais tipos existem?",
    "options": [
      "Tipos que definem conjunto fixo de valores possíveis; podem ser 'Pure' (sem valor) ou 'Backed' (com valor string/int)",
      "Arrays constantes",
      "Classes abstratas",
      "Variáveis globais nomeadas"
    ],
    "correctIndex": 0,
    "explanation": "Enums PHP 8.1 definem um tipo com conjunto fechado de valores. Pure Enums não têm valor interno. Backed Enums têm um valor string ou int associado (para serialização/DB). Enums podem implementar interfaces, ter métodos e constantes. Não podem ser instanciados com new.",
    "example": "enum Status: string { case Active = 'active'; case Inactive = 'inactive'; } $s = Status::Active; $s->value; // 'active'. Status::from('active'); // Status::Active. Status::tryFrom('x'); // null."
  },
  {
    "id": "linguagens-de-programacao__PHP__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Difícil",
    "question": "Em PHP, o que são 'Attributes' (PHP 8.0+) e como substituem DocBlock annotations?",
    "options": [
      "Metadados estruturados nativos da linguagem que podem ser lidos via Reflection em runtime",
      "Comentários de documentação",
      "Variáveis de ambiente",
      "Configurações do php.ini"
    ],
    "correctIndex": 0,
    "explanation": "Attributes (PHP 8.0) são metadados nativos definidos com #[...] que substituem @annotations em DocBlocks. São classes reais, type-safe, e podem ser lidos via ReflectionAttribute em runtime. Frameworks como Symfony e Doctrine usam attributes para rotas, validação e mapeamento ORM.",
    "example": "#[Route('/users', methods: ['GET'])] #[IsGranted('ROLE_ADMIN')] public function list(): Response { } // Attributes substituem @Route e @IsGranted de DocBlocks. Lidos via (new ReflectionMethod(...))->getAttributes()."
  },
  {
    "id": "linguagens-de-programacao__PHP__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Difícil",
    "question": "O que são Fibers em PHP 8.1 e como habilitam concorrência cooperativa?",
    "options": [
      "Threads leves cooperativas que podem suspender e retomar execução, base para I/O assíncrono",
      "Threads do sistema operacional",
      "Tipo de array",
      "Conexeões de rede"
    ],
    "correctIndex": 0,
    "explanation": "Fibers (PHP 8.1): execução que pode ser suspensa (Fiber::suspend()) e retomada (fiber->resume()). Cooperativas: a fiber decide quando ceder controle. Base para frameworks assíncronos (ReactPHP, Amp, Swoole). Não são paralelas — são concurrent no mesmo thread.",
    "example": "$fiber = new Fiber(function() { $value = Fiber::suspend('pausado'); echo \"Recebeu: $value\"; }); $result = $fiber->start(); // 'pausado'. $fiber->resume('dados'); // 'Recebeu: dados'. Frameworks usam isso para async I/O."
  },
  {
    "id": "linguagens-de-programacao__PHP__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Difícil",
    "question": "O que é o Eloquent ORM no Laravel e como funciona o Active Record pattern?",
    "options": [
      "Cada model mapeia uma tabela do banco; instância do model representa uma linha; métodos fazem queries",
      "Linguagem de query",
      "Banco de dados NoSQL",
      "Framework de testes"
    ],
    "correctIndex": 0,
    "explanation": "Eloquent: Active Record ORM do Laravel. Cada classe Model mapeia uma tabela. Métodos estáticos fazem queries (User::where()->get()). Relações: hasMany, belongsTo, belongsToMany. Mass assignment protection, eager loading (with()), scopes, events.",
    "example": "class User extends Model { public function posts() { return $this->hasMany(Post::class); } } User::where('active', true)->with('posts')->get(); // Eager loading: 2 queries em vez de N+1."
  },
  {
    "id": "linguagens-de-programacao__PHP__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Difícil",
    "question": "O que são readonly properties e readonly classes em PHP 8.1/8.2?",
    "options": [
      "Propriedades que só podem ser atribuídas uma vez (no construtor); readonly class torna todas as propriedades readonly",
      "Propriedades estáticas",
      "Propriedades privadas",
      "Propriedades computadas"
    ],
    "correctIndex": 0,
    "explanation": "readonly (PHP 8.1): propriedade só pode ser escrita uma vez, na inicialização (construtor). Depois é imutável. readonly class (PHP 8.2): todas as propriedades são readonly. Promove value objects e DTOs imutáveis. Não pode ter propriedades sem tipo.",
    "example": "readonly class User { public function __construct(public string $name, public int $age) {} } $u = new User('Ana', 25); $u->name; // 'Ana'. $u->name = 'Bob'; // Error: Cannot modify readonly property."
  },
  {
    "id": "linguagens-de-programacao__PHP__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Difícil",
    "question": "O que é o PHP-FPM e como processa requests web diferente do mod_php?",
    "options": [
      "FastCGI Process Manager: pool de workers PHP persistentes que recebem requests do web server, mais eficiente que mod_php",
      "Framework PHP",
      "Compilador JIT",
      "Gerenciador de pacotes"
    ],
    "correctIndex": 0,
    "explanation": "PHP-FPM: gerencia pool de processos PHP worker. Nginx/Apache passa request via FastCGI. Vantagens sobre mod_php (embutido no Apache): melhor gerenciamento de memória, pools por site, configuração independente, suporta Nginx. Workers: static (fixo), dynamic (sob demanda), ondemand (cria por request).",
    "example": "Nginx config: location ~ \\.php$ { fastcgi_pass 127.0.0.1:9000; } // PHP-FPM escuta na porta 9000. Pool config: pm = dynamic; pm.max_children = 50; pm.start_servers = 5; // 5 workers iniciais, até 50 sob demanda."
  },
  {
    "id": "linguagens-de-programacao__PHP__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "PHP",
    "difficulty": "Difícil",
    "question": "Como PHP 8.x Fibers implementam concorrência cooperativa e como diferem de goroutines e coroutines?",
    "options": [
      "Fibers: pausam/retomam execução manualmente com Fiber::suspend/resume; concorrência cooperativa single-thread; base para async em PHP (ReactPHP, Revolt); goroutines têm scheduling automático",
      "Fibers criam threads reais no OS; goroutines são apenas corotinas de usuário",
      "Fibers e coroutines são idênticos; goroutines têm scheduling preemptivo como threads OS",
      "PHP Fibers são descontinuadas em PHP 8.2; async/await nativo foi introduzido"
    ],
    "correctIndex": 0,
    "explanation": "Fiber (PHP 8.1): $fiber = new Fiber(function() { $val = Fiber::suspend('primeiro'); echo 'segundo: ' . $val; }); $r1 = $fiber->start(); // 'primeiro'. $fiber->resume('hello'); // 'segundo: hello'. Stack própria. Não multithreading. Event loop (Revolt): Fiber::suspend cede controle ao loop que processa I/O (sockets, timers) e retoma fiber quando pronto. ampersand PHP diferente de Go go-routine scheduler.",
    "example": "ReactPHP + Fibers: $response = Fiber::suspend($deferredRequest); event loop processa outros reqs enquanto aguarda I/O. Revolt event loop (base de Amp v3): readStream/writeStream, addTimer. $conn->query('SELECT...') retorna Promise que Fiber aguarda com suspend. Comparação: Go goroutines scheduler M:N automático; PHP Fibers = manual + event loop externo; ambas resolvêm I/O-bound sem threads."
  },
  {
    "id": "linguagens-de-programacao__Python__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Fácil",
    "question": "Em Python, qual estrutura de dados é uma coleção ordenada e mutável que permite elementos duplicados?",
    "options": [
      "Lista (list)",
      "Conjunto (set)",
      "Tupla (tuple)",
      "Dicionário (dict)"
    ],
    "correctIndex": 0,
    "explanation": "Listas em Python são coleções ordenadas e mutáveis definidas com colchetes []. Permitem elementos duplicados, acesso por índice, e operações como append(), insert(), pop() e slicing. São implementadas como arrays dinâmicos.",
    "example": "frutas = ['maçã', 'banana', 'maçã'] // duplicatas OK. frutas.append('uva') // ['maçã', 'banana', 'maçã', 'uva']. frutas[1] // 'banana'."
  },
  {
    "id": "linguagens-de-programacao__Python__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Fácil",
    "question": "Em Python, o que é um dicionário (dict) e como acessar seus valores?",
    "options": [
      "Coleção de pares chave-valor onde chaves são únicas; acesso via dict[key] ou dict.get(key)",
      "Lista ordenada",
      "Array de índices",
      "Objeto imutável"
    ],
    "correctIndex": 0,
    "explanation": "Dicionários (dict) armazenam pares chave-valor com chaves hasháveis e únicas. Acesso O(1) por chave. dict[key] lança KeyError se não existir; dict.get(key, default) retorna default. Desde Python 3.7, mantêm ordem de inserção.",
    "example": "user = {'name': 'Ana', 'age': 25}; user['name'] // 'Ana'. user.get('email', 'N/A') // 'N/A' (default). user['email'] = 'ana@x.com' // adiciona. 'name' in user // True."
  },
  {
    "id": "linguagens-de-programacao__Python__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Fácil",
    "question": "Em Python, o que é uma list comprehension e como usá-la?",
    "options": [
      "Sintaxe concisa para criar listas: [expressão for item in iterável if condição]",
      "Função de ordenação",
      "Método de classe",
      "Import condicional"
    ],
    "correctIndex": 0,
    "explanation": "List comprehensions criam listas de forma concisa em uma linha. Sintaxe: [expr for var in iterable if condition]. São mais legíveis e geralmente mais rápidas que loops equivalentes. Também existem dict, set e generator comprehensions.",
    "example": "pares = [x for x in range(10) if x % 2 == 0] // [0, 2, 4, 6, 8]. quadrados = {x: x**2 for x in range(5)} // {0:0, 1:1, 2:4, 3:9, 4:16} (dict comprehension)."
  },
  {
    "id": "linguagens-de-programacao__Python__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Fácil",
    "question": "O que são decorators em Python e para que servem?",
    "options": [
      "Funções que modificam o comportamento de outras funções/classes usando a sintaxe @decorator",
      "Comentários especiais",
      "Estilos visuais",
      "Tipo de classe"
    ],
    "correctIndex": 0,
    "explanation": "Decorator: função que recebe uma função e retorna uma função modificada. @decorator é syntax sugar para func = decorator(func). Usos: logging, caching (@lru_cache), autentificação (@login_required), timing, retry. Podem ser empilhados e aceitar argumentos.",
    "example": "from functools import wraps; def timer(f): @wraps(f) def wrapper(*args): start = time.time(); result = f(*args); print(f'{f.__name__}: {time.time()-start:.2f}s'); return result; return wrapper. @timer def slow(): time.sleep(1). slow() // 'slow: 1.00s'."
  },
  {
    "id": "linguagens-de-programacao__Python__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre lista, tupla e set em Python?",
    "options": [
      "Lista: mutável, ordenada; Tupla: imutável, ordenada; Set: mutável, sem duplicatas, não ordenado",
      "São todos idênticos",
      "Tupla é mutável",
      "Set é ordenado"
    ],
    "correctIndex": 0,
    "explanation": "List [1,2,3]: mutável, indexada, duplicatas OK. Tuple (1,2,3): imutável, indexada, hashable (pode ser chave de dict). Set {1,2,3}: mutável, sem duplicatas, sem ordem, operações de conjunto (união, interseção). Frozenset: set imutável.",
    "example": "l = [1,2,2]; l.append(3) // [1,2,2,3]. t = (1,2); t[0] = 3 // TypeError. s = {1,2,2,3}; s // {1,2,3}. s & {2,3,4} // {2,3} (interseção)."
  },
  {
    "id": "linguagens-de-programacao__Python__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Fácil",
    "question": "O que são f-strings em Python e como fazer interpolação de variáveis?",
    "options": [
      "Strings com prefixo f que permitem inserir expressões Python entre chaves {}: f'{var}'",
      "Strings formatadas com %",
      "Strings com método .format()",
      "Strings de arquivo"
    ],
    "correctIndex": 0,
    "explanation": "f-strings (Python 3.6+): prefixo f antes da string, {expressão} avalia qualquer código Python. Suporta formatação: {val:.2f}, {val:>10}, {val!r}. Mais rápidas e legíveis que .format() e %. Python 3.12: f-strings podem ter { dentro de {}.",
    "example": "name = 'Ana'; age = 25; f'{name} tem {age} anos' // 'Ana tem 25 anos'. f'{3.14159:.2f}' // '3.14'. f'{[x**2 for x in range(5)]}' // '[0, 1, 4, 9, 16]'. f'{'hello':>10}' // '     hello'."
  },
  {
    "id": "linguagens-de-programacao__Python__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Fácil",
    "question": "O que é a keyword 'with' em Python e como funciona o context manager?",
    "options": [
      "Garante aquisição e liberação automática de recursos via __enter__ e __exit__, mesmo com exceções",
      "Import condicional",
      "Loop especial",
      "Declaração de classe"
    ],
    "correctIndex": 0,
    "explanation": "with statement: chama __enter__() no início e __exit__() ao final (mesmo com exceções). Equivalente a try/finally. Usado para: arquivos, locks, conexões DB, transações. contextlib.contextmanager permite criar context managers com yield.",
    "example": "with open('data.txt', 'r') as f: content = f.read() // f.close() chamado automaticamente. // Equivale a: f = open('data.txt'); try: content = f.read(); finally: f.close(). // Custom: @contextmanager def timer(): start = time.time(); yield; print(time.time() - start)."
  },
  {
    "id": "linguagens-de-programacao__Python__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Fácil",
    "question": "O que são list comprehensions em Python e como diferem de generator expressions?",
    "options": [
      "List comprehension cria lista em memória imediatamente [x*2 for x in range(10)]; generator expression é lazy (x*2 for x in range(10)) gerando valores sob demanda, mais eficiente em memória",
      "List comprehensions são mais rápidas que generator expressions em todas as situações",
      "Generator expressions criam listas internamente; a diferença é apenas sintática",
      "List comprehensions não aceitam condições (if); apenas loops for simples"
    ],
    "correctIndex": 0,
    "explanation": "List comp: [expr for item in iter if cond] — cria lista completa na memória. Set comp: {expr for ...}. Dict comp: {k:v for ...}. Generator: (expr for ...) — objeto gerador, lógica executada ao iterar. sum(x**2 for x in range(1000000)): usa gen, não aloca lista de 1M. Nested: [y for x in matrix for y in x]. Condição: [x for x in lst if x > 0].",
    "example": "Lista: quadrados = [x**2 for x in range(10000)] — aloca 10k ints em memória. Generator: gen = (x**2 for x in range(10000)) — usa ~100 bytes. sum(gen) consome sob demanda. Para processar arquivo grande: (linha.strip() for linha in open('big.csv') if linha.startswith('2025')). any()/all()/sum() com gen expression são idiomáticos e memória-eficientes."
  },
  {
    "id": "linguagens-de-programacao__Python__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Médio",
    "question": "Em Python, o que são decorators e como eles modificam o comportamento de funções?",
    "options": [
      "São funções que envolvem outra função, adicionando comportamento antes/depois sem modificar o código original",
      "São comentários especiais para documentação",
      "São imports condicionais",
      "São variáveis globais decorativas"
    ],
    "correctIndex": 0,
    "explanation": "Decorators são funções de ordem superior que recebem uma função como argumento e retornam uma nova função com comportamento adicional. A sintaxe @decorator é syntactic sugar para func = decorator(func). São usados para logging, autenticação, caching, etc.",
    "example": "def timer(f): def wrapper(*a): start = time.time(); result = f(*a); print(f'{time.time()-start:.2f}s'); return result; return wrapper. @timer def process(): ... // mede tempo automaticamente."
  },
  {
    "id": "linguagens-de-programacao__Python__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Médio",
    "question": "Em Python, o que são generators e como diferem de funções normais?",
    "options": [
      "Funções com yield que produzem valores sob demanda (lazy) sem manter toda a sequência em memória",
      "Funções mais rápidas",
      "Funções que retornam listas",
      "Classes especiais"
    ],
    "correctIndex": 0,
    "explanation": "Generators usam 'yield' em vez de 'return'. Cada chamada a next() executa até o próximo yield e pausa. O estado local (variáveis) é preservado entre chamadas. São lazy (produzem valores sob demanda), usando O(1) memória para sequências infinitas.",
    "example": "def fibonacci(): a, b = 0, 1; while True: yield a; a, b = b, a+b. gen = fibonacci(); next(gen) // 0. next(gen) // 1. next(gen) // 1. next(gen) // 2. // Sequência infinita com memória O(1)."
  },
  {
    "id": "linguagens-de-programacao__Python__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Médio",
    "question": "Em Python, o que é a diferença entre métodos de instância, @classmethod e @staticmethod?",
    "options": [
      "Instância recebe self; classmethod recebe cls (a classe); staticmethod não recebe nem self nem cls",
      "São idênticos",
      "staticmethod é mais rápido",
      "classmethod é privado"
    ],
    "correctIndex": 0,
    "explanation": "Método de instância: opera em self (instância específica). @classmethod: recebe cls (a classe), usado para factory methods e herança. @staticmethod: não recebe self nem cls, é como função normal agrupada na classe por organização lógica.",
    "example": "class Date: def __init__(self, y, m, d): self.year=y. @classmethod def from_string(cls, s): return cls(*s.split('-')). @staticmethod def is_valid(s): ... // Date.from_string('2024-01-15'); Date.is_valid('abc')."
  },
  {
    "id": "linguagens-de-programacao__Python__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Médio",
    "question": "O que são generators em Python e como diferem de listas?",
    "options": [
      "Funções com yield que produzem valores sob demanda (lazy), usando memória O(1) vs O(n) de listas",
      "Listas mais rápidas",
      "Funções recursivas",
      "Tipo de classe"
    ],
    "correctIndex": 0,
    "explanation": "Generator: função com yield que retorna um iterator. Cada chamada a next() executa até o próximo yield. Memória constante vs lista que armazena tudo. Generator expressions: (x**2 for x in range(10**9)). Usado para processar grandes datasets.",
    "example": "def fib(): a, b = 0, 1; while True: yield a; a, b = b, a+b. g = fib(); [next(g) for _ in range(7)] // [0,1,1,2,3,5,8]. Memória: O(1) vs list(fib_list(10**9)) que crasharia."
  },
  {
    "id": "linguagens-de-programacao__Python__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Médio",
    "question": "O que é o conceito de virtual environment (venv) em Python?",
    "options": [
      "Ambiente isolado com suas próprias dependências, evitando conflitos entre projetos",
      "Máquina virtual",
      "Container Docker",
      "IDE para Python"
    ],
    "correctIndex": 0,
    "explanation": "venv cria um diretório com cópia/link do interpretador Python e pip próprio. Pacotes instalados ficam isolados do sistema. Cada projeto pode ter versões diferentes de dependências. Alternativas: conda, poetry, pyenv-virtualenv. Ativar: source venv/bin/activate.",
    "example": "python -m venv .venv && source .venv/bin/activate && pip install flask==2.3 && pip freeze > requirements.txt. Projeto B pode ter flask==3.0 em seu próprio .venv sem conflito."
  },
  {
    "id": "linguagens-de-programacao__Python__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Médio",
    "question": "O que são type hints em Python e por que usá-las?",
    "options": [
      "Anotações de tipo opcionais que melhoram legibilidade, autocomplete e detecção de erros com mypy/pyright",
      "Declarações obrigatórias de tipo",
      "Validações em runtime",
      "Comentários de documentação"
    ],
    "correctIndex": 0,
    "explanation": "Type hints (PEP 484): anotações opcionais verificadas por ferramentas externas (mypy, pyright), não pelo runtime. def greet(name: str) -> str:. Tipos complexos: list[int], dict[str, Any], Optional[str] (= str | None). Python 3.10+: X | Y em vez de Union[X, Y].",
    "example": "def greet(name: str, times: int = 1) -> str: return name * times. from typing import Optional; def find(id: int) -> Optional[User]: ... // User | None. # mypy check: greet(42) → erro: expected str, got int."
  },
  {
    "id": "linguagens-de-programacao__Python__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Médio",
    "question": "O que é asyncio em Python e como difere de threading?",
    "options": [
      "Framework de I/O assíncrono single-threaded baseado em event loop e coroutines (async/await); threading usa múltiplas threads",
      "São idênticos",
      "asyncio usa múltiplos processos",
      "threading é assíncrono"
    ],
    "correctIndex": 0,
    "explanation": "asyncio: concorrência cooperativa em uma thread via event loop. async def + await. Ideal para I/O-bound (HTTP, DB, files). Sem overhead de threads. Threading: concorrência preemptiva com GIL (sem paralelismo real CPU-bound). asyncio escala melhor para milhares de conexões.",
    "example": "async def fetch_all(urls): async with aiohttp.ClientSession() as s: tasks = [s.get(url) for url in urls]; return await asyncio.gather(*tasks) // 1000 requests em paralelo, 1 thread. Threading: 1000 threads = overhead considerável."
  },
  {
    "id": "linguagens-de-programacao__Python__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Médio",
    "question": "O que são decorators em Python e como implementar um decorator com argumentos?",
    "options": [
      "Decorator: função de ordem superior que envolve outra função adicionando comportamento; decorator com argumentos requer três níveis de função (outer, wrapper, decorated)",
      "Decorators são classes especiais que herdam de type para modificar métodos",
      "Decorator com argumentos usa apenas dois níveis; o parâmetro vai no @decorator(arg)",
      "Decorators só são válidos para funções de módulo; não para métodos de classe"
    ],
    "correctIndex": 0,
    "explanation": "@dec equivale a func = dec(func). Decorator com args: @dec(n) → func = dec(n)(func). def retry(times): def decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): for _ in range(times): try: return func(*args, **kwargs) except: pass return wrapper return decorator. functools.wraps preserva __name__, __doc__ da função original. Class decorator: __call__.",
    "example": "@retry(times=3) def call_api(): requests.get(url). Equivale a: call_api = retry(3)(call_api). @lru_cache(maxsize=128): memoização com LRU. @dataclass: gera __init__, __repr__, __eq__. @property: getter/setter. @staticmethod, @classmethod. Stacking: @login_required @cache_page(300): executa de baixo para cima (login_required(cache_page(view)))."
  },
  {
    "id": "linguagens-de-programacao__Python__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Difícil",
    "question": "Em Python, o que é o GIL (Global Interpreter Lock) e como ele afeta a performance de código CPU-bound multithread?",
    "options": [
      "O GIL permite que apenas uma thread execute bytecode Python por vez, limitando paralelismo CPU-bound; use multiprocessing para contornar",
      "O GIL acelera código multithread",
      "O GIL só existe no Jython, não no CPython",
      "O GIL foi removido no Python 3.10"
    ],
    "correctIndex": 0,
    "explanation": "O GIL no CPython é um mutex que protege o acesso a objetos Python, permitindo apenas uma thread executar bytecode por vez. Para I/O-bound, threads funcionam bem (GIL é liberado durante I/O). Para CPU-bound, multiprocessing (processos separados, cada um com seu GIL) ou extensões C são necessários para verdadeiro paralelismo.",
    "example": "CPU-bound (calcular pi): threading → sem speedup (GIL). multiprocessing.Pool(4).map(calc, chunks) → 4x speedup (4 processos com GILs independentes). I/O-bound (HTTP requests): threading → speedup normal (GIL liberado durante await de rede)."
  },
  {
    "id": "linguagens-de-programacao__Python__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Difícil",
    "question": "Em Python, o que são metaclasses e como elas controlam a criação de classes?",
    "options": [
      "Classes de classes: definem como classes são criadas, permitindo modificar atributos, métodos e validações na definição da classe",
      "Classes abstratas",
      "Decorators de classe",
      "Módulos de import"
    ],
    "correctIndex": 0,
    "explanation": "Em Python, classes são objetos criados por metaclasses. type é a metaclass padrão. Ao definir class Foo(metaclass=Meta), Meta.__new__() e Meta.__init__() controlam como Foo é criada. Metaclasses podem validar, registrar ou modificar classes automaticamente. ORMs como Django usam metaclasses.",
    "example": "class ValidateFields(type): def __new__(mcs, name, bases, namespace): for k, v in namespace.items(): if isinstance(v, str) and not k.startswith('_'): raise TypeError(f'{k} must not be string'). return super().__new__(mcs, name, bases, namespace). class Model(metaclass=ValidateFields): ..."
  },
  {
    "id": "linguagens-de-programacao__Python__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Difícil",
    "question": "Em Python, o que são 'descriptors' e como os protocolos __get__, __set__, __delete__ funcionam?",
    "options": [
      "Objetos que definem __get__/__set__/__delete__ e controlam o acesso a atributos de outras classes",
      "Tipos de iterator",
      "Funções de I/O",
      "Métodos de string"
    ],
    "correctIndex": 0,
    "explanation": "Descriptors são objetos com __get__, __set__ e/ou __delete__ que interceptam acesso a atributos quando usados como atributos de classe. @property, @classmethod, @staticmethod são implementados com descriptors. Data descriptors (__get__ + __set__) têm prioridade sobre o instance __dict__.",
    "example": "class Positive: def __set_name__(self, owner, name): self.name = name. def __set__(self, obj, value): if value < 0: raise ValueError('Must be positive'). obj.__dict__[self.name] = value. def __get__(self, obj, type): return obj.__dict__.get(self.name, 0). class Product: price = Positive() // Product().price = -1 → ValueError."
  },
  {
    "id": "linguagens-de-programacao__Python__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Difícil",
    "question": "O que é o GIL (Global Interpreter Lock) em Python e como impacta concorrência?",
    "options": [
      "Lock que permite apenas uma thread executar bytecode por vez; limita paralelismo CPU-bound mas não I/O-bound",
      "Lock de arquivo",
      "Firewall do Python",
      "Gerenciador de memória"
    ],
    "correctIndex": 0,
    "explanation": "GIL (CPython): mutex que protege o reference counting do GC. Consequência: threads Python não executam em paralelo real para código CPU-bound. Soluções: multiprocessing (processos separados), asyncio (I/O-bound), extenso C/Rust (libera GIL), Python 3.13 free-threaded (experimental).",
    "example": "CPU-bound: threading = lento (GIL). multiprocessing.Pool(4).map(heavy_calc, data) = 4x mais rápido. I/O-bound: threading OK (GIL é liberado durante I/O). asyncio: ainda melhor para I/O com milhares de conexões."
  },
  {
    "id": "linguagens-de-programacao__Python__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Difícil",
    "question": "O que são metaclasses em Python e quando usá-las?",
    "options": [
      "Classes de classes — controlam a criação e comportamento de classes em tempo de definição",
      "Classes abstratas",
      "Decorators para classes",
      "Classes estáticas"
    ],
    "correctIndex": 0,
    "explanation": "Metaclass: classe cujas instâncias são classes. type é a metaclass padrão. Ao definir class Foo(metaclass=Meta), Meta.__new__ e Meta.__init__ controlam a criação de Foo. Usos avançados: ORMs (Django models), registro automático, validação de classes, ABCs.",
    "example": "class Meta(type): def __new__(cls, name, bases, ns): if 'validate' not in ns: raise TypeError(f'{name} must implement validate'). return super().__new__(cls, name, bases, ns). class User(metaclass=Meta): def validate(self): pass // OK. class Bad(metaclass=Meta): pass // TypeError!"
  },
  {
    "id": "linguagens-de-programacao__Python__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Difícil",
    "question": "O que é __slots__ em Python e como melhora performance de memória?",
    "options": [
      "Declara atributos fixos de instância, eliminando __dict__ e reduzindo memória por objeto em 40-50%",
      "Lista de métodos permitidos",
      "Cache de atributos",
      "Pool de conexões"
    ],
    "correctIndex": 0,
    "explanation": "__slots__ = ('x', 'y') impede criação de __dict__ por instância. Cada atributo usa descriptor (armazenamento fixo). Benefícios: ~40% menos memória, acesso ~10% mais rápido. Trade-off: não pode adicionar atributos dinâmicos, complica herança múltipla.",
    "example": "class Point: __slots__ = ('x', 'y'); def __init__(self, x, y): self.x = x; self.y = y. p = Point(1, 2); p.z = 3 // AttributeError: 'Point' object has no attribute 'z'. # Sem __slots__: ~160 bytes/inst. Com __slots__: ~56 bytes/inst."
  },
  {
    "id": "linguagens-de-programacao__Python__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Difícil",
    "question": "O que são dataclasses em Python e como simplificam classes de dados?",
    "options": [
      "Decorator que gera __init__, __repr__, __eq__ automaticamente a partir de anotações de tipo dos campos",
      "Classes de banco de dados",
      "Tipo especial de dict",
      "Classe abstrata"
    ],
    "correctIndex": 0,
    "explanation": "@dataclass (Python 3.7): gera __init__, __repr__, __eq__. frozen=True: imutável. field(default_factory=list): defaults mutáveis seguros. __post_init__: validação. Alternativas: NamedTuple (imutável, mais leve), attrs (mais features), Pydantic (validação runtime).",
    "example": "from dataclasses import dataclass; @dataclass(frozen=True) class Point: x: float; y: float; def magnitude(self) -> float: return (self.x**2 + self.y**2)**0.5. p = Point(3, 4); p.magnitude() // 5.0. p.x = 0 // FrozenInstanceError."
  },
  {
    "id": "linguagens-de-programacao__Python__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "Python",
    "difficulty": "Difícil",
    "question": "Como o GIL (Global Interpreter Lock) do CPython afeta multithread e quando usar multiprocessing ou asyncio?",
    "options": [
      "GIL: um lock por processo CPython que impede execução paralela de bytecode Python; threads funcionam para I/O-bound (GIL liberado durante I/O); multiprocessing para CPU-bound (processos separados = GIL separado)",
      "GIL foi removido no Python 3.10; threads CPython são totalmente paralelas",
      "GIL afeta multiprocessing e asyncio igualmente; não há alternativa sem trocar o interpretador",
      "asyncio usa múltiplas threads internamente para paralelismo real de I/O"
    ],
    "correctIndex": 0,
    "explanation": "GIL garante que apenas uma thread execute bytecode Python por vez por processo. I/O-bound (network, disco): C extensions liberam GIL durante I/O — threads realmente paralelas. CPU-bound (cálculo puro): threads não ajudam (GIL serializa). Soluções: multiprocessing (processos com memoória separada), concurrent.futures.ProcessPoolExecutor. asyncio: event loop single-thread para I/O-bound com async/await. NumPy/Pandas: liberam GIL em operações C. Python 3.13 (experimental): no-GIL build.",
    "example": "CPU benchmark: 4 cores, 4 threads Python = ~1x (GIL). 4 processes = ~3.8x. I/O: 100 requests HTTP, 4 threads = ~100x vs 1 thread. asyncio + aiohttp: lógica single-thread, alta concorrência. ProcessPoolExecutor: from concurrent.futures import ProcessPoolExecutor; with PPE(4) as ex: results = list(ex.map(cpu_task, data)). Celery: distribute tasks entre workers (processos diferentes)."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Fácil__1",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Fácil",
    "question": "No TypeScript, como se define o tipo de uma variável que pode ser string ou number?",
    "options": [
      "Usando union type: string | number",
      "Usando any",
      "Usando Object",
      "Usando string + number"
    ],
    "correctIndex": 0,
    "explanation": "Union types permitem que uma variável aceite dois ou mais tipos. A sintaxe usa o pipe (|) entre os tipos. O TypeScript exige que operações na variável sejam válidas para todos os tipos da union, ou que se faça narrowing para um tipo específico.",
    "example": "let id: string | number; id = 'abc'; // OK. id = 123; // OK. id = true; // Erro: boolean não é string | number."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Fácil__2",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Fácil",
    "question": "No TypeScript, o que é uma 'interface' e como usá-la para tipar objetos?",
    "options": [
      "Contrato que define a estrutura (propriedades e tipos) que um objeto deve ter",
      "Classe abstrata",
      "Função de validação",
      "Módulo de import"
    ],
    "correctIndex": 0,
    "explanation": "Interfaces definem a 'forma' de um objeto: quais propriedades existem e seus tipos. São apagadas em tempo de compilação (zero-cost). Suportam propriedades opcionais (?), readonly, e podem ser estendidas (extends). Classes podem implementá-las.",
    "example": "interface User { name: string; age: number; email?: string; } const u: User = { name: 'Ana', age: 25 }; // email é opcional. u.phone; // Erro: 'phone' não existe em User."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Fácil__3",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Fácil",
    "question": "No TypeScript, o que são type guards e como usar 'typeof' e 'instanceof' para narrowing?",
    "options": [
      "Condições que estreitam o tipo de uma variável dentro de um bloco, permitindo acesso seguro a propriedades",
      "Guardas de segurança",
      "Assertions de tipo",
      "Validações de runtime"
    ],
    "correctIndex": 0,
    "explanation": "Type guards são expressões condicionais que informam ao TypeScript o tipo específico dentro de um bloco. typeof funciona para primitivos (string, number, boolean). instanceof para classes. Também: 'in' operator, discriminated unions, e custom type predicates (is).",
    "example": "function process(value: string | number) { if (typeof value === 'string') { value.toUpperCase(); // OK: TS sabe que é string aqui } else { value.toFixed(2); // OK: TS sabe que é number aqui } }"
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Fácil__4",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Fácil",
    "question": "O que é o TypeScript e por que usá-lo em vez de JavaScript puro?",
    "options": [
      "Superset tipado de JS que adiciona tipos estáticos, detectando erros em compile-time antes de rodar",
      "Linguagem diferente de JS",
      "Framework de testes",
      "Substituto do Node.js"
    ],
    "correctIndex": 0,
    "explanation": "TypeScript: JavaScript + sistema de tipos estáticos. Compila para JS puro. Vantagens: erros detectados antes de executar, autocomplete no editor, refactoring seguro, documentação via tipos. Zero overhead em runtime (tipos são removidos na compilação).",
    "example": "function greet(name: string): string { return `Hello ${name}`; } greet(42); // Erro em compile-time: Argument of type 'number' is not assignable to parameter of type 'string'. Em JS puro, só descobriria em runtime."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Fácil__5",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Fácil",
    "question": "O que são Union Types em TypeScript?",
    "options": [
      "Tipo que pode ser um de vários tipos, usando | para combinar; requer narrowing para acessar membros específicos",
      "Tipo que combina todos os membros",
      "Array de tipos",
      "Tipo de união de tabelas SQL"
    ],
    "correctIndex": 0,
    "explanation": "Union type (A | B): valor pode ser A ou B. Para acessar membros específicos, precisa de narrowing (typeof, instanceof, discriminante). Literal unions: type Dir = 'up' | 'down'. Utilisímos para modelar estados.",
    "example": "function format(value: string | number): string { if (typeof value === 'string') return value.toUpperCase(); return value.toFixed(2); } format('hello'); // 'HELLO'. format(3.14); // '3.14'."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Fácil__6",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Fácil",
    "question": "O que são enums em TypeScript e quais tipos estão disponíveis?",
    "options": [
      "Conjunto nomeado de constantes: numeric enums (auto-incremento), string enums (valores explícitos) e const enums (inlined)",
      "Arrays de constantes",
      "Tipos de variáveis",
      "Funções especiais"
    ],
    "correctIndex": 0,
    "explanation": "Numeric enum: auto-incrementa (Up=0, Down=1). String enum: cada membro tem valor string explícito. const enum: inlined em compile-time (sem objeto em runtime). Alternativa moderna: union de literais ('up' | 'down') — mais simples, tree-shakeable.",
    "example": "enum Direction { Up, Down, Left, Right } // Up=0, Down=1... enum Status { Active = 'ACTIVE', Inactive = 'INACTIVE' } // String enum. const enum Color { Red, Green, Blue } // Inlined: Color.Red vira 0 no JS. // Alternativa: type Dir = 'up' | 'down';"
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Fácil__7",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Fácil",
    "question": "O que é a keyword 'readonly' em TypeScript e onde usá-la?",
    "options": [
      "Modifica propriedades para serem somente leitura após inicialização; aplicável em interfaces, classes e arrays",
      "Torna variáveis globais",
      "Impede importação",
      "Delete a propriedade"
    ],
    "correctIndex": 0,
    "explanation": "readonly impede reatribuição de propriedades após construção. Em interfaces: readonly id: number. Em classes: readonly name: string (só no construtor). ReadonlyArray<T> ou readonly T[]: array sem push/pop. Readonly<T> utility type: todas props readonly.",
    "example": "interface User { readonly id: number; name: string; } const u: User = { id: 1, name: 'Ana' }; u.name = 'Bob'; // OK. u.id = 2; // Erro: Cannot assign to 'id' because it is a read-only property. const arr: readonly number[] = [1,2,3]; arr.push(4); // Erro."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Fácil__8",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Fácil",
    "question": "O que são union types e intersection types em TypeScript e quando usar cada um?",
    "options": [
      "Union (A | B): valor pode ser A OU B; intersection (A & B): valor deve satisfazer A E B simultaneamente; union para variantes, intersection para composição de tipos",
      "Union combina todos os campos de A e B; intersection restringe a campos comuns",
      "São pré-condicionais; TypeScript seleciona automaticamente com base no contexto",
      "Union é somente para tipos primitivos; intersection somente para objetos"
    ],
    "correctIndex": 0,
    "explanation": "Union: type ID = string | number — função aceita string ou number. Narrowing: typeof, instanceof para tratar cada caso. Intersection: type AdminUser = User & Admin — deve ter todos os campos de User E Admin. Discriminated union: { type: 'circle', radius: number } | { type: 'square', side: number } — switch em 'type' faz narrowing exaustivo. never em default garante exaustividade.",
    "example": "type Result<T> = { status: 'ok'; data: T } | { status: 'error'; message: string }. Narrowing: if(r.status === 'ok') r.data; else r.message. Intersection: type PaginatedResponse<T> = ApiResponse & { items: T[]; total: number }. Utility types: Partial<T> (todos opcionais), Required<T>, Pick<T, 'a'|'b'>, Omit<T, 'senha'>."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Médio__1",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Médio",
    "question": "No TypeScript, para que serve o utility type 'Partial<T>' e quando usá-lo?",
    "options": [
      "Torna todas as propriedades de T opcionais, útil para atualizações parciais de objetos",
      "Remove todas as propriedades de T",
      "Torna T um array",
      "Faz todas as propriedades readonly"
    ],
    "correctIndex": 0,
    "explanation": "Partial<T> cria um novo tipo onde todas as propriedades de T são opcionais (?). É útil para funções de atualização parcial onde nem todos os campos precisam ser fornecidos. Internamente: type Partial<T> = { [P in keyof T]?: T[P] }.",
    "example": "interface User { name: string; age: number; } function update(id: number, data: Partial<User>) { } update(1, { name: 'Ana' }); // OK: age é opcional."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Médio__2",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Médio",
    "question": "No TypeScript, o que são 'type assertions' (as) e quando usá-las com cuidado?",
    "options": [
      "Afirmam ao compilador que um valor é de determinado tipo, sem verificar em runtime; podem mascarar erros",
      "Conversão de tipos em runtime",
      "Validação automática",
      "Criação de novos tipos"
    ],
    "correctIndex": 0,
    "explanation": "Type assertions (valor as Tipo) dizem ao TS 'confie em mim, eu sei o tipo'. NÃO fazem conversão em runtime — só afetam a verificação do compilador. Uso legítimo: quando você sabe mais que o TS (ex: após validação). Perigo: mascarar erros de tipo que só aparecem em runtime.",
    "example": "const input = document.getElementById('name') as HTMLInputElement; input.value; // OK. // Perigoso: const data = response as User; // Se response não for User, erro em runtime, não em compiletime."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Médio__3",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Médio",
    "question": "No TypeScript, o que são 'discriminated unions' e como usam uma propriedade tag para narrowing?",
    "options": [
      "Uniões onde cada membro tem uma propriedade literal única (tag) que permite narrowing exaustivo via switch/if",
      "Uniões de strings",
      "Enums",
      "Generics"
    ],
    "correctIndex": 0,
    "explanation": "Discriminated unions têm uma propriedade 'tag' (tipo literal) que identifica cada membro. TypeScript usa a tag para narrowing: dentro de cada case/if, o tipo é estreitado automaticamente. ExhaustiveCheck (é atribuír a never) garante cobertura total.",
    "example": "type Shape = { kind: 'circle'; radius: number } | { kind: 'rect'; w: number; h: number }; function area(s: Shape) { switch(s.kind) { case 'circle': return Math.PI * s.radius ** 2; case 'rect': return s.w * s.h; } }"
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Médio__4",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Médio",
    "question": "O que são Utility Types em TypeScript e quais os mais usados?",
    "options": [
      "Tipos genéricos built-in que transformam outros tipos: Partial, Required, Pick, Omit, Record",
      "Tipos para utilitários de string",
      "Funções helper",
      "Tipos numéricos"
    ],
    "correctIndex": 0,
    "explanation": "Utility Types: Partial<T> (todas props opcionais), Required<T> (todas required), Pick<T,K> (seleciona props), Omit<T,K> (remove props), Record<K,V> (mapa de chave-valor), Readonly<T>, ReturnType<T>, Parameters<T>. Construídos com Mapped Types.",
    "example": "type User = { name: string; age: number; email: string }; type UpdateUser = Partial<Pick<User, 'name' | 'email'>>; // { name?: string; email?: string }. Omit<User, 'email'>; // { name: string; age: number }."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Médio__5",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Médio",
    "question": "O que é o conceito de type narrowing em TypeScript?",
    "options": [
      "Processo de refinar um tipo amplo para um mais específico usando guards (typeof, instanceof, in, discriminant)",
      "Converter tipos automaticamente",
      "Criar tipos menores",
      "Comprimir tipos para performance"
    ],
    "correctIndex": 0,
    "explanation": "Type narrowing: TS refina o tipo dentro de blocos condicionais. typeof (primitivos), instanceof (classes), 'prop' in obj (presença de propriedade), discriminated unions (campo literal), type predicates (is). Após narrowing, TS conhece o tipo exato.",
    "example": "function handle(x: string | string[]) { if (Array.isArray(x)) { x.join(', '); // TS sabe: string[] } else { x.toUpperCase(); // TS sabe: string } } // Custom guard: function isUser(x: any): x is User { return 'name' in x; }"
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Médio__6",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Médio",
    "question": "O que são Mapped Types em TypeScript e como funcionam?",
    "options": [
      "Tipos que iteram sobre chaves de outro tipo criando novas propriedades: { [K in keyof T]: NovoTipo }",
      "Tipos de Map/Set",
      "Arrays tipados",
      "Mapeamento de rotas"
    ],
    "correctIndex": 0,
    "explanation": "Mapped Types: iteram sobre keys de um tipo com 'in keyof'. Base dos Utility Types. Modificadores: +/- readonly, +/- ?. Podem remapear chaves com 'as'. Partial<T> = { [K in keyof T]?: T[K] }. Readonly<T> = { readonly [K in keyof T]: T[K] }.",
    "example": "type Optional<T> = { [K in keyof T]?: T[K] }; // = Partial<T>. type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] }; type UserGetters = Getters<{name: string}>; // { getName: () => string }."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Médio__7",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Médio",
    "question": "O que é o operador 'keyof' em TypeScript e como usá-lo?",
    "options": [
      "Produz uma union type de todas as chaves (propriedades) de um tipo: keyof {a: 1, b: 2} = 'a' | 'b'",
      "Retorna as chaves de um objeto em runtime",
      "Cria chaves de array",
      "Operador de comparação"
    ],
    "correctIndex": 0,
    "explanation": "keyof T: produz union de chaves de T como string literal types. keyof {name: string; age: number} = 'name' | 'age'. Combinado com generics: function get<T, K extends keyof T>(obj: T, key: K): T[K] — retorno tipado corretamente. Indexed access: T[K].",
    "example": "type User = { name: string; age: number }; type UserKey = keyof User; // 'name' | 'age'. function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; } getProperty(user, 'name'); // retorno tipo string. getProperty(user, 'xyz'); // ERRO."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Médio__8",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Médio",
    "question": "O que são template literal types em TypeScript e quais padrões permitem expressar?",
    "options": [
      "Tipos construídos combinando string literals com interpolacão de tipos em compile-time; permitem expressar padrões como EventNames, CSS properties e API routes com type-safety total",
      "Strings de template com tipos genéricos usadas somente em runtime",
      "Funções que retornam strings de template; equivalem a template literals do JS com tipos",
      "Apenas documentam o formato esperado sem verificacão de tipo efetiva"
    ],
    "correctIndex": 0,
    "explanation": "type EventName = `on${Capitalize<string>}`; // onLoad, onClick... type CSSunit = `${number}px` | `${number}%` | `${number}rem`. Combinação: type Direction = 'left'|'right'|'top'|'bottom'; type Padding = `padding-${Direction}` — 4 strings. Inferrência com infer: type ExtractId<T> = T extends `${infer K}_id` ? K : never. Mapped + template: { [K in `get${string}`]: ... }.",
    "example": "API type-safe: type Route = '/users' | '/users/:id' | '/posts'. type ApiGet = `GET ${Route}`. Emit events type-safe: type Emitter<T extends string> = { on(event: `${T}Changed`, cb: () => void): void }. Prisma usa template literal types para gerar tipos de queries. Deriveção automática: type GettersFor<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] }."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Difícil__1",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Difícil",
    "question": "No TypeScript, como os 'template literal types' permitem construir tipos de string com padrões dinâmicos?",
    "options": [
      "Usando backtick types que interpolam outros tipos para gerar unions de strings automaticamente",
      "Usando regex em runtime",
      "Usando typeof com strings",
      "Usando enums com string values"
    ],
    "correctIndex": 0,
    "explanation": "Template literal types usam a sintaxe de template strings para criar tipos. Quando combinados com unions, geram automaticamente o produto cartesiano de todas as combinações possíveis. Permitem tipagem precisa de padrões de string como event names, CSS properties, etc.",
    "example": "type Color = 'red' | 'blue'; type Size = 'sm' | 'lg'; type ClassName = `${Color}-${Size}`; // 'red-sm' | 'red-lg' | 'blue-sm' | 'blue-lg' — 4 combinações geradas automaticamente."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Difícil__2",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Difícil",
    "question": "No TypeScript, o que são Conditional Types e como usar 'infer' para extrair tipos?",
    "options": [
      "Tipos que escolhem entre dois ramos com T extends U ? X : Y; infer extrai sub-tipos dentro de condições",
      "If/else em runtime",
      "Validação de dados",
      "Loops de tipo"
    ],
    "correctIndex": 0,
    "explanation": "Conditional types permitem lógica no nível de tipos: T extends U ? TrueType : FalseType. 'infer' captura sub-tipos dentro da condição. ReturnType<T>, Parameters<T>, Awaited<T> são implementados com conditional types + infer. Distribui sobre unions automaticamente.",
    "example": "type Flatten<T> = T extends Array<infer U> ? U : T; type A = Flatten<string[]>; // string. type B = Flatten<number>; // number. type Params<T> = T extends (...args: infer P) => any ? P : never; type P = Params<(a: string, b: number) => void>; // [string, number]."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Difícil__3",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Difícil",
    "question": "No TypeScript, como os 'declaration files' (.d.ts) permitem tipar bibliotecas JavaScript?",
    "options": [
      "Arquivos que declaram tipos sem implementação, descrevendo a interface de código JS para o compilador TS",
      "Arquivos de documentação",
      "Configurações do compilador",
      "Testes unitários"
    ],
    "correctIndex": 0,
    "explanation": "Declaration files (.d.ts) contêm apenas declarações de tipo (sem código executado). Permitem que o TypeScript entenda a API de bibliotecas JavaScript. @types/* no npm (DefinitelyTyped) fornece .d.ts para milhares de libs. 'declare module' tipar módulos sem tipos.",
    "example": "// lodash.d.ts: declare module 'lodash' { export function chunk<T>(array: T[], size: number): T[][]; } // Agora: import { chunk } from 'lodash'; chunk([1,2,3,4], 2); // TypeScript sabe que retorna number[][]."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Difícil__4",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Difícil",
    "question": "O que é Template Literal Types em TypeScript e como permitem tipagem de strings dinâmicas?",
    "options": [
      "Tipos que usam template literals para criar uniões de strings automaticamente a partir de outros tipos",
      "Strings multilinhas",
      "Templates de código",
      "Formatação de strings"
    ],
    "correctIndex": 0,
    "explanation": "Template Literal Types: type EventName = `on${Capitalize<'click' | 'hover'>}` = 'onClick' | 'onHover'. Combinam com Mapped Types para gerar tipos de strings programaticamente. Usados em tipagem de APIs como CSS-in-JS, event handlers, path params.",
    "example": "type Getter<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] }; type UserGetters = Getter<{name: string; age: number}>; // { getName: () => string; getAge: () => number }."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Difícil__5",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Difícil",
    "question": "O que é o TypeScript 'satisfies' operator e quando usá-lo?",
    "options": [
      "Valida que um valor atende a um tipo sem alargar o tipo inferido, mantendo narrowing",
      "Operador de comparação",
      "Verifica igualdade em runtime",
      "Alternativa ao 'as'"
    ],
    "correctIndex": 0,
    "explanation": "satisfies (TS 4.9): valida conformidade com um tipo sem alterar o tipo inferido. Diferente de ': Type' (anotação que alarga) e 'as Type' (asserção que pode mentir). Com satisfies, TS valida E preserva o tipo literal/narrowed.",
    "example": "const config = { port: 3000, host: 'localhost' } satisfies Record<string, string | number>; config.port; // tipo: number (preservado!). Com ': Record<...>': config.port seria string | number (alargado)."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Difícil__6",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Difícil",
    "question": "O que são Mapped Types com modificação de chaves (key remapping) em TypeScript?",
    "options": [
      "Mapped Types com 'as' que transformam ou filtram chaves durante a iteração: [K in keyof T as NewKey]: Type",
      "Renomeação de variáveis",
      "Import com alias",
      "Refactoring automático"
    ],
    "correctIndex": 0,
    "explanation": "Key remapping (TS 4.1): [K in keyof T as `get${Capitalize<K>}`]: permite renomear, transformar ou filtrar chaves. Filtrar: [K in keyof T as T[K] extends Function ? never : K] remove métodos. Combina com template literal types para gerar APIs tipadas.",
    "example": "type EventConfig<T> = { [K in keyof T as `on${Capitalize<string & K>}Change`]: (val: T[K]) => void }; type UserEvents = EventConfig<{name: string; age: number}>; // { onNameChange: (val: string) => void; onAgeChange: (val: number) => void }."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Difícil__7",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Difícil",
    "question": "O que são branded/nominal types em TypeScript e qual problema resolvem?",
    "options": [
      "Técnica para criar tipos estruturalmente únicos via propriedade fantasma, evitando troca acidental de valores",
      "Tipos de marca registrada",
      "Nomes de tipos exportados",
      "Tipos de classe nominal"
    ],
    "correctIndex": 0,
    "explanation": "TypeScript usa tipagem estrutural (dois tipos com mesma forma são compatíveis). Branded types adicionam propriedade única __brand para criar incompatibilidade: UserId e PostId são ambos number, mas branded types impedem passar UserId onde PostId é esperado.",
    "example": "type UserId = number & { __brand: 'UserId' }; type PostId = number & { __brand: 'PostId' }; function getUser(id: UserId) {} function createUserId(id: number): UserId { return id as UserId; } getUser(createUserId(1)); // OK. getUser(42 as PostId); // ERRO: PostId != UserId."
  },
  {
    "id": "linguagens-de-programacao__TypeScript__Difícil__8",
    "track": "linguagens-de-programacao",
    "category": "TypeScript",
    "difficulty": "Difícil",
    "question": "O que é o TypeScript type system sound vs unsound e por que ele aceita algumas inseguranças por design?",
    "options": [
      "TypeScript é unsound por design (prioriza ergonomia): bivariance de métodos de classe, type assertions, any, enums não nominais; troca soundness total por usabilidade prática em codebases JS existentes",
      "TypeScript é completamente sound; qualquer erro de runtime indica bug no programa, não no type system",
      "Soundness é garantida pelo strict mode; sem strict o sistema é unsound por omissão",
      "Unsound apenas para tipos primitivos; objetos e classes são sempre sound"
    ],
    "correctIndex": 0,
    "explanation": "Sound type system: se compila sem erros, nenhum runtime type error. TypeScript documentou escolher unsoundness em alguns pontos: bivariant method parameters (para compatibilidade com callbacks), type assertion (as T) bypassa checks, any disabilita tudo, function parameter bivariance em métodos de classe. Razão: JS é dinâmico; 100% soundness tornaria muitos padrões JS impossíveis de tipar. Haskell, Elm: sound. Typescript, Flow: unsound por design.",
    "example": "Bivariance de método: class Animal { speak(a: Animal) {} } class Dog extends Animal { speak(d: Dog) {} }. TypeScript aceita (unsound): Dog pode ser atribuído a Animal mesmo que speak espere Dog mais restrito. strictFunctionTypes (strict): corrige para types de função mas não para métodos de classe (retrocompat). (x as any as OutroType): force cast total. Esses pontos geram runtime errors reais."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Fácil",
    "question": "Qual algoritmo de classificação calcula a distância entre um novo ponto e seus K vizinhos mais próximos para prever a classe?",
    "options": [
      "K-Nearest Neighbors (KNN)",
      "Regressão Linear",
      "K-Means",
      "PCA"
    ],
    "correctIndex": 0,
    "explanation": "O KNN classifica um novo dado encontrando os K pontos mais próximos no conjunto de treino e atribuindo a classe mais frequente entre eles. É um algoritmo 'lazy learning' — não constrói modelo, apenas memoriza os dados de treino.",
    "example": "Para classificar um e-mail: KNN com K=5 encontra os 5 e-mails mais semelhantes no treino. Se 4 são spam e 1 é legítimo, classifica como spam (votação majoritária)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Fácil",
    "question": "Qual algoritmo de classificação cria regras de decisão em formato de árvore para dividir os dados?",
    "options": [
      "Árvore de Decisão (Decision Tree)",
      "Regressão Linear",
      "K-Means",
      "PCA"
    ],
    "correctIndex": 0,
    "explanation": "Árvores de Decisão classificam dados fazendo perguntas sequenciais sobre as features. Cada nó interno testa uma condição (ex: idade > 30?), cada ramo é um resultado, e cada folha é uma classe. São interpretáveis mas propensas a overfitting.",
    "example": "Aprovar empréstimo: Renda > 5k? Sim → Histórico bom? Sim → Aprovar. Não → Dívidas < 30%? Sim → Aprovar. Não → Negar. Cada folha é uma decisão."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Fácil",
    "question": "O que é classificação binária vs multi-classe em Machine Learning?",
    "options": [
      "Binária: 2 classes (sim/não); multi-classe: 3+ classes (gato/cão/pássaro)",
      "Binária usa números e multi-classe usa texto",
      "São idênticas",
      "Multi-classe só funciona com redes neurais"
    ],
    "correctIndex": 0,
    "explanation": "Classificação binária tem exatamente 2 classes (spam/não-spam, fraude/legítimo). Multi-classe tem 3 ou mais classes (dígitos 0-9, espécies de flores). Algoritmos como Logistic Regression são naturalmente binários; para multi-classe, usam-se estratégias como One-vs-All ou Softmax.",
    "example": "Binária: e-mail é spam ou não-spam (sigmoid, threshold 0.5). Multi-classe: reconhecer dígitos 0-9 em fotos (softmax com 10 saídas, cada uma a probabilidade de ser 0,1,...,9)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Fácil",
    "question": "O que é o algoritmo Naive Bayes e por que ele é considerado 'ingênuo'?",
    "options": [
      "Assume que todas as features são independentes entre si dada a classe, simplificando o cálculo de probabilidades",
      "É ingênuo porque usa poucas features",
      "Porque só funciona com dados pequenos",
      "Porque ignora as probabilidades"
    ],
    "correctIndex": 0,
    "explanation": "Naive Bayes aplica o teorema de Bayes assumindo independência condicional entre features: P(classe|features) ∝ P(classe) × ∏P(featureᵢ|classe). A suposição 'ingênua' raramente é verdadeira, mas funciona surpreendentemente bem para texto, spam e classificação de documentos.",
    "example": "Classificar e-mail: P(spam|'ganhe','dinheiro','agora') ∝ P(spam) × P('ganhe'|spam) × P('dinheiro'|spam) × P('agora'|spam). Assume que as palavras são independentes — 'ganhe' não influencia 'dinheiro' — ingênuo mas eficaz."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Fácil",
    "question": "Qual é a diferença entre dados de treino e dados de teste em classificação?",
    "options": [
      "Dados de treino servem para o modelo aprender padrões; dados de teste avaliam o desempenho em dados nunca vistos",
      "São os mesmos dados usados duas vezes",
      "Dados de teste são usados para treinar",
      "Não há diferença prática"
    ],
    "correctIndex": 0,
    "explanation": "O dataset é dividido em treino (~70-80%) e teste (~20-30%). O modelo aprende padrões nos dados de treino. Depois, é avaliado nos dados de teste (nunca vistos) para medir generalização. Usar os mesmos dados para treinar e avaliar leva a métricas falsamente altas (data leakage).",
    "example": "1000 e-mails: 800 para treino (modelo aprende o que é spam), 200 para teste (avalia sem viés). Accuracy no treino: 99%. Accuracy no teste: 92%. A diferença de 7% indica leve overfitting."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Fácil",
    "question": "O que é a Regressão Logística quando usada para classificação, apesar do nome sugerir 'regressão'?",
    "options": [
      "Estima a probabilidade de pertencer a uma classe usando a função sigmoid, prevendo a classe mais provável",
      "É um modelo de regressão que prevê valores contínuos",
      "É idêntica à Regressão Linear",
      "Só funciona com variáveis categóricas"
    ],
    "correctIndex": 0,
    "explanation": "A Regressão Logística aplica a função sigmoid σ(z) = 1/(1+e^-z) sobre uma combinação linear das features, produzindo um valor entre 0 e 1 interpretado como probabilidade. Se P ≥ 0.5, prediz classe 1. O nome 'regressão' vem do fato de que estima uma probabilidade contínua, mas a decisão final é de classificação.",
    "example": "Prever se aluno passa: z = 0.3×horas + 0.2×frequência − 4.0. Aluno com 10h e 80%: z = 3+16−4 = 15 → σ(15) ≈ 1.0 → classe 'Aprovado'. Aluno com 2h e 30%: z = 0.6+6−4 = 2.6 → σ(2.6) ≈ 0.93 → 'Aprovado'. Aluno com 0h e 10%: z = 0+2−4 = −2 → σ(−2) ≈ 0.12 → 'Reprovado'."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Fácil",
    "question": "Por que é importante normalizar ou padronizar os dados antes de usar algoritmos baseados em distância como o KNN?",
    "options": [
      "Porque features com escalas maiores dominam o cálculo de distância, ignorando features menores mas relevantes",
      "Porque o KNN só aceita dados entre 0 e 1",
      "Normalizar melhora a acurácia em todos os algoritmos sem exceção",
      "Não faz diferença para o KNN"
    ],
    "correctIndex": 0,
    "explanation": "Se 'salário' varia de 1000 a 100000 e 'idade' de 18 a 80, a distância euclidiana será dominada por salário. Normalização (min-max para [0,1]) ou padronização (z-score, média=0, desvio=1) equipara as escalas, garantindo que todas as features contribuam proporcionalmente.",
    "example": "Sem normalização: distância entre João (25 anos, R$5000) e Maria (30 anos, R$80000) ≈ 75000 (dominada por salário). Com normalização: idade_norm = [0.11, 0.19], salário_norm = [0.04, 0.80] → distância = 0.76, ambas features pesam igualmente."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Fácil",
    "question": "O que é a acurácia (accuracy) e quando ela pode ser uma métrica enganosa?",
    "options": [
      "Proporção de previsões corretas; enganosa em classes desbalanceadas (ex: 99% classe A, 1% B — prever sempre A dá 99% accuracy sem aprender nada)",
      "Média das probabilidades de cada previsão estar correta",
      "Proporção de verdadeiros positivos sobre o total de positivos",
      "Sempre a métrica mais confiável independentemente da distribuição das classes"
    ],
    "correctIndex": 0,
    "explanation": "Accuracy = (TP+TN)/(TP+TN+FP+FN). Problemática em datasets desbalanceados: fraude bancária com 0,1% de fraudes — modelo que nunca prevê fraude tem 99,9% de accuracy mas é inútil. Alternativas: F1-score (harmônica de precision e recall), AUC-ROC, precision e recall separados por classe.",
    "example": "Detecção de câncer: 990 negativos, 10 positivos. Modelo 'sempre negativo': accuracy=99% mas recall=0% (não detecta nenhum câncer). F1-score=0 revela o problema. Use precision (dos que previ positivo, quantos eram?) e recall (dos positivos reais, quantos peguei?)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Médio",
    "question": "Na Regressão Logística, qual função transforma a saída linear em uma probabilidade entre 0 e 1?",
    "options": [
      "Função Sigmoid (logística)",
      "Função ReLU",
      "Função Softmax",
      "Função Tangente Hiperbólica"
    ],
    "correctIndex": 0,
    "explanation": "A função sigmoid σ(z) = 1/(1 + e^(-z)) mapeia qualquer valor real para o intervalo (0, 1), interpretado como probabilidade. Para classificação binária, se σ(z) ≥ 0.5, prediz classe 1; caso contrário, classe 0. O limiar pode ser ajustado.",
    "example": "z = w₁x₁ + w₂x₂ + b = 2.5 → σ(2.5) = 1/(1+e^(-2.5)) ≈ 0.924 → probabilidade de 92.4% para classe positiva → prediz classe 1."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Médio",
    "question": "O que é a matriz de confusão e quais métricas ela permite calcular?",
    "options": [
      "Tabela que mostra TP, FP, TN, FN; permite calcular acurácia, precisão, recall e F1-Score",
      "Gráfico de dispersão",
      "Tabela de correlações entre features",
      "Histograma de distribuição"
    ],
    "correctIndex": 0,
    "explanation": "A matriz de confusão mostra: TP (verdadeiro positivo), FP (falso positivo), FN (falso negativo), TN (verdadeiro negativo). Precision = TP/(TP+FP), Recall = TP/(TP+FN), F1 = 2×(P×R)/(P+R), Accuracy = (TP+TN)/total.",
    "example": "Detector de fraude: 90 transações legítimas corretas (TN), 5 fraudes detectadas (TP), 3 fraudes não detectadas (FN), 2 falsos alarmes (FP). Precision = 5/7 = 71%, Recall = 5/8 = 62.5%."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Médio",
    "question": "O que é a curva ROC e como o AUC ajuda a avaliar classificadores?",
    "options": [
      "Curva que plota TPR vs FPR em diferentes thresholds; AUC = área sob a curva, 1.0 = perfeito, 0.5 = aleatório",
      "Gráfico de loss vs epochs",
      "Curva de aprendizado",
      "Gráfico de resíduos"
    ],
    "correctIndex": 0,
    "explanation": "A curva ROC (Receiver Operating Characteristic) plota True Positive Rate (Recall) vs False Positive Rate para cada threshold de decisão. AUC (Area Under Curve) resume a performance: 1.0 = classificação perfeita, 0.5 = aleatório. Permite comparar modelos independente do threshold.",
    "example": "Modelo A: AUC = 0.95 (excelente). Modelo B: AUC = 0.72 (razoável). Modelo random: AUC = 0.50 (diagonal). Escolhemos o modelo A. O threshold ótimo é onde a curva ROC está mais distante da diagonal."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Médio",
    "question": "O que é o F1-Score e quando ele é preferível à accuracy como métrica de classificação?",
    "options": [
      "É a média harmônica de Precision e Recall; preferível quando as classes são desbalanceadas",
      "É a média aritmética de Precision e Recall",
      "É usado apenas para regressão",
      "É sempre igual à accuracy"
    ],
    "correctIndex": 0,
    "explanation": "F1 = 2×(Precision×Recall)/(Precision+Recall). Em datasets desbalanceados (ex: 95% não-fraude, 5% fraude), accuracy alta (95%) pode ser enganosa — o modelo pode simplesmente prever 'não-fraude' sempre. F1 penaliza modelos que ignoram a classe minoritária, forçando bom Precision E Recall.",
    "example": "Detecção de câncer: 1000 pacientes, 50 positivos. Modelo A: prediz tudo negativo → accuracy 95%, F1=0. Modelo B: acerta 40 positivos, 10 falsos alarmes → accuracy 94%, F1=0.80. F1 revela que B é muito melhor."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Médio",
    "question": "O que são hiperparâmetros em algoritmos de classificação e como diferem dos parâmetros do modelo?",
    "options": [
      "Hiperparâmetros são definidos antes do treino (ex: K no KNN); parâmetros são aprendidos durante o treino (ex: pesos)",
      "São a mesma coisa",
      "Parâmetros são definidos manualmente",
      "Hiperparâmetros só existem em redes neurais"
    ],
    "correctIndex": 0,
    "explanation": "Parâmetros do modelo (pesos, bias) são aprendidos automaticamente durante o treino via otimização. Hiperparâmetros (learning rate, K, profundidade da árvore) são definidos ANTES do treino pelo cientista de dados. Grid Search e Random Search testam combinações de hiperparâmetros sistematicamente.",
    "example": "KNN: K=3 (hiperparâmetro, você escolhe). Os 3 vizinhos mais próximos (parâmetro implícito, determinado pelos dados). Testando K=[1,3,5,7,9] via Grid Search: K=5 deu melhor accuracy no validation set."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Médio",
    "question": "O que é overfitting em classificação e como o conjunto de validação (validation set) ajuda a detectá-lo?",
    "options": [
      "Overfitting é quando o modelo decora o treino; o validation set mede performance em dados não usados no treino para detectar esse problema",
      "Overfitting melhora a generalização",
      "O validation set é usado para treinar o modelo",
      "Overfitting só ocorre em redes neurais"
    ],
    "correctIndex": 0,
    "explanation": "Dividir dados em treino/validação/teste: treino para aprender, validação para tunar hiperparâmetros e detectar overfitting, teste para avaliação final. Se accuracy no treino é 99% mas na validação é 75%, há overfitting. Soluções: mais dados, regularização, simplificar modelo, dropout, early stopping.",
    "example": "Árvore de Decisão sem limite de profundidade: treino 100%, validação 70% → overfitting severo. Com max_depth=5: treino 88%, validação 85% → generaliza melhor. O gap treino-validação caiu de 30% para 3%."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Médio",
    "question": "Qual a diferença entre as técnicas de Bagging e Boosting em ensembles de classificação?",
    "options": [
      "Bagging treina modelos em paralelo com subsets aleatórios; Boosting treina sequencialmente corrigindo erros anteriores",
      "São a mesma técnica",
      "Bagging é sempre superior ao Boosting",
      "Boosting treina modelos em paralelo"
    ],
    "correctIndex": 0,
    "explanation": "Bagging (Bootstrap AGGregatING): gera N subsets via amostragem com reposição, treina N modelos independentemente, combina por votação. Reduz variância. Ex: Random Forest. Boosting: treina modelos sequencialmente, cada um focando nos erros do anterior. Reduz bias e variância. Ex: AdaBoost, XGBoost.",
    "example": "Bagging: 100 árvores independentes, cada uma vê 63% dos dados (bootstrap). Votação: 70 dizem 'gato', 30 dizem 'cão' → 'gato'. Boosting: árvore 1 erra 20 exemplos → árvore 2 dá mais peso a esses 20 → árvore 3 foca nos que ainda erram → ensemble final muito preciso."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Médio",
    "question": "Como o SVM (Support Vector Machine) usa o conceito de margem máxima e kernel trick?",
    "options": [
      "Encontra hiperplano que maximiza a margem entre classes; kernel trick mapeia dados para espaço de maior dimensão para separar classes não-linearmente separáveis sem calcular explicitamente esse espaço",
      "Usa gradiente descendente para minimizar erro quadrático médio em classificação binária",
      "Cria ensemble de árvores de decisão com votação por maioria para maximizar separação",
      "Aplica bayes theorem para calcular probabilidade posterior de cada classe"
    ],
    "correctIndex": 0,
    "explanation": "SVM: suporte vectors = pontos mais próximos do hiperplano. Margem = distância entre suporte vectors das duas classes. Objetivo: maximizar essa margem. Kernel trick (RBF, polinomial): K(x,y) = φ(x)·φ(y) calcula produto interno no espaço transformado sem computar φ explicitamente. Permite decisões não-lineares com custo computacional linear no espaço original.",
    "example": "Dados circulares (círculo dentro de círculo): linearmente inseparáveis em 2D. Kernel RBF mappa para 3D onde se tornam separáveis por hiperplano. SVM com kernel linear para texto (alta dimensionalidade já é linear). C (regularização): alto C = menos erros no treino, mais overfitting."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Difícil",
    "question": "No algoritmo SVM (Support Vector Machine), o que representa o 'kernel trick' e por que ele é fundamental para classificação não-linear?",
    "options": [
      "Mapeia dados para dimensão superior implicitamente usando produto interno, sem computar coordenadas no espaço transformado",
      "Reduz a dimensionalidade dos dados",
      "É uma técnica de regularização para evitar overfitting",
      "Substitui o hiperplano por uma rede neural"
    ],
    "correctIndex": 0,
    "explanation": "O kernel trick permite ao SVM operar em espaços de alta dimensão sem computar explicitamente as coordenadas nesse espaço. Kernels (RBF, polinomial) calculam o produto interno entre pontos no espaço transformado usando apenas os dados originais, tornando viável separar classes não-linearmente separáveis.",
    "example": "Dados em 2D formam um círculo (classe A) dentro de um anel (classe B) — impossível separar linearmente. Kernel RBF K(x,y) = exp(-γ||x-y||²) mapeia para dimensão infinita onde um hiperplano linear separa as classes."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Difícil",
    "question": "O que é Random Forest e por que geralmente supera uma árvore de decisão individual?",
    "options": [
      "Ensemble de múltiplas árvores treinadas com subsets aleatórios; a agregação reduz variância e overfitting",
      "Uma árvore muito grande",
      "Florestas reais modeladas",
      "Árvore com random features apenas"
    ],
    "correctIndex": 0,
    "explanation": "Random Forest cria N árvores de decisão, cada uma treinada com bootstrap (amostra com reposição) e subset aleatório de features em cada split. A predição final é votação majoritária (classificação) ou média (regressão). A diversidade entre árvores reduz variância sem aumentar bias.",
    "example": "1 árvore: accuracy 78%, alta variância. Random Forest com 100 árvores: accuracy 91%, baixa variância. Cada árvore erra diferente, mas a maioria acerta — a 'sabedoria da multidão' corrige erros individuais."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Difícil",
    "question": "O que é Gradient Boosting e como difere de Random Forest na construção do ensemble?",
    "options": [
      "Treina árvores sequencialmente, cada nova corrigindo os erros da anterior; Random Forest treina em paralelo",
      "São idênticos",
      "Boosting usa árvores maiores",
      "Random Forest é sequencial"
    ],
    "correctIndex": 0,
    "explanation": "Random Forest treina árvores INDEPENDENTEMENTE em paralelo (bagging). Gradient Boosting treina SEQUENCIALMENTE: cada nova árvore aprende os resíduos (erros) da anterior. XGBoost, LightGBM e CatBoost são implementações otimizadas. Boosting geralmente tem melhor accuracy, mas é mais propenso a overfitting.",
    "example": " Árvore 1: prediz 50 (real 70, resíduo +20). Árvore 2: prediz +18 do resíduo. Árvore 3: prediz +1.8 do resíduo restante. Final: 50+18+1.8 = 69.8 ≈ 70. Cada árvore corrige o erro acumulado."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Difícil",
    "question": "O que é o XGBoost e por que se tornou um dos algoritmos mais usados em competições de ML?",
    "options": [
      "Implementação otimizada de Gradient Boosting com regularização, tratamento de missing values e paralelismo",
      "É uma rede neural profunda",
      "É um ensemble de KNN",
      "É idêntico ao Random Forest"
    ],
    "correctIndex": 0,
    "explanation": "XGBoost (eXtreme Gradient Boosting) adiciona regularização L1/L2 aos pesos das folhas, poda inteligente de árvores, tratamento nativo de valores faltantes, e paralelização na construção de árvores. Dominou competições no Kaggle e é amplamente utilizado em produção por sua combinação de precisão e velocidade.",
    "example": "Competição Kaggle de previsão de preço: Random Forest accuracy 85%. XGBoost com tuning: accuracy 91%. Features: regularização (evita overfitting), histogram-based splits (10x mais rápido), early stopping (para quando não melhora)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Difícil",
    "question": "Como funciona a técnica de Stratified K-Fold Cross-Validation e quando é essencial usá-la?",
    "options": [
      "Mantém a proporção das classes em cada fold, essencial quando há desbalanceamento de classes",
      "Divide dados em K partes aleatoriamente sem considerar classes",
      "Treina apenas na classe majoritária",
      "É o mesmo que Leave-One-Out"
    ],
    "correctIndex": 0,
    "explanation": "K-Fold padrão pode ter folds sem exemplos da classe minoritária. Stratified K-Fold garante que cada fold tem a mesma proporção de classes que o dataset original. Essencial em datasets desbalanceados como detecção de fraude (1% fraude, 99% legítimo) para avaliação confiável.",
    "example": "Dataset: 950 legítimos, 50 fraudes (5%). K-Fold K=5 normal: fold pode ter 0 fraudes → métricas inúteis. Stratified K=5: cada fold tem ~190 legítimos + 10 fraudes (5% mantido). Recall por fold: [0.80, 0.85, 0.90, 0.75, 0.80]."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Difícil",
    "question": "O que é a técnica SMOTE e como ela aborda o problema de classes desbalanceadas em classificação?",
    "options": [
      "Gera exemplos sintéticos da classe minoritária interpolando entre vizinhos próximos no espaço de features",
      "Remove exemplos da classe majoritária aleatoriamente",
      "Duplica exemplos da classe minoritária idênticos",
      "Altera os pesos da função de perda"
    ],
    "correctIndex": 0,
    "explanation": "SMOTE (Synthetic Minority Over-sampling Technique) seleciona um exemplo da classe minoritária, encontra seus K vizinhos mais próximos (da mesma classe) e cria um novo exemplo sintético em um ponto aleatório no segmento de linha entre eles. Gera diversidade real, ao contrário de oversampling ingênuo (duplicação).",
    "example": "Classe fraude: 50 exemplos. SMOTE com K=5: para cada fraude, encontra 5 vizinhos. Exemplo x=[0.3, 0.8], vizinho=[0.5, 0.9]. Sintético = x + rand×(vizinho−x) = [0.3+0.4×0.2, 0.8+0.4×0.1] = [0.38, 0.84]. Repete até ter ~500 fraudes sintéticas. Classe balanceada sem duplicação."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Difícil",
    "question": "O que é soft voting vs hard voting em ensembles de classificação e quando cada abordagem é preferível?",
    "options": [
      "Hard voting usa a classe mais votada; soft voting usa a média das probabilidades, sendo preferível quando modelos calibram bem suas probabilidades",
      "São a mesma coisa",
      "Soft voting é sempre inferior",
      "Hard voting usa probabilidades"
    ],
    "correctIndex": 0,
    "explanation": "Hard voting: cada modelo vota em uma classe, vence a maioria (2 de 3 dizem 'gato' → 'gato'). Soft voting: média as probabilidades de cada classe e escolhe a de maior probabilidade média. Soft voting aproveita a confiança de cada modelo e geralmente supera hard voting quando os modelos emitem probabilidades bem calibradas.",
    "example": "3 modelos classificando 'gato' vs 'cão'. Hard: [gato, cão, gato] → gato (2×1). Soft: probabilidades gato = [0.51, 0.40, 0.52], média = 0.477 → cão vence (0.523)! O modelo que disse 'cão' tinha alta confiança (0.60), enquanto os que disseram 'gato' tinham baixa (0.51, 0.52)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Classificação__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Classificação",
    "difficulty": "Difícil",
    "question": "O que é o problema de imbalanced classes e quais técnicas de reamostragem e de loss function existem para tratá-lo?",
    "options": [
      "Classes desbalanceadas enviesam o modelo para a majoritária; técnicas: SMOTE (oversampling sintético), undersampling, class_weight, focal loss e threshold tuning",
      "Apenas aumentar o dataset com mais dados reais da classe minoritária resolve o problema",
      "Normalizar features resolve o desbalanceamento antes do treinamento",
      "Usar accuracy como métrica de avaliação compensa automaticamente o desbalanceamento"
    ],
    "correctIndex": 0,
    "explanation": "Desbalanceamento: modelo aprende a ignorar classe minoritária. SMOTE: gera amostras sintéticas interpolando vizinhos da classe minoritária. Undersampling: remove exemplos da majoritária (perda de dados). class_weight='balanced': penaliza erros na minoritária proporcionalmente. Focal Loss: (1-pt)^γ × CE — foca em exemplos difíceis (mal classificados). Threshold tuning: mover threshold de 0.5 para aumentar recall.",
    "example": "Fraude: 10k normal, 100 fraude. SMOTE gera 9.9k fraudes sintéticas (interpolação kNN). class_weight={0:1, 1:100}. Focal Loss γ=2: erros em fraudes pesam muito mais. Após treino: threshold=0.3 em vez de 0.5 para capturar mais fraudes (aumenta recall, reduz precision). PR-AUC melhor métrica que ROC-AUC para desbalanceados."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Fácil",
    "question": "Na Regressão Linear Simples, qual é o objetivo do algoritmo ao traçar uma reta nos dados?",
    "options": [
      "Minimizar a soma dos erros quadráticos entre os valores previstos e reais",
      "Encontrar a mediana dos dados",
      "Classificar dados em duas categorias",
      "Maximizar a distância entre os pontos"
    ],
    "correctIndex": 0,
    "explanation": "A Regressão Linear Simples encontra a reta y = ax + b que minimiza a soma dos quadrados dos resíduos (diferença entre valor real e previsto). Essa minimização é feita pelo método dos mínimos quadrados ordinários (OLS).",
    "example": "Dados de estudo (horas) vs nota: ajustar a reta nota = 5.2 × horas + 30. Para 4 horas de estudo, previsão: 5.2×4 + 30 = 50.8."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Fácil",
    "question": "O que é Regressão Linear Múltipla e como difere da Simples?",
    "options": [
      "Múltipla usa duas ou mais variáveis independentes; Simples usa apenas uma",
      "São idênticas",
      "Múltipla é não-linear",
      "Simples usa múltiplas variáveis"
    ],
    "correctIndex": 0,
    "explanation": "Regressão Linear Simples: y = ax + b (1 feature). Múltipla: y = a₁x₁ + a₂x₂ + ... + aₙxₙ + b (n features). Múltipla permite modelar relações mais complexas considerando múltiplos fatores. Os coeficientes indicam o impacto de cada feature mantendo as outras constantes.",
    "example": "Preço do imóvel = 2500 × área + 15000 × quartos + 50000 × piscina - 10000 × distância_centro + 80000. Cada coeficiente mede o impacto isolado daquela feature no preço."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Fácil",
    "question": "O que significa overfitting e underfitting em modelos de regressão?",
    "options": [
      "Overfitting: modelo decora o treino e falha em dados novos; underfitting: modelo é simples demais e falha em ambos",
      "São a mesma coisa",
      "Overfitting é bom",
      "Underfitting só ocorre com redes neurais"
    ],
    "correctIndex": 0,
    "explanation": "Overfitting: modelo muito complexo que captura ruído do treino (alta accuracy no treino, baixa no teste). Underfitting: modelo muito simples que não captura o padrão (baixa accuracy em ambos). O ideal é o equilíbrio que generaliza bem para dados novos.",
    "example": "Prever salário por experiência: underfitting = reta horizontal (ignora a relação). Bom fit = curva suave crescente. Overfitting = curva que passa por TODOS os pontos (inclusive outliers) mas erra previsões novas."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Fácil",
    "question": "O que são as features (variáveis independentes) e o target (variável dependente) em um modelo de regressão?",
    "options": [
      "Features são os dados de entrada usados para prever; target é o valor que se deseja prever",
      "Features são os resultados e target é a entrada",
      "São a mesma coisa",
      "Features são apenas números e target é texto"
    ],
    "correctIndex": 0,
    "explanation": "Em regressão, features (X) são as variáveis de entrada usadas para fazer previsões: área, localização, idade do imóvel. O target (y) é o valor que queremos prever: preço do imóvel. Mais features relevantes geralmente melhoram o modelo, mas features irrelevantes adicionam ruído.",
    "example": "Prever preço de casa: features = [área=120m², quartos=3, bairro='Centro', idade=5anos]. Target = preço=R$500k. O modelo aprende: preço ≈ 3000×área + 20000×quartos − 5000×idade."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Fácil",
    "question": "O que é o Gradient Descent e qual seu papel no treinamento de modelos de regressão?",
    "options": [
      "Algoritmo de otimização que ajusta os parâmetros iterativamente na direção que minimiza a função de custo",
      "É um tipo de modelo de classificação",
      "Método para visualizar dados",
      "Técnica para coletar mais dados"
    ],
    "correctIndex": 0,
    "explanation": "Gradient Descent calcula o gradiente (derivada parcial) da função de custo em relação a cada parâmetro, indicando a direção de maior crescimento. Os parâmetros são atualizados na direção OPOSTA: w = w − lr × ∂J/∂w. O learning rate (lr) controla o tamanho do passo. Convergência ocorre quando os gradientes se aproximam de zero.",
    "example": "Reta y = wx + b com w=0, b=0. Erro alto. Gradiente diz: 'aumente w em 2.5, aumente b em 1.3'. Novo: w=2.5, b=1.3. Erro diminui. Após 100 iterações: w=5.2, b=30.0 — reta convergiu."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Fácil",
    "question": "O que é o coeficiente angular (slope) em uma regressão linear simples e como interpretá-lo?",
    "options": [
      "Indica quanto y muda para cada unidade de aumento em x; é a inclinação da reta",
      "É o valor de y quando x é zero",
      "É a média de todos os valores de y",
      "É sempre um valor entre 0 e 1"
    ],
    "correctIndex": 0,
    "explanation": "Na equação y = ax + b, o coeficiente angular 'a' (slope) mede a taxa de variação: para cada aumento de 1 unidade em x, y muda em 'a' unidades. Se a > 0, relação positiva; se a < 0, relação negativa. O valor absoluto indica a força da relação.",
    "example": "salário = 2000 × experiência + 25000. Slope = 2000: cada ano a mais de experiência aumenta o salário previsto em R$2000. 5 anos → R$35000, 10 anos → R$45000. Se fosse -500: cada ano a mais DIMINUIRIA o salário (relação negativa, improvável aqui)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Fácil",
    "question": "O que é o intercepto (bias/b) na equação de regressão linear e qual seu significado prático?",
    "options": [
      "É o valor previsto de y quando todas as features são zero; é onde a reta cruza o eixo y",
      "É a inclinação da reta de regressão",
      "É o erro do modelo",
      "Não tem significado prático"
    ],
    "correctIndex": 0,
    "explanation": "Na equação y = ax + b, o intercepto 'b' é o valor base quando x=0. Nem sempre tem interpretação prática (ex: preço de uma casa com 0m² não faz sentido), mas é matematicamente necessário para posicionar a reta corretamente. Sem ele, a reta seria forçada a passar pela origem.",
    "example": "preço = 3000 × área + 50000. Intercepto = R$50000: é o 'preço base' teórico para área = 0m². Na prática, não existe imóvel de 0m², mas o intercepto ajusta a posição da reta. Se forçássemos b=0: reta passaria pela origem, previsões ruins para áreas pequenas."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Fácil",
    "question": "O que é o coeficiente de determinação R² e como interpretar seus valores?",
    "options": [
      "Proporção da variância da variável dependente explicada pelo modelo; R²=1 ajuste perfeito, R²=0 o modelo não explica nada, R²<0 é pior que a média",
      "Correlação entre features e target, sempre entre 0 e 1",
      "Erro médio quadrático normalizado pelo desvio padrão dos dados",
      "Número de features que o modelo usa efetivamente para predição"
    ],
    "correctIndex": 0,
    "explanation": "R² = 1 - SS_res/SS_tot. SS_res = soma dos quadrados dos resíduos. SS_tot = variância total dos dados (desvio em relação à média). R²=0.85: modelo explica 85% da variação. R²<0: possível com dados de teste se modelo treinou em distribuição diferente. Adjusted R² penaliza features irrelevantes adicionadas.",
    "example": "Previsão de preço de imóvel: R²=0.78 — 78% da variação de preço explicada por área, localização, quartos. 22% por fatores não capturados (reforma recente, vizinhança específica). R²=0.3 em previsão de ações: normal, pois mercado tem alta aleatoriedade. Sempre comparar R² treino vs teste para detectar overfitting."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Médio",
    "question": "Qual métrica de avaliação de regressão indica a proporção da variância da variável dependente explicada pelo modelo?",
    "options": [
      "R² (coeficiente de determinação)",
      "Acurácia",
      "F1-Score",
      "AUC-ROC"
    ],
    "correctIndex": 0,
    "explanation": "O R² varia de 0 a 1 (podendo ser negativo para modelos ruins). R²=1 indica que o modelo explica 100% da variância. R²=0.85 indica que 85% da variação nos dados é explicada pelo modelo, e 15% é variação residual não capturada.",
    "example": "Modelo de previsão de preço de imóvel com R² = 0.90: 90% da variação de preços é explicada pelas features (área, quartos, localização). 10% resta como ruído/fatores não modelados."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Médio",
    "question": "O que é cross-validation (validação cruzada) e por que é melhor que uma única divisão treino/teste?",
    "options": [
      "Divide os dados em K folds, treina em K-1 e testa em 1, repetindo K vezes; dá estimativa mais robusta",
      "Treina no dataset inteiro",
      "Usa apenas metade dos dados",
      "Só funciona com regressão"
    ],
    "correctIndex": 0,
    "explanation": "K-Fold Cross-Validation divide o dataset em K partes iguais. Em cada iteração, K-1 folds treinam e 1 fold testa. A métrica final é a média das K iterações. Evita dependência de uma única divisão aleatória e usa todos os dados para treino e teste.",
    "example": "K=5 com 1000 dados: Fold 1 testa 200, treina 800. Fold 2 testa outros 200, treina 800... Métricas: [0.85, 0.87, 0.83, 0.86, 0.84]. Média: 0.85 ± 0.015. Mais confiável que um único split 80/20."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Médio",
    "question": "Quais são as métricas MAE, MSE e RMSE e quando usar cada uma em regressão?",
    "options": [
      "MAE é média do erro absoluto; MSE é média do erro quadrado; RMSE é raiz do MSE, na mesma unidade dos dados",
      "São todas iguais",
      "Só MAE importa",
      "RMSE é para classificação"
    ],
    "correctIndex": 0,
    "explanation": "MAE (Mean Absolute Error): média de |real - previsto|, interpretável e robusto a outliers. MSE (Mean Squared Error): média de (real-previsto)², penaliza erros grandes. RMSE (Root MSE): √MSE, mesma unidade dos dados. RMSE > MAE sempre; grande diferença indica outliers.",
    "example": "Previsão de temperatura: erros [1, -2, 1, -1, 10]°C. MAE = 3.0°C. MSE = 21.4°C². RMSE = 4.63°C. RMSE >> MAE porque o erro 10°C é penalizado quadraticamente pelo MSE."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Médio",
    "question": "O que é multicolinearidade em Regressão Múltipla e como ela afeta os coeficientes?",
    "options": [
      "Correlação alta entre features que torna os coeficientes instáveis e difíceis de interpretar",
      "Quando o target tem múltiplos valores",
      "Quando há muitas features categóricas",
      "Quando o modelo tem R² muito alto"
    ],
    "correctIndex": 0,
    "explanation": "Multicolinearidade: features fortemente correlacionadas (ex: área em m² e área em pés²). O modelo não consegue separar o efeito individual de cada uma — coeficientes oscilam muito entre amostras. VIF > 10 indica multicolinearidade. Soluções: remover uma das features correlacionadas, usar PCA ou regularização Ridge.",
    "example": "Prever salário: features experiência e anos_na_empresa (correlação 0.95). Modelo 1: coef_experiência=5000, coef_anos=-200. Modelo 2 (outra amostra): coef_experiência=2000, coef_anos=2800. Instável! Remover uma resolve: coef_experiência=4500 (estável)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Médio",
    "question": "Como o R² ajustado difere do R² e por que é mais confiável em Regressão Múltipla?",
    "options": [
      "R² ajustado penaliza a adição de features que não melhoram o modelo, evitando inflação artificial do R²",
      "R² ajustado é sempre maior que R²",
      "São sempre iguais",
      "R² ajustado só se aplica a regressão simples"
    ],
    "correctIndex": 0,
    "explanation": "R² SEMPRE aumenta ao adicionar features, mesmo irrelevantes (como signo do zodíaco). R² ajustado penaliza features inúteis: R²ₐ = 1 − (1−R²)(n−1)/(n−p−1), onde p = nº de features. Se uma nova feature não melhora o modelo o suficiente, R² ajustado CAI, indicando que ela é desnecessária.",
    "example": "Prever nota: [horas_estudo] → R²=0.80, R²ₐ=0.79. Adiciona [cor_favorita] → R²=0.801 (subiu trivialmente), R²ₐ=0.78 (caiu!). Adiciona [frequência_aula] → R²=0.88, R²ₐ=0.87 (ambos subiram → feature útil)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Médio",
    "question": "O que é feature scaling e por que é essencial antes de aplicar regularização em regressão?",
    "options": [
      "Colocar features na mesma escala para que a regularização penalize coeficientes de forma justa, sem favorecer features de escala menor",
      "Feature scaling melhora o R² diretamente",
      "Só é necessário para redes neurais",
      "Regularização funciona igualmente sem scaling"
    ],
    "correctIndex": 0,
    "explanation": "Regularização penaliza coeficientes grandes. Se 'área' (0-500) tem coeficiente 200 e 'quartos' (0-10) tem coeficiente 50000, a penalidade recai mais sobre 'quartos' (coeficiente maior), mesmo que ambos sejam igualmente importantes. Padronizando (z-score), os coeficientes ficam comparáveis e a penalidade é justa.",
    "example": "Sem scaling: coef_área=200, coef_quartos=50000. Ridge penaliza quartos 62500× mais (50000²/200²). Com StandardScaler: coef_área=0.45, coef_quartos=0.52 → penalidades proporcionais. Modelo regularizado corretamente mantém ambas as features."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Médio",
    "question": "O que é Stochastic Gradient Descent (SGD) e como difere do Batch Gradient Descent?",
    "options": [
      "SGD atualiza pesos usando um exemplo por vez; Batch usa todos os exemplos, tornando SGD mais rápido mas com mais ruído",
      "SGD é mais lento que Batch",
      "SGD usa todos os dados de uma vez",
      "São idênticos em resultado e velocidade"
    ],
    "correctIndex": 0,
    "explanation": "Batch GD: calcula gradiente sobre TODOS os N exemplos, atualiza uma vez → convergência suave mas lenta para datasets grandes. SGD: calcula gradiente sobre 1 exemplo aleatório, atualiza imediatamente → rápido, mas oscila. Mini-batch GD (compromisso): usa B exemplos (ex: 32, 64) por atualização.",
    "example": "Dataset com 1M de exemplos. Batch: 1 atualização por época (processa 1M antes de ajustar). SGD: 1M atualizações por época (ajusta a cada exemplo). Mini-batch (B=64): ~15600 atualizações por época. SGD oscila mais, mas chega perto do mínimo muito mais rápido."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Médio",
    "question": "Como Ridge e Lasso diferem na regularização e qual a diferença prática no comportamento dos coeficientes?",
    "options": [
      "Ridge (L2) encolhe coeficientes sem zerar; Lasso (L1) pode zerar coeficientes completamente (feature selection implícita) por ser geometricamente anguloso",
      "Ridge remove features; Lasso encolhe uniformemente; Elastic Net combina as duas sem zerar nenhum coeficiente",
      "São idênticos matematicamente; a diferença é apenas computacional",
      "Ridge funciona somente para regressão logística; Lasso somente para regressão linear"
    ],
    "correctIndex": 0,
    "explanation": "Ridge (L2): penalidade = λΣβ². Gradiente suave: coeficientes tendem a zero mas nunca chegam lá — todos pequenos, nenhum exatamente zero. Lasso (L1): penalidade = λΣ|β|. Geometria rômbica: ótimo frequentemente cai em vértice com β=0. Feature selection automática. Elastic Net = αL1 + (1-α)L2: combina estabilidade de Ridge com esparsidade de Lasso.",
    "example": "10 features, 8 irrelevantes. Lasso (λ=0.1): 8 coeficientes zeraram automaticamente, modelo usa apenas 2 features relevantes. Ridge com mesmo λ: todos os 10 coeficientes continuam (mas pequenos). Quando features correlacionadas: Ridge distribui peso entre elas; Lasso escolhe uma arbitrariamente. Elastic Net: melhor nesse caso de multicolinearidade."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Difícil",
    "question": "Na Regressão Ridge (L2), como o term de regularização λ||w||² afeta os coeficientes do modelo e quando é preferível sobre Lasso (L1)?",
    "options": [
      "Ridge encolhe todos os coeficientes proporcionalmente sem zerar nenhum; preferível quando muitas features contribuem com pequeno efeito",
      "Ridge elimina features irrelevantes zerando coeficientes",
      "Ridge aumenta os coeficientes para melhorar performance",
      "Ridge e Lasso são matematicamente equivalentes"
    ],
    "correctIndex": 0,
    "explanation": "Ridge adiciona λΣwᵢ² à loss function, penalizando coeficientes grandes. Isso encolhe todos os coeficientes em direção a zero mas nunca os zera completamente (ao contrário de Lasso/L1 que pode zerar). Ridge é preferível quando muitas features são relevantes com efeitos moderados, enquanto Lasso é melhor para seleção de features.",
    "example": "Dataset com 100 genes influenciando uma doença: Ridge mantém todos os 100 coeficientes pequenos. Lasso zeraria ~80 genes, mantendo apenas ~20. Se todos forem relevantes, Ridge tem melhor poder preditivo."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Difícil",
    "question": "O que é Elastic Net e como combina Ridge e Lasso?",
    "options": [
      "Combina penalizações L1 (Lasso) e L2 (Ridge) em uma única função de loss com parâmetro de mistura",
      "É um tipo de rede neural",
      "Substitui ambos completamente",
      "Apenas para classificação"
    ],
    "correctIndex": 0,
    "explanation": "Elastic Net adiciona αλ∑|wᵢ| + (1-α)λ∑wᵢ² à loss. α=1 é Lasso puro, α=0 é Ridge puro. Elastic Net combina seleção de features do Lasso com estabilidade do Ridge. Ideal quando features são correlacionadas (onde Lasso seleciona arbitrariamente entre correlacionadas).",
    "example": "100 genes, 20 pares altamente correlacionados. Lasso: seleciona 1 de cada par aleatoriamente. Elastic Net (α=0.5): mantém ambos do par com coeficientes menores, resultado mais estável e robusto."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Difícil",
    "question": "O que é Regressão Polinomial e quando usá-la em vez de Regressão Linear?",
    "options": [
      "Adiciona termos polinomiais (x², x³) às features para modelar relações não-lineares; usar quando a relação não é linear",
      "É sempre melhor que linear",
      "Só funciona com 2 variáveis",
      "Não existe"
    ],
    "correctIndex": 0,
    "explanation": "Regressão Polinomial expande as features: x → [x, x², x³, ...]. Ainda é 'linear' nos parâmetros (y = a + bx + cx²), então usa OLS. Grau alto = overfitting, grau baixo = underfitting. Usar quando gráfico dos dados mostra curvatura que reta não captura.",
    "example": "Velocidade vs consumo de combustível: relação parabólica (consome mais em baixa e alta velocidade). Linear: R²=0.40. Polinomial grau 2: y = ax² + bx + c, R²=0.92. Grau 10: R² treino=0.99, R² teste=0.60 (overfitting)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Difícil",
    "question": "O que é regularização em modelos de regressão e por que é necessária?",
    "options": [
      "Técnica que adiciona penalidade à magnitude dos coeficientes para evitar overfitting e melhorar a generalização",
      "Técnica para aumentar o número de features",
      "Método de coleta de dados",
      "Forma de aumentar a complexidade do modelo"
    ],
    "correctIndex": 0,
    "explanation": "Regularização adiciona um termo de penalidade à função de custo: J(w) + λ×penalty. L1 (Lasso): penalty = Σ|wᵢ| (pode zerar coeficientes). L2 (Ridge): penalty = Σwᵢ² (encolhe coeficientes). λ controla a força: λ=0 → sem regularização, λ=∞ → todos os coeficientes vão a zero.",
    "example": "Modelo com 50 features: sem regularização, coeficientes: [500, -300, 200, ...] → overfitting. Ridge (λ=1): coeficientes: [5, -3, 2, ...] → generalizou. Lasso (λ=1): coeficientes: [5, 0, 2, 0, 0, ...] → eliminou 30 features irrelevantes."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Difícil",
    "question": "Como a Bayesian Linear Regression difere da abordagem frequentista tradicional?",
    "options": [
      "Trata os parâmetros como distribuições de probabilidade em vez de pontos fixos, incorporando incerteza nas previsões",
      "Usa mais dados para treinar",
      "É idêntica à regressão linear padrão",
      "Não usa probabilidades"
    ],
    "correctIndex": 0,
    "explanation": "Regressão frequentista estima um único valor para cada coeficiente. Bayesiana trata cada coeficiente como uma distribuição: prior (crença inicial) × likelihood (dados) = posterior (crença atualizada). Resultado: não apenas a predição, mas também intervalos de confiança. Útil quando dados são escassos ou incerteza é importante.",
    "example": "Prever preço com 10 dados: Frequentista: preço = 5000×área + 80000, ponto único. Bayesiana: preço = N(5000,±800)×área + N(80000,±15000). Previsão para 100m²: R$580k com intervalo [R$520k, R$640k]. A incerteza está explícita."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Difícil",
    "question": "O que é Quantile Regression e como difere da regressão linear padrão que estima a média?",
    "options": [
      "Estima quantis condicionais (mediana, percentil 90) em vez da média, capturando a distribuição completa da resposta",
      "É idêntica à regressão linear",
      "Só funciona com dados normalmente distribuídos",
      "Estima a moda em vez da média"
    ],
    "correctIndex": 0,
    "explanation": "Regressão linear padrão estima E[Y|X] (média condicional). Quantile Regression estima Q_τ[Y|X] para qualquer quantil τ ∈ (0,1). Minimiza a função de perda assimétrica: ρ_τ(u) = u(τ − I(u<0)). Captura como diferentes partes da distribuição de Y respondem a X, sendo robusta a outliers.",
    "example": "Prever salário por experiência: Regressão Linear → salário médio = 5000×exp + 30000. Quantile τ=0.5 (mediana) → 4800×exp + 28000 (robusto a CEOs). τ=0.9 (topo) → 8000×exp + 50000 (como os maiores salários crescem). τ=0.1 → 3000×exp + 22000 (pisos salariais)."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Difícil",
    "question": "O que é heteroscedasticidade em regressão e como ela viola premissas do modelo linear?",
    "options": [
      "Variância dos resíduos não é constante ao longo dos valores previstos, violando a premissa de homocedasticidade",
      "Os resíduos não seguem distribuição normal",
      "As features são correlacionadas entre si",
      "O modelo tem muitas variáveis"
    ],
    "correctIndex": 0,
    "explanation": "Homocedasticidade: Var(ε|X) = σ² constante. Heteroscedasticidade: Var(ε|X) varia com X. Consequência: estimadores OLS continuam não-viesados mas não são mais eficientes (BLUE). Erros padrão são incorretos → testes de hipótese e intervalos de confiança inválidos. Soluções: WLS, erros robustos de White, transformação log.",
    "example": "Prever gastos por renda: baixa renda → gastos variam pouco (R$1k-3k). Alta renda → gastos variam muito (R$5k-50k). Gráfico resíduos vs preditos: forma de 'funil'. Teste de Breusch-Pagan: p < 0.05 → heteroscedasticidade. Solução: log(gastos) ~ renda, ou erros robustos HC3 de White."
  },
  {
    "id": "machine-learning-e-ia__Algoritmos de Regressão__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "Algoritmos de Regressão",
    "difficulty": "Difícil",
    "question": "O que é heteroscedasticidade em regressão e como diagnosticar e tratar?",
    "options": [
      "Variância dos resíduos não é constante (varia com o valor previsto ou uma feature); diagnóstico: Breusch-Pagan test, gráfico resíduos vs fitted; tratamento: transformação log(y), WLS ou modelos robustos",
      "Correlação serial entre resíduos em séries temporais; tratamento com ARIMA",
      "Multicolinearidade severa entre features; diagnosticada por VIF alto",
      "Ausência de linearidade entre features e target; tratada com features polinomiais"
    ],
    "correctIndex": 0,
    "explanation": "Homocedasticidade (pressuposto OLS): Var(ε)=σ² constante. Heterocedasticidade: Var(ε) varia — ex: resíduos maiores para valores maiores de Y. Consequências: OLS ainda não-enviesado mas não mais BLUE, p-values e IC inválidos. Diagnóstico: resíduo vs fitted plot (cone), Breusch-Pagan, White test. Tratamentos: transformar Y (log, sqrt), WLS (pesos inversamente proporcionais à variância), HC standard errors (erros robustos).",
    "example": "Preço de casas: resíduos menores para imóveis baratos, maiores para mansões. Plot cone crescente. log(preço) como target: heterocedasticidade frequentemente desaparece. WLS: peso_i = 1/variancia_i para imóvel i. statsmodels: sm.OLS(...).fit(cov_type='HC3') para inferência robusta sem transformar Y."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Fácil",
    "question": "Qual algoritmo de clustering agrupa dados em K clusters baseando-se na distância até centróides iterativamente recalculados?",
    "options": [
      "K-Means",
      "DBSCAN",
      "KNN",
      "Regressão Linear"
    ],
    "correctIndex": 0,
    "explanation": "K-Means particiona n dados em K clusters. Inicializa K centróides, atribui cada ponto ao centróide mais próximo, recalcula os centróides como média dos pontos do cluster, e repete até convergir. É necessário definir K previamente.",
    "example": "Para segmentar clientes em 3 grupos: K-Means com K=3 itera até estabilizar. Resultado: Cluster 1 (alto valor), Cluster 2 (frequentes, baixo valor), Cluster 3 (inativos)."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Fácil",
    "question": "O que é redução de dimensionalidade e por que PCA é importante?",
    "options": [
      "PCA reduz o número de features projetando dados nos eixos de maior variância, preservando informação",
      "PCA aumenta as dimensões",
      "PCA é um algoritmo de classificação",
      "Só funciona com 2 features"
    ],
    "correctIndex": 0,
    "explanation": "PCA (Principal Component Analysis) encontra as direções (componentes principais) de maior variância nos dados e projeta os dados nessas direções. Reduz dimensionalidade eliminando componentes de baixa variância. Útil para visualização (reduzir para 2D/3D) e remover ruído.",
    "example": "Dataset com 100 features. PCA: 2 primeiros componentes explicam 85% da variância. Reduz de 100 para 2 features para visualização em scatter plot, mantendo 85% da informação."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre aprendizado supervisionado e não supervisionado?",
    "options": [
      "Supervisionado usa dados rotulados (features + target); não supervisionado encontra padrões sem rótulos",
      "São iguais",
      "Não supervisionado é sempre melhor",
      "Supervisionado não precisa de dados"
    ],
    "correctIndex": 0,
    "explanation": "Supervisionado: dados têm features (X) e target (y). O modelo aprende a relação X→y (classificação, regressão). Não supervisionado: dados têm apenas features, sem rótulos. O modelo descobre estruturas ocultas (clusters, anomalias, dimensões). Semi-supervisionado: mistura dos dois.",
    "example": "Supervisionado: fotos rotuladas 'gato'/'cachorro' → modelo aprende a classificar. Não supervisionado: fotos sem rótulos → modelo agrupa fotos semelhantes sem saber as categorias."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Fácil",
    "question": "O que é o algoritmo de Associação (Association Rules) e onde é aplicado?",
    "options": [
      "Descobre relações frequentes entre itens em transações, como análise de cesta de compras",
      "É um algoritmo de classificação supervisionada",
      "Agrupa dados por distância",
      "Reduz dimensionalidade"
    ],
    "correctIndex": 0,
    "explanation": "Association Rules (ex: Apriori, FP-Growth) encontram padrões como 'quem compra pão também compra manteiga'. Métricas: Support (frequência da combinação), Confidence (probabilidade condicional), Lift (quanto um item influencia o outro). É não supervisionado pois aprende padrões sem target.",
    "example": "Supermercado, 10000 transações. Regra: {fraldas} → {cerveja}: support=5%, confidence=70%, lift=2.3. Significa: quem compra fraldas tem 70% de chance de comprar cerveja (2.3x mais que aleatório). Colocar juntos no corredor."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Fácil",
    "question": "O que é o algoritmo de clustering GMM (Gaussian Mixture Model) e como difere do K-Means?",
    "options": [
      "GMM modela clusters como distribuições gaussianas, permitindo sobreposição e clusters elípticos vs K-Means que usa distância e forma circular",
      "São idênticos",
      "GMM é supervisionado",
      "K-Means é mais flexível"
    ],
    "correctIndex": 0,
    "explanation": "K-Means atribui cada ponto a exatamente 1 cluster (hard assignment) com clusters esféricos. GMM usa distribuições gaussianas e atribui probabilidades de pertencimento (soft assignment): o ponto pode ter 60% de chance de pertencer ao cluster A e 40% ao B. Clusters podem ser elípticos.",
    "example": "Dados de altura e peso: K-Means faz 2 círculos. GMM com 2 gaussianas encontra uma elipse para mulheres e outra para homens, com sobreposição na fronteira. Ponto 170cm/65kg: 55% grupo A, 45% grupo B."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Fácil",
    "question": "O que é a 'inércia' (WCSS) no K-Means e como interpretar seu valor?",
    "options": [
      "É a soma das distâncias quadráticas de cada ponto ao centróide do seu cluster; quanto menor, clusters mais compactos",
      "É a velocidade de convergência do algoritmo",
      "É o número de clusters ideal",
      "É a distância entre centróides"
    ],
    "correctIndex": 0,
    "explanation": "Inércia (WCSS — Within-Cluster Sum of Squares) = Σ Σ ||xᵢ − μₖ||², onde μₖ é o centróide do cluster k. Inércia alta = pontos distantes dos centróides (clusters diluídos). Inércia baixa = clusters compactos. Mas inércia SEMPRE diminui ao aumentar K (com K=N, inércia=0), então não serve sozinha.",
    "example": "K=2: inércia=500 (clusters grandes). K=3: inércia=200 (mais compactos). K=10: inércia=50 (cada cluster ~3 pontos). K=N: inércia=0 (trivial). O Elbow Method acha onde a queda de inércia desacelera — o ponto 'ótimo' balanceia compactação vs simplicidade."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Fácil",
    "question": "O que é aprendizado semi-supervisionado e quando ele é útil?",
    "options": [
      "Combina poucos dados rotulados com muitos não rotulados para melhorar o modelo, útil quando rotular é caro",
      "É idêntico ao supervisionado",
      "Usa apenas dados sem rótulos",
      "Requer todos os dados rotulados"
    ],
    "correctIndex": 0,
    "explanation": "Aprendizado semi-supervisionado utiliza um pequeno conjunto de dados rotulados junto com um grande volume de dados não rotulados. Técnicas: self-training (modelo rotula dados, retreina), label propagation (propaga rótulos por similaridade), pseudo-labels. Ideal quando rotular é caro (exames médicos, anotação de imagens).",
    "example": "Diagnosticar raio-X: 100 imagens rotuladas por médicos (caro!) + 10000 sem rótulo disponíveis. Supervisionado com 100: accuracy 70%. Semi-supervisionado: modelo treina com 100, rotula as 10000 com alta confiança, retreina → accuracy 85%. Quase o mesmo que ter 5000 rótulos."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Fácil",
    "question": "Como o algoritmo K-Means define e atualiza os clusters iterativamente?",
    "options": [
      "Inicializa K centroides aleatórios, atribui cada ponto ao centroide mais próximo, recalcula centroides como média do cluster; repete até convergência",
      "Constrói dendrograma hierárquico mesclando os dois pontos mais próximos a cada passo",
      "Usa rede neural para aprender representação comprimida e agrupa no espaço latente",
      "Calcula a densidade de pontos em cada região e marca regiões densas como clusters"
    ],
    "correctIndex": 0,
    "explanation": "K-Means: minimiza a inércia (soma das distâncias quadráticas ao centroide). Passos: 1) Inicializar K centroides (K-Means++ melhora inicialização). 2) Atribuição: cada ponto vai ao centroide mais próximo (distância euclidiana). 3) Atualização: centroide = média de todos os pontos do cluster. Repetir 2 e 3 até centroides não moverem. Sensível a outliers e escala — normalizar antes.",
    "example": "Segmentação de clientes: K=3. Iter 1: centroide aleatório. Iter 2: clientes de alta renda agrupam perto de um centroide, jovens próximos de outro. Convergência em ~20 iterações. Elbow method: testar K=1..10, plot inércia — cotovelo indica K ótimo. K-Means++ evita inicialização ruim com centroides espalhados."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Médio",
    "question": "Qual método é usado para determinar o número ideal de clusters K no algoritmo K-Means?",
    "options": [
      "Método do Cotovelo (Elbow Method) com inércia (WCSS)",
      "Dividir o dataset ao meio",
      "Usar sempre K = número de features",
      "Testar K = 1 e parar"
    ],
    "correctIndex": 0,
    "explanation": "O Elbow Method plota o valor de inércia (soma das distâncias quadráticas de cada ponto ao seu centróide — WCSS) para diferentes valores de K. O ponto de 'cotovelo' onde a redução da inércia desacelera significativamente indica o K ideal. Complementa-se com Silhouette Score.",
    "example": "K=1: inércia=1000, K=2: 500, K=3: 300, K=4: 280, K=5: 270. O cotovelo está em K=3: após 3, a inércia cai muito pouco. K ideal = 3."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Médio",
    "question": "O que é o Silhouette Score e como complementa o Elbow Method?",
    "options": [
      "Mede quão similar um ponto é ao seu cluster vs clusters vizinhos; varia de -1 a 1, quanto maior melhor",
      "Mede a velocidade do algoritmo",
      "Conta número de clusters",
      "Mede a distância ao centróide"
    ],
    "correctIndex": 0,
    "explanation": "Silhouette Score s(i) = (b(i)-a(i))/max(a(i),b(i)). a(i) = distância média intra-cluster, b(i) = distância média ao cluster vizinho mais próximo. s=1: ponto bem agrupado. s=0: na fronteira. s=-1: provavelmente no cluster errado. Média global avalia a qualidade geral.",
    "example": "K=2: silhouette=0.71 (bom). K=3: silhouette=0.65. K=4: silhouette=0.45. K=5: silhouette=0.30. Melhor K=2 pelo silhouette, mesmo que elbow sugira K=3. Usar ambos para decisão."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Médio",
    "question": "O que é clustering hierárquico e como o dendrograma ajuda a escolher K?",
    "options": [
      "Monta hierarquia de clusters por merge (aglomerativo) ou split (divisivo); dendrograma mostra a estrutura e onde cortar",
      "Tipo de árvore de decisão",
      "Regressão hierárquica",
      "K-Means com múltiplos níveis"
    ],
    "correctIndex": 0,
    "explanation": "Clustering Hierárquico Aglomerativo: começa com N clusters (1 por ponto) e itera fundindo os 2 mais próximos até restar 1. O dendrograma é uma árvore que mostra a ordem das fusões. 'Cortar' o dendrograma em determinada altura define o número de clusters. Não requer K prévio.",
    "example": "5 pontos: A,B,C,D,E. Merge 1: {A,B}. Merge 2: {D,E}. Merge 3: {A,B,C}. Merge 4: {A,B,C,D,E}. Cortando na altura do Merge 3, temos 2 clusters: {A,B,C} e {D,E}."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Médio",
    "question": "O que é a métrica Adjusted Rand Index (ARI) e para que serve em clustering?",
    "options": [
      "Mede a concordância entre clusters previstos e rótulos reais, ajustado para chance; varia de -1 a 1",
      "Mede a distância entre centróides",
      "Conta o número ideal de clusters",
      "É uma métrica de regressão"
    ],
    "correctIndex": 0,
    "explanation": "ARI (Adjusted Rand Index) compara a atribuição de clusters com rótulos verdadeiros (quando disponíveis para validação). ARI=1: concordância perfeita. ARI=0: resultado esperado aleatoriamente. ARI<0: pior que aleatório. É ajustado para chance, diferente do Rand Index puro.",
    "example": "K-Means com K=3 nos dados Iris (3 espécies reais). ARI=0.73: boa concordância. Com K=5: ARI=0.55 (clusters desnecessários). Comparando K-Means (ARI=0.73) vs GMM (ARI=0.89) → GMM captura melhor a estrutura natural das espécies."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Médio",
    "question": "Como funciona a técnica de Clustering Espectral e quando é preferível ao K-Means?",
    "options": [
      "Usa autovalores da matriz de similaridade para reduzir dimensões antes do clustering; ideal para clusters não-convexos",
      "É uma versão mais rápida do K-Means",
      "Funciona apenas com dados textuais",
      "Não precisa de K"
    ],
    "correctIndex": 0,
    "explanation": "Spectral Clustering: 1) Constrói grafo de similaridade entre pontos. 2) Calcula Laplaciana do grafo. 3) Extrai os K menores autovalores/autovetores. 4) Aplica K-Means nos autovetores. Captura estrutura por conectividade, não por forma ou distância, funcionando para clusters com formas arbitrárias.",
    "example": "Dados em formato de duas meias-luas entrelaçadas: K-Means falha (assume clusters circulares). Spectral Clustering: constrói grafo → autovetores separam perfeitamente as duas luas. Computational cost: O(n³), então inviável para n>10000."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Médio",
    "question": "O que é HDBSCAN e quais vantagens oferece sobre o DBSCAN padrão?",
    "options": [
      "Versão hierárquica do DBSCAN que não requer o parâmetro eps e detecta clusters de densidades variadas",
      "É uma versão mais rápida do K-Means",
      "Requer mais parâmetros que DBSCAN",
      "Funciona apenas com dados 2D"
    ],
    "correctIndex": 0,
    "explanation": "HDBSCAN (Hierarchical DBSCAN) constrói uma hierarquia de clusterings para diferentes valores de eps, extraindo os clusters mais estáveis. Vantagens: não precisa definir eps (apenas min_cluster_size), detecta clusters com densidades diferentes (DBSCAN usa eps global), e é mais robusto a ruído.",
    "example": "Dados com cluster denso (100 pontos em 1cm²) e cluster esparso (50 pontos em 10cm²). DBSCAN com eps=0.5: encontra o denso, classifica o esparso como ruído. HDBSCAN: encontra ambos os clusters, adaptando a 'escala' automaticamente. min_cluster_size=10 é o único parâmetro essencial."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Médio",
    "question": "O que é a Maldição da Dimensionalidade e como afeta algoritmos de clustering?",
    "options": [
      "Em alta dimensionalidade, distâncias entre pontos convergem e clusters se tornam indistinguíveis",
      "Mais dimensões sempre melhoram o clustering",
      "Só afeta redes neurais",
      "É um problema de falta de memória RAM"
    ],
    "correctIndex": 0,
    "explanation": "Com muitas dimensões, a distância entre qualquer par de pontos se torna quase igual (todas as distâncias convergem para um valor similar). Isso quebra algoritmos baseados em distância (KNN, K-Means, DBSCAN). Soluções: redução de dimensionalidade (PCA, UMAP) antes do clustering, seleção de features, ou métricas de distância adaptadas.",
    "example": "100 pontos em 2D: distâncias variam de 0.1 a 10.0 (100×). Em 1000D: distâncias variam de 28.5 a 32.0 (1.12×). Tudo fica 'igualmente distante'. K-Means em 2D: clusters claros. K-Means em 1000D: clusters aleatórios sem significado. Solução: PCA para 50D → K-Means funciona."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Médio",
    "question": "O que é PCA (Principal Component Analysis) e como interpretar os componentes principais?",
    "options": [
      "PCA encontra combinações lineares das features (componentes) que maximizam variância explicada em ordem decrescente; componentes são ortogonais entre si",
      "Algoritmo de clustering que projeta dados em k dimensões maximizando separabilidade",
      "Técnica de regularização que remove features correlacionadas diretamente",
      "Rede neural de compressão que aprende representação não-linear dos dados"
    ],
    "correctIndex": 0,
    "explanation": "PCA: decomposição espectral da matriz de covariância. Autovalores = variância capturada. Autovetores = direções (componentes principais). PC1 = maior variância. PC2 = segunda maior, ortogonal à PC1. Scree plot: variância acumulada por componente. Escolha: componentes que explicam 90-95% da variância total. Interpretação: cada PC é combinação linear de features originais com pesos (loadings).",
    "example": "Dataset com 50 features de imagens faciais. PCA: PC1 explica 40% (iluminação geral), PC2 12% (orientação facial), PC3 8% (expressão). Com 10 componentes: 85% da variância. Reduz de 50 para 10 dimensões. Biplot: loadings mostram quais features originais mais influenciam cada PC. Normalizar antes (Z-score)."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Difícil",
    "question": "Como o algoritmo DBSCAN (Density-Based Spatial Clustering) identifica clusters de forma arbitrária e detecta outliers sem definir K?",
    "options": [
      "Usa dois parâmetros (eps e minPts) para encontrar regiões densas conectadas, classificando pontos isolados como ruído",
      "Usa K centróides como K-Means",
      "Calcula a média global e separa por desvio padrão",
      "Usa árvores de decisão para agrupar"
    ],
    "correctIndex": 0,
    "explanation": "DBSCAN define: 'core point' = ponto com ≥ minPts vizinhos dentro do raio eps. 'Border point' = está na vizinhança de um core point mas tem < minPts vizinhos. 'Noise' = nem core nem border. Clusters são formados conectando core points que estão a ≤ eps de distância. Descobre clusters de forma arbitrária e identifica outliers naturalmente.",
    "example": "eps=0.5, minPts=5. Ponto A tem 7 vizinhos a ≤ 0.5 → core point. Ponto B tem 3 vizinhos → se um é A, B é border. Ponto C tem 0 vizinhos → noise (outlier). Clusters formam-se pela cadeia de core points conectados."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Difícil",
    "question": "O que é t-SNE e como difere de PCA para visualização de dados de alta dimensionalidade?",
    "options": [
      "t-SNE preserva vizinhanças locais (não-linear); PCA preserva variância global (linear). t-SNE é melhor para visualizar clusters",
      "São idênticos",
      "PCA é não-linear",
      "t-SNE é linear"
    ],
    "correctIndex": 0,
    "explanation": "PCA: projeção linear que preserva variância global (direções de maior dispersão). t-SNE: técnica não-linear que preserva similaridades locais (pontos próximos em alta dimensão ficam próximos em 2D). t-SNE é melhor para revelar clusters mas não preserva distâncias globais e é estocástico.",
    "example": "MNIST (dígitos 0-9): PCA 2D mostra blocos sobrepostos. t-SNE 2D mostra 10 clusters claramente separados, cada um correspondendo a um dígito. t-SNE revela a estrutura local que PCA perde."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Difícil",
    "question": "O que é Isolation Forest e como ele detecta anomalias de forma diferente de métodos baseados em distância?",
    "options": [
      "Isola anomalias usando árvores aleatórias: outliers precisam de menos splits para serem isolados",
      "Usa distância euclidiana",
      "K-Means adaptado",
      "Regressão para detectar outliers"
    ],
    "correctIndex": 0,
    "explanation": "Isolation Forest constrói árvores com splits aleatórios em features e valores aleatórios. Anomalias são pontos 'fáceis de isolar' (requerem poucos splits). Pontos normais em regiões densas requerem muitos splits. O 'anomaly score' é baseado no path length médio. Eficiente: O(n log n), funciona em alta dimensionalidade.",
    "example": "100 transações normais (~R$50-200) + 1 fraude (R$50.000). Isolation Forest: ponto R$50.000 é isolado em 2 splits (valor>10000, valor>40000). Pontos normais precisam de 8+ splits. Score de anomalia alto = provável fraude."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Difícil",
    "question": "O que são Autoencoders e como são usados para detecção de anomalias?",
    "options": [
      "Redes que comprimem dados em representação menor e reconstroem; anomalias têm erro de reconstrução alto",
      "São algoritmos de classificação",
      "Geram dados novos como GANs",
      "Só funcionam com imagens"
    ],
    "correctIndex": 0,
    "explanation": "Autoencoder: Encoder comprime input → representação latente (bottleneck) → Decoder reconstrói output. Treinado apenas com dados normais. Quando recebe uma anomalia, a reconstrução é ruim (alto erro). Limiar de erro define anomalia. Variante: Variational Autoencoder (VAE) para geração de dados.",
    "example": "Autoencoder treinado com ECGs normais. ECG normal: reconstrução quase perfeita, erro=0.02. ECG com arritmia: reconstrução distorcida, erro=0.35. Limiar=0.15 → alerta de anomalia cardíaca. Usado em monitoramento hospitalar 24/7."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Difícil",
    "question": "O que é UMAP e como se compara ao t-SNE para visualização de dados em alta dimensão?",
    "options": [
      "UMAP é mais rápido que t-SNE, preserva melhor a estrutura global e permite transformar novos pontos",
      "São algoritmos idênticos",
      "t-SNE é sempre superior",
      "UMAP é um algoritmo de clustering"
    ],
    "correctIndex": 0,
    "explanation": "t-SNE: O(n²), preserva estrutura local, não permite transform de novos pontos, stochastic (resultados variam). UMAP: O(n log n), preserva estruturas local E global, permite transform (fit_transform + transform), determinístico com seed. Ambos reduzem para 2D/3D para visualização.",
    "example": "Dataset MNIST (70k dígitos): t-SNE em 50 min, clusters claros mas layout instável. UMAP em 3 min, clusters claros E distâncias entre clusters preservadas (1 e 7 próximos, 1 e 8 distantes). Para novos dados, UMAP.transform() é instantâneo."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Difícil",
    "question": "O que é Non-negative Matrix Factorization (NMF) e onde é aplicada em aprendizado não supervisionado?",
    "options": [
      "Decompõe uma matriz não-negativa em dois fatores não-negativos, encontrando partes interpretáveis; usada em topic modeling e decomposição de sinais",
      "É idêntica ao PCA",
      "Só funciona com dados negativos",
      "É um algoritmo de classificação supervisionada"
    ],
    "correctIndex": 0,
    "explanation": "NMF fatora V ≈ W × H onde V, W, H ≥ 0. A restrição de não-negatividade gera partes aditivas interpretáveis (ao contrário de PCA que permite subtração). Em texto: W = documentos × tópicos, H = tópicos × palavras. Em imagens: partes de rostos (olhos, nariz) detectadas individualmente.",
    "example": "Corpus de 1000 artigos: NMF com 5 tópicos. Tópico 1: [esporte, gol, campeonato]. Tópico 2: [economia, inflação, juros]. Artigo X = 0.7×Tópico1 + 0.3×Tópico3 (soma de partes, não subtração). PCA daria: 0.5×PC1 − 0.3×PC2, difícil de interpretar."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Difícil",
    "question": "O que é Contrastive Learning e como funciona no contexto de aprendizado auto-supervisionado?",
    "options": [
      "Aprende representações aproximando exemplos similares (positivos) e afastando dissimilares (negativos) no espaço latente",
      "É uma forma de classificação supervisionada",
      "Usa apenas exemplos positivos",
      "Requer dados rotulados"
    ],
    "correctIndex": 0,
    "explanation": "Contrastive Learning cria pares: positivos (duas augmentações da mesma imagem) e negativos (imagens diferentes). A loss (ex: InfoNCE, NT-Xent) maximiza similaridade entre positivos e minimiza entre negativos. Produz representações universais SEM rótulos. SimCLR, MoCo e BYOL são frameworks populares.",
    "example": "SimCLR: foto de gato → crop aleatório A e flip B (par positivo). Foto de carro C (negativo). Encoder mapeia: sim(A,B) = 0.95 (puxar juntos), sim(A,C) = 0.10 (empurrar). Após pré-treino auto-supervisionado, fine-tune com 1% dos rótulos atinge 85% da accuracy (vs 90% com 100% dos rótulos)."
  },
  {
    "id": "machine-learning-e-ia__Aprendizado Não Supervisionado__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "Aprendizado Não Supervisionado",
    "difficulty": "Difícil",
    "question": "Como o algoritmo DBSCAN difere do K-Means e quais tipos de clusters ele consegue detectar?",
    "options": [
      "DBSCAN detecta clusters de forma arbitrária e identifica outliers via densidade; não requer K predefindo; falha em clusters de densidades muito diferentes (problema de densidade variável)",
      "DBSCAN é hierárquico e requer K assim como K-Means; diferença é na métrica de distância",
      "É variante do K-Means com inicialização determinística que elimina sensibilidade ao ponto inicial",
      "Algoritmo espectral que usa grafo de vizinhança; clusters sempre esféricos como K-Means"
    ],
    "correctIndex": 0,
    "explanation": "DBSCAN: parâmetros ε (raio) e minPts (mínimo de pontos no raio). Core point: tem ≥minPts em ε. Border point: está em ε de core point mas tem <minPts. Noise (outlier): não é core nem border. Clusters: regiões densas conectadas de core points. Detecta formas arbitrárias (lua crescente, espiral). Não escala bem para alta dimensionalidade (curse of dimensionality afeta métrica de distância).",
    "example": "Dados em forma de espiral: K-Means falha (assume esférico). DBSCAN ε=0.5, minPts=5: segue a densidade da espiral. Anomalia detection: pontos de ruído = outliers naturais. HDBSCAN: extensão hierárquica que lida com densidade variável entre clusters. scikit-learn: DBSCAN(eps=0.5, min_samples=5).fit(X)."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Fácil",
    "question": "Em uma rede neural artificial, qual é a função de uma 'camada oculta' (hidden layer)?",
    "options": [
      "Aprender representações intermediárias dos dados transformando features via pesos e funções de ativação",
      "Receber os dados de entrada",
      "Produzir a saída final do modelo",
      "Armazenar os dados de treinamento"
    ],
    "correctIndex": 0,
    "explanation": "Camadas ocultas aplicam transformações lineares (multiplicação por pesos + bias) seguidas de funções de ativação não-lineares. Cada camada aprende representações de nível crescente de abstração — as primeiras capturam features simples, as mais profundas capturam padrões complexos.",
    "example": "Reconhecimento facial: camada 1 detecta bordas, camada 2 combina em formas (olhos, nariz), camada 3 combina em faces. Entrada (pixels) → representações cada vez mais abstratas → classificação."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Fácil",
    "question": "Qual função de ativação é mais usada em camadas ocultas de redes neurais modernas e por quê?",
    "options": [
      "ReLU (Rectified Linear Unit): f(x) = max(0, x); é rápida e evita o problema de vanishing gradient",
      "Sigmoid",
      "Tangente Hiperbólica",
      "Linear"
    ],
    "correctIndex": 0,
    "explanation": "ReLU retorna 0 para inputs negativos e o próprio valor para positivos. Vantagens sobre sigmoid/tanh: não satura para valores positivos (evita vanishing gradient), computação simples (apenas comparação), induz esparsidade (neurônios com input negativo ficam inativos).",
    "example": "ReLU(5) = 5, ReLU(-3) = 0, ReLU(0.1) = 0.1. Sigmoid(5) = 0.993 (quase satura, gradiente ~0). ReLU não satura para positivos, mantendo gradientes saudáveis durante backpropagation."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Fácil",
    "question": "O que é um perceptron e como ele se relaciona com redes neurais?",
    "options": [
      "Neurônio artificial mais simples: soma ponderada de inputs + bias, passada por função de ativação; é a unidade básica de redes neurais",
      "Tipo de kernel",
      "Algoritmo de clustering",
      "Otimizador"
    ],
    "correctIndex": 0,
    "explanation": "O perceptron calcula z = Σ(wᵢxᵢ) + b e aplica uma função de ativação. Um único perceptron resolve apenas problemas linearmente separáveis. Empilhando perceptrons em camadas (Multi-Layer Perceptron/MLP) cria-se uma rede neural que resolve problemas não-lineares.",
    "example": "Perceptron: z = 0.3×renda + 0.5×score - 0.2×dívidas + 0.1 (bias). Se z > 0 → aprovar. A rede neural é composta por centenas desses perceptrons interconectados em camadas."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Fácil",
    "question": "O que é uma CNN (Convolutional Neural Network) e para que tipo de dados é mais indicada?",
    "options": [
      "Rede neural com camadas de convolução que extraem features espaciais; ideal para imagens e dados com estrutura espacial",
      "É uma rede neural genérica para qualquer tipo de dados",
      "É usada apenas para texto",
      "Não usa camadas ocultas"
    ],
    "correctIndex": 0,
    "explanation": "CNNs usam filtros (kernels) que deslizam pela imagem detectando padrões locais. Camadas iniciais detectam bordas simples, camadas profundas detectam objetos complexos. Pooling reduz dimensão. Compartilhamento de pesos torna eficiente. Aplicações: visão computacional, processamento de áudio (espectrogramas).",
    "example": "Classificar dígitos MNIST (28×28 pixels): Camada Conv1 (32 filtros 3×3) → Pool → Conv2 (64 filtros 3×3) → Pool → Flatten → Dense(128) → Dense(10, softmax). Accuracy: 99.2% com apenas ~100k parâmetros."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Fácil",
    "question": "O que são epochs, batch size e iterações no treinamento de redes neurais?",
    "options": [
      "Epoch = 1 passada completa pelo dataset; batch = subconjunto processado de cada vez; iterações = nº de batches por epoch",
      "São a mesma coisa",
      "Epochs são medidas de accuracy",
      "Batch size é o tamanho total dos dados"
    ],
    "correctIndex": 0,
    "explanation": "1 Epoch = todos os dados passam pela rede uma vez. Batch size = quantas amostras são processadas antes de atualizar pesos. Iterações = nº de batches por epoch = N/batch_size. Batch grande = treino estável mas lento e usa muita RAM. Batch pequeno = ruidoso mas regulariza e generaliza melhor.",
    "example": "Dataset com 10000 imagens, batch_size=100: cada epoch tem 100 iterações (10000/100). Treino por 50 epochs = 5000 updates de pesos. Batch_size=32: mais ruidoso, 312 iterações/epoch, mas geralmente converge melhor."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Fácil",
    "question": "O que é uma RNN (Recurrent Neural Network) e para que tipo de dados é indicada?",
    "options": [
      "Rede com conexões recorrentes que processam dados sequenciais, mantendo memória de passos anteriores",
      "Rede para processar imagens estáticas",
      "Rede sem camadas ocultas",
      "Rede que não tem parâmetros treináveis"
    ],
    "correctIndex": 0,
    "explanation": "RNNs processam sequências (texto, áudio, séries temporais) mantendo um estado oculto (hidden state) atualizado a cada passo: h_t = f(W_h × h_{t-1} + W_x × x_t + b). O estado oculto carrega 'memória' dos passos anteriores. Limitação: dificuldade em reter informação de longo prazo (vanishing gradient).",
    "example": "Prever próxima palavra: 'O gato sentou no ___'. RNN processa token a token: h1 = f('O'), h2 = f('gato', h1), h3 = f('sentou', h2), h4 = f('no', h3) → output: 'tapete'. O estado h4 carrega o contexto de toda a frase anterior."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Fácil",
    "question": "O que é a função de loss (função de custo) em redes neurais e quais são as mais comuns?",
    "options": [
      "Mede o erro entre previsão e valor real; Cross-Entropy para classificação e MSE para regressão são as mais comuns",
      "É a função de ativação da última camada",
      "É o learning rate do modelo",
      "É o número de parâmetros da rede"
    ],
    "correctIndex": 0,
    "explanation": "A função de loss quantifica quão longe as previsões estão dos valores reais. O otimizador minimiza essa função. Classificação binária: Binary Cross-Entropy = −[y log(ŷ) + (1−y) log(1−ŷ)]. Multi-classe: Categorical Cross-Entropy. Regressão: MSE = mean((y−ŷ)²). A escolha errada de loss leva a convergência ruim.",
    "example": "Classificar gato/cachorro: label=[1,0], predição=[0.9,0.1]. BCE = −[1×log(0.9) + 0×log(0.1)] = 0.105 (baixo, boa predição). Se predição=[0.1,0.9]: BCE = −[1×log(0.1)] = 2.302 (alto, erro grande). O otimizador ajusta pesos para minimizar esse valor."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Fácil",
    "question": "O que é a função de ativação ReLU e por que substituiu a sigmoid em redes profundas?",
    "options": [
      "ReLU(x)=max(0,x); resolve o problema de vanishing gradient da sigmoid (gradiente ~0 para valores extremos) e é computacionalmente mais eficiente",
      "ReLU é uma função probabilística que normaliza ativações entre 0 e 1",
      "Substitui sigmoid pois produz outputs sempre positivos, eliminando gradientes negativos",
      "ReLU é usada apenas na camada de saída para classificação binária"
    ],
    "correctIndex": 0,
    "explanation": "Sigmoid: f(x) = 1/(1+e^-x). Gradiente máximo 0.25. Em redes profundas: gradientes multiplicados camada a camada → vanishing gradient (gradientes próximos de 0 nas primeiras camadas). ReLU: gradiente = 1 se x>0, 0 se x<0. Não satura em positivos. Rápido de computar. Problema: Dying ReLU (neurônio sempre produz 0). Variantes: Leaky ReLU, ELU, GELU (usado em Transformers).",
    "example": "Rede de 10 camadas com sigmoid: gradiente na entrada = 0.25^10 ≈ 0.000001 (impraticável). Com ReLU: gradiente flui sem atenuação para x>0. GELU (BERT/GPT): suave, diferenciável em zero. Leaky ReLU: f(x) = max(0.01x, x) — evita Dying ReLU permitindo gradiente pequeno em x<0."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Médio",
    "question": "Na retropropagação (backpropagation), qual técnica matemática é usada para calcular o gradiente da loss em relação a cada peso da rede?",
    "options": [
      "Regra da cadeia (chain rule) de derivadas parciais",
      "Inversão de matrizes",
      "Integração numérica",
      "Transformada de Fourier"
    ],
    "correctIndex": 0,
    "explanation": "A retropropagação usa a regra da cadeia para computar ∂Loss/∂wᵢ camada por camada, da saída para a entrada. Como a loss é composição de funções (ativações, lineares), a regra da cadeia decompõe o gradiente completo em gradientes locais multiplicados sequencialmente.",
    "example": "Loss = (y - σ(wx+b))². ∂Loss/∂w = ∂Loss/∂σ × ∂σ/∂z × ∂z/∂w. Cada fator é um gradiente local simples de calcular. O resultado atualiza w: w = w - lr × ∂Loss/∂w."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Médio",
    "question": "O que é learning rate e como afeta o treinamento de redes neurais?",
    "options": [
      "Hiperparâmetro que controla o tamanho do passo na atualização dos pesos; muito alto diverge, muito baixo é lento",
      "Número de camadas",
      "Tamanho do dataset",
      "Número de epochs"
    ],
    "correctIndex": 0,
    "explanation": "Learning rate (lr) multiplica o gradiente na atualização: w = w - lr × ∇L. lr alto: passos grandes, pode ultrapassar o mínimo (divergir). lr baixo: passos pequenos, convergência lenta, pode ficar preso em mínimos locais. Schedulers (step decay, cosine annealing) reduzem lr durante o treino.",
    "example": "lr=1.0: loss oscila e diverge (passos grandes demais). lr=0.001: convergência suave em 100 epochs. lr=0.0000001: converge muito lentamente, 10000 epochs. Cosine annealing: começa 0.01, diminui gradualmente até 0.0001."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Médio",
    "question": "O que é Dropout e como ele previne overfitting em redes neurais?",
    "options": [
      "Desativa neurônios aleatoriamente durante o treino (com probabilidade p), forçando redundância",
      "Remove camadas inteiras",
      "Reduz learning rate",
      "Aumenta o dataset"
    ],
    "correctIndex": 0,
    "explanation": "Dropout 'desliga' cada neurônio com probabilidade p (ex: 0.5) a cada mini-batch durante o treino. Isso força a rede a não depender de neurônios específicos (redundância), funcionando como ensemble implícito. Na inferência, todos os neurônios são ativados com pesos escalados.",
    "example": "Sem dropout: accuracy treino 99%, teste 80% (overfitting). Com Dropout(0.5): accuracy treino 92%, teste 88% (generaliza melhor). Cada forward pass treina um sub-modelo diferente."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Médio",
    "question": "O que é Batch Normalization e como ela acelera o treinamento de redes profundas?",
    "options": [
      "Normaliza as ativações de cada camada para média 0 e variância 1, estabilizando e acelerando o treino",
      "Aumenta o tamanho do batch",
      "Reduz o número de camadas",
      "É um tipo de ativação como ReLU"
    ],
    "correctIndex": 0,
    "explanation": "Batch Norm normaliza as entradas de cada camada: x̂ = (x-μ_batch)/σ_batch, depois escala e desloca: y = γx̂ + β (parâmetros aprendidos). Benefícios: permite learning rates maiores, reduz dependência da inicialização, atua como regularização leve. Aplicado após camada linear/conv, antes da ativação.",
    "example": "Rede 20 camadas sem BatchNorm: treino diverge com lr=0.01. Com BatchNorm: treino converge com lr=0.1 (10x maior) e em metade das epochs. Accuracy final: sem BN 85%, com BN 91%. Cada camada recebe entrada estável."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Médio",
    "question": "O que são as arquiteturas LSTM e GRU e por que foram criadas para substituir RNNs simples?",
    "options": [
      "Possuem gates que controlam o fluxo de informação, resolvendo o problema de vanishing gradient em sequências longas",
      "São mais simples que RNNs",
      "Foram criadas para imagens",
      "Não processam sequências"
    ],
    "correctIndex": 0,
    "explanation": "RNNs simples perdem informação de longo prazo (vanishing gradient). LSTM adiciona 3 gates: forget (o que descartar), input (o que armazenar), output (o que emitir). Cell state carrega informação por longos períodos. GRU simplifica para 2 gates (reset, update), sendo mais rápida com performance similar. Ambas são base para NLP e séries temporais.",
    "example": "Traduzir frase de 30 palavras: RNN simples 'esquece' as primeiras palavras (accuracy 60%). LSTM mantém contexto longo (accuracy 85%). GRU: accuracy 84%, mas treina 20% mais rápido que LSTM. Hoje, Transformers superaram ambas."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Médio",
    "question": "O que são skip connections (residual connections) e como a ResNet as utiliza?",
    "options": [
      "Conexões que pulam camadas somando a entrada diretamente à saída, permitindo treinar redes muito profundas sem degradação",
      "Conexões que removem camadas desnecessárias",
      "Técnica de regularização como Dropout",
      "Conexões entre redes neurais diferentes"
    ],
    "correctIndex": 0,
    "explanation": "Skip connections adicionam a entrada x de um bloco à sua saída: y = F(x) + x. Assim, se F(x) = 0 (camada inútil), o bloco passa x intacto (identidade). Isso resolve degradation problem: redes mais profundas sem skip connections performam PIOR. ResNet-152 (152 camadas) supera redes de 20 camadas graças a isso.",
    "example": "Rede 20 camadas sem skip: accuracy 90%. 56 camadas sem skip: accuracy 87% (pior!). ResNet-56 com skip connections: accuracy 93%. ResNet-152: accuracy 95%. Skip connections permitem gradiente fluir direto: ∂Loss/∂x = ∂Loss/∂y × (∂F/∂x + 1) — o '+1' garante gradiente mínimo."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Médio",
    "question": "O que é data augmentation e como ajuda a prevenir overfitting em deep learning?",
    "options": [
      "Técnica que cria variações dos dados de treino (rotação, flip, zoom) para aumentar o dataset efetivamente sem coletar novos dados",
      "Coleta mais dados reais",
      "Remove dados duplicados",
      "Aumenta o tamanho do batch"
    ],
    "correctIndex": 0,
    "explanation": "Data augmentation aplica transformações aleatórias preservando o rótulo: flip horizontal, rotação ±15°, zoom, crop, ajuste de brilho/contraste, Cutout, Mixup. Cada epoch vê versões ligeiramente diferentes, impedindo memorização. Funciona como regularização e é essencial quando o dataset é pequeno.",
    "example": "Dataset de raio-X: 500 imagens originais. Com augmentation (flip, rotation, zoom, brightness): cada imagem gera ~10 variações = 5000 imagens efetivas. Sem augmentation: accuracy 75%, overfitting. Com augmentation: accuracy 88%. CutMix/MixUp avançadas: accuracy 91%."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Médio",
    "question": "Como o mecanismo de Dropout funciona como regularização e por que só é aplicado no treino?",
    "options": [
      "Desativa neurônios aleatoriamente com probabilidade p durante o treino, forçando redundância e independência entre neurônios; no teste usa todos os neurônios com pesos escalados por (1-p)",
      "Remove permanentemente os neurônios menos ativos do modelo para reduzir parâmetros",
      "Cria ensemble de modelos menores treinados em subsets de dados usando subconjuntos de neurônios",
      "Aplica ruído gaussiano às ativações durante treino e teste para robustez"
    ],
    "correctIndex": 0,
    "explanation": "Dropout (Srivastava 2014): cada neurônio é zerado com p (ex: p=0.5) independentemente a cada batch. Efeito: rede não pode depender de neurônio específico → aprende representações redundantes e robustas. Equivale a treinar 2^n sub-redes diferentes. Na inferência: todos ativos, pesos multiplicados por (1-p) para compensar escala — ou inverted dropout escala durante treino.",
    "example": "Camada com 100 neurônios, p=0.3: cada forward pass desativa ~30 neurônios aleatórios. Rede aprende a funcionar com qualquer subconjunto. Treino: output × (1/(1-p)). Teste: sem Dropout. Típico: p=0.5 em FC layers, p=0.1-0.2 em conv layers. Batch Normalization + Dropout: cuidado com interação, geralmente BatchNorm depois do Dropout."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Difícil",
    "question": "No mecanismo de Self-Attention (Transformers), como os vetores Query (Q), Key (K) e Value (V) geram a saída de atenção?",
    "options": [
      "Attention(Q,K,V) = softmax(QKᵀ/√dₖ)V — similaridade Q·K pondera os valores V",
      "Soma simples de Q + K + V",
      "Convolução entre Q e V",
      "Concatenação de Q, K e V com pooling"
    ],
    "correctIndex": 0,
    "explanation": "Self-Attention calcula: 1) Score = QKᵀ (similaridade entre cada par de tokens), 2) Scale por √dₖ (estabiliza gradientes), 3) Softmax (normaliza para pesos de atenção entre 0 e 1), 4) Multiplica por V (média ponderada dos valores). Cada token 'atende' a todos os outros com pesos aprendidos.",
    "example": "Frase: 'O gato sentou no tapete dele'. Ao processar 'dele', Q de 'dele' é similar ao K de 'gato' (alto score) → softmax concentra peso em 'gato' → V de 'gato' contribui mais para a representação de 'dele'. O modelo aprende que 'dele' refere-se a 'gato'."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Difícil",
    "question": "O que é o problema de vanishing gradient e como afeta redes neurais profundas?",
    "options": [
      "Gradientes diminuem exponencialmente em camadas profundas, impedindo o aprendizado das primeiras camadas",
      "Gradientes explodem",
      "Problema de memória",
      "Excesso de dados"
    ],
    "correctIndex": 0,
    "explanation": "Na backpropagation, gradientes são multiplicados camada por camada (regra da cadeia). Se cada gradiente local < 1, o produto de muitas frações → ~0 nas primeiras camadas (vanishing). Soluções: ReLU (vs sigmoid), skip connections (ResNet), batch normalization, inicialização He/Xavier.",
    "example": "Rede 50 camadas com sigmoid: gradiente na camada 1 = 0.25⁵⁰ ≈ 0 (vanishing). Com ReLU + skip connections (ResNet-50): gradiente flui diretamente via atalhos, camada 1 aprende normalmente."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Difícil",
    "question": "O que são GANs (Generative Adversarial Networks) e como o treinamento adversário funciona?",
    "options": [
      "Duas redes competem: Generator cria dados falsos, Discriminator distingue real vs falso; ambas melhoram mutuamente",
      "Rede única que gera dados",
      "Ensemble de classificadores",
      "Auto-encoder com regularização"
    ],
    "correctIndex": 0,
    "explanation": "GAN tem Generator (G) que gera dados a partir de ruído, e Discriminator (D) que classifica real vs falso. G é treinado para enganar D, D é treinado para detectar G. No equilíbrio (Nash equilibrium), G gera dados indistinguíveis dos reais. Min_G Max_D V(D,G) = E[log D(x)] + E[log(1-D(G(z)))].",
    "example": "GAN para gerar rostos: G começa gerando ruído, D detecta fácil (100%). Após 1000 epochs, G gera rostos quase reais, D acerta ~55% (quase aleatório). Resultado: StyleGAN gera rostos fotorrealistas de pessoas que não existem."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Difícil",
    "question": "O que é Transfer Learning em Deep Learning e por que revolucionou a prática?",
    "options": [
      "Usar pesos pré-treinados de um modelo grande como base para tarefas específicas com poucos dados",
      "Transferir dados entre datasets",
      "Copiar a arquitetura sem os pesos",
      "Treinar dois modelos simultaneamente"
    ],
    "correctIndex": 0,
    "explanation": "Transfer Learning: modelo pré-treinado em grande dataset (ImageNet 14M imagens, GPT em trilhões de tokens) já aprendeu representações universais. Para nova tarefa: congelar camadas base + treinar camadas finais (fine-tuning). Reduz dados necessários de milhões para centenas. ResNet, BERT, GPT são bases comuns.",
    "example": "Detectar raças de cachorro (120 classes, 200 fotos cada): treino do zero → accuracy 35% (pouco dado). ResNet50 pré-treinado no ImageNet: congelar 48 camadas, substituir última por Dense(120) → accuracy 92% com 30 min de treino."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Difícil",
    "question": "O que é o problema de Exploding Gradients e como técnicas como Gradient Clipping resolvem?",
    "options": [
      "Gradientes crescem exponencialmente durante backpropagation; gradient clipping limita a norma máxima do gradiente",
      "Os gradientes ficam muito pequenos",
      "É resolvido adicionando mais camadas",
      "Gradient clipping aumenta os gradientes"
    ],
    "correctIndex": 0,
    "explanation": "Em redes profundas, gradientes multiplicados repetidamente podem explodir (valores > 10⁶). Gradient clipping: se ||∇|| > max_norm, escala ∇ = ∇ × max_norm/||∇||. Mantém a direção mas limita a magnitude. Combinado com inicialização Xavier/He e BatchNorm, previne instabilidade no treinamento.",
    "example": "RNN treinando texto: gradiente na camada 1 = 1.5⁵⁰ ≈ 6.4×10⁸ (explodindo). Loss salta de 2.5 para NaN. Com gradient clipping max_norm=1.0: gradiente limitado, loss decresce suavemente 2.5→1.8→1.2→0.8."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Difícil",
    "question": "O que é Knowledge Distillation e como permite comprimir modelos grandes em modelos menores?",
    "options": [
      "Treina um modelo menor (student) para imitar as probabilidades suavizadas (soft targets) de um modelo grande (teacher)",
      "Copia os pesos diretamente do modelo grande",
      "Remove camadas aleatórias do modelo grande",
      "É o mesmo que pruning de pesos"
    ],
    "correctIndex": 0,
    "explanation": "Knowledge Distillation: o teacher gera soft labels (probabilidades com temperature T alta, ex: [gato:0.6, tigre:0.3, cachorro:0.1]). O student aprende dessas distribuições suaves, que contêm mais informação que hard labels [1,0,0]. Loss: α×CE(soft_teacher, soft_student) + (1−α)×CE(hard_label, student). Student menor atinge ~95% da performance do teacher.",
    "example": "Teacher BERT-Large (340M params): accuracy 92%. Hard labels: gato=[1,0,0]. Soft labels (T=3): gato=[0.6,0.3,0.1] — 'gato se parece com tigre' é informação extra. Student BERT-Tiny (14M params, 24× menor): com hard labels 82%, com distillation 89%. Quase a performance do teacher com 4% dos parâmetros."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Difícil",
    "question": "O que é Multi-Head Attention e por que é superior a usar uma única cabeça de atenção?",
    "options": [
      "Executa múltiplas atenções em paralelo com projeções diferentes, capturando diferentes tipos de relações simultaneamente",
      "É uma única atenção aplicada múltiplas vezes",
      "Cada head processa um token diferente",
      "É apenas uma otimização de velocidade sem ganho de qualidade"
    ],
    "correctIndex": 0,
    "explanation": "Multi-Head Attention divide Q, K, V em h cabeças com projeções lineares diferentes: head_i = Attention(QWᵢQ, KWᵢK, VWᵢV). As saídas são concatenadas e projetadas: MultiHead = Concat(head₁,...,head_h)Wᴼ. Cada cabeça pode aprender padrões diferentes: uma para adjacência, outra para correferência, outra para sintaxe.",
    "example": "GPT com 12 heads analisando 'O programador que escreveu o código testou ele': Head 3 conecta 'ele' → 'programador' (correferência). Head 7 conecta 'testou' → 'código' (relação verbo-objeto). Head 11 conecta 'escreveu' → 'programador' (sujeito-verbo). Uma única head não capturaria todos esses padrões."
  },
  {
    "id": "machine-learning-e-ia__Deep Learning e Redes Neurais__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "Deep Learning e Redes Neurais",
    "difficulty": "Difícil",
    "question": "O que é batch normalization e como resolve o problema de internal covariate shift?",
    "options": [
      "Normaliza ativações de cada camada para média 0 e variância 1 por mini-batch (parâmetros γ e β aprendíveis); estabiliza treino, permite learning rates maiores e reduz sensibilidade à inicialização",
      "Normaliza os dados de entrada antes do treino para acelerar convergência do gradiente descendente",
      "Técnica de regularização que adiciona ruído normalizado às ativações durante o treino",
      "Balanceia gradientes entre camadas usando normalização por camada ao invés de por batch"
    ],
    "correctIndex": 0,
    "explanation": "Internal covariate shift: distribuição das ativações de camadas intermediárias muda durante o treino (parâmetros das camadas anteriores mudam). BatchNorm: para cada mini-batch, normaliza (x - μ_batch)/σ_batch, depois escala com γ e desloca com β (learnable). Na inferência: usa média/variância do treino (running statistics). Benefícios: permite LR maiores, menos sensível à inicialização, leve efeito regularizador.",
    "example": "Sem BatchNorm: LR=0.001 obrigatório para estabilidade. Com BatchNorm: LR=0.01 funciona, treino 10× mais rápido. Posicionar: antes ou depois da ativação (debate — antes mais comum). Layer Normalization (Transformers): normaliza ao longo das features, não do batch — funciona com batch_size=1. Group Norm: alternativa para visão com batch pequeno."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Fácil",
    "question": "Qual medida estatística representa o valor que divide um conjunto de dados ordenados exatamente ao meio?",
    "options": [
      "Mediana",
      "Média",
      "Moda",
      "Variância"
    ],
    "correctIndex": 0,
    "explanation": "A mediana é o valor central de um dataset ordenado. Para n ímpar, é o elemento do meio. Para n par, é a média dos dois centrais. Ao contrário da média, a mediana é robusta a outliers, sendo mais representativa em distribuições assimétricas.",
    "example": "Salários: [2k, 3k, 3k, 4k, 100k]. Média = 22.4k (distorcida pelo outlier 100k). Mediana = 3k (valor central real, mais representativo)."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Fácil",
    "question": "O que é desvio padrão e como ele mede a dispersão dos dados?",
    "options": [
      "Mede o quanto os valores se afastam da média; quanto maior, mais dispersos os dados",
      "Média dos dados",
      "Valor mais frequente",
      "Diferença entre máximo e mínimo"
    ],
    "correctIndex": 0,
    "explanation": "Desvio padrão (σ) é a raiz quadrada da variância. Mede a dispersão dos dados em torno da média. σ baixo: dados concentrados perto da média. σ alto: dados espalhados. Em distribuição normal, ~68% dos dados estão dentro de ±1σ da média, ~95% dentro de ±2σ.",
    "example": "Notas turma A: [7, 7, 8, 7, 8], média=7.4, σ=0.49 (concentrados). Notas turma B: [2, 5, 7, 9, 10], média=6.6, σ=2.87 (dispersos)."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Fácil",
    "question": "Qual é a diferença entre correlação e causalidade?",
    "options": [
      "Correlação indica associação estatística entre variáveis; causalidade indica que uma causa a outra",
      "São a mesma coisa",
      "Causalidade é mais fraca",
      "Correlação implica causalidade"
    ],
    "correctIndex": 0,
    "explanation": "Correlação mede a força da relação linear entre duas variáveis (-1 a 1). Causalidade exige que uma variável CAUSE mudança na outra. Variáveis podem ser correlacionadas por confounders (terceira variável). Correlação ≠ causalidade: vendas de sorvete correlacionam com afogamentos (ambos causados pelo calor).",
    "example": "Correlação: consumo de sorvete ↑ e afogamentos ↑ (r=0.85). Causalidade? Não! Ambos são causados pelo calor (confounder). Comer sorvete não causa afogamento."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Fácil",
    "question": "O que significam os percentis e quartis em uma distribuição de dados?",
    "options": [
      "Percentis dividem dados em 100 partes iguais; quartis dividem em 4 (Q1=25%, Q2=50%/mediana, Q3=75%)",
      "São médias de subconjuntos",
      "Medem a correlação entre variáveis",
      "Só se aplicam a distribuições normais"
    ],
    "correctIndex": 0,
    "explanation": "Percentil k: valor abaixo do qual k% dos dados caem. Quartis são percentis especiais: Q1 (25º percentil), Q2 (50º = mediana), Q3 (75º). IQR = Q3-Q1 mede dispersão central. Outliers: pontos fora de [Q1-1.5×IQR, Q3+1.5×IQR]. Boxplot visualiza quartis e outliers.",
    "example": "Notas de 100 alunos: Q1=6.0, Q2=7.5(mediana), Q3=8.5, IQR=2.5. Limites: [6.0-3.75=2.25, 8.5+3.75=12.25]. Nota 2.0 é outlier inferior. Nota 10.0 está dentro dos limites."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Fácil",
    "question": "O que é a covariância e como se relaciona com a correlação de Pearson?",
    "options": [
      "Covariância mede a direção da relação entre variáveis; correlação de Pearson a normaliza para [-1,1]",
      "São conceitos independentes",
      "Covariância só mede relações positivas",
      "Correlação não usa covariância no cálculo"
    ],
    "correctIndex": 0,
    "explanation": "Covariância: cov(X,Y) = E[(X-μx)(Y-μy)]. Positiva = crescem juntas, negativa = sentidos opostos. Problema: depende da escala. Correlação de Pearson: r = cov(X,Y)/(σx×σy). Normalizada em [-1,1], independente de escala. r=0 não implica independência (pode haver relação não-linear).",
    "example": "Altura (cm) e peso (kg): cov=350 (difícil interpretar). r=0.82 (forte relação positiva, claro!). Idade e temperatura corporal: cov=0.5, r=0.03 (relação desprezível)."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Fácil",
    "question": "O que é a moda de um conjunto de dados e em quais situações ela é mais útil que a média?",
    "options": [
      "É o valor mais frequente no dataset; útil para dados categóricos e distribuições multimodais",
      "É o valor central do dataset",
      "É a média dos extremos",
      "Só existe em distribuições normais"
    ],
    "correctIndex": 0,
    "explanation": "A moda é o valor que aparece com maior frequência. Pode haver uma moda (unimodal), duas (bimodal) ou mais (multimodal). É a única medida de tendência central aplicável a dados categóricos (ex: cor favorita). Em dados numéricos, é útil quando a distribuição tem picos múltiplos.",
    "example": "Tamanhos de camisetas vendidos: [P, M, M, G, M, G, P, M]. Moda = M (mais vendido → guia produção). Média não faz sentido para categorias. Notas: [5, 7, 7, 8, 8, 8, 9]. Moda = 8 (nota mais comum), média = 7.4, mediana = 8."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Fácil",
    "question": "O que é um outlier e como pode distorcer estatísticas descritivas como média e desvio padrão?",
    "options": [
      "É um valor atipicamente distante dos demais que inflaciona a média e o desvio padrão",
      "É o valor mais comum do dataset",
      "Só outliers acima da média existem",
      "Outliers não afetam nenhuma métrica"
    ],
    "correctIndex": 0,
    "explanation": "Outlier: valor extremo que se desvia significativamente do padrão. Média é sensível: um outlier puxa a média na sua direção. Mediana é robusta. Detecção: IQR (fora de Q1−1.5×IQR ou Q3+1.5×IQR), z-score > 3, ou Isolation Forest. Outliers podem ser erros ou dados legítimos raros.",
    "example": "Salários: [3k, 4k, 4k, 5k, 5k, 200k]. Média = 36.8k (distorcida pelo CEO 200k). Mediana = 4.5k (representativa). Desvio padrão: com outlier = 79k, sem outlier = 0.8k. O outlier inflou o σ em 100×. Decisão: manter (dado legítimo) ou tratar (winsorização, log transform)."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre viés (bias) e variância (variance) no contexto de modelos de ML?",
    "options": [
      "Viés: erro sistemático por suposições simplificadoras (underfitting); variância: sensibilidade excessiva aos dados de treino (overfitting); tradeoff entre os dois define a complexidade ideal do modelo",
      "Viés é erro de medição nos dados; variância é o desvio padrão das predições",
      "Variância indica a quantidade de parâmetros do modelo; viés é o erro no conjunto de treino",
      "São sinônimos estatísticos para o erro total do modelo de ML"
    ],
    "correctIndex": 0,
    "explanation": "Erro total = Bias² + Variance + Ruído irredutível. High bias (underfitting): modelo muito simples, erra sistematicamente em treino e teste. High variance (overfitting): modelo memoriza treino, generaliza mal. Complexity trade-off: modelo simples (linear) → high bias, low variance. Modelo complexo (deep NN) → low bias, high variance. Regularização, dropout, early stopping: reduzem variância.",
    "example": "Regressão linear para dados polinomiais: high bias (linha reta não captura curva). Polinômio grau 15 no mesmo dataset: ajusta perfeitamente o treino, oscila absurdamente no teste (high variance). Grau 3: equilíbrio. Cross-validation mede variância (desvio padrão do score entre folds) e viés (score médio vs ótimo esperado)."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Médio",
    "question": "Em estatística, o que é o 'p-value' em um teste de hipóteses e como ele é interpretado?",
    "options": [
      "Probabilidade de observar o resultado obtido (ou mais extremo) assumindo que a hipótese nula é verdadeira",
      "Probabilidade de a hipótese alternativa ser verdadeira",
      "Porcentagem de dados acima da média",
      "Chance de erro no dataset"
    ],
    "correctIndex": 0,
    "explanation": "O p-value mede a probabilidade de obter um resultado tão extremo quanto o observado, assumindo que H₀ (hipótese nula) é verdadeira. Se p-value < α (nível de significância, geralmente 0.05), rejeitamos H₀. Um p-value pequeno indica evidência contra H₀, não prova que H₁ é verdadeira.",
    "example": "Teste se medicamento reduz pressão: H₀ = 'sem efeito'. p-value = 0.003 < 0.05 → rejeitamos H₀, há evidência estatística significativa de que o medicamento tem efeito."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Médio",
    "question": "O que é distribuição normal (gaussiana) e por que é tão importante em estatística?",
    "options": [
      "Distribuição em forma de sino definida por média e desvio padrão; muitos fenômenos naturais seguem esta distribuição",
      "Distribuição uniforme",
      "Apenas para dados discretos",
      "Só existe em teoria"
    ],
    "correctIndex": 0,
    "explanation": "A distribuição normal é simétrica, com formato de sino, parametrizada por μ (média) e σ (desvio padrão). Pelo Teorema Central do Limite, a média de amostras grandes tende à normalidade. Muitos testes estatísticos assumem normalidade. Regra 68-95-99.7: ±1σ=68%, ±2σ=95%, ±3σ=99.7%.",
    "example": "Alturas de adultos: média=170cm, σ=10cm. 68% entre 160-180cm, 95% entre 150-190cm, 99.7% entre 140-200cm. Uma pessoa de 210cm está a 4σ — extremamente rara."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Médio",
    "question": "O que é um teste A/B e como a estatística garante que o resultado não é por acaso?",
    "options": [
      "Experimento controlado que compara duas versões; significância estatística (p-value < 0.05) confirma que a diferença não é aleatória",
      "Testar versões A e B simultaneamente sem análise",
      "Escolher a versão preferida pelo chefe",
      "Rodar por 1 dia e comparar"
    ],
    "correctIndex": 0,
    "explanation": "Teste A/B divide usuários aleatoriamente em grupo controle (A) e tratamento (B). Métricas são comparadas usando testes estatísticos (t-test, chi-quadrado). Requer: tamanho amostral suficiente (poder estatístico), randomização, e p-value < α para concluir significância.",
    "example": "Botão verde (A): 5% conversão (500/10000). Botão vermelho (B): 5.5% (550/10000). p-value = 0.03 < 0.05 → diferença significativa. Se p-value = 0.15 → pode ser acaso, manter A."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Médio",
    "question": "O que é um intervalo de confiança e como interpretá-lo corretamente?",
    "options": [
      "Faixa de valores que contém o parâmetro real com certa probabilidade (ex: 95% de confiança)",
      "A probabilidade do resultado ser exato",
      "A margem de erro do computador",
      "O range dos dados coletados"
    ],
    "correctIndex": 0,
    "explanation": "IC 95%: se repetíssemos o experimento 100 vezes, ~95 dos intervalos conteriam o valor verdadeiro. IC = x̄ ± z×(s/√n). IC mais estreito = mais precisão. Fatores: nível de confiança (95% vs 99%), tamanho amostral (mais dados = IC menor), variabilidade dos dados.",
    "example": "Pesquisa eleitoral: candidato A = 45% ± 3% (IC 95%: [42%, 48%]). Candidato B = 47% ± 3% (IC 95%: [44%, 50%]). ICs se sobrepõem → empate técnico (não se pode afirmar quem está à frente)."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Médio",
    "question": "O que são os erros Tipo I e Tipo II em testes de hipóteses?",
    "options": [
      "Tipo I: rejeitar H₀ quando veradadeira (falso positivo); Tipo II: não rejeitar H₀ quando falsa (falso negativo)",
      "São erros de cálculo matemático",
      "Tipo I é pior que Tipo II sempre",
      "São a mesma coisa"
    ],
    "correctIndex": 0,
    "explanation": "Erro Tipo I (α): rejeitar hipótese nula verdadeira (alarme falso). Controlado pelo nível de significância (α=0.05 = 5% de chance). Erro Tipo II (β): não rejeitar hipótese nula falsa (perder efeito real). Poder = 1−β. Para reduzir ambos: aumentar tamanho amostral.",
    "example": "Teste COVID: Tipo I = pessoa saudável testada positiva (falso positivo, quarentena desnecessária). Tipo II = pessoa infectada testada negativa (falso negativo, espalha o vírus). Em pandemias, Tipo II é mais perigoso."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Médio",
    "question": "O que é o Teorema Central do Limite (TCL) e por que é fundamental em estatística inferencial?",
    "options": [
      "A distribuição das médias amostrais tende à Normal conforme n aumenta, independentemente da distribuição original",
      "Todos os dados seguem distribuição normal",
      "Só funciona para dados normais",
      "A média amostral é sempre igual à populacional"
    ],
    "correctIndex": 0,
    "explanation": "TCL: se tirarmos muitas amostras de tamanho n de QUALQUER distribuição (com média μ e variância σ² finitos), a distribuição das médias amostrais será aproximadamente Normal(μ, σ²/n) para n ≥ 30. Isso permite usar testes baseados na Normal mesmo com dados não-normais, fundamentando testes de hipótese e ICs.",
    "example": "Lançamento de dado (distribuição uniforme, não normal): média=3.5, σ=1.71. Tire 1000 amostras de n=30 e calcule a média de cada: distribuição das médias → Normal(3.5, 0.31). Podemos fazer t-test nas médias, mesmo o dado não sendo normal!"
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Médio",
    "question": "O que é poder estatístico (statistical power) e quais fatores o influenciam?",
    "options": [
      "Probabilidade de detectar um efeito real quando ele existe (1−β); influenciado por tamanho amostral, tamanho do efeito e nível de significância",
      "É a probabilidade de commit erro Tipo I",
      "É o valor do p-value",
      "É sempre fixo em 80%"
    ],
    "correctIndex": 0,
    "explanation": "Power = P(rejeitar H₀ | H₀ é falsa) = 1−β. Poder ≥ 80% é convencional. Aumentar poder: ↑ tamanho amostral (n), ↑ tamanho do efeito (effect size), ↑ α (nível de significância), ou ↓ variância. Análise de poder a priori determina o n mínimo antes do estudo.",
    "example": "Testar se novo remédio baixa pressão em 5mmHg (σ=10): Power analysis: α=0.05, power=0.80, effect_size=0.5 → preciso n=64 por grupo. Com n=20: power=0.40 (40% chance de detectar o efeito mesmo que exista). Com n=200: power=0.99 (quase certeza)."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Médio",
    "question": "O que é o teorema de Bayes e qual sua aplicação no classificador Naive Bayes?",
    "options": [
      "P(A|B) = P(B|A)×P(A)/P(B); Naive Bayes usa independência condicional das features para calcular P(classe|features) de forma eficiente mesmo com muitas features",
      "Define probabilidade condicional como produto das probabilidades marginais de cada feature",
      "Teorema de convergência de estimadores de máxima verossimilhança para grandes amostras",
      "Fundamenta redes bayesianas que modelam dependências causais entre variáveis"
    ],
    "correctIndex": 0,
    "explanation": "Bayes: P(Y|X) = P(X|Y)×P(Y)/P(X). Naive Bayes assume P(X1,X2,...Xn|Y) = ∏P(Xi|Y) (features condicionalmente independentes dado a classe). 'Naive' porque raro na prática, mas funciona surpreendentemente bem. P(X) = denominador constante, ignorado na classificação. Eficiente: estima P(Xi|Y) separadamente. Gaussian NB, Multinomial NB (texto), Bernoulli NB.",
    "example": "Spam: P(spam|'venda','grátis') ∝ P('venda'|spam)×P('grátis'|spam)×P(spam). Treino: conta frequência de palavras por classe. Teste: multiplica probabilidades. 'Naive': assume 'venda' e 'grátis' independentes dado spam (falso, mas funciona). Laplace smoothing: P(palavra|classe) = (count+1)/(total+vocab) para evitar probabilidade zero."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Difícil",
    "question": "O que é o 'bias-variance tradeoff' em ML e como ele se relaciona com overfitting e underfitting?",
    "options": [
      "Alto bias = underfitting (modelo simples demais); alta variância = overfitting (modelo complexo demais); o ideal é equilibrar ambos",
      "Bias e variância sempre diminuem juntos",
      "Bias causa overfitting e variância causa underfitting",
      "Só é relevante para redes neurais"
    ],
    "correctIndex": 0,
    "explanation": "Bias é o erro por suposições simplificadoras do modelo (un performance no treino). Variância é a sensibilidade a flutuações no dataset de treino (gap entre treino e teste). Modelos simples: alto bias, baixa variância (underfitting). Modelos complexos: baixo bias, alta variância (overfitting). O objetivo é minimizar o erro total = bias² + variância.",
    "example": "Prever salários: regressão linear (alto bias: reta não captura curva) vs polinômio grau 20 (alta variância: se ajusta ao ruído). Polinômio grau 3: equilibra bias e variância, generaliza melhor para dados novos."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Difícil",
    "question": "O que é a maldição da dimensionalidade e como afeta modelos de ML?",
    "options": [
      "Em alta dimensionalidade, dados tornam-se esparsos e distâncias perdem significado; modelos precisam exponencialmente mais dados",
      "Mais features sempre melhora",
      "Só afeta regressão",
      "Resolvido com mais camadas"
    ],
    "correctIndex": 0,
    "explanation": "Conforme dimensões aumentam: volume do espaço cresce exponencialmente, dados ficam esparsos, distâncias euclidianas convergem (todos os pontos ficam 'igualmente distantes'), e o número de amostras necessárias cresce exponencialmente. Algoritmos como KNN e DBSCAN sofrem muito. Solução: redução de dimensionalidade.",
    "example": "KNN com 5 features e 1000 pontos: funciona bem. Com 500 features e 1000 pontos: todos os vizinhos têm distância similar, KNN falha. Precisa de ~10⁵⁰⁰ pontos para cobrir o espaço 500D — impossível. PCA para 10 features resolve."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Difícil",
    "question": "O que é análise Bayesiana e como o teorema de Bayes é aplicado em ML?",
    "options": [
      "Atualiza crenças (prior) com evidências (likelihood) para obter probabilidade posterior; base do Naive Bayes e inferência Bayesiana",
      "Apenas para classificação binária",
      "Técnica de clustering",
      "Método de otimização"
    ],
    "correctIndex": 0,
    "explanation": "Teorema de Bayes: P(A|B) = P(B|A)×P(A)/P(B). Prior P(A): crença inicial. Likelihood P(B|A): probabilidade dos dados dado o modelo. Posterior P(A|B): crença atualizada. Naive Bayes assume independência entre features (ingenuamente), mas funciona surpreendentemente bem para NLP.",
    "example": "Spam filter: P(spam|palavra='viagra') = P('viagra'|spam)×P(spam) / P('viagra'). Prior P(spam)=0.3. P('viagra'|spam)=0.8. P('viagra')=0.25. Posterior = 0.8×0.3/0.25 = 0.96 → 96% chance de spam."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Difícil",
    "question": "O que é o Bootstrap em estatística e como é usado para estimar incerteza?",
    "options": [
      "Reamostragem com reposição do dataset original para gerar distribuição empírica de uma estatística e estimar intervalos de confiança",
      "É um tipo de regressão",
      "Método de normalização de dados",
      "É o mesmo que cross-validation"
    ],
    "correctIndex": 0,
    "explanation": "Bootstrap: reamostrar N dados com reposição, calcula a estatística (média, mediana, R²), repetir B vezes (ex: 1000). Resultado: distribuição da estatística sem supor normalidade. IC Bootstrap: percentis 2.5% e 97.5% das B amostras. Não-paramétrico — funciona para qualquer estatística.",
    "example": "Dataset com 50 observações, média=75. Bootstrap 1000x: médias amostradas = [72.1, 76.3, 74.8, ...]. Ordena e pega percentis: IC 95% = [71.5, 78.2]. Sem supor normalidade nem fórmulas analíticas."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Difícil",
    "question": "O que é a distribuição t de Student e quando usá-la em vez da Normal?",
    "options": [
      "Usada quando a amostra é pequena e/ou o desvio padrão populacional é desconhecido; tem caudas mais pesadas que a Normal",
      "É sempre preferível à Normal",
      "Só se aplica a dados categóricos",
      "É a mesma distribuição Normal com outro nome"
    ],
    "correctIndex": 0,
    "explanation": "Distribuição t: similar à Normal mas com caudas mais pesadas, parametrizada por graus de liberdade (df=n-1). Com n pequeno, mais incerteza → caudas mais largas. Conforme n→∞, t→Normal. Usar t-test em vez de z-test quando: n<30 ou σ populacional desconhecido (quase sempre na prática).",
    "example": "Testar se novo remédio reduz pressão com n=15 pacientes: z-test exigiria σ populacional (desconhecido). t-test com df=14: t=2.8, p=0.014 < 0.05 → efeito significativo. Com n=500, t-test e z-test dariam resultado idêntico."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Difícil",
    "question": "O que é o teste de Kolmogorov-Smirnov (KS) e quando utilizá-lo?",
    "options": [
      "Teste não-paramétrico que compara a distribuição acumulada dos dados com uma distribuição de referência ou entre duas amostras",
      "Testa apenas normalidade",
      "É um teste para médias",
      "Só funciona com dados categóricos"
    ],
    "correctIndex": 0,
    "explanation": "O teste KS mede a distância máxima (D) entre a função de distribuição acumulada (CDF) empírica e uma CDF teórica (1-amostra) ou entre dois CDFs empíricos (2-amostras). H₀: as distribuições são iguais. Vantagem: não-paramétrico, sensível a diferenças em localização, escala e forma. Limitação: menos poderoso que testes específicos.",
    "example": "Verificar se dados seguem Normal: KS 1-amostra, D=0.08, p=0.42 > 0.05 → não rejeitamos H₀, dados compatíveis com Normal. Comparar vendas Jan vs Fev: KS 2-amostras, D=0.25, p=0.001 → distribuições significativamente diferentes."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Difícil",
    "question": "O que é a correção de Bonferroni e por que é necessária em múltiplas comparações?",
    "options": [
      "Ajusta o nível de significância dividindo α pelo número de testes para controlar a taxa de erro global",
      "Aumenta o p-value de cada teste",
      "Remove testes não significativos",
      "É apenas para testes de normalidade"
    ],
    "correctIndex": 0,
    "explanation": "Ao realizar m testes simultâneos com α=0.05, a probabilidade de pelo menos 1 falso positivo sobe: P = 1−(1−0.05)^m. Com m=20: P=64%! Bonferroni: usa α/m como limiar (0.05/20 = 0.0025). Conservador mas simples. Alternativas menos conservadoras: Holm-Bonferroni, Benjamini-Hochberg (FDR).",
    "example": "Comparar 10 grupos em pares: C(10,2)=45 testes. α=0.05: ~2.3 falsos positivos esperados! Bonferroni: α_adj = 0.05/45 = 0.0011. Só resultados com p < 0.0011 são significativos. FDR (Benjamini-Hochberg): menos conservador, aceita proporcão controlada de falsos positivos."
  },
  {
    "id": "machine-learning-e-ia__Estatística para ML__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "Estatística para ML",
    "difficulty": "Difícil",
    "question": "O que é validação cruzada k-fold e como corrigir o data leakage em pipelines com feature engineering?",
    "options": [
      "Divide dados em k folds; treina em k-1 e valida em 1 repetindo k vezes; leakage é prevenido encapsulando TODA transformação (scaler, imputer, encoder) dentro do pipeline que é ajustado somente no fold de treino",
      "Particiona dados aleatoriamente k vezes com reposição para estimativa de bootstrap",
      "Data leakage é prevenido normalizando todos os dados antes de criar qualquer fold",
      "Aplica transformações no dataset completo antes de qualquer split, depois faz k-fold"
    ],
    "correctIndex": 0,
    "explanation": "k-fold: estimativa de generalização mais confiável. Leakage: fit de scaler/imputer no dataset COMPLETO inclui estatísticas do fold de teste → modelo parece melhor que realmente é. Correto: Pipeline([(scaler, StandardScaler()), (model, SVC())]); cross_val_score(pipeline, X, y, cv=5) — scaler.fit_transform só vê X_train de cada fold. StratifiedKFold para classificação desbalanceada.",
    "example": "ERRADO: scaler.fit(X_all); cross_val_score(model, X_scaled, y). CORRETO: pipe = Pipeline([('scaler', StandardScaler()), ('clf', LR())]); cross_val_score(pipe, X, y, cv=10). fold de teste nunca influencia a normalização. Time Series: TimeSeriesSplit (fold de teste sempre depois do treino — sem shuffling). Nested CV para hyperparameter tuning simultâneo."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Fácil",
    "question": "O que significa a sigla LLM no contexto de Inteligência Artificial?",
    "options": [
      "Large Language Model (Modelo de Linguagem Grande)",
      "Linear Learning Machine",
      "Low Latency Memory",
      "Logical Language Module"
    ],
    "correctIndex": 0,
    "explanation": "LLM (Large Language Model) é um modelo de deep learning treinado em grandes volumes de texto para compreender e gerar linguagem natural. Exemplos incluem GPT-4, Claude, Gemini e LLaMA. São baseados na arquitetura Transformer e possuem bilhões de parâmetros.",
    "example": "O GPT-4 foi treinado em trilhões de tokens de texto e possui centenas de bilhões de parâmetros, permitindo gerar texto, traduzir, programar, analisar e raciocinar sobre informações complexas."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Fácil",
    "question": "O que é um chatbot baseado em LLM e como ele difere de chatbots tradicionais baseados em regras?",
    "options": [
      "LLM gera respostas contextuais com compreensão semântica; chatbot de regras segue scripts predefinidos (if/else)",
      "São idênticos",
      "Chatbot de regras é mais inteligente",
      "LLM só funciona em inglês"
    ],
    "correctIndex": 0,
    "explanation": "Chatbots de regras usam padrões fixos (regex, intent matching, árvores de decisão). LLMs entendem contexto, nuance e geram respostas criativas. LLMs: flexíveis mas podem alucinar. Regras: previsíveis mas limitados. Abordagem híbrida: LLM para compreensão + regras para ações críticas.",
    "example": "Regras: 'cancelar pedido' → script fixo pedindo número do pedido. LLM: 'quero devolver aquele negócio que comprei terça' → entende contexto, identifica o pedido, sugere opções, tudo em linguagem natural."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Fácil",
    "question": "O que é tokenização em LLMs e por que modelos usam subword tokens?",
    "options": [
      "Dividir texto em unidades processáveis; subwords equilibram vocabulário finito com cobertura de palavras desconhecidas",
      "Dividir por espaços apenas",
      "Cada letra é um token",
      "Tokenização não é necessária"
    ],
    "correctIndex": 0,
    "explanation": "Tokenização converte texto em IDs numéricos. Character-level: vocabulário pequeno, sequências longas. Word-level: vocabulário enorme, não lida com palavras novas. Subword (BPE, WordPiece): equilibra ambos. 'unhappiness' → ['un', 'happiness'] ou ['un', 'happi', 'ness']. GPT-4 usa ~100k tokens via BPE.",
    "example": "'Processamento' → tokens ['Process', 'amento'] (2 tokens). 'ML' → ['ML'] (1 token). 'Pneumoultramicroscopicossilicovulcanoconiótico' → múltiplos subword tokens porque é rara, mas composta de partes conhecidas."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Fácil",
    "question": "O que é o conceito de 'temperatura' na geração de texto por LLMs?",
    "options": [
      "Parâmetro que controla a aleatoriedade: temperatura baixa = respostas mais determinísticas, alta = mais criativas",
      "A temperatura do hardware durante a geração",
      "Mede a qualidade da resposta",
      "Controla o tamanho da resposta"
    ],
    "correctIndex": 0,
    "explanation": "Temperatura escala os logits antes do softmax: pᵢ = exp(zᵢ/T) / Σexp(zⱼ/T). T=0: determinístico (sempre o token mais provável). T=1: distribuição original. T>1: mais uniforme (mais criativa/arriscada). Top-p (nucleus sampling) complementa, limitando o pool de tokens candidatos.",
    "example": "Prompt: 'O céu é...' T=0.1: 'azul' (99% das vezes). T=0.7: 'azul'(60%), 'lindo'(20%), 'infinito'(15%). T=1.5: 'um oceano invertido'(10%), 'misterioso'(8%). Para código, T=0.2. Para poesia, T=0.9."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Fácil",
    "question": "O que é o conceito de 'context window' (janela de contexto) em LLMs?",
    "options": [
      "Número máximo de tokens que o modelo pode processar de uma vez (input + output)",
      "É o tamanho do dataset de treino",
      "É o número de camadas do modelo",
      "É a memória RAM necessária"
    ],
    "correctIndex": 0,
    "explanation": "Context window define a quantidade total de texto (input + output) que o modelo 'vê' de uma vez. GPT-3.5: 4k tokens. GPT-4: 8k/32k/128k tokens. Claude: 200k tokens. Texto fora da janela é 'esquecido'. Estratégias para textos longos: chunking, summarization, RAG.",
    "example": "Modelo com 4k tokens (~3000 palavras): resume um artigo de 2 páginas perfeitamente. Mas um livro de 300 páginas? Não cabe. Solução: dividir em chunks de 3k tokens, resumir cada, combinar resumos. Modelo 128k: livro inteiro cabe."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Fácil",
    "question": "O que são embeddings (vetores) no contexto de LLMs e como representam significado?",
    "options": [
      "Vetores numéricos de alta dimensão que capturam o significado semântico de palavras/frases; palavras similares têm vetores próximos",
      "São os parâmetros do modelo",
      "São os tokens do vocabulário",
      "São as camadas ocultas da rede"
    ],
    "correctIndex": 0,
    "explanation": "Embeddings mapeiam texto para vetores densos (ex: 768 ou 1536 dimensões) onde a distância geométrica reflete similaridade semântica. Usados para busca semântica, clustering, RAG e similaridade textual. Modelos: Word2Vec, BERT embeddings, OpenAI text-embedding-3. Propriedade famosa: rei − homem + mulher ≈ rainha.",
    "example": "embed('gato') e embed('felino') têm cosseno ~0.92 (muito próximos). embed('gato') e embed('avião') têm cosseno ~0.15 (distantes). RAG usa embeddings: query 'como cuidar de gatos' → busca vetorial encontra documentos similares mesmo sem as palavras exatas."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre zero-shot, one-shot e few-shot prompting em LLMs?",
    "options": [
      "Zero-shot: sem exemplos; one-shot: 1 exemplo; few-shot: vários exemplos no prompt para guiar o modelo",
      "São técnicas de treinamento do modelo",
      "Referem-se ao número de camadas da rede",
      "São métricas de avaliação"
    ],
    "correctIndex": 0,
    "explanation": "Zero-shot: apenas a instrução, o modelo generaliza sem exemplos. One-shot: 1 exemplo de entrada/saída esperada. Few-shot: 3-5 exemplos que demonstram o padrão desejado. Mais exemplos geralmente melhoram a consistência do formato e qualidade, mas consomem tokens da context window.",
    "example": "Classificar sentimento: Zero-shot: 'Classifique: O filme foi ótimo'. Few-shot: 'Adorei o livro → positivo. Péssimo serviço → negativo. Comida razoável → neutro. O filme foi ótimo →'. Few-shot accuracy: 95% vs zero-shot 82% na maioria dos benchmarks."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Fácil",
    "question": "O que é um Large Language Model (LLM) e como ele gera texto token a token?",
    "options": [
      "Modelo de linguagem treinado com bilhões de tokens que prevê o próximo token baseado no contexto anterior; usa distribuição de probabilidade para escolher cada token",
      "Modelo que gera imagens a partir de descrições textuais usando difusão",
      "Banco de dados de frases pré-escritas que recupera respostas por similaridade",
      "Assistente de voz com reconhecimento de fala integrado e busca na internet"
    ],
    "correctIndex": 0,
    "explanation": "LLM (ex: GPT-4, Llama3): treinado para prever P(próximo_token | contexto). Na geração: dado prompt, calcula distribuição sobre vocabulário (32k+ tokens), amostra um token, adiciona ao contexto, repete. Temperature: alto → mais aleatório, baixo → mais determinístico. Top-p (nucleus sampling): considera tokens com probabilidade acumulada ≥ p. Tokenização: byte-pair encoding, ~4 chars/token.",
    "example": "Prompt 'O céu é': LLM calcula P(azul|...) alto, P(pizza|...) baixo. Temperature=0: escolhe sempre 'azul'. Temperature=1: amostragem da distribuição. Temperature=2: respostas criativas/caóticas. Tokens ≠ palavras: 'ChatGPT' = 2 tokens. GPT-4 context window: 128k tokens (~96k palavras). Geração de 1 token por vez = autoregressive."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Médio",
    "question": "O que é 'prompt engineering' e por que é importante para obter bons resultados de LLMs?",
    "options": [
      "A arte de formular instruções precisas para guiar o modelo a produzir respostas mais relevantes e acuradas",
      "Treinar o modelo do zero com novos dados",
      "Otimizar os hiperparâmetros de treinamento",
      "Comprimir o modelo para executar mais rápido"
    ],
    "correctIndex": 0,
    "explanation": "Prompt engineering é a técnica de estruturar inputs (prompts) para maximizar a qualidade das respostas de LLMs. Inclui técnicas como few-shot (exemplos no prompt), chain-of-thought (raciocínio passo a passo), role-playing (definir persona) e constraint specification (definir formato/limites).",
    "example": "Prompt ruim: 'resuma o texto'. Prompt bom: 'Você é um analista financeiro sênior. Resuma o relatório abaixo em 3 bullet points focando em: receita, margem e riscos. Formato: - [tema]: [insight]'."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Médio",
    "question": "O que é RAG (Retrieval-Augmented Generation) e como reduz alucinações em LLMs?",
    "options": [
      "Busca documentos relevantes em base de conhecimento antes de gerar resposta; fundamenta a resposta em fatos reais",
      "Treina o modelo com mais dados",
      "Aumenta a temperatura",
      "Remove camadas do modelo"
    ],
    "correctIndex": 0,
    "explanation": "RAG combina retrieval (busca em base de dados/documentos) com generation (LLM). Fluxo: query → busca semântica em documentos → contexto relevante + query → LLM gera resposta fundamentada. Reduz alucinações porque o LLM tem acesso a fatos verificados. Mais barato que fine-tuning.",
    "example": "Pergunta: 'Qual a política de férias da empresa?' Sem RAG: LLM alucina uma resposta genérica. Com RAG: busca no manual da empresa → encontra 'Funcionários têm 30 dias/ano' → LLM responde com base no documento real."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Médio",
    "question": "O que é fine-tuning de LLMs e quando é preferível ao prompt engineering?",
    "options": [
      "Retreinar o modelo em dados específicos do domínio; preferível quando prompt engineering não alcança a qualidade necessária",
      "São a mesma coisa",
      "Fine-tuning é sempre melhor",
      "Prompt engineering é sempre melhor"
    ],
    "correctIndex": 0,
    "explanation": "Fine-tuning ajusta os pesos do modelo em dados específicos (ex: textos médicos, jurídicos). Vantagens: melhor performance no domínio, pode aprender formato/estilo específico. Desvantagens: custo computacional, risco de overfitting, dados de qualidade necessários. Usar quando: prompt engineering insuficiente, domínio muito especializado.",
    "example": "Chatbot jurídico: prompt engineering → 70% de respostas corretas. Fine-tuning com 10k decisões judiciais → 92% de respostas corretas. O modelo aprendeu terminologia e padrões jurídicos específicos."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Médio",
    "question": "O que são AI Agents e como diferem de um simples chatbot baseado em LLM?",
    "options": [
      "Agents podem planejar, usar ferramentas externas e executar ações autônomas além de gerar texto",
      "São a mesma coisa",
      "Agents não usam LLMs",
      "Chatbots são mais avançados"
    ],
    "correctIndex": 0,
    "explanation": "Chatbot simples: recebe prompt, gera texto, fim. AI Agent: recebe objetivo → planeja passos → usa tools (APIs, código, buscas) → avalia resultado → itera até completar. Frameworks: LangChain, AutoGPT, CrewAI. Exemplos: pesquisar web + analisar dados + gerar relatório automaticamente.",
    "example": "Chatbot: 'Qual o clima?' → 'Não posso acessar dados em tempo real.' Agent: 'Qual o clima?' → chama API do OpenWeather → 'São Paulo: 22°C, nublado.' Agent pode encadear: buscar → analisar → enviar email → confirmar."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Médio",
    "question": "O que é o fenômeno de 'emergent abilities' em LLMs e por que é relevante?",
    "options": [
      "Capacidades que surgem apenas em modelos acima de certo tamanho, não previsíveis por modelos menores",
      "É quando o modelo é treinado com mais dados",
      "É sinônimo de fine-tuning",
      "Ocorre em qualquer tamanho de modelo"
    ],
    "correctIndex": 0,
    "explanation": "Emergent abilities: modelos pequenos têm accuracy ~0% em certas tarefas (aritmética, lógica), mas ao cruzar um limiar de parâmetros (~100B+), accuracy salta para 60-90%. Exemplos: raciocínio em cadeia (chain-of-thought), tradução zero-shot, resolução de analogias complexas. Implicação: modelos maiores podem ter capacidades imprevisíveis.",
    "example": "Aritmética de 3 dígitos: GPT-2 (1.5B) → accuracy 5%. GPT-3 (175B) → accuracy 80%. O modelo não foi treinado para matemática explicitamente, mas a habilidade 'emergiu' com escala. Chain-of-thought prompting melhora ainda mais."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Médio",
    "question": "O que é chain-of-thought (CoT) prompting e como melhora o raciocínio de LLMs?",
    "options": [
      "Solicitar que o modelo raciocine passo a passo antes de dar a resposta final, melhorando precisão em tarefas complexas",
      "Encadear múltiplos modelos",
      "Treinar o modelo com exemplos sequenciais",
      "Reduzir a temperatura para zero"
    ],
    "correctIndex": 0,
    "explanation": "Chain-of-thought: adicionar 'pense passo a passo' ou mostrar exemplos com raciocínio explícito. O modelo gera etapas intermediárias antes da resposta final, reduzindo erros em matemática, lógica e problemas multi-step. Variantes: zero-shot CoT ('pense passo a passo'), few-shot CoT (exemplos com raciocínio), Tree-of-Thought.",
    "example": "Sem CoT: '23×17=?' → '381' (errado). Com CoT: '23×17: 23×10=230, 23×7=161, 230+161=391' → correto! GSM8K benchmark (matemática): sem CoT 18%, com CoT 57%. CoT força o modelo a 'mostrar o trabalho'."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Médio",
    "question": "O que é function calling em LLMs e como permite interação com sistemas externos?",
    "options": [
      "Capacidade do LLM de gerar chamadas estruturadas a funções/APIs externas com parâmetros corretos em JSON",
      "O LLM executa código diretamente no servidor",
      "É o mesmo que gerar texto",
      "Só funciona com Python"
    ],
    "correctIndex": 0,
    "explanation": "Function calling: o modelo recebe descrições de funções disponíveis (nome, parâmetros, tipos). Ao responder, pode gerar uma chamada JSON estruturada em vez de texto. O sistema executa a função e retorna o resultado ao modelo, que incorpora na resposta. Permite: buscar dados, enviar emails, acessar APIs.",
    "example": "User: 'Qual o clima em SP?' → LLM gera: {function: 'get_weather', params: {city: 'São Paulo'}}. Sistema executa API → retorna {temp: 22, cond: 'nublado'}. LLM: 'Em São Paulo está 22°C e nublado.' Tudo automático, sem alucinação sobre o clima."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Médio",
    "question": "O que é fine-tuning supervisionado de LLMs e como difere de RAG (Retrieval-Augmented Generation)?",
    "options": [
      "Fine-tuning atualiza pesos do modelo com exemplos do domínio (conhecimento no parâmetro); RAG recupera documentos relevantes em tempo real e os injeta no contexto (conhecimento externo e atualizável)",
      "Fine-tuning é para classificação; RAG é para geração de texto",
      "São equivalentes — ambos armazenam conhecimento externo nos embeddings",
      "RAG modifica os pesos do modelo com documentos; fine-tuning usa contexto expandido"
    ],
    "correctIndex": 0,
    "explanation": "Fine-tuning SFT: continua treinamento com pares (instrução, resposta desejada) do domínio. Conhecimento gravado nos pesos. Desvantagem: requer retreinamento para atualizar info, caro, risco de catastrophic forgetting. RAG: embedding dos documentos → banco vetorial. Query time: recupera top-k por similaridade → injeta no prompt. Vantagem: conhecimento atualizado sem retreinar. Desvantagem: qualidade depende do retrieval.",
    "example": "Chatbot jurídico. Fine-tuning: treinar com 10k Q&A de leis → modelo 'sabe' direito. RAG: embedar todas as leis no Pinecone → query 'direito trabalhista' recupera artigos relevantes → LLM responde com base nos documentos. Fine-tuning: estável, sem latência de busca. RAG: atualiza banco vetorial quando lei muda sem retreinar modelo."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Difícil",
    "question": "No fine-tuning de LLMs, qual é a diferença entre Full Fine-Tuning e LoRA (Low-Rank Adaptation) em termos de eficiência de parâmetros?",
    "options": [
      "LoRA congela os pesos originais e treina matrizes de baixo rank inseridas em cada camada, usando <1% dos parâmetros",
      "LoRA treina todos os parâmetros como Full Fine-Tuning",
      "Full Fine-Tuning é mais eficiente que LoRA",
      "LoRA só funciona para modelos pequenos (<1B parâmetros)"
    ],
    "correctIndex": 0,
    "explanation": "Full Fine-Tuning atualiza todos os bilhões de parâmetros do modelo, exigindo GPUs enormes e arriscando catastrophic forgetting. LoRA insere matrizes de decomposição de baixo rank (A×B, onde rank r << d) em camadas de atenção, treinando apenas essas matrizes (~0.1-1% dos parâmetros). Resultado comparável com fração do custo computacional.",
    "example": "LLaMA 7B: Full FT = 7 bilhões de parâmetros treináveis (requer 4×A100 80GB). LoRA rank 16: ~4 milhões de parâmetros treináveis (roda em 1×A100 24GB). Performance: ~95-99% do Full FT."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Difícil",
    "question": "O que é alucinação em LLMs e quais técnicas ajudam a mitigá-la?",
    "options": [
      "Modelo gera informações falsas com alta confiança; mitigar com RAG, grounding, temperature baixa e verificação factual",
      "Erro de digitação do modelo",
      "Problema de hardware",
      "Bug no código do modelo"
    ],
    "correctIndex": 0,
    "explanation": "Alucinação: LLM gera texto que parece correto mas é factualmente falso ou inventado. Causas: modelo é treinado para gerar texto plausível, não necessariamente verdadeiro. Mitigações: RAG (fundamentar em documentos), low temperature (menos criatividade), chain-of-thought (raciocínio passo a passo), citação de fontes.",
    "example": "Pergunta: 'Quem escreveu Dom Casmurro?' Correto: 'Machado de Assis, 1899'. Alucinação: 'José de Alencar, 1875' (confiante mas errado). Com RAG + citação: 'Machado de Assis (fonte: Wikipedia, Biblioteca Nacional)'."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Difícil",
    "question": "O que é RLHF (Reinforcement Learning from Human Feedback) e como é usado para alinhar LLMs?",
    "options": [
      "Humanos classificam respostas do LLM; um modelo de recompensa é treinado e usado para otimizar o LLM via RL",
      "Treinamento supervisionado normal",
      "Clustering de respostas",
      "Apenas filtros de conteúdo"
    ],
    "correctIndex": 0,
    "explanation": "RLHF: 1) Pré-treinar LLM. 2) SFT (Supervised Fine-Tuning) com exemplos curados. 3) Humanos comparam pares de respostas (qual é melhor?). 4) Treinar Reward Model com essas preferências. 5) Otimizar o LLM com PPO maximizando o Reward Model. Resultado: modelo mais útil, honesto e inofensivo.",
    "example": "Prompt: 'Como fazer um bolo'. Resposta A: receita detalhada. Resposta B: 'compre um pronto'. Humano: A > B. Reward Model aprende preferência. PPO otimiza LLM para gerar respostas como A. ChatGPT usa RLHF extensivamente."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Difícil",
    "question": "O que é Quantização de modelos LLM (GPTQ, AWQ, GGUF) e por que é importante?",
    "options": [
      "Reduzir a precisão numérica dos pesos (ex: 32-bit → 4-bit) para diminuir tamanho e acelerar inferência com perda mínima",
      "Aumentar o número de parâmetros",
      "Treinar o modelo com mais dados",
      "Converter o modelo para outro formato"
    ],
    "correctIndex": 0,
    "explanation": "LLaMA 70B em FP16: 140GB de VRAM (2×A100 80GB). Quantizado 4-bit: ~35GB (1×A100). Perda de qualidade: <3% em benchmarks. Técnicas: GPTQ (calibração com dados), AWQ (pesos ativados), GGUF (CPU-friendly, llama.cpp). Democratiza LLMs: roda em GPUs consumer.",
    "example": "LLaMA-2 70B: FP16=140GB (US$30k em GPUs). GPTQ 4-bit=35GB (US$2k GPU). GGUF Q4_K_M=40GB+RAM (roda em MacBook M2 Max). Benchmark MMLU: FP16=68.9%, 4-bit=67.2%. Perda de 1.7% → aceita para produção local."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Difícil",
    "question": "O que é Constitutional AI (CAI) e como difere do RLHF?",
    "options": [
      "Usa um conjunto de princípios escritos ('constituição') para o modelo se auto-avaliar, reduzindo dependência de feedback humano",
      "É a mesma coisa que RLHF",
      "Não usa nenhum tipo de treinamento",
      "Treina o modelo sem nenhuma regra"
    ],
    "correctIndex": 0,
    "explanation": "RLHF: humanos comparam respostas manualmente (caro, lento, subjetivo). CAI (Anthropic): define princípios (‘seja honesto’, ‘não ajude em atividades ilegais’). O modelo gera respostas → revisa com base nos princípios → gera versão melhorada. RLAIF: usa IA como avaliador em vez de humanos. Escalável e consistênte.",
    "example": "Pergunta tóxica: RLHF precisa de humano avaliando cada resposta (US$50/hora). CAI: modelo gera resposta → revisa contra princípio 'seja respeitoso' → corrige automaticamente. 1000 avaliações/minuto vs 10/hora com humanos."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Difícil",
    "question": "O que é Mixture of Experts (MoE) em LLMs e como essa arquitetura permite modelos maiores e mais eficientes?",
    "options": [
      "Divide o modelo em 'experts' especializados e um router que ativa apenas alguns por token, reduzindo custo computacional",
      "Treina múltiplos modelos completos em paralelo",
      "Combina as saídas de todos os experts para cada token",
      "É o mesmo que ensemble de modelos independentes"
    ],
    "correctIndex": 0,
    "explanation": "MoE substitui cada camada feed-forward por N experts especializados + um router (gating network). Para cada token, o router seleciona os Top-K experts (ex: 2 de 8). Resultado: parâmetros totais altos (capacidade), mas FLOPs por token baixos (eficiência). Mixtral 8x7B: 47B params total, mas ativa ~13B por token (como um modelo de 13B em custo).",
    "example": "Mixtral 8x7B: 8 experts de 7B cada, router ativa 2 por token. Token 'funcção matemática': router → experts 3 e 7 (especializados em lógica). Token 'poema romântico': router → experts 1 e 5 (especializados em criatividade). Custo: ~2×7B = 14B FLOPs vs 47B se ativasse todos."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Difícil",
    "question": "O que é DPO (Direct Preference Optimization) e como simplifica o processo de alinhamento comparado ao RLHF?",
    "options": [
      "Otimiza diretamente o modelo com dados de preferência sem treinar um reward model separado, eliminando a etapa de RL",
      "É idêntico ao RLHF",
      "Requer mais etapas que RLHF",
      "Não usa dados de preferência humana"
    ],
    "correctIndex": 0,
    "explanation": "RLHF: 3 etapas (SFT → treinar reward model → PPO). DPO simplifica para 1: dadas preferências (resposta A > resposta B), otimiza diretamente o policy model com uma loss de classificação binária. Matemática: a loss do DPO é equivalente à do RLHF sob certas condições, mas sem instabilidade do RL.",
    "example": "RLHF: (1) SFT no base model, (2) treinar reward model com 50k comparações, (3) PPO com reward model (instável, hiperparâmetros sensíveis). DPO: (1) SFT no base model, (2) treinar diretamente com 50k comparações via binary cross-entropy. Mesmo resultado, metade da complexidade, sem reward model."
  },
  {
    "id": "machine-learning-e-ia__IA Generativa e LLMs__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "IA Generativa e LLMs",
    "difficulty": "Difícil",
    "question": "O que é RLHF (Reinforcement Learning from Human Feedback) e como o PPO é aplicado para alinhar LLMs?",
    "options": [
      "RLHF: treina reward model com preferências humanas e usa PPO para otimizar a política (LLM) maximizando reward com penalidade KL para não desviar muito do modelo base",
      "Fine-tuning supervisionado com anotações humanas binárias de certo/errado",
      "Técnica de data augmentation onde humanos corrigem outputs do modelo iterativamente",
      "Método de destilação de conhecimento de modelos grandes para pequenos com feedback humano"
    ],
    "correctIndex": 0,
    "explanation": "RLHF (InstructGPT/ChatGPT): 1) SFT: fine-tuning com demonstrações humanas. 2) Reward Model: treinar RM para prever qual resposta humanos preferem (comparações pairwise). 3) PPO: otimizar LLM para maximizar RM(resposta) - β×KL(π||π_SFT). KL penalty evita o modelo colapsar para exploits do RM (reward hacking). DPO (Direct Preference Optimization): alternativa mais simples sem RM explícito.",
    "example": "ChatGPT: SFT em diálogos curados, depois RM treinado em 50k comparações humanas (qual resposta é melhor?). PPO: LLM gera resposta → RM pontua → gradiente ajusta LLM para respostas mais bem pontuadas. KL divergência: impede LLM de gerar texto estranho que engana o RM. Constitutional AI (Anthropic): substitui humanos por princípios no feedback."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Fácil",
    "question": "O que é MLOps e qual problema ele resolve no ciclo de vida de modelos de Machine Learning?",
    "options": [
      "Conjunto de práticas que automatiza e monitora o ciclo de ML: treinar, validar, deployar e monitorar modelos em produção",
      "É uma linguagem de programação para ML",
      "É um tipo de modelo de machine learning",
      "É uma ferramenta de visualização de dados"
    ],
    "correctIndex": 0,
    "explanation": "MLOps combina Machine Learning + DevOps para automatizar todo o ciclo de vida de modelos: versionamento de dados/modelos, pipelines de treinamento reproduzíveis, deploy automatizado, monitoramento de drift e retreinamento. Resolve o problema de 'funciona no notebook mas não em produção'.",
    "example": "Sem MLOps: cientista treina em Jupyter, envia .pkl por email, engenheiro deploya manualmente. Com MLOps: push no Git → pipeline treina, avalia métricas, deploiaa automaticamente se accuracy > threshold, monitora drift em produção."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Fácil",
    "question": "O que é versionamento de modelos e por que é importante em MLOps?",
    "options": [
      "Rastrear versões de modelos, dados e código para reprodutibilidade e rollback; ferramentas como MLflow e DVC",
      "Apenas versionar o código",
      "Salvar o modelo uma vez",
      "Usar Git apenas"
    ],
    "correctIndex": 0,
    "explanation": "Versionamento em ML envolve: código (Git), dados (DVC, Delta Lake), modelos (MLflow Model Registry), experimentos (MLflow, W&B). Permite: reproduzir resultados, comparar versões, rollback se novo modelo falhar, auditoria. Sem versionamento: 'qual modelo está em produção?' → impossível responder.",
    "example": "MLflow: Experimento #42: model_v3.pkl + dataset_v2.csv + hiperparâmetros {lr:0.01, epochs:50} → accuracy 92%. Se v4 cair para 85%, rollback instantâneo para v3."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Fácil",
    "question": "O que é Feature Store e como ele padroniza features em ML?",
    "options": [
      "Repositório centralizado de features pré-computadas reutilizáveis entre projetos, garantindo consistência treino/produção",
      "Banco de dados comum",
      "Loja de modelos",
      "Cache de predições"
    ],
    "correctIndex": 0,
    "explanation": "Feature Store centraliza o cálculo e armazenamento de features. Resolve: 1) Reutilização (mesma feature em múltiplos modelos). 2) Consistência treino-produção (training-serving skew). 3) Point-in-time correctness (evitar data leakage temporal). Exemplos: Feast, Tecton, Hopsworks.",
    "example": "Feature 'média_gastos_últimos_30_dias': calculada uma vez no Feature Store, reutilizada em modelos de fraude, crédito e recomendação. Sem Feature Store: cada time calcula diferente, causando inconsistência."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Fácil",
    "question": "O que é o conceito de 'reproducibilidade' em experimentos de ML e por que é difícil de alcançar?",
    "options": [
      "Capacidade de obter os mesmos resultados ao repetir um experimento; difícil devido a randomness, versões e ambiente",
      "É reproduzir o dataset",
      "É sempre automático com Git",
      "Só se aplica a produção"
    ],
    "correctIndex": 0,
    "explanation": "Reproducibilidade requer fixar: random seeds, versões de bibliotecas (requirements.txt), dados (DVC), código (Git), hiperparâmetros, hardware (GPU, CUDA). Python 3.10 + scikit-learn 1.3 + seed=42 pode dar resultado diferente de Python 3.11 + scikit-learn 1.4. Containers Docker ajudam a isolar o ambiente.",
    "example": "Resultado paper: accuracy 92.3%. Reprodução: instalar mesmas libs → accuracy 92.1% (ok). Lib atualizada → 91.5% (divergiu). Sem seed → 90.8-93.1% (varia). Docker + DVC + MLflow → 92.3% toda vez."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Fácil",
    "question": "O que é CI/CD para Machine Learning e como difere do CI/CD de software tradicional?",
    "options": [
      "Além de testar código, precisa validar dados, treinar modelos e verificar métricas antes do deploy",
      "É idêntico ao CI/CD de software",
      "ML não usa CI/CD",
      "Apenas testa o código Python"
    ],
    "correctIndex": 0,
    "explanation": "CI/CD tradicional: push → testes unitários → build → deploy. ML CI/CD adiciona: validação de dados (schema, drift), treino do modelo, avaliação de métricas (accuracy > threshold), teste de integração com API, deploy automatizado (canary/shadow). Se métrica cai → pipeline falha → alerta. Ferramentas: GitHub Actions + MLflow + Seldon.",
    "example": "Push no Git → CI: lint + testes unitários (5min) → valida schema dos dados → treina modelo (30min) → accuracy 91% > threshold 88% ✓ → CD: deploy canary 5% → métricas ok → 100%. Se accuracy=85% → pipeline falha → alerta."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Fácil",
    "question": "O que é o MLflow e quais problemas ele resolve no ciclo de vida de modelos?",
    "options": [
      "Plataforma open-source para tracking de experimentos, empacotamento de modelos, model registry e deploy",
      "É uma linguagem de programação para ML",
      "É um tipo de banco de dados",
      "Só serve para treinar modelos"
    ],
    "correctIndex": 0,
    "explanation": "MLflow tem 4 componentes: (1) Tracking — registra parâmetros, métricas e artefatos de cada experimento. (2) Projects — empacota código de treino de forma reproduzível. (3) Models — formato padrão para salvar modelos (sklearn, PyTorch, etc). (4) Model Registry — versionamento com stages (Staging → Production → Archived).",
    "example": "Experimento #42: mlflow.log_param('lr', 0.01), mlflow.log_metric('accuracy', 0.92), mlflow.sklearn.log_model(model). UI mostra todos os runs comparados. Model Registry: promover modelo v3 de Staging para Production com 1 clique."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Fácil",
    "question": "O que é um endpoint de API para servir modelos de ML e como funciona?",
    "options": [
      "URL que recebe dados via HTTP e retorna predições do modelo em formato JSON, permitindo integração com aplicações",
      "É o arquivo do modelo salvo em disco",
      "É o código de treinamento",
      "Só funciona com modelos de imagem"
    ],
    "correctIndex": 0,
    "explanation": "O modelo é carregado em memória e exposto via API REST (Flask, FastAPI) ou gRPC. O cliente envia dados de entrada em JSON, o servidor executa a inferência e retorna a predição. Requisitos: latência baixa, autoscaling, health checks, autenticação. Plataformas: SageMaker, Vertex AI, Seldon Core.",
    "example": "POST /predict {features: [25, 50000, 3]} → modelo executa inferência → resposta {prediction: 'approved', confidence: 0.87}. FastAPI + uvicorn: 500 requests/seg com latência < 50ms. Em produção: load balancer + autoscaling de 2 a 20 réplicas."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Fácil",
    "question": "O que é model drift e qual a diferença entre data drift e concept drift?",
    "options": [
      "Data drift: distribuição das features muda em produção vs treino; concept drift: relação entre features e target muda; ambos degradam performance do modelo com o tempo",
      "Model drift é a redução de performance por underfitting; corrigido com mais dados de treino",
      "Data drift ocorre apenas em séries temporais; concept drift em dados categóricos",
      "São sinônimos para overfitting do modelo nos dados de produção"
    ],
    "correctIndex": 0,
    "explanation": "Data drift (covariate shift): P(X) muda — ex: perfil demográfico dos usuários muda. Concept drift: P(Y|X) muda — ex: padrões de fraude evoluem, comportamento de compra muda em crise. Prior probability drift: P(Y) muda — mais usuários premium. Detecção: PSI (Population Stability Index), KS test, monitoramento de distribuições. Resposta: retreinamento periódico, trigger por threshold de degradação.",
    "example": "Modelo de crédito treinado em 2020: data drift em 2022 (inflação muda perfil de inadimplência). Concept drift: padrões de calote antes vs depois da pandemia. Monitor: PSI > 0.25 = data drift severo → alertar. Evidently AI, WhyLabs, Arize: ferramentas de monitoramento de ML. Retreino automático quando accuracy cai abaixo de threshold."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Médio",
    "question": "O que é 'model drift' (deriva de modelo) e como detectá-lo em produção?",
    "options": [
      "Degradação da performance do modelo ao longo do tempo porque a distribuição dos dados de produção muda; detecta-se monitorando métricas e distribuições",
      "O modelo fica mais lento com o tempo",
      "O modelo cresce em tamanho de arquivo",
      "Os logs do modelo param de ser gerados"
    ],
    "correctIndex": 0,
    "explanation": "Model drift ocorre quando a relação entre features e target muda ao longo do tempo (concept drift) ou quando a distribuição dos dados de entrada muda (data drift). Detecta-se comparando métricas de produção com baseline, monitorando distribuições estatísticas das features e outputs com testes como KS, PSI ou Page-Hinkley.",
    "example": "Modelo de fraude treinado em 2024. Em 2025, novo tipo de fraude com Pix surge. Accuracy cai de 95% para 82%. Alerta de drift: distribuição de 'metodo_pagamento' mudou (PSI > 0.2). Ação: retreinar com dados recentes."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Médio",
    "question": "O que é um pipeline de ML e quais são suas etapas principais?",
    "options": [
      "Sequência automatizada: ingestão → pré-processamento → treino → avaliação → deploy → monitoramento",
      "Apenas o treino do modelo",
      "Pipeline de dados apenas",
      "Só o deploy"
    ],
    "correctIndex": 0,
    "explanation": "Pipeline de ML automatiza o fluxo end-to-end: 1) Ingestão de dados. 2) Validação de qualidade. 3) Feature engineering. 4) Treino com hiperparâmetros. 5) Avaliação de métricas. 6) Registro do modelo. 7) Deploy (canary/blue-green). 8) Monitoramento. Ferramentas: Kubeflow, Airflow, Vertex AI Pipelines.",
    "example": "Pipeline automatizado: dados chegam diariamente → validação (schema check) → pré-processamento → treino XGBoost → se accuracy > 90% → deploy automático em API → monitorar drift. Falha em qualquer etapa → alerta."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Médio",
    "question": "O que é A/B testing para modelos de ML em produção?",
    "options": [
      "Dividir tráfego entre modelo atual e novo para comparar métricas de negócio em tempo real antes de migrar",
      "Treinar dois modelos e comparar offline",
      "Testar em dados de validação",
      "Comparar logs depois"
    ],
    "correctIndex": 0,
    "explanation": "A/B testing em ML: modelo A (atual/controle) recebe X% do tráfego, modelo B (novo/tratamento) recebe Y%. Métricas de negócio (conversão, receita, engajamento) são comparadas com significância estatística. Se B > A → migrar 100% para B. Diferente de avaliação offline: captura efeitos reais do usuário.",
    "example": "Recomendação de produtos: modelo atual (A) → 3.2% conversão em 50% do tráfego. Novo modelo (B) → 3.8% conversão em 50%. Após 2 semanas, p-value < 0.01 → B é melhor. Migrar 100% para B."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Médio",
    "question": "O que é 'model monitoring' e quais sinais de degradação devem ser monitorados?",
    "options": [
      "Acompanhar performance, data drift, concept drift e métricas de sistema do modelo em produção continuamente",
      "Monitorar apenas o tempo de resposta da API",
      "Verificar o modelo uma vez por mês manualmente",
      "Apenas monitorar erros de código"
    ],
    "correctIndex": 0,
    "explanation": "Monitorar em produção: 1) Data drift: distribuição dos inputs muda (PSI, KS test). 2) Concept drift: relação input→output muda. 3) Performance: accuracy, latência, throughput. 4) Infraestrutura: CPU, memória, GPU usage. Ferramentas: Evidently AI, WhyLabs, Arize. Sem monitoramento: modelo degradado leva a decisões ruins silenciosamente.",
    "example": "Modelo de crédito: Janeiro accuracy=93%. Março: PSI da feature 'renda' = 0.35 (drift alto!). Abril: accuracy caiu para 84%. Causa: inflação mudou a distribuição de renda. Ação automática: retreinar com dados recentes → accuracy volta a 91%."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Médio",
    "question": "O que é o conceito de 'model governance' e por que é importante em ML empresarial?",
    "options": [
      "Framework de controle, documentação e auditoria sobre quem treina, aprova e deploya modelos",
      "É apenas versionamento de código",
      "Só importa para modelos grandes",
      "É controle de acesso ao servidor"
    ],
    "correctIndex": 0,
    "explanation": "Model governance define: quem pode treinar e deployar modelos (RBAC), documentação obrigatória (model cards), aprovação antes de produção (review board), auditoria de bias/fairness, conformidade regulatória (LGPD, GDPR). Essencial em setores regulados (finanças, saúde). Ferramentas: MLflow Model Registry com stages (Staging → Production).",
    "example": "Banco: cientista treina modelo de crédito → submete model card (dados, métricas, bias analysis) → comitê de risco revisa → aprovado com condições ('retreinar a cada 3 meses') → deploy para produção → audit log registra tudo."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Médio",
    "question": "O que é DVC (Data Version Control) e como complementa o Git para projetos de ML?",
    "options": [
      "Ferramenta que versiona datasets e modelos grandes usando ponteiros no Git enquanto armazena os arquivos em storage externo",
      "Substitui o Git completamente",
      "Só funciona com dados de texto",
      "É um banco de dados relacional"
    ],
    "correctIndex": 0,
    "explanation": "Git não suporta arquivos grandes (datasets de GB, modelos de GB). DVC armazena hash pointers no Git (.dvc files) e os dados reais em remote storage (S3, GCS, Azure Blob). Permite: git checkout v1.0 + dvc checkout → restaura exatamente o dataset e modelo daquela versão. Reprodutibilidade total.",
    "example": "dvc add data/train.csv → cria train.csv.dvc (hash do arquivo). git add train.csv.dvc && git commit. Arquivo real (2GB) vai para S3. Colega faz git pull + dvc pull → baixa exatamente o mesmo dataset. dvc diff v1.0..v2.0 mostra o que mudou."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Médio",
    "question": "O que é blue-green deployment para modelos de ML e como reduz downtime?",
    "options": [
      "Mantém dois ambientes idênticos (blue=atual, green=novo); switch instantâneo de tráfego para o green após validação",
      "Deploy gradual por percentual",
      "É o mesmo que shadow deploy",
      "Requer parar o serviço para atualizar"
    ],
    "correctIndex": 0,
    "explanation": "Blue-green: ambiente Blue (modelo v1 servindo 100% do tráfego). Deploy modelo v2 no ambiente Green (sem tráfego). Testar Green isoladamente. Switch: load balancer aponta para Green (0 downtime). Se falhar: switch instantâneo de volta para Blue. Custo: precisa do dobro de infraestrutura temporariamente.",
    "example": "Blue (v1): API /predict servindo 1000 req/s. Green (v2): deploy + smoke tests + health checks (5 min). Switch DNS/load balancer: Green assume 100% em < 1s. Problema em v2? Rollback para Blue em < 1s. Zero downtime para usuários."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Médio",
    "question": "O que é um feature store e qual problema ele resolve em pipelines de ML em produção?",
    "options": [
      "Repositório centralizado de features computadas e versionadas; resolve inconsistência treino-serviço (training-serving skew) garantindo que treino e inferência usem as mesmas transformações",
      "Banco de dados de hiperparâmetros e métricas de experimentos de ML",
      "Repositório de modelos treinados com versionamento e rollback automático",
      "Cache de predições recentes para reduzir latência de inferência em tempo real"
    ],
    "correctIndex": 0,
    "explanation": "Training-serving skew: feature computada diferente em treino vs produção → degradação silenciosa. Feature store: features pré-computadas e armazenadas offline (batch) e online (baixa latência). Partes: feature registry (catálogo), offline store (histórico, warehouse), online store (Redis, DynamoDB para inferência). Point-in-time correctness: features históricas sem data leakage futuro em treino.",
    "example": "Feature 'média de compras dos últimos 30 dias'. Treino: computa com SQL offline no warehouse. Produção: sem feature store → reimplementa em Python → resultado levemente diferente (timezone, arredondamento). Feature store (Feast, Tecton, Vertex): compute once, serve everywhere. Treino e serving usam mesmo pipeline. feature_store.get_online_features(['avg_purchase_30d'], entity_rows=[{'user_id': 123}])."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Difícil",
    "question": "Em um pipeline ML de produção, qual é a diferença entre 'online serving' (real-time inference) e 'batch serving' e quando usar cada um?",
    "options": [
      "Online serve predições individuais em ms via API; batch processa grandes volumes periodicamente; escolha depende de latência requerida",
      "Online é sempre melhor que batch",
      "Batch é em tempo real e online é periódico",
      "São sinônimos para o mesmo tipo de deploy"
    ],
    "correctIndex": 0,
    "explanation": "Online serving: modelo carregado em memória responde requisições individuais via API REST/gRPC com latência em milissegundos (ex.: recomendações, detecção de fraude). Batch serving: modelo processa grandes lotes de dados periodicamente (ex.: prever churn mensal de todos os clientes). Online exige mais infra (GPU, autoscaling), batch pode usar Spark/EMR.",
    "example": "Fraude bancária: online serving — cada transação é avaliada em <100ms antes de autorizar. Previsão de demanda mensal: batch — roda modelo sobre 1M de SKUs toda segunda-feira às 3h, resultado salvo em tabela para dashboard."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Difícil",
    "question": "O que é containerização de modelos ML e por que Docker é essencial em MLOps?",
    "options": [
      "Empacotar modelo + dependências + código em container Docker para deploy reproduzível em qualquer ambiente",
      "Apenas salvar o modelo em arquivo",
      "Virtualização completa de OS",
      "Compressão do modelo"
    ],
    "correctIndex": 0,
    "explanation": "Docker encapsula modelo, runtime (Python, libs), código de inferência e configuração em uma imagem. Garante que o modelo funcione identicamente em dev, staging e produção. Resolve 'funciona na minha máquina'. Integra com Kubernetes para escalabilidade, auto-scaling e health checks.",
    "example": "Dockerfile: FROM python:3.11 → COPY model.pkl → pip install scikit-learn==1.3.0 flask → CMD serve.py. Imagem de 500MB rodará idêntica em qualquer máquina com Docker, de laptop a cluster Kubernetes."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Difícil",
    "question": "O que é shadow deployment e canary release para modelos de ML?",
    "options": [
      "Shadow: novo modelo recebe tráfego real mas respostas são descartadas (só monitora). Canary: envia % pequena do tráfego real para o novo modelo",
      "São a mesma coisa",
      "Shadow substitui o modelo antigo",
      "Canary usa dados de teste"
    ],
    "correctIndex": 0,
    "explanation": "Shadow deploy: novo modelo processa requests reais em paralelo com o atual, mas respostas do novo não são retornadas ao usuário. Compara predições sem risco. Canary release: envia 1-5% do tráfego real para o novo modelo, monitora métricas, aumenta gradualmente (5→10→50→100%). Ambos reduzem risco de deploy.",
    "example": "Shadow: modelo v2 processa 100% do tráfego em paralelo com v1. Logs mostram que v2 acerta 95% vs 90% do v1. Canary: migra 5% → monitora 1h → ok → 25% → ok → 100%. Se falhar em qualquer ponto → rollback automático."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Difícil",
    "question": "O que é 'model compression' e quais técnicas permitem rodar modelos em edge devices?",
    "options": [
      "Reduzir tamanho/complexidade via pruning, quantização, destilação de conhecimento e otimização de arquitetura",
      "Apenas reduzir o dataset de treino",
      "Usar GPUs mais potentes",
      "Não é possível rodar modelos em edge"
    ],
    "correctIndex": 0,
    "explanation": "Pruning: remove conexões/neurônios com peso próximo de zero (90% pruning → modelo 10× menor, ~1% perda). Quantização: FP32→INT8 (4× menor, 2× mais rápido). Knowledge Distillation: modelo grande (teacher) treina modelo pequeno (student). ONNX Runtime + TensorRT otimizam para hardware específico.",
    "example": "BERT-base (110M parâmetros, 440MB): latência 50ms em A100. DistilBERT (66M, 260MB): latência 25ms, 97% da performance. Quantizado INT8 (66MB): latência 8ms em CPU. TinyBERT (14.5M, 58MB): roda em smartphone com 15ms."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Difícil",
    "question": "O que são Feature Flags para modelos de ML e como habilitam experimentação segura?",
    "options": [
      "Switches que permitem ativar/desativar modelos ou versões em produção sem redeploy",
      "Flags no código de treino",
      "Parâmetros do modelo",
      "Tags no dataset"
    ],
    "correctIndex": 0,
    "explanation": "Feature flags para ML: ativar modelo v2 para 10% dos usuários, ou apenas para região X, ou apenas internamente. Se problemas → desativar a flag instantaneamente (sem redeploy). Combina com A/B testing: flag controla qual modelo cada segmento recebe. Ferramentas: LaunchDarkly, Split.io, Unleash.",
    "example": "Flag 'ml-recomendacao-v2': ativo para equipe interna (100%) → funcionários testam 1 semana → ativo para 5% users Brasil → métricas ok → 50% → 100%. Bug detectado? Desativa a flag em 1 clique, volta ao v1 em segundos."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Difícil",
    "question": "O que são data contracts em MLOps e como previnem quebras em pipelines de ML?",
    "options": [
      "Acordos formais sobre schema, tipos e semântica dos dados entre produtores e consumidores, validados automaticamente",
      "São contratos legais entre empresas",
      "São validações de modelo",
      "Só existem para dados de texto"
    ],
    "correctIndex": 0,
    "explanation": "Data contracts definem: schema (colunas, tipos), constraints (not null, ranges, enums), SLAs (fresqueness, completeness), ownership (quem produz/consome). Validados automaticamente no pipeline. Se o produtor mudar o schema sem atualizar o contrato → pipeline falha com erro claro em vez de modelo silenciosamente degradado.",
    "example": "Contrato: feature 'renda' → tipo float, range [0, 1000000], not null, updated daily. Time de data eng muda 'renda' para string → validação falha no pipeline → alerta: 'contract violation: renda expected float, got string'. Sem contrato: modelo receberia strings, faria predições lixo silenciosamente."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Difícil",
    "question": "O que é observabilidade de modelos (model observability) e como vai além do monitoramento tradicional?",
    "options": [
      "Além de métricas, captura logs, traces e explicações das predições para diagnóstico de causa raiz",
      "É o mesmo que monitoramento",
      "Só monitora latência",
      "Não se aplica a ML"
    ],
    "correctIndex": 0,
    "explanation": "Monitoramento diz 'algo está errado' (accuracy caiu). Observabilidade diz 'POR QUE está errado': (1) Métricas: accuracy, latência, drift scores. (2) Logs: cada predição com input/output/confiança. (3) Traces: caminho da requisição (feature store → modelo → resposta). (4) Explainability: SHAP values por predição. Ferramentas: Arize, WhyLabs, Fiddler.",
    "example": "Accuracy caiu 5%. Monitoramento: alerta 'accuracy baixa'. Observabilidade: traces mostram que Feature Store está retornando dados stale (2h de atraso). Logs: 30% das predições têm feature 'saldo' = null. SHAP: 'saldo' é a feature mais importante. Causa raiz: ETL do banco de dados atrasou."
  },
  {
    "id": "machine-learning-e-ia__MLOps e Deploy de Modelos__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "MLOps e Deploy de Modelos",
    "difficulty": "Difícil",
    "question": "O que é shadow deployment e como difere de canary release e A/B testing em ML?",
    "options": [
      "Shadow: novo modelo recebe tráfego real mas não serve ao usuário (comparação silenciosa); Canary: portion pequena de usuários recebe novo modelo; A/B: split controlado para teste de hipótese estatístico",
      "São estratégias equivalentes de rollout; a escolha depende apenas do time de engenharia",
      "Shadow deployment não registra métricas; Canary usa feature flags; A/B usa ML para otimizar split",
      "A/B testing é para produto; Shadow e Canary são exclusivos para infraestrutura"
    ],
    "correctIndex": 0,
    "explanation": "Shadow: replica requisições para novo modelo em paralelo, compara predictions sem risco de usuário. Identifica bugs, diferenças de predictions, latência. Canary: 5% do tráfego para novo modelo com monitoramento intensivo. Rollback rápido se métricas pioram. A/B test: split por holdout, mede impacto em KPI de negócio (conversão, receita) com significância estatística. Interleaving: mais eficiente para ranqueamento (tanto modelo A quanto B servem para mesmo usuário).",
    "example": "Novo modelo de recomendação: Shadow (1 semana) → validar latência p99, verificar que não crasha. Canary 5% → monitorar CTR, conversion rate vs controle. A/B formal 50/50 → 2 semanas para significância estatística (α=0.05, potência=0.8). Se lift positivo: rollout 100%. Netflix, Spotify: centenas de A/B tests simultâneos com mutual exclusion de experimentos."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Fácil",
    "question": "Qual técnica de pré-processamento transforma valores numéricos para o intervalo [0, 1]?",
    "options": [
      "Normalização Min-Max",
      "Padronização Z-Score",
      "One-Hot Encoding",
      "Label Encoding"
    ],
    "correctIndex": 0,
    "explanation": "A normalização Min-Max transforma cada valor usando a fórmula: X_norm = (X - X_min) / (X_max - X_min). Resultado sempre entre 0 (mínimo) e 1 (máximo). Preserva a distribuição original mas é sensível a outliers que distorcem X_min e X_max.",
    "example": "Idades [20, 30, 50, 80]. Min=20, Max=80. Normalizado: [(20-20)/60, (30-20)/60, (50-20)/60, (80-20)/60] = [0.0, 0.167, 0.5, 1.0]."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Fácil",
    "question": "O que é feature engineering e por que é tão importante para modelos de ML?",
    "options": [
      "Criar, transformar e selecionar variáveis a partir dos dados brutos para melhorar a performance do modelo",
      "Apenas coletar mais dados",
      "Treinar por mais epochs",
      "Escolher outro algoritmo"
    ],
    "correctIndex": 0,
    "explanation": "Feature engineering transforma dados brutos em features informativas. Inclui: criação (idade_ao_quadrado, dia_da_semana), transformação (log, normalização), combinação (preço/m², ratio), extração (texto→TF-IDF, imagem→embeddings). 'Better features beat better algorithms' — Andrew Ng.",
    "example": "Dataset imobiliário: features brutas [área, quartos, banheiros, preço]. Feature engineering: preço_por_m² = preço/área, proporção_quartos_banheiros = quartos/banheiros. Modelo com features criadas: R²=0.92 vs R²=0.78 sem."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Fácil",
    "question": "Por que dividir dados em treino, validação e teste? Qual a diferença de cada conjunto?",
    "options": [
      "Treino: aprender padrões. Validação: ajustar hiperparâmetros. Teste: avaliação final não enviesada",
      "Dois conjuntos bastam",
      "Usar todos os dados para treino",
      "Teste e validação são iguais"
    ],
    "correctIndex": 0,
    "explanation": "Treino (~70%): modelo aprende os padrões (ajusta pesos). Validação (~15%): ajustar hiperparâmetros (learning rate, regularização) e escolher o melhor modelo sem viesar o teste. Teste (~15%): avaliação final única, simula dados nunca vistos. Se usar teste para ajustar modelo → data leakage.",
    "example": "10000 amostras: 7000 treino, 1500 validação, 1500 teste. Treinar 5 modelos → comparar no validação → melhor modelo → avaliar UMA VEZ no teste → accuracy final 88%. Se fizer ajustes baseados no teste, o 88% não é confiável."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Fácil",
    "question": "O que são dados faltantes (missing values) e quais são as estratégias básicas para tratá-los?",
    "options": [
      "Valores ausentes no dataset; estratégias incluem remoção, imputação pela média/mediana/moda ou preenchimento por modelo",
      "Dados faltantes devem ser ignorados",
      "Sempre substituir por zero",
      "Dados faltantes não existem em datasets reais"
    ],
    "correctIndex": 0,
    "explanation": "Missing values: MCAR (aleatório), MAR (depende de outras features), MNAR (depende do próprio valor faltante). Estratégias: 1) Remoção (>60% faltantes ou MCAR). 2) Média/mediana para numéricos, moda para categóricos. 3) Forward/backward fill para séries temporais. 4) Modelos (KNN Imputer, MICE).",
    "example": "Feature 'renda' com 8% missing: média=R$5000, mediana=R$4200 (há outliers). Mediana é melhor aqui. Feature 'CEP' com 70% missing → remover feature. Feature 'temperatura' em série temporal → forward fill (usar último valor)."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Fácil",
    "question": "O que é Feature Engineering e por que pode ter mais impacto que trocar o algoritmo?",
    "options": [
      "Criar ou transformar features a partir dos dados brutos para melhorar a qualidade das entradas do modelo",
      "É apenas renomear colunas",
      "É trocar o algoritmo de ML",
      "Só funciona com redes neurais"
    ],
    "correctIndex": 0,
    "explanation": "Feature Engineering: transformar dados brutos em representações mais informativas. Técnicas: combinações (preço/área → preço_por_m²), extração temporal (data → dia_semana, mês, é_feriado), encoding, binning (idade → faixa_etária), log transforms (normalizar distribuições). Um bom feature engineering pode melhorar accuracy de 80% para 92% com o mesmo modelo.",
    "example": "Dataset de e-commerce: features brutas [data, valor, produto]. Feature engineering: hora_do_dia, dia_da_semana, valor_médio_últimas_5_compras, dias_desde_última_compra. Modelo com features brutas: 78%. Com features engineered: 91%. Mesmo XGBoost."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Fácil",
    "question": "O que é One-Hot Encoding e para que tipo de variável categórica ele é indicado?",
    "options": [
      "Cria uma coluna binária (0/1) para cada categoria, indicado para variáveis nominais sem ordem natural",
      "É usado para variáveis numéricas",
      "Atribui números sequenciais às categorias",
      "Remove variáveis categóricas do dataset"
    ],
    "correctIndex": 0,
    "explanation": "One-Hot Encoding converte cada valor categórico em uma coluna binária independente. Evita que modelos interpretem ordem inexistente entre categorias. Indicado para: cor, país, tipo de produto. Problema: alta cardinalidade (1000 cidades = 1000 colunas). Solução: Target Encoding ou embeddings.",
    "example": "Feature 'animal': [gato, cão, peixe]. One-Hot: animal_gato=[1,0,0], animal_cão=[0,1,0], animal_peixe=[0,0,1]. Se Label Encoding (gato=0, cão=1, peixe=2), modelo poderia interpretar peixe > cão > gato, o que não faz sentido."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre variáveis numéricas e categóricas e como cada tipo é tratado em ML?",
    "options": [
      "Numéricas representam quantidades contínuas/discretas; categóricas representam classes/grupos e precisam de encoding para uso em modelos",
      "São a mesma coisa",
      "Categóricas sempre são números",
      "Numéricas não precisam de pré-processamento"
    ],
    "correctIndex": 0,
    "explanation": "Numéricas: valores quantitativos (idade: 25, salário: R$5000). Contínuas (temperatura) ou discretas (quartos). Tratamento: normalização, padronização, log transform. Categóricas: classes sem valor numérico intrínseco. Nominais (cor, país) ou ordinais (escolaridade: fundamental < médio < superior). Tratamento: encoding (One-Hot, Label, Target).",
    "example": "Dataset: idade (numérica contínua → StandardScaler), quartos (numérica discreta → manter), cor (categórica nominal → One-Hot), escolaridade (categórica ordinal → Label Encoding: fundamental=0, médio=1, superior=2 preserva a ordem)."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre normalização (min-max scaling) e padronização (z-score standardization)?",
    "options": [
      "Normalização escala para [0,1] e é afetada por outliers; padronização transforma para média 0, desvio 1 e é mais robusta; StandardScaler para algoritmos baseados em distância e gradiente",
      "São equivalentes — qualquer uma pode ser usada em qualquer algoritmo sem diferença",
      "Normalização é somente para dados categóricos; padronização para dados numéricos contínuos",
      "Padronização elimina outliers; normalização apenas reescala sem tratar valores extremos"
    ],
    "correctIndex": 0,
    "explanation": "Min-max: x' = (x - min)/(max - min) → [0,1]. Afetado por outliers (um valor extremo comprime todos os outros). Z-score: x' = (x - μ)/σ → média 0, dp 1. Mais robusto. RobustScaler: usa mediana e IQR, mais resistente a outliers extremos. Quando usar: SVM, KNN, Regressão, Redes Neurais (gradiente) precisam de escala. Árvores de decisão e Random Forest: invariantes à escala.",
    "example": "Renda: [1000, 2000, 3000, 1000000]. Min-max: [0, 0.001, 0.002, 1.0] — todos comprimidos. Z-score: [-0.57, -0.57, -0.57, 1.71] — menos distorcido. RobustScaler: usa mediana=2000, IQR=1000 — (x-2000)/1000. Feature age em [18,90]: normalizar para [0,1]. KNN com age e renda sem scaler: renda domina completamente a distância."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Médio",
    "question": "Para variáveis categóricas nominais como 'cor' (vermelho, azul, verde), qual técnica de encoding é mais adequada e por quê?",
    "options": [
      "One-Hot Encoding — cria uma coluna binária para cada categoria, evitando ordem implícita",
      "Label Encoding — atribui números sequenciais",
      "Ordinal Encoding — atribui números ordenados",
      "Frequency Encoding — usa a frequência como valor"
    ],
    "correctIndex": 0,
    "explanation": "One-Hot Encoding cria uma coluna binária (0 ou 1) para cada valor categórico. Evita que o modelo interprete uma ordem inexistente entre categorias (vermelho=1 < azul=2 < verde=3 não faz sentido). Label Encoding é adequado apenas para variáveis ordinais onde há ordem natural.",
    "example": "cor: [vermelho, azul, verde] → cor_vermelho: [1,0,0], cor_azul: [0,1,0], cor_verde: [0,0,1]. Se usasse Label Encoding (0,1,2), o modelo poderia interpretar verde > azul > vermelho erroneamente."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Médio",
    "question": "O que é data leakage e como ele compromete a avaliação do modelo?",
    "options": [
      "Quando informação do teste/futuro vaza para o treino, inflando métricas artificialmente; modelo falha em produção",
      "Excesso de dados",
      "Dados duplicados",
      "Features faltantes"
    ],
    "correctIndex": 0,
    "explanation": "Data leakage: modelo usa informação que não estaria disponível em produção. Tipos: 1) Target leakage: feature deriva do target (ex: variável 'tratamento_iniciado' para prever 'doença'). 2) Train-test leakage: normalizar antes de dividir. 3) Temporal: usar dados futuros para prever o passado. Resultado: accuracy irreal.",
    "example": "Prever inadimplência: feature 'dias_em_atraso' = target leakage (só existe DEPOIS da inadimplência). No treino: accuracy 99%. Em produção: accuracy 55%. Remover a feature e retreinar dá accuracy real de 82%."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Médio",
    "question": "O que é StandardScaler (Z-score normalization) e quando usá-lo em vez de Min-Max?",
    "options": [
      "Transforma dados para média=0 e desvio padrão=1; melhor quando há outliers ou quando o algoritmo assume normalidade",
      "Remove outliers",
      "Categoriza variáveis",
      "Reduz dimensionalidade"
    ],
    "correctIndex": 0,
    "explanation": "StandardScaler: z = (x - μ) / σ. Centra os dados na média e escala pelo desvio padrão. Preferir sobre Min-Max quando: há outliers (Min-Max comprime tudo para perto de 0), algoritmo assume normalidade (Gaussian Naive Bayes, LDA), dados com distribuições variadas.",
    "example": "Salários: [30k, 35k, 40k, 500k]. Min-Max: [0, 0.01, 0.02, 1.0] — outlier comprime os demais. StandardScaler: [-0.54, -0.48, -0.43, 2.78] — melhor distribuição, outlier sinalizado mas não distorce."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Médio",
    "question": "O que é Target Encoding para variáveis categóricas de alta cardinalidade?",
    "options": [
      "Substitui cada categoria pela média do target naquela categoria, útil para features com muitos valores únicos",
      "É o mesmo que One-Hot Encoding",
      "Remove categorias raras",
      "Converte para números sequenciais"
    ],
    "correctIndex": 0,
    "explanation": "Target Encoding: para a feature 'cidade' (1000 valores únicos), One-Hot cria 1000 colunas. Target Encoding: cidade='SP' → média do target para SP = 0.35. Problema: data leakage se calcular no treino completo. Solução: calcular via K-Fold ou smoothing com prior global μ_global.",
    "example": "Feature 'bairro' com 500 bairros. One-Hot: 500 colunas (esparsas, overfitting). Target Encoding: 'Moema'→R$850k (média preço), 'Capão'→R$280k. Modelo com One-Hot: R²=0.75. Target Encoding com smoothing: R²=0.88."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Médio",
    "question": "Qual a diferença entre normalização e padronização e quando usar cada uma?",
    "options": [
      "Normalização escala para [0,1] (Min-Max); padronização centeriza em média=0, σ=1 (StandardScaler)",
      "São a mesma coisa",
      "Normalização só funciona com dados positivos",
      "Padronização sempre é melhor"
    ],
    "correctIndex": 0,
    "explanation": "Min-Max (normalização): x' = (x-min)/(max-min), escala para [0,1]. Sensível a outliers. Bom para: redes neurais (inputs bounded), algoritmos baseados em distância (KNN, SVM). StandardScaler (padronização): z = (x-μ)/σ, média=0, σ=1. Robusto a outliers. Bom para: regressão linear, PCA, algoritmos que assumem normalidade.",
    "example": "Features: idade [0-100] e renda [0-1000000]. Sem escalar: KNN dominado por renda. Min-Max: ambas [0,1] mas renda 1M distorce. StandardScaler: ambas com σ=1 → KNN trata igualmente. Com outlier renda=1M: StandardScaler é mais robusto."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Médio",
    "question": "O que é Label Encoding e quando usá-lo em vez de One-Hot Encoding?",
    "options": [
      "Atribui números inteiros sequenciais a categorias; usar quando há ordinalidade natural entre as categorias",
      "Sempre preferível ao One-Hot",
      "Criar colunas binárias",
      "Só funciona com 2 categorias"
    ],
    "correctIndex": 0,
    "explanation": "Label Encoding: categorías → inteiros (fundamental=0, médio=1, superior=2). Adequado para variáveis ordinais onde a ordem numérica reflete a realidade. Para nominais (cor, país), gera relações falsas (vermelho=0 < azul=1 < verde=2). Modelos baseados em árvore toleram Label Encoding em nominais; lineares não.",
    "example": "Escolaridade: fundamental=0, médio=1, superior=2. Ordem real → Label Encoding OK. Cor: vermelho=0, azul=1, verde=2. Sem ordem real → One-Hot melhor. Exceção: XGBoost e LightGBM lidam bem com Label Encoding mesmo em nominais por fazerem splits binários."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Médio",
    "question": "O que é log transform e quando aplicá-la em features com distribuição assimétrica?",
    "options": [
      "Aplica logaritmo para comprimir valores altos e reduzir assimetria positiva (right-skewed), aproximando de distribuição normal",
      "Remove outliers do dataset",
      "Transforma dados categóricos em numéricos",
      "É o inverso da normalização"
    ],
    "correctIndex": 0,
    "explanation": "Log transform: x' = log(x+1) (o +1 evita log(0)). Comprime valores altos e expande baixos, reduzindo right-skew. Indicada para: preços, salários, contagens, populações — dados com cauda longa à direita. Alternativas: Box-Cox (encontra melhor transformação automaticamente), Yeo-Johnson (aceita negativos).",
    "example": "Salários: [2k, 3k, 4k, 5k, 200k]. Skewness = 4.5 (muito assimétrico). Log transform: [7.6, 8.0, 8.3, 8.5, 12.2]. Skewness = 1.1 (melhor). Regressão Linear com salário bruto: R²=0.55. Com log(salário): R²=0.82. A transformação linearizou a relação."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Médio",
    "question": "O que é one-hot encoding e quando label encoding pode causar problemas em variáveis categóricas nominais?",
    "options": [
      "One-hot cria coluna binária por categoria (sem ordem implícita); label encoding atribui inteiro por categoria e implica ordem/magnitude que modelos paramétricos interpretam incorretamente",
      "Label encoding cria mais features; one-hot é mais compacto e eficiente em memória",
      "São equivalentes para árvores de decisão mas diferentes apenas para redes neurais",
      "One-hot fica inviável com alta cardinalidade; label encoding é sempre preferível nesse caso"
    ],
    "correctIndex": 0,
    "explanation": "Label encoding: cor = {'azul':0, 'verde':1, 'vermelho':2}. Problema: modelo interpreta vermelho (2) como 'maior que' azul (0). Regressão linear/logística, SVM, KNN: afetados. One-hot: cria coluna is_azul, is_verde, is_vermelho — sem ordem implícita. Dummy variable trap: retirar uma coluna (k-1) em modelos com intercepto. Alta cardinalidade: target encoding, embedding.",
    "example": "Cidade: São Paulo, Rio, Belo Horizonte. Label: SP=0, RJ=1, BH=2. Regressão linear: BH = 2×SP, o que não faz sentido. One-hot: is_SP, is_RJ, is_BH (dropar is_BH para evitar multicolinearidade). 1000 cidades: one-hot cria 999 colunas → target encoding ou embedding layer em deep learning."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Difícil",
    "question": "Ao lidar com um dataset com 50% de dados faltantes em uma feature importante, qual estratégia é mais robusta que simples imputação pela média?",
    "options": [
      "Imputação múltipla (MICE) que gera múltiplas estimativas refletindo a incerteza dos valores faltantes",
      "Deletar todas as linhas com dados faltantes",
      "Preencher com zero",
      "Duplicar as linhas completas para compensar"
    ],
    "correctIndex": 0,
    "explanation": "MICE (Multiple Imputation by Chained Equations) imputa cada feature faltante usando um modelo condicional baseado nas demais features, gerando múltiplos datasets completos. As análises são feitas em cada dataset e os resultados combinados, capturando a incerteza da imputação. Muito mais robusto que imputação única pela média.",
    "example": "Feature 'renda' com 50% missing. MICE usa idade, escolaridade e profissão para prever renda faltante via regressão. Gera 5 datasets completos, treina modelo em cada, combina predições. Captura que 'renda imputada para jovem estudante' difere de 'executivo sênior'."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Difícil",
    "question": "O que é SMOTE e como lidar com classes desbalanceadas em ML?",
    "options": [
      "SMOTE cria exemplos sintéticos da classe minoritária interpolando entre vizinhos; alternativas: undersampling, class weights",
      "Duplicar exemplos da classe minoritária",
      "Remover a classe majoritária",
      "Ignorar o desbalanceamento"
    ],
    "correctIndex": 0,
    "explanation": "SMOTE (Synthetic Minority Over-sampling Technique): cria novos exemplos interpolando entre pontos existentes da classe minoritária e seus K vizinhos mais próximos. Outras técnicas: undersampling (reduzir majoritária), class weights (penalizar erros na minoritária mais), ensemble balanceado. Aplicar SMOTE APENAS no treino, NUNCA no teste.",
    "example": "Fraude: 9900 normais, 100 fraudes (1%). SMOTE gera 9800 fraudes sintéticas → 9900 normais + 9900 fraudes. Modelo agora aprende ambas classes. Sem SMOTE: modelo sempre prediz 'normal' e acerta 99% (mas detecta 0% de fraudes)."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Difícil",
    "question": "O que é feature selection e quais métodos ajudam a escolher as melhores features?",
    "options": [
      "Selecionar subconjunto de features mais informativas; métodos: filter (correlação), wrapper (RFE), embedded (Lasso, feature importance)",
      "Usar todas as features",
      "Apenas PCA",
      "Remover features aleatoriamente"
    ],
    "correctIndex": 0,
    "explanation": "Feature selection remove features irrelevantes/redundantes. Filter: estatísticas (correlação, chi², mutual information). Wrapper: treinar modelo com subsets (RFE, forward/backward selection). Embedded: regularização seleciona durante treino (Lasso L1, tree feature importance). Benefícios: menor overfitting, treino mais rápido, modelo mais interpretável.",
    "example": "Dataset com 100 features. Feature importance do Random Forest: top 15 features explicam 95% das predições. Remover as 85 restantes: accuracy cai 0.5%, treino 6x mais rápido, modelo explicável."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Difícil",
    "question": "O que é o pipeline de pré-processamento e por que deve ser aplicado separadamente em treino e teste?",
    "options": [
      "Sequência de transformações que deve ser fitted no treino e apenas transformada no teste para evitar data leakage",
      "Deve ser aplicado igualmente em todos os dados",
      "Pipeline só funciona com sklearn",
      "Não faz diferença a ordem"
    ],
    "correctIndex": 0,
    "explanation": "Pipeline.fit_transform(X_train): calcula estatísticas (μ, σ, min, max) do treino E aplica. Pipeline.transform(X_test): aplica as MESMAS estatísticas do treino sem recalcular. Se fizer fit no teste: μ_teste vaza para o modelo → métricas otimistas. sklearn.Pipeline encapsula: Scaler → Encoder → PCA → Model.",
    "example": "Correto: scaler.fit(X_train) → μ=50, σ=10. scaler.transform(X_test) usa μ=50, σ=10 do treino. Errado: scaler.fit_transform(X_test) → μ_test=52, σ=9.5 (diferentes!) → teste contaminado. Accuracy 'inflada' de 95% cai para 88% em produção."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Difícil",
    "question": "O que é a técnica de binning (discretização) e quando é útil no pré-processamento?",
    "options": [
      "Converter variáveis contínuas em categorias (faixas), útil quando a relação com o target é não-linear por faixas",
      "É remover outliers",
      "É o mesmo que normalização",
      "Só funciona com dados categóricos"
    ],
    "correctIndex": 0,
    "explanation": "Binning: idade contínua → faixas ('0-18', '19-30', '31-50', '51+'). Tipos: equal-width (intervalos iguais), equal-frequency (quantis iguais), custom (domínio). Útil quando: relação não-linear por faixas (risco de crédito muda por faixa etária), modelo simples (Logistic Regression), reduzir impacto de outliers.",
    "example": "Renda contínua [1k-500k]: regressão linear fraca (R²=0.55). Binning: [0-3k='baixa', 3k-10k='média', 10k-30k='alta', 30k+='muito_alta']. Um-hot encode → modelo captura que risco de default é 25% para 'baixa' e 2% para 'muito_alta'. R²=0.78."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Difícil",
    "question": "O que é TF-IDF e como transforma texto em features numéricas para modelos de ML?",
    "options": [
      "Term Frequency × Inverse Document Frequency: pondera palavras pela frequência no documento e raridade no corpus",
      "É apenas contar palavras",
      "É um embeddings neural",
      "Só funciona com bigrams"
    ],
    "correctIndex": 0,
    "explanation": "TF(t,d) = freq de t no documento d / total de termos em d. IDF(t) = log(N/n_t), onde N = total de docs, n_t = docs com t. TF-IDF = TF × IDF. Palavras frequentes em 1 doc mas raras no corpus têm alto TF-IDF (discriminativas). Palavras comuns como 'de', 'o' têm IDF baixo e são naturalmente penalizadas.",
    "example": "Corpus de 1000 artigos. Artigo de futebol: 'gol' aparece 10x, TF=0.05. 'gol' aparece em 20 docs: IDF=log(1000/20)=1.70. TF-IDF('gol')=0.085 (alto, discriminativo). 'de' aparece em 990 docs: IDF=log(1000/990)=0.004. TF-IDF('de')=0.0001 (baixo, não discriminativo)."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Difícil",
    "question": "O que são window functions na engenharia de features para séries temporais?",
    "options": [
      "Cálculos sobre janelas deslizantes de tempo que geram features como média móvel, máximo, tendência e sazonalidade",
      "São filtros de imagem",
      "Funções SQL apenas",
      "Aplicam-se apenas a dados categóricos"
    ],
    "correctIndex": 0,
    "explanation": "Window functions criam features baseadas em janelas temporais: rolling_mean_7d (média dos últimos 7 dias), rolling_std_30d, lag_1 (valor do dia anterior), diff_1 (variação em relação ao anterior), ewma (média móvel exponencial). Essenciais para capturar tendência, sazonalidade e volatilidade em dados temporais.",
    "example": "Prever vendas diárias: features brutas [data, vendas] → R²=0.40. Window features: média_7d, média_30d, vendas_ontem (lag_1), vendas_semana_passada (lag_7), pico_últimos_30d, tendência_30d (slope). Com window features: R²=0.87. O modelo agora captura padrões temporais."
  },
  {
    "id": "machine-learning-e-ia__Pré-processamento de Dados__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "Pré-processamento de Dados",
    "difficulty": "Difícil",
    "question": "Quais estratégias existem para imputação de dados faltantes (missing values) e como o tipo de missingness (MCAR, MAR, MNAR) influencia a estratégia?",
    "options": [
      "MCAR (totalmente aleatório): qualquer imputação; MAR (aleatório dado outras vars): imputação múltipla ou MICE; MNAR (não-aleatório): requer modelagem explícita do mecanismo de ausência ou coleta de dados",
      "Sempre deletar linhas com missing — não faz diferença o mecanismo de ausência",
      "One-hot encoding de missing resolve qualquer tipo de missingness sem viés",
      "MCAR e MAR são resolvidos com média; MNAR com mediana dos dados disponíveis"
    ],
    "correctIndex": 0,
    "explanation": "MCAR: P(missing) constante, independente de qualquer variável. Listwise deletion válida mas desperdiça dados. MAR: P(missing|outras_vars) — ex: renda falta mais para jovens. Imputação com outras variáveis como preditores (MICE/IterativeImputer) é válida. MNAR: P(missing|valor_próprio) — ex: pessoas com renda alta não informam. Imputação padrão gera viés. Necesita: survey redesign, modelo de seleção (Heckman), indicador binário de missingness como feature.",
    "example": "Pressão arterial falta mais para pacientes saudáveis (não vão ao médico) = MNAR. Imputar com média subestima pressão média da população. Solução: adicionar feature is_pa_missing (captura padrão de ausência). MICE: itera, imputa cada feature usando as outras como preditores, repete até convergência. scikit-learn: IterativeImputer (experimental) ou MissForest (RF como imputer)."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Fácil",
    "question": "No NLP, o que é 'tokenização' e por que é a primeira etapa no processamento de texto?",
    "options": [
      "Dividir o texto em unidades menores (tokens) como palavras ou sub-palavras para processamento computacional",
      "Traduzir o texto para outro idioma",
      "Remover pontuação do texto",
      "Converter texto em áudio"
    ],
    "correctIndex": 0,
    "explanation": "Tokenização é o processo de dividir uma sequência de texto em tokens — podem ser palavras, sub-palavras ou caracteres. É a primeira etapa porque modelos de NLP não processam texto bruto; precisam de unidades numéricas. Cada token é mapeado para um ID numérico no vocabulário.",
    "example": "'O gato sentou no tapete' → tokens: ['O', 'gato', 'sentou', 'no', 'tapete'] → IDs: [15, 4521, 8823, 22, 6701]."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Fácil",
    "question": "O que é análise de sentimento e como ela é usada em aplicações reais?",
    "options": [
      "Classificar texto como positivo, negativo ou neutro; usada em reviews, redes sociais e feedback de clientes",
      "Traduzir textos",
      "Resumir documentos",
      "Gerar texto"
    ],
    "correctIndex": 0,
    "explanation": "Análise de sentimento classifica a polaridade emocional de textos. Abordagens: léxico (dicionários de palavras positivas/negativas), ML (Naive Bayes, SVM com TF-IDF), Deep Learning (BERT fine-tuned). Aplicações: monitorar marca em redes sociais, classificar reviews, detectar urgência em tickets de suporte.",
    "example": "Review: 'Produto excelente, entrega rápida!' → Positivo (0.95). 'Péssima qualidade, devolvi' → Negativo (0.92). 'Chegou ontem' → Neutro (0.78). Empresa monitora 10k reviews/dia para detectar problemas rapidamente."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Fácil",
    "question": "O que é TF-IDF e como ele representa a importância de palavras em documentos?",
    "options": [
      "TF mede frequência no documento; IDF penaliza palavras comuns em todos os documentos; TF-IDF destaca termos discriminantes",
      "Conta apenas frequência",
      "Embedding neural",
      "Método de tradução"
    ],
    "correctIndex": 0,
    "explanation": "TF (Term Frequency): frequência do termo no documento. IDF (Inverse Document Frequency): log(N/df), onde N = total de documentos e df = documentos contendo o termo. TF-IDF = TF × IDF. Palavras frequentes mas comuns ('o', 'de') têm IDF baixo. Palavras raras mas relevantes têm TF-IDF alto.",
    "example": "3 documentos sobre programação. 'Python' aparece em 1 doc: TF=5, IDF=log(3/1)=1.1 → TF-IDF=5.5 (discriminante). 'código' aparece em todos: TF=3, IDF=log(3/3)=0 → TF-IDF=0 (não discrimina)."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Fácil",
    "question": "O que é análise de sentimentos e como é usada em aplicações do mundo real?",
    "options": [
      "Classificar texto como positivo, negativo ou neutro usando NLP; usada para monitorar opiniões de clientes",
      "É tradução automática",
      "Só funciona com inglês",
      "É análise de gramática"
    ],
    "correctIndex": 0,
    "explanation": "Análise de sentimentos classifica texto em polaridade (positivo, negativo, neutro) e/ou emoção (alegria, raiva, tristeza). Abordagens: léxico (lista de palavras com scores), ML clássico (TF-IDF + SVM/Naive Bayes), deep learning (BERT fine-tuned). Aplicações: monitorar reviews, mídias sociais, suporte ao cliente.",
    "example": "Empresa monitora 50k tweets/dia: 'Adoro o novo produto!' → Positivo (0.95). 'Péssimo atendimento, nunca mais!' → Negativo (0.98). Alerta: sentimento negativo subiu 30% na última hora → equipe de crise investiga problema no app."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Fácil",
    "question": "O que é um bag of words (BoW) e quais são suas limitações?",
    "options": [
      "Representa texto como frequência de palavras ignorando a ordem; perde contexto e semântica",
      "Mantém a ordem das palavras",
      "É o mesmo que word embeddings",
      "Só funciona com frases curtas"
    ],
    "correctIndex": 0,
    "explanation": "BoW: vetor de frequência de cada palavra do vocabulário. 'O gato comeu o peixe' e 'O peixe comeu o gato' têm o mesmo BoW! Perde: ordem (semântica muda), contexto, sinônimos. Vocabulário grande = vetores esparsos. Melhorias: n-grams (bigrams, trigrams), TF-IDF para pesar relevância.",
    "example": "Vocabulário: [gato, comeu, peixe, ama, cachorro]. 'O gato comeu o peixe' → [1,1,1,0,0]. 'O gato ama o cachorro' → [1,0,0,1,1]. Similaridade cosine = 0.33. Mas: 'Gato comeu peixe' e 'Peixe comeu gato' → MESMO vetor [1,1,1,0,0]!"
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Fácil",
    "question": "O que é stemming e lemmatization e qual a diferença entre eles?",
    "options": [
      "Stemming corta sufixos de forma agressiva (correndo→corr); lemmatization usa dicionário para encontrar a forma base (correndo→correr)",
      "São a mesma coisa",
      "Stemming é mais preciso",
      "Lemmatization não funciona em português"
    ],
    "correctIndex": 0,
    "explanation": "Stemming: algoritmo baseado em regras que remove sufixos (Porter Stemmer, Snowball). Rápido mas pode gerar radicais inválidos ('universidade'→'univers'). Lemmatization: usa dicionário e análise morfológica para retornar a forma canônica ('better'→'good', 'correndo'→'correr'). Mais preciso, mais lento.",
    "example": "Stemming: 'gatos'→'gat', 'gatinho'→'gat', 'programando'→'program', 'programação'→'program'. Lemmatization: 'gatos'→'gato', 'gatinho'→'gato', 'correndo'→'correr', 'melhor'→'bom'. Para BoW/TF-IDF, stemming basta. Para tarefas que exigem palavras válidas, lemmatization."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Fácil",
    "question": "O que são stopwords e por que são removidas no pré-processamento de texto?",
    "options": [
      "Palavras muito frequentes sem significado discriminativo ('o', 'de', 'é', 'em') que são removidas para reduzir ruído",
      "São palavras ofensivas",
      "São palavras raras do vocabulário",
      "Stopwords sempre devem ser mantidas"
    ],
    "correctIndex": 0,
    "explanation": "Stopwords são palavras funcionais que aparecem frequentemente em quase todos os documentos: artigos ('o', 'a'), preposições ('de', 'em'), conjunções ('e', 'mas'). Removê-las reduz dimensionalidade e ruído. Cuidado: para análise de sentimento, 'não' é crucial ('não gostei'). Para BERT/GPT, manter stopwords (o modelo usa contexto completo).",
    "example": "'O gato não gostou da comida dele' → sem stopwords: 'gato gostou comida'. Problema: perdeu 'não' que inverte o sentido! Solução: lista customizada de stopwords que mantém negações. Para modelos Transformer: não remover nada, o modelo aprende o que importa."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Fácil",
    "question": "O que são word embeddings e qual problema eles resolvem em relação à representação one-hot?",
    "options": [
      "Vetores densos em espaço contínuo que capturam semântica; one-hot: esparso, sem relação semântica entre palavras; embeddings: 'rei' - 'homem' + 'mulher' ≈ 'rainha'",
      "Compressão de one-hot usando PCA para reduzir dimensionalidade sem perda semântica",
      "Tabelas de hash que mapeiam palavras para IDs numéricos com colisão mínima",
      "Tokens BPE que subdividem palavras em subunidades morfológicas para vocabulários menores"
    ],
    "correctIndex": 0,
    "explanation": "One-hot: vocabulário de 50k palavras → vetores de 50k dimensões, todos zeros exceto um 1. Sem relação entre palavras semelhantes (cosseno entre qualquer par = 0). Word2Vec, GloVe, FastText: mapeiam palavra → vetor denso (300 dimensões), palavras similares têm vetores próximos. Treinados para prever contexto (CBOW) ou palavra central (Skip-gram).",
    "example": "Word2Vec: 'paris' - 'france' + 'italy' ≈ 'rome' (analogias aritméticas no espaço vetorial). Cosseno('gato','felino') ≈ 0.85 (alta similaridade). Cosseno('gato','carro') ≈ 0.1. OOV (out of vocabulary): FastText usa n-gramas de caracteres → representa palavras novas. Contextualizados (BERT): mesmo token tem embedding diferente conforme contexto (banco da praça vs banco financeiro)."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Médio",
    "question": "Qual é a diferença entre os modelos de word embeddings Word2Vec e embeddings contextuais como BERT?",
    "options": [
      "Word2Vec gera um vetor fixo por palavra; BERT gera vetores diferentes para a mesma palavra dependendo do contexto da frase",
      "Word2Vec é mais moderno que BERT",
      "BERT gera vetores fixos como Word2Vec",
      "Word2Vec entende contexto bidirecional"
    ],
    "correctIndex": 0,
    "explanation": "Word2Vec atribui um único vetor a cada palavra independentemente do contexto ('banco' tem o mesmo vetor em 'banco de dados' e 'banco de investimentos'). BERT gera embeddings contextuais: o vetor de 'banco' é diferente em cada frase, capturando o significado específico no contexto.",
    "example": "Word2Vec: vec('banco') = [0.2, 0.5, ...] sempre igual. BERT: vec('banco' em 'sentou no banco') = [0.1, 0.8, ...] ≠ vec('banco' em 'conta no banco') = [0.7, 0.2, ...]. BERT entende polissemia."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Médio",
    "question": "O que é Named Entity Recognition (NER) e quais são as entidades mais comuns?",
    "options": [
      "Identificar e classificar entidades nomeadas (pessoas, organizações, locais, datas) em texto",
      "Classificar sentimento",
      "Traduzir nomes",
      "Resumir texto"
    ],
    "correctIndex": 0,
    "explanation": "NER identifica spans de texto que são entidades e classifica-os: PERSON (Elon Musk), ORG (Google), LOC (São Paulo), DATE (15 de março), MONEY (R$100). Usado em: extração de informação, chatbots (pegar nome/data do usuário), compliance (anonimizar dados pessoais). Modelos: spaCy, BERT-NER.",
    "example": "Texto: 'João da Silva trabalha na Google desde 2020 em São Paulo'. NER: [João da Silva]=PERSON, [Google]=ORG, [2020]=DATE, [São Paulo]=LOC. Chatbot extrai automaticamente: nome, empresa, ano, cidade."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Médio",
    "question": "O que é text preprocessing em NLP e quais etapas são essenciais?",
    "options": [
      "Limpar e padronizar texto: lowercase, remover pontuação, stopwords, stemming/lemmatization, tokenization",
      "Apenas dividir por espaços",
      "Treinar diretamente no texto bruto",
      "Apenas remover emojis"
    ],
    "correctIndex": 0,
    "explanation": "Pipeline de preprocessing: 1) Lowercase. 2) Remover pontuação/caracteres especiais. 3) Tokenização. 4) Remover stopwords ('o', 'de', 'é'). 5) Stemming (correndo→corr) ou Lemmatization (correndo→correr). 6) Remover palavras muito raras/frequentes. Para modelos modernos (BERT), preprocessing é mínimo (o modelo aprende).",
    "example": "Texto: 'Os GATOS estavam correndo rapidamente!!!' → lowercase: 'os gatos estavam correndo rapidamente' → remove stopwords: 'gatos correndo rapidamente' → lemmatization: 'gato correr rápido'. BERT: usa texto quase original, apenas tokeniza."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Médio",
    "question": "O que é NER (Named Entity Recognition) e em quais aplicações é utilizado?",
    "options": [
      "Identifica e classifica entidades nomeadas (pessoas, organizações, locais, datas) em texto",
      "É sinônimo de análise de sentimentos",
      "Reconhece apenas nomes de pessoas",
      "É tradução automática"
    ],
    "correctIndex": 0,
    "explanation": "NER classifica spans de texto em categorias: PERSON, ORG, LOC, DATE, MONEY, etc. Modelos: CRF (tradicional), BiLSTM-CRF, BERT-NER. Aplicações: extração de informações de contratos, chatbots que extraem dados (nome, CPF), análise de notícias, anonimização (substituir nomes por [PERSON]).",
    "example": "Email: 'João da Silva quer agendar reunião na Google em 15/03/2025 sobre um contrato de R$1M.' NER: [João da Silva]=PERSON, [Google]=ORG, [15/03/2025]=DATE, [R$1M]=MONEY. Chatbot extrai automaticamente: contato, empresa, data, valor."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Médio",
    "question": "O que é topic modeling e como o algoritmo LDA funciona?",
    "options": [
      "Descobre tópicos latentes em uma coleção de documentos; LDA modela cada documento como mistura de tópicos",
      "É classificação supervisionada de textos",
      "Só funciona com textos em inglês",
      "É análise de sentimentos"
    ],
    "correctIndex": 0,
    "explanation": "LDA (Latent Dirichlet Allocation): não supervisionado. Assume que cada documento é mistura de tópicos, e cada tópico é distribuição de palavras. LDA aprende: 1) distribuição de tópicos por documento, 2) distribuição de palavras por tópico. Inputs: bag of words + nº de tópicos K. Alternativas modernas: BERTopic.",
    "example": "1000 artigos de notícias, K=5 tópicos. Tópico 1: 'governo, eleição, político' (política). Tópico 2: 'jogo, gol, campeonato' (esporte). Artigo X: 70% Tópico 1 + 30% Tópico 3 → notícia de política econômica. Clusterização automática sem rótulos."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Médio",
    "question": "O que é text summarization e qual a diferença entre abordagem extractiva e abstractiva?",
    "options": [
      "Extractiva seleciona frases importantes do texto original; abstractiva gera frases novas que capturam a essência",
      "São idênticas",
      "Extractiva gera texto novo",
      "Abstractiva copia frases do original"
    ],
    "correctIndex": 0,
    "explanation": "Extractiva: identifica e extrai as frases mais importantes do texto original (TextRank, LexRank). Vantagem: factualmente confiável. Desvantagem: pode ser desconexa. Abstractiva: gera texto novo que resume o conteúdo (T5, BART, GPT). Vantagem: fluente e coeso. Desvantagem: pode alucinar. Modelos modernos usam abstractiva com RAG para fundamenção.",
    "example": "Texto: 'A temperatura subiu 2°C. Cientistas alertam sobre seca. Governo planeja reservatórios.' Extractiva: 'Cientistas alertam sobre seca. Governo planeja reservatórios.' (copia frases). Abstractiva: 'Aumento de 2°C na temperatura gera alerta de seca, levando o governo a planejar nova infraestrutura hídrica.' (gera texto novo)."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Médio",
    "question": "O que é BM25 e como se compara ao TF-IDF para recuperação de documentos?",
    "options": [
      "BM25 é uma evolução probabilística do TF-IDF com saturação de frequência e normalização por tamanho de documento",
      "É idêntico ao TF-IDF",
      "BM25 usa embeddings neurais",
      "TF-IDF é sempre superior"
    ],
    "correctIndex": 0,
    "explanation": "BM25 (Best Matching 25) melhora TF-IDF em dois aspectos: (1) Saturação TF: frequência alta não cresce linearmente (param k1 controla saturação). (2) Normalização por comprimento (param b): penaliza documentos longos proporcionalmente. É o padrão em motores de busca (Elasticsearch, Solr) e baseline forte para RAG.",
    "example": "Query: 'machine learning'. TF-IDF: doc com 'ML' mencionado 100x em 200 palavras > doc com 'ML' 50x em 1000 palavras. BM25: 'ML' 100x satura (não é 100x melhor que 1x, param k1=1.5), e doc curto de 200 palavras é normalizado (param b=0.75). BM25 é mais justo e eficaz na prática."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Médio",
    "question": "Como funciona o mecanismo de atenção (Attention) e por que é mais eficaz que RNNs para dependências de longo alcance?",
    "options": [
      "Attention calcula peso de cada token em relação a todos os outros diretamente (O(n²)); RNN processa sequencialmente degradando gradiente em longas sequências; atenção acessa qualquer posição em 1 passo",
      "RNNs usam atenção internamente para resolver dependências longas com custo O(n)",
      "Atenção só funciona com textos curtos; RNN é mais eficaz para documentos longos",
      "Ambos têm mesma capacidade de longas dependências; atenção é mais rápida por paralelismo apenas"
    ],
    "correctIndex": 0,
    "explanation": "Attention: Query, Key, Value. Score = softmax(QK^T/√d_k)×V. Cada token atende a outros com pesos aprendidos. Long-range: 'O banco que fica na margem do rio transbordou' — 'banco' resolve referência em 1 hop. RNN: gradiente de posição 1 passa por M passos até posição M → vanishing gradient. Self-attention: paralelizável (vs RNN sequencial) → treino mais rápido em GPUs. Custo O(n²) em comprimento de sequência.",
    "example": "Tradução: 'The cat sat on the mat, it was comfortable' — resolver 'it'. RNN LSTM: gradiente de 'cat' passou por 8 tokens, fraco. Transformer: atenção de 'it' para 'cat' com score alto (peso 0.92). Long document: Longformer usa atenção esparsa (local+global) para reduzir O(n²). Flash Attention: otimização GPU para O(n²) manejável."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Difícil",
    "question": "No treinamento de modelos de linguagem autorregressivos (como GPT), o que é 'causal masking' e por que é necessário?",
    "options": [
      "Mascara tokens futuros durante o treinamento para que o modelo só possa atender a tokens anteriores, simulando geração sequencial",
      "Mascara tokens ruidosos para limpeza",
      "Remove tokens raros do vocabulário",
      "Bloqueia gradientes de camadas superiores"
    ],
    "correctIndex": 0,
    "explanation": "Causal masking (ou autoregressive masking) aplica uma máscara triangular na matriz de atenção, impedindo que o token na posição t atenda a tokens nas posições t+1, t+2, etc. Isso garante que a predição de cada token use apenas informações passadas, consistente com geração sequencial em inferência.",
    "example": "Frase: 'O gato sentou'. Ao predizer 'sentou', a atenção só pode ver 'O' e 'gato', não tokens futuros. Máscara: [[1,0,0],[1,1,0],[1,1,1]]. Sem máscara, o modelo 'colaria' vendo a resposta correta durante o treino."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Difícil",
    "question": "O que são embeddings e por que são fundamentais para NLP moderno?",
    "options": [
      "Representações vetoriais densas de palavras/frases em espaço contínuo, capturando significado semântico",
      "Índices de palavras em dicionário",
      "One-hot encoding",
      "Tabelas de frequência"
    ],
    "correctIndex": 0,
    "explanation": "Embeddings mapeiam palavras/frases para vetores densos (ex: 768 dimensões). Palavras semanticamente similares ficam próximas no espaço vetorial. Vantagens sobre one-hot: dimensionalidade fixa, capturam similaridade semântica, transferíveis entre tarefas. Tipos: Word2Vec, GloVe (estáticos), BERT, GPT (contextuais).",
    "example": "One-hot: 'gato' = [0,0,0,1,0,...,0] (50k dim, esparso). Embedding: 'gato' = [0.2, -0.5, 0.8, ...] (768 dim, denso). cos_similarity(gato, felino) = 0.92, cos_similarity(gato, carro) = 0.05. Embeddings capturam significado."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Difícil",
    "question": "O que é Seq2Seq e como modelos encoder-decoder funcionam em tradução automática?",
    "options": [
      "Encoder comprime a frase de entrada em vetor; decoder gera a tradução palavra por palavra a partir desse vetor",
      "Traduz palavra por palavra com dicionário",
      "Substitui palavras por sinônimos",
      "Usa regras gramaticais fixas"
    ],
    "correctIndex": 0,
    "explanation": "Seq2Seq: Encoder (LSTM/Transformer) processa a sequência de entrada e produz um vetor de contexto. Decoder gera a sequência de saída token por token, condicionado no vetor de contexto. Attention mechanism permite ao decoder focar em partes relevantes da entrada. Base do Google Translate, chatbots, sumarização.",
    "example": "Traduzir 'I love cats': Encoder processa [I, love, cats] → vetor context [0.3, -0.7, ...]. Decoder: step 1 → 'Eu' (attention foca em 'I'), step 2 → 'amo' (attention foca em 'love'), step 3 → 'gatos' (attention foca em 'cats')."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Difícil",
    "question": "O que é o modelo BERT e por que revolucionou o NLP?",
    "options": [
      "É um Transformer bidirecional pré-treinado em masked language modeling e next sentence prediction",
      "É um modelo de tradução",
      "É uma CNN para texto",
      "Só funciona para classificação"
    ],
    "correctIndex": 0,
    "explanation": "BERT (Bidirectional Encoder Representations from Transformers): pré-treinado em 2 tarefas: 1) MLM (mascarar 15% dos tokens e prever), 2) NSP (prever se duas frases são consecutivas). Bidirecional: cada token atende a TODOS os outros (diferente de GPT que é unidirecional). Fine-tuning: adicionar camada de classificação no topo para tarefas específicas.",
    "example": "Frase: 'O [MASK] sentou no tapete.' BERT bidirectional: vê 'O' E 'sentou no tapete' → prevê 'gato' (80%). GPT unidirecional: só vê 'O' → prevê 'homem' (30%). BERT + fine-tune para sentimentos: accuracy 93% vs modelo from scratch 75%."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Difícil",
    "question": "O que é Retrieval Augmented Generation (RAG) e como combina busca com geração?",
    "options": [
      "Busca documentos relevantes em uma base de conhecimento e usa como contexto para o LLM gerar respostas fundamentadas",
      "É treinamento do modelo",
      "É fine-tuning com documentos",
      "Só funciona com GPT"
    ],
    "correctIndex": 0,
    "explanation": "RAG: Query → Embedding → Busca vetorial no vector store (Pinecone, Chroma, FAISS) → Top-K documentos relevantes → Prompt = query + documentos → LLM gera resposta baseada nos documentos. Vantagens: sem treino, dado atualizado, citavel, reduz alucinação. Pipeline: chunk → embed → index → retrieve → generate.",
    "example": "Pergunta: 'Qual o prazo de garantia do produto X?' Sem RAG: LLM alucina '1 ano'. Com RAG: busca vetorial encontra manual.pdf → 'Garantia de 2 anos para defeitos de fabricação'. LLM responde: '2 anos, conforme manual, seção 5.2.'"
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Difícil",
    "question": "O que é BPE (Byte Pair Encoding) e por que é o algoritmo de tokenização dominante em LLMs?",
    "options": [
      "Algoritmo que mescla iterativamente os pares de bytes/caracteres mais frequentes, criando um vocabulário de subwords equilibrado",
      "Divide texto em caracteres individuais",
      "Divide texto por espaços",
      "Usa dicionário de palavras completas"
    ],
    "correctIndex": 0,
    "explanation": "BPE começa com caracteres individuais e iterativamente merge o par mais frequente em um novo token. Repete até atingir o tamanho do vocabulário desejado (ex: 50k). Resultado: palavras comuns são tokens únicos ('the'), palavras raras são divididas em subwords ('unhappiness'→['un','happiness']). Equilibra vocabulário finito com cobertura ilimitada.",
    "example": "Corpus: 'aaba aab'. Caracteres iniciais: {a,b}. Passo 1: par mais freq = 'aa' → merge 'Z=aa'. Tokens: {a,b,Z}. 'Zba Zb'. Passo 2: par 'Zb' mais freq → merge 'Y=Zb'. 'Ya Yb'. GPT-4 com 100k tokens BPE: 'Hello'→1 token, 'deoxyribonucleic'→4 subword tokens."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Difícil",
    "question": "O que são Sentence Transformers (SBERT) e como geram embeddings de frases inteiras?",
    "options": [
      "BERT modificado com rede siamesa que gera embeddings de qualidade para frases inteiras, permitindo busca semântica eficiente",
      "É o BERT padrão aplicado a frases",
      "Só funciona com palavras individuais",
      "É um modelo de geração de texto"
    ],
    "correctIndex": 0,
    "explanation": "BERT padrão para comparar 2 frases: concatena e processa juntas — O(n²) para n pares. SBERT: usa rede siamesa — cada frase passa independentemente pelo BERT + pooling → embedding 768D. Comparar frases: cosseno entre embeddings — O(1). Pré-computar embeddings permite busca semântica em milhões de documentos em ms.",
    "example": "BERT para busca em 1M de documentos: comparar query com cada doc = 1M forward passes (horas). SBERT: pré-computar embeddings de 1M docs (1 vez). Query → embedding → busca por cosseno via FAISS em 5ms. Accuracy similar ao BERT cross-encoder, 10000× mais rápido."
  },
  {
    "id": "machine-learning-e-ia__Processamento de Linguagem Natural__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "Processamento de Linguagem Natural",
    "difficulty": "Difícil",
    "question": "O que é transfer learning com BERT e como o fine-tuning de camadas superiores vs completo ('full fine-tuning') diferem?",
    "options": [
      "BERT pré-treinado captura representações gerais; fine-tuning completo atualiza todos os pesos (alto custo, melhor performance); fine-tuning de camadas superiores prezerva representações gerais e adapta apenas as últimas camadas",
      "BERT nunca deve ter todos os pesos atualizados — apenas a camada de classificação final",
      "Fine-tuning de camadas superiores é exclusivo para classificação; camadas inferiores para geração",
      "Transfer learning com BERT só funciona para inglês; idiomas diferentes requerem treino do zero"
    ],
    "correctIndex": 0,
    "explanation": "BERT: pré-treinado com Masked LM + Next Sentence Prediction em 3.3B tokens. Camadas inferiores: representações sintáticas/morfológicas. Superiores: semânticas. Full fine-tuning: atualiza todos os 110M parâmetros com baixo LR (2-5e-5). Dataset pequeno: risk of catastrophic forgetting, preferir congelar camadas inferiores. LoRA: fine-tuning eficiente em parâmetros (apenas matrizes de baixo rank), reduz 100× os parâmetros treináveis.",
    "example": "Classificação de sentimento em reviews médicas (dataset 10k). Full fine-tuning BERT: 92% F1. Freeze camadas 1-8, fine-tune 9-12: 89% F1, treina 3× mais rápido. LoRA rank=8: 91% F1, apenas 2% dos parâmetros treináveis. Dataset muito pequeno (<1k): congelar mais camadas, apenas classificador. mBERT/XLM-R: BERT multilíngue, fine-tune em português."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Fácil__1",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Fácil",
    "question": "Em visão computacional, qual tipo de rede neural é mais utilizado para processar e classificar imagens?",
    "options": [
      "CNN (Convolutional Neural Network)",
      "RNN (Recurrent Neural Network)",
      "GAN (Generative Adversarial Network)",
      "Autoencoder"
    ],
    "correctIndex": 0,
    "explanation": "CNNs são projetadas para processar dados em grade (imagens). Usam camadas convolucionais que aplicam filtros (kernels) para detectar features como bordas, texturas e formas. Camadas de pooling reduzem dimensionalidade e camadas densas fazem a classificação final.",
    "example": "Uma CNN para classificar gatos vs cães: primeira conv detecta bordas, segunda detecta orelhas/focinho, terceira combina em padrões complexos. Pooling reduz de 224×224 para features compactas. Fully connected classifica: gato 92%, cachorro 8%."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Fácil__2",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Fácil",
    "question": "O que é uma operação de convolução e por que é eficiente para processar imagens?",
    "options": [
      "Filtro (kernel) desliza sobre a imagem multiplicando e somando valores locais, detectando padrões como bordas; compartilha pesos",
      "Redimensionar imagens",
      "Comprimir arquivos",
      "Classificação linear"
    ],
    "correctIndex": 0,
    "explanation": "Convolução: kernel n×n (ex: 3×3) desliza sobre a imagem, calculando a soma ponderada em cada posição. Vantagens: compartilhamento de parâmetros (mesmo filtro em toda a imagem), invariância a translação (detecta bordas onde quer que estejam), hierarquia de features (camadas empilhadas capturam padrões crescentes).",
    "example": "Kernel detector de borda vertical: [[-1,0,1],[-1,0,1],[-1,0,1]]. Desliza pela imagem 28×28. Onde há transição claro→escuro, output é alto. Um filtro 3×3 tem apenas 9 parâmetros, mas processa a imagem inteira."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Fácil__3",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Fácil",
    "question": "O que é data augmentation em visão computacional e por que é importante?",
    "options": [
      "Criar variações das imagens de treino (rotação, flip, zoom, brilho) para aumentar o dataset e melhorar generalização",
      "Coletar mais imagens",
      "Aumentar resolução",
      "Remover imagens duplicadas"
    ],
    "correctIndex": 0,
    "explanation": "Data augmentation aplica transformações aleatórias nas imagens de treino: rotação (±15°), flip horizontal, crop aleatório, mudança de brilho/contraste, zoom (±20%). Aumenta efetivamente o dataset sem coletar novos dados. Reduz overfitting forçando o modelo a ser invariante a essas transformações.",
    "example": "Dataset: 1000 imagens de gatos. Augmentation: cada imagem × 10 variações (rotação, flip, zoom, brilho) = 10000 imagens efetivas. Sem augmentation: accuracy 78%. Com augmentation: accuracy 89%."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Fácil__4",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Fácil",
    "question": "O que é a operação de convolução em uma CNN e o que os filtros detectam?",
    "options": [
      "Filtros (kernels) deslizam pela imagem multiplicando e somando valores, detectando padrões como bordas, texturas e formas",
      "Filtros classificam a imagem inteira de uma vez",
      "Convolução reduz a imagem pela metade",
      "Filtros são definidos manualmente"
    ],
    "correctIndex": 0,
    "explanation": "Convolução: filtro 3×3 desliza pela imagem, multiplica elemento a elemento e soma → 1 valor no feature map. Filtros são APRENDIDOS durante o treino. Camadas iniciais aprendem bordas/texturas, camadas profundas aprendem partes de objetos (olhos, rodas). Parâmetros: kernel size, stride, padding.",
    "example": "Imagem 32×32, filtro 3×3, stride=1, padding=0 → feature map 30×30. 32 filtros produzem 32 feature maps. Filtro 1 detecta bordas verticais, filtro 2 bordas horizontais, filtro 3 cantos. Total: 32×3×3 = 288 parâmetros (muito eficiente)."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Fácil__5",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Fácil",
    "question": "O que é uma imagem em termos de dados computacionais e quais formatos são usados em ML?",
    "options": [
      "Uma matriz de números representando pixels; formato usual: Altura × Largura × Canais (RGB=3, grayscale=1)",
      "Texto descrevendo a cena",
      "Um vetor unidimensional",
      "Um arquivo comprimido sem dados numéricos"
    ],
    "correctIndex": 0,
    "explanation": "Imagem RGB: tensor 3D com shape (H, W, 3). Cada pixel = [R, G, B] com valores 0-255 (uint8) ou 0.0-1.0 (float32). Grayscale: (H, W, 1). Batch para CNN: (B, C, H, W) em PyTorch, (B, H, W, C) em TensorFlow. Normalização: /255 ou ImageNet mean/std.",
    "example": "Foto 1920×1080 RGB: tensor 1080×1920×3 = 6.2M valores. Para CNN: resize para 224×224×3 = 150k valores. Normalizar: pixel[128,200,50] → [0.502, 0.784, 0.196]. Batch de 32 imagens: tensor 32×3×224×224."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Fácil__6",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Fácil",
    "question": "O que é um feature map em CNNs e como ele se forma a partir da convolução?",
    "options": [
      "Saída de um filtro aplicado à imagem: mapa 2D que indica onde o padrão detectado pelo filtro está presente",
      "É a imagem original",
      "É os pesos da rede",
      "É a saída final da classificação"
    ],
    "correctIndex": 0,
    "explanation": "Quando um filtro (kernel) é convolvido com a imagem, o resultado é um feature map (mapa de ativação). Valores altos indicam que o padrão do filtro foi detectado naquela região. Cada camada convolucional aplica múltiplos filtros, gerando múltiplos feature maps. Camadas profundas combinam feature maps anteriores em padrões mais complexos.",
    "example": "Imagem 28×28, filtro de borda vertical 3×3 → feature map 26×26 com valores altos onde há bordas verticais. 32 filtros na camada 1 → 32 feature maps (bordas, cantos, gradientes). Camada 2 combina esses 32 maps em 64 feature maps de padrões mais complexos (curvas, texturas)."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Fácil__7",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Fácil",
    "question": "Quais são as arquiteturas de CNN mais clássicas para classificação de imagens?",
    "options": [
      "LeNet, AlexNet, VGG, GoogLeNet/Inception, ResNet — cada uma trouxe inovações como profundidade, skip connections e módulos inception",
      "Todas as CNNs são iguais",
      "Só existe uma arquitetura de CNN",
      "CNNs não são usadas para classificação"
    ],
    "correctIndex": 0,
    "explanation": "LeNet (1998): pioneira, dígitos. AlexNet (2012): venceu ImageNet, ReLU + dropout. VGG (2014): filtros 3×3 empilhados, muito profunda (16-19 camadas). GoogLeNet (2014): módulos Inception com múltiplas escalas. ResNet (2015): skip connections permitiram 152+ camadas. Cada uma marcou época reduzindo error rate no ImageNet.",
    "example": "ImageNet Top-5 Error: AlexNet (2012) 15.3% → VGG (2014) 7.3% → GoogLeNet (2014) 6.7% → ResNet (2015) 3.6% → humanos ~5.1%. ResNet-152 superou humanos! Hoje: EfficientNet, ConvNeXt e Vision Transformers (ViT) lideram."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Fácil__8",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Fácil",
    "question": "O que é uma Convolutional Neural Network (CNN) e qual a função das camadas convolucionais e de pooling?",
    "options": [
      "CNN usa conv layers com filtros que detectam features locais (bordas, texturas) compartilhando pesos; pooling reduz dimensionalidade preservando features mais relevantes",
      "Rede que processa pixels em sequência como texto — cada pixel é um token de entrada",
      "Rede totalmente conectada com regularização específica para processamento de imagens",
      "Algoritmo que comprime imagens usando transformada de Fourier discreta para extração de features"
    ],
    "correctIndex": 0,
    "explanation": "Convolução: filtro (kernel) 3×3 desliza sobre a imagem calculando produto escalar — detecta padrões locais. Weight sharing: mesmo filtro aplicado em toda a imagem (translational invariance). Camadas iniciais: bordas e cantos. Camadas profundas: formas e partes de objetos. MaxPooling 2×2: reduz dimensão à metade tomando o máximo de cada janela — invariância a pequenas translações.",
    "example": "Imagem 224×224×3. Conv 64 filtros 3×3 → 224×224×64. MaxPool 2×2 → 112×112×64. Conv 128×3×3 → 112×112×128. MaxPool → 56×56×128. Flatten + FC + Softmax. AlexNet (2012) provou eficácia de CNNs no ImageNet. ResNet-50: 50 camadas com skip connections para gradiente fluir. Transfer learning: usar ResNet pré-treinado como extrator de features."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Médio__1",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Médio",
    "question": "Em uma CNN, o que é 'transfer learning' e como ele reduz drasticamente o tempo de treinamento para novas tarefas?",
    "options": [
      "Reutilizar pesos de um modelo pré-treinado (ex.: ImageNet) e treinar apenas as camadas finais para a nova tarefa",
      "Treinar o modelo do zero em cada nova tarefa",
      "Transferir dados entre datasets",
      "Copiar a arquitetura mas reinicializar todos os pesos"
    ],
    "correctIndex": 0,
    "explanation": "Transfer learning usa modelos pré-treinados em grandes datasets (ex.: ResNet treinado no ImageNet com 1.4M imagens). As camadas convolucionais iniciais já aprenderam features universais (bordas, texturas). Congela-se essas camadas e treina apenas as camadas finais (cabeça de classificação) com dados da nova tarefa, economizando tempo e dados.",
    "example": "Classificar 500 imagens de raio-X: treinar do zero → precisa de 100k+ imagens. Transfer learning com ResNet50 pré-treinado: congela 48 camadas, treina 2 últimas → 500 imagens bastam, 95% accuracy em 10 min de treino."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Médio__2",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Médio",
    "question": "O que são pooling layers (Max Pooling, Average Pooling) em CNNs e qual sua função?",
    "options": [
      "Reduzem dimensão espacial do feature map pegando valor máximo ou médio de regiões; reduz parâmetros e overfitting",
      "Aumentam a resolução",
      "Adicionam mais filtros",
      "Normalizam os valores"
    ],
    "correctIndex": 0,
    "explanation": "Pooling reduz a dimensão espacial do feature map. Max Pooling: pega o valor máximo em cada janela (ex: 2×2 reduz WxH pela metade). Preserva features mais fortes. Average Pooling: média da janela. Benefícios: reduz parâmetros, computação e overfitting. Adiciona invariância a pequenas translações.",
    "example": "Feature map 4×4 → Max Pool 2×2, stride 2 → output 2×2. Janela [[1,3],[2,8]] → max = 8. Imagem 224×224 após conv+pool+conv+pool → 7×7 (32× menor), mas com informação semântica concentrada."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Médio__3",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Médio",
    "question": "O que é object detection e como difere de classificação de imagens?",
    "options": [
      "Classificação: 'que objeto está na imagem?'. Detection: 'onde estão os objetos?' com bounding boxes e classes",
      "São idênticas",
      "Detection não classifica",
      "Classificação usa bounding boxes"
    ],
    "correctIndex": 0,
    "explanation": "Classificação: uma classe por imagem (gato ou cachorro). Object Detection: múltiplos objetos localizados com bounding boxes + classes. Arquiteturas: YOLO (You Only Look Once, real-time), SSD (Single Shot Detector), Faster R-CNN (two-stage, mais preciso). Métricas: mAP (mean Average Precision), IoU (Intersection over Union).",
    "example": "Foto de rua: Classificação → 'cena urbana'. Object Detection → [carro (92%, bbox:[10,20,200,150]), pessoa (88%, bbox:[300,50,380,250]), semáforo (95%, bbox:[400,10,420,60])]. Cada objeto localizado com coordenadas."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Médio__4",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Médio",
    "question": "O que são as métricas IoU e mAP em object detection?",
    "options": [
      "IoU mede sobreposição entre bounding boxes; mAP é a média de Average Precision por classe",
      "São métricas de classificação",
      "IoU mede velocidade, mAP mede tamanho",
      "São usadas apenas em segmentação"
    ],
    "correctIndex": 0,
    "explanation": "IoU (Intersection over Union): área de interseção / área de união entre bbox predito e ground truth. IoU > 0.5 = detecção correta (TP). AP (Average Precision): área sob a curva Precision-Recall para uma classe. mAP: média do AP sobre todas as classes. mAP@0.5 = IoU threshold 0.5. COCO mAP: média em IoU 0.5:0.05:0.95.",
    "example": "Detector de carros: bbox predito [100,100,200,200], ground truth [110,105,205,195]. Interseção = 8550px², União = 11450px². IoU = 8550/11450 = 0.75 > 0.5 → TP. AP carros = 0.85. AP pedestres = 0.78. mAP = 0.815."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Médio__5",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Médio",
    "question": "O que é Semantic Segmentation vs Instance Segmentation?",
    "options": [
      "Semântica rotula cada pixel por classe; Instância diferencia objetos individuais da mesma classe",
      "São a mesma coisa",
      "Instância é mais simples",
      "Semântica só funciona com 2 classes"
    ],
    "correctIndex": 0,
    "explanation": "Semantic segmentation: cada pixel recebe uma classe (céu, estrada, carro) mas não diferencia instâncias (todos os carros = 'carro'). Instance segmentation: cada pixel recebe classe E instância (carro_1, carro_2). Panoptic = semantic + instance. Modelos: U-Net, DeepLab (semantic), Mask R-CNN (instance).",
    "example": "Foto com 3 carros e 2 pedestres: Semantic → todos os pixels de carro = verde, pedestre = azul (não sabe quantos). Instance → carro_1=verde, carro_2=amarelo, carro_3=roxo, pedestre_1=azul, pedestre_2=ciano. Mask R-CNN gera máscara pixel-perfect para cada instância."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Médio__6",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Médio",
    "question": "O que é Feature Pyramid Network (FPN) e como melhora a detecção de objetos em múltiplas escalas?",
    "options": [
      "Combina feature maps de diferentes resoluções da CNN em uma pirâmide, permitindo detectar objetos pequenos e grandes simultaneamente",
      "É uma técnica de data augmentation",
      "Só detecta objetos grandes",
      "É uma função de ativação"
    ],
    "correctIndex": 0,
    "explanation": "FPN constrói uma pirâmide de features: bottom-up (encoder CNN, resolução diminui) + top-down (upsampling + lateral connections). Feature maps de alta resolução detectam objetos pequenos, feature maps de baixa resolução detectam objetos grandes. Usado em Faster R-CNN, RetinaNet, YOLO modernos.",
    "example": "Imagem com pedaço de fruta (20×20px) e caminhão (200×100px). Sem FPN: detector falha na fruta (muito pequena em feature maps profundos). Com FPN: feature map P2 (alta resolução) detecta fruta, P5 (baixa resolução) detecta caminhão. mAP sobe 5-8% com FPN."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Médio__7",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Médio",
    "question": "O que é face recognition e como difere de face detection?",
    "options": [
      "Detection localiza rostos na imagem; recognition identifica QUEM é a pessoa comparando com um banco de faces conhecidas",
      "São a mesma coisa",
      "Recognition é mais fácil que detection",
      "Detection identifica a pessoa"
    ],
    "correctIndex": 0,
    "explanation": "Face detection: localizar retangulos com rostos (MTCNN, RetinaFace). Face recognition: (1) Detection, (2) Alignment, (3) Embedding (ArcFace, FaceNet geram vetor 128/512D), (4) Comparar embedding com banco via distância cosseno. Verificação (1:1): é a pessoa X? Identificação (1:N): quem é esta pessoa?",
    "example": "Foto em grupo de 10 pessoas: Face detection → 10 bounding boxes. Face recognition → cada face gera embedding 512D. Comparar com banco de funcionários: face_1 embedding ≈ 'João' (cosseno 0.92 > threshold 0.85). face_2 ≈ 'Maria' (0.88). face_3 = desconhecido (max cosseno 0.60 < 0.85)."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Médio__8",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Médio",
    "question": "Como funciona o algoritmo YOLO (You Only Look Once) e por que é mais rápido que abordagens de two-stage como R-CNN?",
    "options": [
      "YOLO divide imagem em grid e prevê bounding boxes e classes em um único forward pass; two-stage extrai propostas de regiões depois classifica — mais lento mas mais preciso em objetos pequenos",
      "YOLO usa sliding window denso com CNN; R-CNN usa atenção para localizar objetos",
      "YOLO é mais lento que R-CNN mas mais preciso; a diferença é na métrica de avaliação usada",
      "YOLO processa cada região independentemente enquanto R-CNN faz uma única passagem"
    ],
    "correctIndex": 0,
    "explanation": "R-CNN: 1) Selective Search gera ~2k propostas de região. 2) CNN classifica cada proposta. ~47s por imagem (treinamento). Two-stage, alta precisão. YOLO: divide imagem em S×S grid. Cada célula prevê B bounding boxes (x,y,w,h,confidence) + C class probabilities. Uma única passagem pela rede. YOLOv8: ~2ms por imagem em GPU, suficiente para vídeo em tempo real. Trade-off: precisão ligeiramente menor em objetos muito pequenos.",
    "example": "Câmera de segurança 30fps: R-CNN = impossível (~47s/frame). YOLOv8 = detecta em 2ms, 500fps. mAP@50 em COCO: YOLOv8x = 53.9, Faster-RCNN = 42. NMS (Non-Maximum Suppression): remove bounding boxes sobrepostas, guarda a de maior confiança. Anchor boxes: prior shapes para objetos de diferentes aspectos (carros largos, pessoas altas)."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Difícil__1",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Difícil",
    "question": "Na arquitetura U-Net para segmentação semântica, qual é o papel do 'skip connections' entre encoder e decoder?",
    "options": [
      "Transmitem features de alta resolução do encoder para o decoder, preservando detalhes espaciais perdidos no downsampling",
      "Aceleram o treinamento pulando camadas",
      "Previnem overfitting removendo neurônios",
      "Conectam a entrada diretamente à saída"
    ],
    "correctIndex": 0,
    "explanation": "A U-Net tem um encoder (downsampling) e decoder (upsampling) simétricos. Skip connections concatenam feature maps do encoder com feature maps correspondentes do decoder. Isso permite que o decoder combine informações semânticas profundas (do bottleneck) com detalhes espaciais finos (do encoder), essencial para segmentação pixel-a-pixel precisa.",
    "example": "Segmentação de tumores em MRI: encoder reduz 256×256 → 16×16 (perde detalhes de borda). Skip connections enviam features 256×256, 128×128, 64×64 do encoder para o decoder, que combina com upsampled features para delinear bordas do tumor com precisão de pixel."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Difícil__2",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Difícil",
    "question": "O que é YOLO (You Only Look Once) e por que revolucionou a detecção de objetos em tempo real?",
    "options": [
      "Processa a imagem inteira em uma única passada pela rede, prevendo bounding boxes e classes simultaneamente",
      "Usa várias passadas",
      "Apenas classifica",
      "Baseado em template matching"
    ],
    "correctIndex": 0,
    "explanation": "YOLO divide a imagem em grid S×S. Cada célula prevê B bounding boxes + confiança + C classes em uma única forward pass. Diferente de R-CNN (propõe regiões, depois classifica cada uma). YOLO é 100× mais rápido que R-CNN. YOLOv8 atinge ~60 FPS em GPU com alta precisão.",
    "example": "YOLO para carro autônomo: imagem 416×416 → grid 13×13 → cada célula prevê 3 boxes. Uma passada (30ms) detecta pedestres, carros, sinais simultaneamente. R-CNN: ~2000ms por imagem (propõe ~2000 regiões). YOLO viabiliza detecção em tempo real."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Difícil__3",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Difícil",
    "question": "O que são Vision Transformers (ViT) e como eles aplicam a arquitetura Transformer a imagens?",
    "options": [
      "Dividem a imagem em patches, tratam cada patch como um token e aplicam self-attention; competem com CNNs",
      "CNN com mais camadas",
      "Transformers para texto apenas",
      "Tipo especial de pooling"
    ],
    "correctIndex": 0,
    "explanation": "ViT (Vision Transformer): divide imagem em patches (ex: 16×16), cada patch é linearizado e projetado como embedding (análogo a token de texto). Position embeddings são adicionados. Self-attention captura relações entre patches distantes (campo receptivo global desde a primeira camada, vs CNN que é local). ViT supera CNNs com dados suficientes.",
    "example": "Imagem 224×224 → 196 patches de 16×16. Cada patch → embedding 768D. 196 'tokens' + [CLS] token → 12 camadas Transformer → [CLS] → classificação. Patch do olho 'atende' ao patch da boca via attention, capturando relação global."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Difícil__4",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Difícil",
    "question": "O que é o modelo SAM (Segment Anything Model) e por que é considerável para visão computacional?",
    "options": [
      "Modelo fundacional que segmenta qualquer objeto em qualquer imagem dado um prompt (ponto, caixa ou texto)",
      "É um classificador de imagens",
      "Só funciona com rostos",
      "É um modelo de geração de imagens"
    ],
    "correctIndex": 0,
    "explanation": "SAM (Meta, 2023): treinado em 11M de imagens e 1.1B de máscaras. Foundation model para segmentação: aceita prompts (pontos, caixas, texto) e gera máscaras precisas para qualquer objeto. Zero-shot: funciona em domínios nunca vistos (médico, satélite). Combina image encoder (ViT), prompt encoder e mask decoder.",
    "example": "Imagem de satélite (nunca treinado com satélite): clique no ponto central de um prédio → SAM segmenta o prédio perfeitamente. Caixa ao redor de um lago → máscara precisa. Antes: treinar modelo específico com 10k imagens rotuladas. SAM: zero imagens, zero treino."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Difícil__5",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Difícil",
    "question": "O que é Diffusion Model e como gera imagens de alta qualidade?",
    "options": [
      "Adiciona ruído gaussiano progressivamente e aprende a reverter o processo, gerando imagens do ruído",
      "Gera imagens combinando partes de outras imagens",
      "É o mesmo que GAN",
      "Usa regras programáticas para desenhar"
    ],
    "correctIndex": 0,
    "explanation": "Diffusion Models: Forward process: imagem → ruído gaussiano em T steps. Reverse process: rede neural aprende a remover ruído step a step. Geração: começa de ruído puro e denoisa iterativamente. Vantagens sobre GANs: treino estável, maior diversidade. Exemplos: Stable Diffusion, DALL-E 3, Midjourney.",
    "example": "Prompt: 'gato astronauta na lua, óleo sobre tela'. Step 1000 (ruído puro) → Step 750 (formas vagas) → Step 500 (silüeta de gato) → Step 250 (detalhes do capacete) → Step 0 (imagem final fotorrealista). 50 steps de inferência com DDIM sampler."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Difícil__6",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Difícil",
    "question": "O que é Neural Style Transfer e como combina conteúdo de uma imagem com estilo de outra?",
    "options": [
      "Usa features das camadas profundas de uma CNN para conteúdo e Gram matrices das camadas rasas para estilo, otimizando uma imagem de saída",
      "Copia pixels de uma imagem para outra",
      "É um filtro do Instagram",
      "Treina uma rede do zero para cada par de imagens"
    ],
    "correctIndex": 0,
    "explanation": "Neural Style Transfer (Gatys et al., 2015): extrai conteúdo das camadas profundas de VGG (formas, objetos) e estilo das camadas rasas via Gram matrix (texturas, cores, pinceladas). A imagem de saída é otimizada para minimizar: L_total = α×L_content + β×L_style. Versões rápidas (feed-forward) geram em 1 forward pass.",
    "example": "Foto de São Paulo (conteúdo) + 'Noite Estrelada' de Van Gogh (estilo). L_content preserva prédios e ruas. L_style aplica espirais, cores vibrantes, pinceladas grossas. Resultado: São Paulo pintada no estilo Van Gogh. Otimização: ~300 iterações de gradient descent diretamente nos pixels."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Difícil__7",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Difícil",
    "question": "O que é Depth Estimation monocular e como redes neurais estimam profundidade de uma única imagem?",
    "options": [
      "Rede neural prevê mapa de profundidade pixel a pixel a partir de uma única imagem 2D usando pistas monoculares aprendidas",
      "Requer duas câmeras (estéreo)",
      "Mede a profundidade com sensores LIDAR",
      "Só funciona com imagens RGB-D"
    ],
    "correctIndex": 0,
    "explanation": "Depth Estimation monocular: rede (ex: DPT, MiDaS, Depth Anything) recebe 1 imagem RGB e prevê profundidade relativa ou absoluta para cada pixel. Aprende pistas monoculares: perspectiva, oclusão, tamanho relativo, textura, foco/blur. Aplicações: AR/VR, robótica, direção autônoma, efeito bokeh em smartphones.",
    "example": "Foto de rua com câmera do celular: MiDaS gera mapa de profundidade — calçada=2m (perto, branco), carros=15m (médio, cinza), prédios=100m (longe, preto). Smartphone usa isso para efeito 'retrato' (desfocar fundo). Carro autônomo: combina mono depth com LIDAR para 3D map em tempo real."
  },
  {
    "id": "machine-learning-e-ia__Visão Computacional__Difícil__8",
    "track": "machine-learning-e-ia",
    "category": "Visão Computacional",
    "difficulty": "Difícil",
    "question": "O que são Generative Adversarial Networks (GANs) e qual o problema de mode collapse?",
    "options": [
      "GAN: Generator tenta enganar o Discriminator que distingue real de falso; mode collapse: generator aprende produzir poucas variações que enganam o discriminator, ignorando diversidade dos dados reais",
      "GAN é rede que gera dados via difusão progressiva; mode collapse é instabilidade de gradiente",
      "Generator e Discriminator são treinados em datasets diferentes sem interação direta",
      "Mode collapse refere-se ao colapso dos pesos do discriminator para zero durante o treino"
    ],
    "correctIndex": 0,
    "explanation": "GAN: minimax game. G minimiza, D maximiza log D(x) + log(1-D(G(z))). Nash equilibrium: G gera distribuição idêntica à real. Mode collapse: G descobre subconjunto de outputs que consistentemente engana D (ex: sempre gera mesmo dígito '7'). D evolui para rejeitar '7' → G migra para '3' → ciclagem. Soluções: Wasserstein GAN (WGAN), minibatch discrimination, progressive training (ProGAN), diferentes arquiteturas (StyleGAN).",
    "example": "GAN de dígitos MNIST: mode collapse = sempre gera '4'. WGAN usa Wasserstein distance em vez de JS divergence — gradientes mais estáveis, mode collapse menos frequente. StyleGAN2 (NVIDIA): rostos humanos foto-realistas (este-rosto-não-existe.com). Conditional GAN (cGAN): gera imagem condicionada em label (gerar 'gato' especificamente). Discriminator saturação = gradiente zero para G."
  },
  {
    "id": "matematica__Análise Combinatória__Fácil__1",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Fácil",
    "question": "De quantas maneiras diferentes 4 pessoas podem se organizar em uma fila?",
    "options": [
      "24",
      "16",
      "12",
      "8"
    ],
    "correctIndex": 0,
    "explanation": "Trata-se de uma permutação simples de 4 elementos: P(4) = 4! = 4 × 3 × 2 × 1 = 24. Em permutações, a ordem importa e usamos todos os elementos disponíveis.",
    "example": "Pessoas A, B, C, D: 1ª posição tem 4 opções, 2ª tem 3, 3ª tem 2 e 4ª tem 1. Total: 4 × 3 × 2 × 1 = 24 filas diferentes."
  },
  {
    "id": "matematica__Análise Combinatória__Fácil__2",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Fácil",
    "question": "Quantos números de 3 algarismos distintos podem ser formados com os dígitos {1, 2, 3, 4, 5}?",
    "options": [
      "60",
      "125",
      "120",
      "80"
    ],
    "correctIndex": 0,
    "explanation": "Arranjo simples: A(5,3) = 5!/(5-3)! = 5!/2! = 120/2 = 60. Para o 1º dígito temos 5 opções, para o 2º 4, para o 3º 3. Total: 5 × 4 × 3 = 60.",
    "example": "1º algarismo: 5 opções. 2º: 4 (não pode repetir). 3º: 3. Total = 5 × 4 × 3 = 60 números distintos."
  },
  {
    "id": "matematica__Análise Combinatória__Fácil__3",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Fácil",
    "question": "O que é o princípio fundamental da contagem (princípio multiplicativo)?",
    "options": [
      "Se uma decisão tem m opções e outra tem n opções, o total de combinações é m × n",
      "Soma-se as opções de cada decisão",
      "Multiplica-se apenas quando há repetição",
      "Divide-se o total pelo número de etapas"
    ],
    "correctIndex": 0,
    "explanation": "Se uma tarefa pode ser feita em m etapas, com n₁ opções na 1ª, n₂ na 2ª, etc., o total de maneiras é n₁ × n₂ × ... × nₘ. É a base de toda análise combinatória.",
    "example": "Roupa: 3 camisas × 4 calças × 2 sapatos = 24 combinações. Cada escolha é independente, então multiplicamos as opções."
  },
  {
    "id": "matematica__Análise Combinatória__Fácil__4",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Fácil",
    "question": "Em uma sorveteria com 6 sabores, João vai tomar 2 bolas de sabores diferentes. De quantas maneiras ele pode escolher?",
    "options": [
      "15",
      "30",
      "12",
      "36"
    ],
    "correctIndex": 0,
    "explanation": "Como a ordem das bolas não importa, usamos combinação: C(6,2) = 6! / (2! × 4!) = (6 × 5) / (2 × 1) = 15.",
    "example": "C(6,2): numerador 6 × 5 = 30, denominador 2! = 2. 30 ÷ 2 = 15 formas de escolher 2 sabores dentre 6."
  },
  {
    "id": "matematica__Análise Combinatória__Fácil__5",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Fácil",
    "question": "Quantos números de 2 algarismos distintos podem ser formados com os dígitos {1, 2, 3, 4}?",
    "options": [
      "12",
      "16",
      "8",
      "6"
    ],
    "correctIndex": 0,
    "explanation": "A ordem importa (12 ≠ 21), sem repetição. Arranjo: A(4,2) = 4 × 3 = 12. O 1º algarismo tem 4 opções e o 2º tem 3.",
    "example": "1º dígito: 4 opções. 2º dígito: 3 opções (não repete). Total = 4 × 3 = 12 números distintos."
  },
  {
    "id": "matematica__Análise Combinatória__Fácil__6",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Fácil",
    "question": "Em uma turma de 7 alunos, de quantas maneiras podemos escolher 2 para um trabalho em dupla?",
    "options": [
      "21",
      "42",
      "14",
      "35"
    ],
    "correctIndex": 0,
    "explanation": "Ordem não importa (dupla AB = dupla BA), usamos combinação: C(7,2) = 7! / (2! × 5!) = (7 × 6) / (2 × 1) = 42/2 = 21.",
    "example": "C(7,2): 7 × 6 = 42 no numerador, 2! = 2 no denominador. 42 ÷ 2 = 21 duplas possíveis."
  },
  {
    "id": "matematica__Análise Combinatória__Fácil__7",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Fácil",
    "question": "De quantas maneiras podemos organizar as letras A, B e C em uma sequência?",
    "options": [
      "6",
      "3",
      "9",
      "8"
    ],
    "correctIndex": 0,
    "explanation": "Permutação simples de 3 elementos: P(3) = 3! = 3 × 2 × 1 = 6. Listando: ABC, ACB, BAC, BCA, CAB, CBA.",
    "example": "1ª posição: 3 opções. 2ª: 2 opções. 3ª: 1 opção. Total = 3 × 2 × 1 = 6 sequências."
  },
  {
    "id": "matematica__Análise Combinatória__Fácil__8",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Fácil",
    "question": "Quantas diagonais tem um hexágono regular?",
    "options": [
      "9",
      "6",
      "12",
      "18"
    ],
    "correctIndex": 0,
    "explanation": "Fórmula: n(n−3)/2. Para n=6: 6×3/2 = 9. Subtrai-se as n arestas do total de combinações C(n,2) = n(n−1)/2: C(6,2)−6 = 15−6 = 9.",
    "example": "C(6,2) = 15 segmentos. 6 são lados (arestas). 15−6 = 9 diagonais. Polígono de 10 lados: 10×7/2 = 35 diagonais. Triângulo: 0 diagonais. Quadrilátero: 2. Pentágono: 5."
  },
  {
    "id": "matematica__Análise Combinatória__Médio__1",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Médio",
    "question": "De um grupo de 10 alunos, de quantas formas podemos escolher 3 para formar uma comissão?",
    "options": [
      "120",
      "720",
      "210",
      "30"
    ],
    "correctIndex": 0,
    "explanation": "Como a ordem não importa (é uma comissão, não um ranking), usamos combinação: C(10,3) = 10! / (3! × 7!) = (10 × 9 × 8) / (3 × 2 × 1) = 720/6 = 120.",
    "example": "C(10,3): simplifica — 10×9×8 = 720 no numerador, 3! = 6 no denominador. 720 ÷ 6 = 120 comissões possíveis."
  },
  {
    "id": "matematica__Análise Combinatória__Médio__2",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Médio",
    "question": "De quantas maneiras podemos escolher 2 representantes (presidente e vice) de um grupo de 8 pessoas?",
    "options": [
      "56",
      "28",
      "64",
      "36"
    ],
    "correctIndex": 0,
    "explanation": "Como a ordem importa (ser presidente é diferente de ser vice), usamos arranjo: A(8,2) = 8!/(8-2)! = 8×7 = 56. Se a ordem não importasse, seria C(8,2) = 28.",
    "example": "Presidente: 8 opções. Vice: 7 opções (não pode ser a mesma pessoa). Total: 8 × 7 = 56."
  },
  {
    "id": "matematica__Análise Combinatória__Médio__3",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Médio",
    "question": "Uma senha de 4 dígitos permite repetição e usa algarismos de 0 a 9. Quantas senhas são possíveis?",
    "options": [
      "10.000",
      "5.040",
      "6.561",
      "3.024"
    ],
    "correctIndex": 0,
    "explanation": "Com repetição permitida, cada posição tem 10 opções independentes. Total = 10⁴ = 10.000 senhas possíveis (de 0000 a 9999).",
    "example": "1º dígito: 10 opções. 2º: 10. 3º: 10. 4º: 10. Total = 10 × 10 × 10 × 10 = 10.000."
  },
  {
    "id": "matematica__Análise Combinatória__Médio__4",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Médio",
    "question": "Uma prova tem 8 questões e o aluno deve resolver exatamente 5. De quantas formas ele pode escolher quais resolver?",
    "options": [
      "56",
      "336",
      "40",
      "120"
    ],
    "correctIndex": 0,
    "explanation": "Ordem não importa (escolher questões 1,3,5,7,8 é o mesmo conjunto). Combinação: C(8,5) = C(8,3) = (8×7×6)/(3×2×1) = 56.",
    "example": "C(8,5) = C(8,3) por simetria. 8×7×6 = 336. 3! = 6. 336/6 = 56 formas de escolher 5 questões."
  },
  {
    "id": "matematica__Análise Combinatória__Médio__5",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Médio",
    "question": "De quantas maneiras 5 pessoas podem se sentar em uma mesa circular?",
    "options": [
      "24",
      "120",
      "60",
      "20"
    ],
    "correctIndex": 0,
    "explanation": "Em permutação circular, fixamos uma pessoa e permutamos as demais: (n-1)! = (5-1)! = 4! = 24.",
    "example": "Mesa circular: fixe 1 pessoa como referência. As outras 4 se arranjam em 4! = 4×3×2×1 = 24 maneiras."
  },
  {
    "id": "matematica__Análise Combinatória__Médio__6",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Médio",
    "question": "Um comitê de 3 pessoas será formado a partir de 5 homens e 4 mulheres, com exatamente 2 homens e 1 mulher. Quantas formações possíveis?",
    "options": [
      "40",
      "60",
      "36",
      "20"
    ],
    "correctIndex": 0,
    "explanation": "Escolher 2 homens de 5: C(5,2) = 10. Escolher 1 mulher de 4: C(4,1) = 4. Pelo princípio multiplicativo: 10 × 4 = 40 comitês possíveis.",
    "example": "C(5,2) = (5×4)/(2×1) = 10. C(4,1) = 4. Total = 10 × 4 = 40. Cada decisão é independente, então multiplicamos."
  },
  {
    "id": "matematica__Análise Combinatória__Médio__7",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Médio",
    "question": "De quantas formas podemos distribuir 3 livros diferentes para 5 alunos, sendo no máximo 1 livro por aluno?",
    "options": [
      "60",
      "15",
      "125",
      "120"
    ],
    "correctIndex": 0,
    "explanation": "Ordem importa (qual livro vai para qual aluno) e sem repetição. Arranjo: A(5,3) = 5 × 4 × 3 = 60.",
    "example": "1º livro: 5 alunos possíveis. 2º livro: 4 alunos restantes. 3º livro: 3. Total = 5 × 4 × 3 = 60 distribuições."
  },
  {
    "id": "matematica__Análise Combinatória__Médio__8",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Médio",
    "question": "De quantas maneiras pode-se escolher uma comissão de 3 membros de um grupo de 8 pessoas, sendo que 2 delas são incompatíveis e não podem estar juntas?",
    "options": [
      "46",
      "56",
      "42",
      "50"
    ],
    "correctIndex": 3,
    "explanation": "Total sem restrição C(8,3)=56. Combinações com os 2 incompatíveis juntos: C(6,1)=6 (escolher 1 dos 6 restantes). Válidas: 56-6=50.",
    "example": "C(8,3)=56. Proibidas (A e B juntos + 1 dos 6 restantes): C(6,1)=6. Válidas: 56-6=50. Método complementar. Verificação: se A e B forem obrigatoriamente incluídos, sobram 6 para escolher 1 → 6 combinações proibidas."
  },
  {
    "id": "matematica__Análise Combinatória__Difícil__1",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Difícil",
    "question": "Quantos anagramas da palavra MISSISSIPPI existem?",
    "options": [
      "34.650",
      "39.916.800",
      "11!/(4!×4!×2!)",
      "Ambas A e C estão corretas"
    ],
    "correctIndex": 3,
    "explanation": "MISSISSIPPI tem 11 letras com repetições: M(1), I(4), S(4), P(2). Permutação com repetição: 11! / (1! × 4! × 4! × 2!) = 39.916.800 / (1 × 24 × 24 × 2) = 39.916.800 / 1.152 = 34.650. Tanto 34.650 quanto a fórmula 11!/(4!×4!×2!) estão corretos.",
    "example": "11! = 39.916.800 (total se fossem todas diferentes). Dividimos pelas repetições: 4! para os 4 I's, 4! para os 4 S's, 2! para os 2 P's. 39.916.800 ÷ 1.152 = 34.650."
  },
  {
    "id": "matematica__Análise Combinatória__Difícil__2",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Difícil",
    "question": "De quantas maneiras podemos distribuir 3 prêmios distintos entre 10 candidatos (cada prêmio para uma pessoa diferente)?",
    "options": [
      "720",
      "1000",
      "120",
      "30"
    ],
    "correctIndex": 0,
    "explanation": "Arranjo: A(10,3) = 10 × 9 × 8 = 720. O 1º prêmio pode ir para qualquer um dos 10, o 2º para 9 restantes, o 3º para 8. Os prêmios são distintos, então a ordem importa.",
    "example": "1º prêmio (ouro): 10 opções. 2º (prata): 9. 3º (bronze): 8. Total: 10 × 9 × 8 = 720."
  },
  {
    "id": "matematica__Análise Combinatória__Difícil__3",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Difícil",
    "question": "Em uma pizza com 8 sabores disponíveis, de quantas maneiras podemos escolher 3 sabores diferentes (a ordem não importa)?",
    "options": [
      "56",
      "336",
      "24",
      "120"
    ],
    "correctIndex": 0,
    "explanation": "Combinação (ordem não importa): C(8,3) = 8! / (3! × 5!) = (8 × 7 × 6) / (3 × 2 × 1) = 336 / 6 = 56.",
    "example": "Numerador: 8 × 7 × 6 = 336. Denominador: 3! = 6. C(8,3) = 336/6 = 56 combinações de sabores."
  },
  {
    "id": "matematica__Análise Combinatória__Difícil__4",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Difícil",
    "question": "Quantos anagramas da palavra BANANA existem?",
    "options": [
      "60",
      "720",
      "120",
      "360"
    ],
    "correctIndex": 0,
    "explanation": "BANANA tem 6 letras: B(1), A(3), N(2). Permutação com repetição: 6! / (3! × 2!) = 720 / 12 = 60.",
    "example": "6! = 720. Repetições: A aparece 3 vezes (3!=6), N aparece 2 vezes (2!=2). 720 / (6 × 2) = 720/12 = 60 anagramas."
  },
  {
    "id": "matematica__Análise Combinatória__Difícil__5",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Difícil",
    "question": "De quantas formas 4 casais podem formar uma fila, de modo que cada casal fique junto?",
    "options": [
      "384",
      "40320",
      "192",
      "768"
    ],
    "correctIndex": 0,
    "explanation": "Trate cada casal como um bloco: 4 blocos podem ser permutados de 4! = 24 formas. Dentro de cada bloco, 2 pessoas trocam de posição: 2⁴ = 16. Total: 24 × 16 = 384.",
    "example": "4 blocos de casais → 4! = 24 arranjos. Cada casal troca internamente: 2⁴ = 16. Total = 24 × 16 = 384."
  },
  {
    "id": "matematica__Análise Combinatória__Difícil__6",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Difícil",
    "question": "Quantas diagonais tem um polígono de 10 lados?",
    "options": [
      "35",
      "45",
      "40",
      "30"
    ],
    "correctIndex": 0,
    "explanation": "Fórmula: D = n(n-3)/2. Para n=10: D = 10×7/2 = 70/2 = 35. Ou: C(10,2) - 10 lados = 45 - 10 = 35. Cada par de vértices forma segmento; subtraímos os lados.",
    "example": "C(10,2) = 45 segmentos ligando vértices. 10 desses são os próprios lados. Diagonais = 45 - 10 = 35."
  },
  {
    "id": "matematica__Análise Combinatória__Difícil__7",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Difícil",
    "question": "De quantas formas podemos distribuir 8 bolas idênticas em 3 caixas distintas?",
    "options": [
      "45",
      "24",
      "56",
      "84"
    ],
    "correctIndex": 0,
    "explanation": "Combinação com repetição (Stars and Bars): C(n+k-1, k-1) onde n=8 bolas e k=3 caixas. C(10,2) = 10!/(2!×8!) = 45.",
    "example": "Stars and Bars: 8 estrelas (bolas) + 2 barras (separadores) = 10 posições. Escolher 2 para barras: C(10,2) = 45. Ex: ★★★|★★★★★| = (3,5,0)."
  },
  {
    "id": "matematica__Análise Combinatória__Difícil__8",
    "track": "matematica",
    "category": "Análise Combinatória",
    "difficulty": "Difícil",
    "question": "Qual o coeficiente de x³y² no desenvolvimento de (2x + y)⁵ pelo Binômio de Newton?",
    "options": [
      "40",
      "80",
      "10",
      "20"
    ],
    "correctIndex": 1,
    "explanation": "Termo geral: C(5,k)×(2x)^(5-k)×y^k. Para x³y²: 5-k=3 ⇒ k=2. C(5,2)×2³ = 10×8 = 80.",
    "example": "(2x+y)^5: k=2 ⇒ C(5,2)×(2x)^3×y^2 = 10×8x^3×y^2 = 80x³y². Coeficiente = 80. Verify: k=0 ⇒ 32x^5; k=1 ⇒ C(5,1)×16x^4y=80x^4y; k=2 ⇒ 80x^3y^2 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Fácil__1",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Fácil",
    "question": "Qual é o valor de x na equação 2x + 6 = 20?",
    "options": [
      "7",
      "8",
      "10",
      "13"
    ],
    "correctIndex": 0,
    "explanation": "Isole x: 2x + 6 = 20 → 2x = 20 - 6 → 2x = 14 → x = 14/2 → x = 7. Verificação: 2(7) + 6 = 14 + 6 = 20 ✓.",
    "example": "Passo 1: subtraia 6 de ambos os lados → 2x = 14. Passo 2: divida ambos por 2 → x = 7."
  },
  {
    "id": "matematica__Equações e Inequações__Fácil__2",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Fácil",
    "question": "Resolva a equação 3(x - 2) = 2x + 4. Qual é o valor de x?",
    "options": [
      "10",
      "8",
      "6",
      "2"
    ],
    "correctIndex": 0,
    "explanation": "Distribua: 3x - 6 = 2x + 4. Subtraia 2x: x - 6 = 4. Some 6: x = 10. Verificação: 3(10-2) = 3×8 = 24 = 2(10)+4 = 24 ✓.",
    "example": "3(x-2) = 2x+4 → 3x-6 = 2x+4 → 3x-2x = 4+6 → x = 10."
  },
  {
    "id": "matematica__Equações e Inequações__Fácil__3",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Fácil",
    "question": "O que é uma equação do 1º grau e como resolvê-la?",
    "options": [
      "Equação da forma ax + b = 0, resolvida isolando x: x = -b/a",
      "Equação com x²",
      "Equação sem incógnita",
      "Só funciona com números positivos"
    ],
    "correctIndex": 0,
    "explanation": "Equação do 1º grau tem a forma ax + b = 0 (a ≠ 0). O gráfico é uma reta. Solução: x = -b/a. Pode ter operações em ambos os lados. Regra: o que passa de um lado para outro inverte a operação.",
    "example": "5x + 3 = 18 → 5x = 18-3 → 5x = 15 → x = 15/5 → x = 3. Na forma ax+b=0: 5x-15=0, x=-(-15)/5=3."
  },
  {
    "id": "matematica__Equações e Inequações__Fácil__4",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Fácil",
    "question": "Se 3x - 9 = 0, qual é o valor de x?",
    "options": [
      "3",
      "9",
      "-3",
      "6"
    ],
    "correctIndex": 0,
    "explanation": "Isole x: 3x = 9 → x = 9/3 = 3. Toda equação do 1º grau ax + b = 0 tem solução x = -b/a.",
    "example": "3x - 9 = 0 → 3x = 9 → x = 9 ÷ 3 = 3. Verificação: 3(3) - 9 = 9 - 9 = 0 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Fácil__5",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Fácil",
    "question": "Resolva a equação: 4x + 8 = 2x + 16.",
    "options": [
      "x = 4",
      "x = 8",
      "x = 2",
      "x = 6"
    ],
    "correctIndex": 0,
    "explanation": "Passe os termos com x para um lado e os números para o outro: 4x - 2x = 16 - 8 → 2x = 8 → x = 4.",
    "example": "4x + 8 = 2x + 16 → 4x - 2x = 16 - 8 → 2x = 8 → x = 4. Verifica: 4(4)+8 = 24, 2(4)+16 = 24 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Fácil__6",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Fácil",
    "question": "Resolva a equação: x/3 + 2 = 5.",
    "options": [
      "x = 9",
      "x = 3",
      "x = 15",
      "x = 1"
    ],
    "correctIndex": 0,
    "explanation": "Isole x: x/3 + 2 = 5 → x/3 = 5 - 2 → x/3 = 3 → x = 3 × 3 → x = 9. Verificação: 9/3 + 2 = 3 + 2 = 5 ✓.",
    "example": "Passo 1: subtraia 2 → x/3 = 3. Passo 2: multiplique por 3 → x = 9."
  },
  {
    "id": "matematica__Equações e Inequações__Fácil__7",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Fácil",
    "question": "Se 5x - 10 = 0, qual o valor de x?",
    "options": [
      "x = 2",
      "x = 5",
      "x = -2",
      "x = 10"
    ],
    "correctIndex": 0,
    "explanation": "Isole x: 5x = 10 → x = 10/5 = 2. Equação do 1º grau na forma ax + b = 0: x = -b/a = -(-10)/5 = 2.",
    "example": "5x - 10 = 0 → 5x = 10 → x = 2. Verificação: 5(2) - 10 = 10 - 10 = 0 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Fácil__8",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Fácil",
    "question": "Qual o conjunto solução da inequação 2x - 5 > 3?",
    "options": [
      "x > 4",
      "x > √2",
      "x < 4",
      "x ≥ 4"
    ],
    "correctIndex": 0,
    "explanation": "2x - 5 > 3 ⇒ 2x > 8 ⇒ x > 4. Conjunto solução: (4, +∞). Lembrar: ao dividir por número negativo, inverte o sinal da desigualdade.",
    "example": "2x > 3+5 = 8; x > 4. Na reta numérica: intervalo aberto à direita de 4. Teste: x=5: 2(5)-5=5>3 ✓. x=4: 2(4)-5=3, não é maior que 3. x=3: 1>3? ✗."
  },
  {
    "id": "matematica__Equações e Inequações__Médio__1",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Médio",
    "question": "Quais são as raízes da equação x² - 5x + 6 = 0?",
    "options": [
      "x = 2 e x = 3",
      "x = 1 e x = 6",
      "x = -2 e x = -3",
      "x = 5 e x = 1"
    ],
    "correctIndex": 0,
    "explanation": "Usando a fórmula de Bhaskara: Δ = b² - 4ac = 25 - 24 = 1. x = (5 ± √1) / 2. x₁ = (5+1)/2 = 3. x₂ = (5-1)/2 = 2. Ou por fatoração: (x-2)(x-3) = 0.",
    "example": "Verificação: (2)² - 5(2) + 6 = 4 - 10 + 6 = 0 ✓. (3)² - 5(3) + 6 = 9 - 15 + 6 = 0 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Médio__2",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Médio",
    "question": "Qual é o discriminante (Δ) da equação 2x² + 3x - 5 = 0 e o que ele indica?",
    "options": [
      "Δ = 49, duas raízes reais distintas",
      "Δ = 0, raiz única",
      "Δ = -31, sem raízes reais",
      "Δ = 9, duas raízes"
    ],
    "correctIndex": 0,
    "explanation": "Δ = b² - 4ac = 3² - 4(2)(-5) = 9 + 40 = 49. Δ > 0 → duas raízes reais e distintas. Δ = 0 → raiz única. Δ < 0 → sem raízes reais.",
    "example": "Δ = 9 + 40 = 49. x = (-3 ± √49)/(2×2) = (-3 ± 7)/4. x₁ = 4/4 = 1. x₂ = -10/4 = -2,5."
  },
  {
    "id": "matematica__Equações e Inequações__Médio__3",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Médio",
    "question": "Resolva o sistema: { x + y = 10 e 2x - y = 5 }.",
    "options": [
      "x = 5, y = 5",
      "x = 3, y = 7",
      "x = 7, y = 3",
      "x = 4, y = 6"
    ],
    "correctIndex": 0,
    "explanation": "Método da adição: somando as equações: (x + y) + (2x - y) = 10 + 5 → 3x = 15 → x = 5. Substituindo: 5 + y = 10 → y = 5.",
    "example": "Soma: x + y + 2x - y = 15 → 3x = 15 → x = 5. Em x + y = 10: y = 5. Verifica: 2(5) - 5 = 5 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Médio__4",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Médio",
    "question": "Qual o valor do discriminante (Δ) na equação 3x² - 2x - 1 = 0?",
    "options": [
      "16",
      "4",
      "10",
      "8"
    ],
    "correctIndex": 0,
    "explanation": "Δ = b² - 4ac. Com a=3, b=-2, c=-1: Δ = (-2)² - 4(3)(-1) = 4 + 12 = 16. Como Δ > 0, a equação tem 2 raízes reais distintas.",
    "example": "b² = (-2)² = 4. 4ac = 4×3×(-1) = -12. Δ = 4 - (-12) = 4 + 12 = 16. Raízes: x = (2±4)/6 → x=1 ou x=-1/3."
  },
  {
    "id": "matematica__Equações e Inequações__Médio__5",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Médio",
    "question": "Resolva o sistema: { 2x + y = 7 e x - y = 2 }.",
    "options": [
      "x = 3, y = 1",
      "x = 2, y = 3",
      "x = 4, y = -1",
      "x = 1, y = 5"
    ],
    "correctIndex": 0,
    "explanation": "Método da adição: (2x + y) + (x - y) = 7 + 2 → 3x = 9 → x = 3. Substituindo em x - y = 2: 3 - y = 2 → y = 1.",
    "example": "Somando as equações: 3x = 9 → x = 3. Em x - y = 2: y = 3 - 2 = 1. Verifica: 2(3)+1 = 7 ✓ e 3-1 = 2 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Médio__6",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Médio",
    "question": "Quais são as raízes da equação x² - 9 = 0?",
    "options": [
      "x = 3 e x = -3",
      "x = 9",
      "x = 3",
      "x = 81"
    ],
    "correctIndex": 0,
    "explanation": "x² - 9 = 0 → x² = 9 → x = ±√9 → x = 3 ou x = -3. Também pode fatorar: (x-3)(x+3) = 0 (diferença de quadrados: a²-b² = (a-b)(a+b)).",
    "example": "Verificação: (3)² - 9 = 9 - 9 = 0 ✓. (-3)² - 9 = 9 - 9 = 0 ✓. Duas raízes reais simétricas."
  },
  {
    "id": "matematica__Equações e Inequações__Médio__7",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Médio",
    "question": "Resolva o sistema: { x + y = 8 e x - y = 2 }.",
    "options": [
      "x = 5, y = 3",
      "x = 4, y = 4",
      "x = 6, y = 2",
      "x = 3, y = 5"
    ],
    "correctIndex": 0,
    "explanation": "Método da adição: some as equações: (x+y) + (x-y) = 8 + 2 → 2x = 10 → x = 5. Substituindo em x + y = 8: y = 3.",
    "example": "Soma: 2x = 10 → x = 5. Em x + y = 8: y = 8 - 5 = 3. Verifica: 5 + 3 = 8 ✓ e 5 - 3 = 2 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Médio__8",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Médio",
    "question": "Quantas raízes reais tem a equação x´ - 5x² + 4 = 0?",
    "options": [
      "4 raízes reais",
      "2 raízes reais",
      "Nenhuma raiz real",
      "1 raiz real"
    ],
    "correctIndex": 0,
    "explanation": "Substituição: u = x². u² - 5u + 4 = 0. Δ = 25-16 = 9. u = (5±3)/2: u=4 ou u=1. x²=4 ⇒ x=±2; x²=1 ⇒ x=±1. Total: 4 raízes reais.",
    "example": "u=4: x=+2 e x=-2. u=1: x=+1 e x=-1. Confirmar: (4)²-5(4)+4=16-20+4=0 ✓. (1)²-5(1)+4=0 ✓. Equação biquadrada: sempre substituir x²=u primeiro."
  },
  {
    "id": "matematica__Equações e Inequações__Difícil__1",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Difícil",
    "question": "Resolva a inequação |2x - 3| > 5. Qual é o conjunto solução?",
    "options": [
      "x < -1 ou x > 4",
      "-1 < x < 4",
      "x > 4",
      "x < -1"
    ],
    "correctIndex": 0,
    "explanation": "Para |A| > k (k > 0), temos A > k OU A < -k. Caso 1: 2x - 3 > 5 → 2x > 8 → x > 4. Caso 2: 2x - 3 < -5 → 2x < -2 → x < -1. Solução: x ∈ (-∞, -1) ∪ (4, +∞).",
    "example": "Teste x = 5: |2(5)-3| = |7| = 7 > 5 ✓. Teste x = -2: |2(-2)-3| = |-7| = 7 > 5 ✓. Teste x = 0: |2(0)-3| = 3 > 5? Não ✗. Confirma: x < -1 ou x > 4."
  },
  {
    "id": "matematica__Equações e Inequações__Difícil__2",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Difícil",
    "question": "Resolva a equação exponencial 2^(x+1) = 32.",
    "options": [
      "x = 4",
      "x = 5",
      "x = 3",
      "x = 16"
    ],
    "correctIndex": 0,
    "explanation": "32 = 2⁵. Então 2^(x+1) = 2⁵ → x + 1 = 5 → x = 4. Em equações exponenciais com mesma base, igualamos os expoentes.",
    "example": "2^(x+1) = 32. Como 32 = 2⁵: x+1 = 5, x = 4. Verificação: 2^(4+1) = 2⁵ = 32 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Difícil__3",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Difícil",
    "question": "Resolva a equação logarítmica: log₂(x - 3) + log₂(x + 1) = 5.",
    "options": [
      "x = 7",
      "x = 5",
      "x = 11",
      "x = 9"
    ],
    "correctIndex": 0,
    "explanation": "Propriedade: log(a) + log(b) = log(a×b). log₂[(x-3)(x+1)] = 5 → (x-3)(x+1) = 2⁵ = 32 → x² - 2x - 3 = 32 → x² - 2x - 35 = 0 → (x-7)(x+5) = 0 → x = 7 ou x = -5. Como x > 3 (domínio), x = 7.",
    "example": "log₂((x-3)(x+1)) = 5 → (x-3)(x+1) = 32 → x²-2x-35 = 0 → x = 7 (válido pois 7 > 3). Verifica: log₂(4) + log₂(8) = 2 + 3 = 5 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Difícil__4",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Difícil",
    "question": "Resolva a inequação x² - 4x - 5 < 0.",
    "options": [
      "-1 < x < 5",
      "x < -1 ou x > 5",
      "0 < x < 5",
      "-5 < x < 1"
    ],
    "correctIndex": 0,
    "explanation": "Raízes: x² - 4x - 5 = 0 → (x-5)(x+1) = 0 → x = 5 ou x = -1. Como a > 0, a parábola abre para cima, então é negativa entre as raízes: -1 < x < 5.",
    "example": "Teste x = 0: 0 - 0 - 5 = -5 < 0 ✓ (entre -1 e 5). Teste x = 6: 36-24-5 = 7 > 0 ✗. Confirma: -1 < x < 5."
  },
  {
    "id": "matematica__Equações e Inequações__Difícil__5",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Difícil",
    "question": "Determine o valor de x: 3^(2x - 1) = 27.",
    "options": [
      "x = 2",
      "x = 3",
      "x = 4",
      "x = 1"
    ],
    "correctIndex": 0,
    "explanation": "27 = 3³. Igualando expoentes: 2x - 1 = 3 → 2x = 4 → x = 2. Em equações exponenciais de mesma base, basta igualar os expoentes.",
    "example": "3^(2x-1) = 3³ → 2x-1 = 3 → 2x = 4 → x = 2. Verificação: 3^(2×2-1) = 3³ = 27 ✓."
  },
  {
    "id": "matematica__Equações e Inequações__Difícil__6",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Difícil",
    "question": "Resolva a inequação (x - 1)/(x + 2) ≥ 0.",
    "options": [
      "x < -2 ou x ≥ 1",
      "-2 ≤ x ≤ 1",
      "x > -2",
      "x ≥ 1"
    ],
    "correctIndex": 0,
    "explanation": "Estude o sinal: numerador x-1 = 0 em x=1. Denominador x+2 = 0 em x=-2 (ponto excluído). Quadro de sinais: x<-2 → (-)/(-) = + ✓. -2<x<1 → (-)/(+) = - ✗. x>1 → (+)/(+) = + ✓. x=1: fração = 0 ✓. Solução: x < -2 ou x ≥ 1.",
    "example": "Teste: x=-3 → (-4)/(-1)=4 ≥ 0 ✓. x=0 → (-1)/(2)=-0,5 ≥ 0? ✗. x=2 → (1)/(4)=0,25 ≥ 0 ✓. x=1 → 0/3=0 ≥ 0 ✓. x=-2 → indefinido (excluído)."
  },
  {
    "id": "matematica__Equações e Inequações__Difícil__7",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Difícil",
    "question": "Resolva a equação exponencial 5^(x² - 1) = 125.",
    "options": [
      "x = 2 ou x = -2",
      "x = 2",
      "x = 4",
      "x = 3"
    ],
    "correctIndex": 0,
    "explanation": "125 = 5³. Igualando expoentes: x² - 1 = 3 → x² = 4 → x = ±2. Em equações exponenciais de mesma base, igualamos os expoentes e resolvemos a equação resultante.",
    "example": "5^(x²-1) = 5³ → x²-1 = 3 → x² = 4 → x = 2 ou x = -2. Verifica: 5^(4-1) = 5³ = 125 ✓ para ambos."
  },
  {
    "id": "matematica__Equações e Inequações__Difícil__8",
    "track": "matematica",
    "category": "Equações e Inequações",
    "difficulty": "Difícil",
    "question": "O sistema { x + y = 5; xy = 6 } tem solução real? Quais os pares (x,y)?",
    "options": [
      "(2,3) e (3,2)",
      "(1,4) e (4,1)",
      "Sem solução real",
      "(2,2) e (3,3)"
    ],
    "correctIndex": 0,
    "explanation": "x e y são raízes de t² - 5t + 6 = 0. Δ = 25-24 = 1. t = (5±1)/2: t=3 ou t=2. Pares: (2,3) e (3,2).",
    "example": "Relações de Girard: soma = 5 (coef linear com sinal trocado), produto = 6 (termo independente). Equação: t²-5t+6=0. Δ=1>0 ⇒ 2 raízes reais. Verificação: 2+3=5 ✓, 2×3=6 ✓."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Fácil__1",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Fácil",
    "question": "Qual é a probabilidade de obter cara ao lançar uma moeda honesta?",
    "options": [
      "1/2",
      "1/3",
      "1/4",
      "1/6"
    ],
    "correctIndex": 0,
    "explanation": "Uma moeda honesta tem 2 resultados igualmente prováveis: cara ou coroa. Probabilidade = casos favoráveis / casos totais = 1/2 = 0,5 = 50%.",
    "example": "Espaço amostral: {cara, coroa}. Evento: {cara}. P(cara) = 1/2 = 50%. Se lançar 100 vezes, espera-se ~50 caras."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Fácil__2",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Fácil",
    "question": "Ao lançar um dado de 6 faces, qual a probabilidade de obter um número par?",
    "options": [
      "1/2",
      "1/3",
      "1/6",
      "2/3"
    ],
    "correctIndex": 0,
    "explanation": "Números pares em um dado: {2, 4, 6}. São 3 resultados favoráveis de 6 possíveis. P = 3/6 = 1/2 = 50%.",
    "example": "Espaço amostral: {1,2,3,4,5,6}. Evento 'par': {2,4,6}. P = 3/6 = 1/2."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Fácil__3",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Fácil",
    "question": "Qual é a média aritmética do conjunto {4, 7, 10, 3, 6}?",
    "options": [
      "6",
      "7",
      "5",
      "8"
    ],
    "correctIndex": 0,
    "explanation": "Média = soma dos valores / número de valores = (4+7+10+3+6)/5 = 30/5 = 6. A média é a medida de tendência central mais comum.",
    "example": "Soma: 4+7+10+3+6 = 30. Quantidade: 5 valores. Média = 30/5 = 6."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Fácil__4",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Fácil",
    "question": "Qual é a moda do conjunto {2, 3, 3, 5, 7, 3, 8}?",
    "options": [
      "3",
      "5",
      "2",
      "7"
    ],
    "correctIndex": 0,
    "explanation": "Moda é o valor que mais se repete. O número 3 aparece 3 vezes, mais do que qualquer outro. Conjunto unimodal.",
    "example": "Frequências: 2(1×), 3(3×), 5(1×), 7(1×), 8(1×). Moda = 3 (maior frequência). Se dois empatassem, seria bimodal."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Fácil__5",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Fácil",
    "question": "Em um baralho de 52 cartas, qual a probabilidade de sortear uma carta de copas?",
    "options": [
      "1/4",
      "1/13",
      "1/2",
      "1/52"
    ],
    "correctIndex": 0,
    "explanation": "O baralho tem 4 naipes com 13 cartas cada. Copas: 13 cartas. P = 13/52 = 1/4 = 25%.",
    "example": "Favoráveis: 13 cartas de copas. Possíveis: 52 cartas. P = 13/52 = 1/4. Mesmo raciocínio para qualquer naipe."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Fácil__6",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Fácil",
    "question": "Qual é a mediana do conjunto {5, 2, 9, 1, 8, 3}?",
    "options": [
      "4",
      "5",
      "3",
      "6"
    ],
    "correctIndex": 0,
    "explanation": "Ordene: {1, 2, 3, 5, 8, 9}. Com 6 elementos (n par), mediana = média dos 2 centrais: (3+5)/2 = 8/2 = 4.",
    "example": "Ordenado: 1, 2, [3, 5], 8, 9. Posições centrais = 3º e 4º. Mediana = (3+5)/2 = 4."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Fácil__7",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Fácil",
    "question": "Uma urna contém 4 bolas vermelhas e 6 azuis. Qual a probabilidade de sortear uma vermelha?",
    "options": [
      "2/5",
      "4/5",
      "3/5",
      "1/2"
    ],
    "correctIndex": 0,
    "explanation": "Total de bolas: 4 + 6 = 10. Favoráveis (vermelha): 4. P = 4/10 = 2/5 = 40%.",
    "example": "P(vermelha) = 4/10 = 2/5 = 0,4 = 40%. P(azul) = 6/10 = 3/5 = 60%. Soma = 100% ✓."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Fácil__8",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Fácil",
    "question": "Em um saco com 4 bolas vermelhas e 6 azuis, qual a probabilidade de retirar uma bola azul?",
    "options": [
      "3/5",
      "2/5",
      "1/2",
      "4/10"
    ],
    "correctIndex": 0,
    "explanation": "P(azul) = 6/10 = 3/5. Total de bolas = 10. Casos favoráveis = 6.",
    "example": "P(azul) = 6/10 = 0,6 = 60%. P(vermelha) = 4/10 = 2/5. P(azul) + P(vermelha) = 1 ✓. Evento complementar: P(não azul) = 1 - 3/5 = 2/5."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Médio__1",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Médio",
    "question": "Em um conjunto de dados {2, 4, 4, 6, 8, 10}, qual é o desvio padrão populacional?",
    "options": [
      "≈ 2,58",
      "≈ 3,00",
      "≈ 2,00",
      "≈ 4,00"
    ],
    "correctIndex": 0,
    "explanation": "Média = (2+4+4+6+8+10)/6 = 34/6 ≈ 5,67. Variância = Σ(xᵢ - μ)²/N = [(2-5,67)² + (4-5,67)² + (4-5,67)² + (6-5,67)² + (8-5,67)² + (10-5,67)²]/6 = [13,47 + 2,79 + 2,79 + 0,11 + 5,43 + 18,77]/6 ≈ 43,36/6 ≈ 6,67. Desvio padrão = √6,67 ≈ 2,58.",
    "example": "Calcule: média ≈ 5,67. Desvios quadráticos somados ≈ 43,36. Divida por N=6 → variância ≈ 6,67. Raiz → σ ≈ 2,58."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Médio__2",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Médio",
    "question": "Qual é a mediana do conjunto {3, 8, 1, 6, 4, 9, 2}?",
    "options": [
      "4",
      "5",
      "6",
      "3"
    ],
    "correctIndex": 0,
    "explanation": "Ordene: {1, 2, 3, 4, 6, 8, 9}. Com 7 elementos (n ímpar), a mediana é o elemento central: posição (7+1)/2 = 4º → mediana = 4. A mediana é robusta a outliers.",
    "example": "Ordenado: 1, 2, 3, [4], 6, 8, 9. Posição central (4º de 7): mediana = 4."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Médio__3",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Médio",
    "question": "Dois eventos A e B são independentes. Se P(A) = 0,3 e P(B) = 0,4, qual é P(A ∩ B)?",
    "options": [
      "0,12",
      "0,70",
      "0,35",
      "0,10"
    ],
    "correctIndex": 0,
    "explanation": "Se A e B são independentes: P(A ∩ B) = P(A) × P(B) = 0,3 × 0,4 = 0,12. Independência significa que a ocorrência de um não afeta a probabilidade do outro.",
    "example": "P(A ∩ B) = P(A) × P(B) = 0,3 × 0,4 = 0,12 = 12%. Se fossem dependentes, usaríamos P(A ∩ B) = P(A) × P(B|A)."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Médio__4",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Médio",
    "question": "Se a variância de um conjunto de dados é 25, qual é o desvio padrão?",
    "options": [
      "5",
      "25",
      "625",
      "12,5"
    ],
    "correctIndex": 0,
    "explanation": "Desvio padrão = √variância. σ = √25 = 5. O desvio padrão tem a mesma unidade dos dados originais, diferente da variância.",
    "example": "σ = √(σ²) = √25 = 5. Relação inversa: se σ = 5, então σ² = 5² = 25. Desvio padrão é mais intuitivo que variância."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Médio__5",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Médio",
    "question": "Dois dados são lançados simultaneamente. Qual a probabilidade de a soma ser par?",
    "options": [
      "1/2",
      "1/3",
      "1/4",
      "2/3"
    ],
    "correctIndex": 0,
    "explanation": "Soma par ocorre quando ambos são pares ou ambos ímpares. P(ambos pares) = 9/36. P(ambos ímpares) = 9/36. Total = 18/36 = 1/2.",
    "example": "Par+par = 9 casos. Ímpar+ímpar = 9 casos. 18 de 36 = 1/2. Metade das somas são pares, metade ímpares."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Médio__6",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Médio",
    "question": "Em uma amostra, a mediana é melhor que a média quando há valores discrepantes (outliers). Por quê?",
    "options": [
      "A mediana não é afetada por valores extremos, já a média é distorcida por outliers",
      "A mediana sempre é maior que a média",
      "Outliers não afetam nenhuma medida",
      "A média é sempre mais precisa"
    ],
    "correctIndex": 0,
    "explanation": "Exemplo: salários {2k, 3k, 3k, 4k, 100k}. Média = 22,4k (distorcida pelo 100k). Mediana = 3k (valor central, representa melhor o grupo). A mediana é uma medida resistente a outliers.",
    "example": "Conjunto {1, 2, 3, 4, 1000}: média = 202 (não representa ninguém), mediana = 3 (80% dos dados estão perto de 3). Por isso salário mediano é mais informativo que salário médio."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Médio__7",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Médio",
    "question": "Qual a probabilidade de, ao lançar dois dados, a soma ser maior que 10?",
    "options": [
      "3/36 = 1/12",
      "6/36",
      "1/6",
      "2/36"
    ],
    "correctIndex": 0,
    "explanation": "Soma > 10 significa soma = 11 ou 12. Soma 11: (5,6),(6,5) = 2 pares. Soma 12: (6,6) = 1 par. Total: 3 pares de 36. P = 3/36 = 1/12.",
    "example": "Soma 11: {(5,6),(6,5)} = 2 combinações. Soma 12: {(6,6)} = 1 combinação. Total = 3/36 = 1/12 ≈ 8,33%."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Médio__8",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Médio",
    "question": "Dados os valores 2, 4, 4, 4, 5, 5, 7, 9, qual a média e mediana?",
    "options": [
      "Média = 5, Mediana = 4,5",
      "Média = 4, Mediana = 5",
      "Média = 5, Mediana = 5",
      "Média = 4,5, Mediana = 4"
    ],
    "correctIndex": 0,
    "explanation": "Média: (2+4+4+4+5+5+7+9)/8 = 40/8 = 5. Mediana (n=8 par): média dos termos 4º e 5º ordenados: (4+5)/2 = 4,5.",
    "example": "Ordenados: 2,4,4,4,5,5,7,9. Soma=40. Média=40/8=5. Mediana: posicões 4 e 5 = 4 e 5. (4+5)/2=4,5. Moda=4 (aparece 3x). Desvio padrão: variância = média dos quadrados das diferenças."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Difícil__1",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Difícil",
    "question": "Numa urna com 5 bolas vermelhas e 3 azuis, retirando-se 2 bolas sem reposição, qual a probabilidade de ambas serem vermelhas?",
    "options": [
      "5/14",
      "25/64",
      "10/28",
      "1/4"
    ],
    "correctIndex": 0,
    "explanation": "Sem reposição → probabilidades mudam após a primeira retirada. P(1ª vermelha) = 5/8. P(2ª vermelha | 1ª vermelha) = 4/7 (restam 4 vermelhas de 7 bolas). P(ambas) = (5/8) × (4/7) = 20/56 = 5/14 ≈ 0,357.",
    "example": "Alternativa com combinações: C(5,2)/C(8,2) = 10/28 = 5/14. Note que 5/14 e 10/28 são equivalentes — por isso a resposta é 5/14."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Difícil__2",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Difícil",
    "question": "No lançamento de 2 dados, qual a probabilidade de a soma ser 7?",
    "options": [
      "1/6",
      "1/12",
      "1/36",
      "7/36"
    ],
    "correctIndex": 0,
    "explanation": "Espaço amostral: 6×6 = 36 resultados. Pares com soma 7: (1,6),(2,5),(3,4),(4,3),(5,2),(6,1) = 6 pares. P = 6/36 = 1/6 ≈ 16,67%. Soma 7 é a mais provável com 2 dados.",
    "example": "Pares: (1,6)(2,5)(3,4)(4,3)(5,2)(6,1) = 6 combinações. P = 6/36 = 1/6."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Difícil__3",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Difícil",
    "question": "Uma distribuição normal tem média 70 e desvio padrão 10. Qual a probabilidade aproximada de um valor estar entre 60 e 80?",
    "options": [
      "≈68,27%",
      "≈95,45%",
      "≈50%",
      "≈99,73%"
    ],
    "correctIndex": 0,
    "explanation": "Intervalo [60, 80] = [μ-1σ, μ+1σ]. Pela regra empírica (68-95-99,7), ≈68,27% dos dados estão dentro de ±1 desvio padrão da média na distribuição normal.",
    "example": "μ=70, σ=10. 60 = 70-10 = μ-1σ. 80 = 70+10 = μ+1σ. Regra 68-95-99.7: ±1σ ≈ 68,27%."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Difícil__4",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Difícil",
    "question": "Uma amostra tem média 50 e desvio padrão 8. Qual o coeficiente de variação (CV)?",
    "options": [
      "16%",
      "6,25%",
      "40%",
      "8%"
    ],
    "correctIndex": 0,
    "explanation": "CV = (desvio padrão / média) × 100% = (8/50) × 100% = 16%. O CV mede a dispersão relativa — útil para comparar conjuntos com médias diferentes.",
    "example": "CV = σ/μ = 8/50 = 0,16 = 16%. Se outro conjunto tem média 100 e σ=8, CV=8% → menos disperso relativamente."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Difícil__5",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Difícil",
    "question": "Em 5 lançamentos de uma moeda, qual a probabilidade de obter exatamente 3 caras?",
    "options": [
      "5/16",
      "1/2",
      "3/5",
      "10/32"
    ],
    "correctIndex": 3,
    "explanation": "Distribuição binomial: P(X=k) = C(n,k) × p^k × (1-p)^(n-k). C(5,3) × (1/2)³ × (1/2)² = 10 × 1/32 = 10/32 = 5/16. As alternativas 5/16 e 10/32 são equivalentes.",
    "example": "C(5,3) = 10. (1/2)⁵ = 1/32. P = 10/32 = 5/16 ≈ 31,25%. Tanto 5/16 quanto 10/32 estão corretos (são frações equivalentes)."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Difícil__6",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Difícil",
    "question": "Qual a probabilidade de, em 3 lançamentos de moeda, obter pelo menos 1 cara?",
    "options": [
      "7/8",
      "3/8",
      "1/2",
      "5/8"
    ],
    "correctIndex": 0,
    "explanation": "P(pelo menos 1 cara) = 1 - P(nenhuma cara) = 1 - P(3 coroas). P(3 coroas) = (1/2)³ = 1/8. P(pelo menos 1 cara) = 1 - 1/8 = 7/8 = 87,5%.",
    "example": "Estratégia 'complementar': calcular 'nenhuma' e subtrair de 1. P(0 caras) = (1/2)³ = 1/8. P(≥1 cara) = 7/8. Muito mais fácil que somar P(1 cara) + P(2 caras) + P(3 caras)."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Difícil__7",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Difícil",
    "question": "Um teste de QI tem distribuição normal com μ = 100 e σ = 15. Qual a probabilidade de uma pessoa ter QI entre 70 e 130?",
    "options": [
      "≈ 95,45%",
      "≈ 68,27%",
      "≈ 99,73%",
      "≈ 50%"
    ],
    "correctIndex": 0,
    "explanation": "70 = 100 - 2×15 = μ - 2σ. 130 = 100 + 2×15 = μ + 2σ. Intervalo [μ-2σ, μ+2σ]. Pela regra empírica (68-95-99,7): ≈ 95,45% dos dados estão dentro de ±2 desvios padrão.",
    "example": "70 = μ-2σ, 130 = μ+2σ. Regra 68-95-99.7: ±2σ ≈ 95,45%. Ou seja, ∼95% da população tem QI entre 70 e 130. Apenas ∼2,3% acima de 130 (superdotado)."
  },
  {
    "id": "matematica__Estatística e Probabilidade__Difícil__8",
    "track": "matematica",
    "category": "Estatística e Probabilidade",
    "difficulty": "Difícil",
    "question": "Uma moeda é lançada 3 vezes. Qual a probabilidade de obter exatamente 2 caras usando a distribuição binomial?",
    "options": [
      "3/8",
      "1/4",
      "1/2",
      "3/4"
    ],
    "correctIndex": 0,
    "explanation": "P(X=2) = C(3,2) × (1/2)² × (1/2)¹ = 3 × 1/4 × 1/2 = 3/8.",
    "example": "Binomial B(n=3, p=1/2). C(3,2)=3. p^2=1/4. q^1=1/2. P=3×1/4×1/2=3/8=0,375. Espaço amostral: HHH, HHT, HTH, HTT, THH, THT, TTH, TTT — 8 resultados. Casos (2 caras): HHT, HTH, THH = 3. 3/8 ✓."
  },
  {
    "id": "matematica__Funções__Fácil__1",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Fácil",
    "question": "Dada a função f(x) = 3x + 2, qual é o valor de f(4)?",
    "options": [
      "14",
      "12",
      "15",
      "10"
    ],
    "correctIndex": 0,
    "explanation": "Substituímos x por 4: f(4) = 3(4) + 2 = 12 + 2 = 14. A função f(x) = 3x + 2 é uma função afim (1º grau), onde 3 é o coeficiente angular e 2 é o coeficiente linear.",
    "example": "f(4) = 3 × 4 + 2 = 12 + 2 = 14. O gráfico é uma reta que cruza o eixo y em y = 2 e sobe 3 unidades para cada unidade de x."
  },
  {
    "id": "matematica__Funções__Fácil__2",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Fácil",
    "question": "Qual é o domínio da função f(x) = √(x - 4)?",
    "options": [
      "x ≥ 4",
      "x > 4",
      "Todos os reais",
      "x ≥ 0"
    ],
    "correctIndex": 0,
    "explanation": "A raiz quadrada só existe para valores não-negativos. Então x - 4 ≥ 0 → x ≥ 4. O domínio é [4, +∞). Para x = 4: f(4) = √0 = 0. Para x = 3: √(-1) não existe nos reais.",
    "example": "f(4) = √0 = 0 ✓. f(5) = √1 = 1 ✓. f(3) = √(-1) = não existe ✗. Domínio: x ≥ 4."
  },
  {
    "id": "matematica__Funções__Fácil__3",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Fácil",
    "question": "Se f(x) = 2x + 1 e g(x) = x², qual é f(g(3))?",
    "options": [
      "19",
      "49",
      "13",
      "7"
    ],
    "correctIndex": 0,
    "explanation": "Composição de funções: f(g(3)). Primeiro: g(3) = 3² = 9. Depois: f(9) = 2(9) + 1 = 19. Note que f(g(x)) ≠ g(f(x)) em geral.",
    "example": "g(3) = 9. f(9) = 2×9 + 1 = 19. Se fosse g(f(3)): f(3) = 7, g(7) = 49 — resultado diferente."
  },
  {
    "id": "matematica__Funções__Fácil__4",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Fácil",
    "question": "Se f(x) = x² - 1, qual o valor de f(-3)?",
    "options": [
      "8",
      "10",
      "-10",
      "4"
    ],
    "correctIndex": 0,
    "explanation": "Substitua x por -3: f(-3) = (-3)² - 1 = 9 - 1 = 8. Lembre-se: (-3)² = 9 (o quadrado de negativo é positivo).",
    "example": "(-3)² = 9 (não confundir com -3² = -9). f(-3) = 9 - 1 = 8."
  },
  {
    "id": "matematica__Funções__Fácil__5",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Fácil",
    "question": "Qual é o domínio da função f(x) = 1/(x - 2)?",
    "options": [
      "Todos os reais exceto x = 2",
      "Todos os reais",
      "x > 2",
      "x ≥ 0"
    ],
    "correctIndex": 0,
    "explanation": "O denominador não pode ser zero: x - 2 ≠ 0 → x ≠ 2. Domínio: ℝ - {2}. Há uma assíntota vertical em x = 2.",
    "example": "Se x = 2: f(2) = 1/0 → indefinido. Qualquer outro valor funciona: f(3) = 1, f(0) = -1/2. D = ℝ - {2}."
  },
  {
    "id": "matematica__Funções__Fácil__6",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Fácil",
    "question": "Se f(x) = 2x - 3, para qual valor de x temos f(x) = 0?",
    "options": [
      "x = 3/2",
      "x = 3",
      "x = -3/2",
      "x = 2"
    ],
    "correctIndex": 0,
    "explanation": "f(x) = 0 → 2x - 3 = 0 → 2x = 3 → x = 3/2 = 1,5. Esse é o zero (ou raiz) da função, o ponto onde o gráfico cruza o eixo x.",
    "example": "f(3/2) = 2(3/2) - 3 = 3 - 3 = 0 ✓. No gráfico, a reta y = 2x - 3 cruza o eixo x no ponto (1,5; 0)."
  },
  {
    "id": "matematica__Funções__Fácil__7",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Fácil",
    "question": "Qual a imagem (contradomínio efetivo) da função f(x) = x² para x ∈ ℝ?",
    "options": [
      "y ≥ 0",
      "Todos os reais",
      "y > 0",
      "y ≤ 0"
    ],
    "correctIndex": 0,
    "explanation": "x² ≥ 0 para qualquer x real (quadrado nunca é negativo). O menor valor é f(0) = 0. A imagem é [0, +∞), ou seja, y ≥ 0.",
    "example": "f(0) = 0 (mínimo). f(1) = 1. f(-2) = 4. f(100) = 10000. Todos os resultados ≥ 0. Nunca obtém valor negativo."
  },
  {
    "id": "matematica__Funções__Fácil__8",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Fácil",
    "question": "Qual o domínio da função f(x) = √(x − 3)?",
    "options": [
      "x ≥ 3",
      "x > 3",
      "x ≠ 3",
      "Todo real"
    ],
    "correctIndex": 0,
    "explanation": "Para a raiz quadrada ser real, o radicando deve ser ≥ 0: x - 3 ≥ 0 ⇒ x ≥ 3. Domínio: [3, +∞).",
    "example": "f(3) = √0 = 0 (válido). f(7) = √4 = 2. f(2) = √(-1) — não real. Domínio: [3,+∞). Para f(x)=√(x²-9): x²≥9 ⇒ x≤-3 ou x≥3 ⇒ D=(-∞,-3]∪[3,+∞)."
  },
  {
    "id": "matematica__Funções__Médio__1",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Médio",
    "question": "Qual é o vértice da parábola y = x² - 6x + 8?",
    "options": [
      "(3, -1)",
      "(3, 1)",
      "(-3, -1)",
      "(6, 8)"
    ],
    "correctIndex": 0,
    "explanation": "Para y = ax² + bx + c, o vértice é V = (-b/2a, -Δ/4a). Aqui: a=1, b=-6, c=8. xᵥ = -(-6)/(2×1) = 3. yᵥ = (3)² - 6(3) + 8 = 9 - 18 + 8 = -1. Logo V = (3, -1).",
    "example": "xᵥ = 6/2 = 3. yᵥ = 9 - 18 + 8 = -1. A parábola abre para cima (a > 0), então (3, -1) é o ponto mínimo."
  },
  {
    "id": "matematica__Funções__Médio__2",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Médio",
    "question": "Determine os zeros (raízes) da função f(x) = x² - 4x - 5.",
    "options": [
      "x = -1 e x = 5",
      "x = 1 e x = -5",
      "x = 4 e x = -1",
      "x = 2 e x = -3"
    ],
    "correctIndex": 0,
    "explanation": "Zeros são onde f(x) = 0: x² - 4x - 5 = 0. Δ = 16 + 20 = 36. x = (4 ± 6)/2. x₁ = 10/2 = 5. x₂ = -2/2 = -1. Ou fatorando: (x-5)(x+1) = 0.",
    "example": "Δ = (-4)² - 4(1)(-5) = 16 + 20 = 36. √36 = 6. x = (4+6)/2 = 5, x = (4-6)/2 = -1."
  },
  {
    "id": "matematica__Funções__Médio__3",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Médio",
    "question": "Qual é a função exponencial que passa pelos pontos (0, 1) e (2, 9)?",
    "options": [
      "f(x) = 3ˣ",
      "f(x) = 9ˣ",
      "f(x) = 2ˣ",
      "f(x) = x²"
    ],
    "correctIndex": 0,
    "explanation": "f(x) = aˣ. Em (0,1): a⁰ = 1 ✓ (qualquer base). Em (2,9): a² = 9 → a = 3 (base positiva). Logo f(x) = 3ˣ. Verifica: f(0) = 1, f(1) = 3, f(2) = 9.",
    "example": "f(0) = 3⁰ = 1 ✓. f(2) = 3² = 9 ✓. f(3) = 3³ = 27. A função cresce exponencialmente."
  },
  {
    "id": "matematica__Funções__Médio__4",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Médio",
    "question": "A função f(x) = -2x² + 8x - 6 tem valor máximo ou mínimo? Qual é?",
    "options": [
      "Máximo = 2",
      "Mínimo = 2",
      "Máximo = -6",
      "Mínimo = -6"
    ],
    "correctIndex": 0,
    "explanation": "a = -2 < 0 → parábola abre para baixo → possui MÁXIMO. xᵥ = -8/(2×(-2)) = 2. yᵥ = -2(4) + 8(2) - 6 = -8 + 16 - 6 = 2. Valor máximo = 2.",
    "example": "a < 0 → concavidade para baixo → máximo. xᵥ = 2, yᵥ = -8+16-6 = 2. Ponto (2, 2) é o vértice máximo."
  },
  {
    "id": "matematica__Funções__Médio__5",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Médio",
    "question": "Qual é o período da função f(x) = sen(2x)?",
    "options": [
      "π",
      "2π",
      "π/2",
      "4π"
    ],
    "correctIndex": 0,
    "explanation": "Para f(x) = sen(bx), o período é T = 2π/|b|. Com b = 2: T = 2π/2 = π. A função completa um ciclo a cada π unidades.",
    "example": "T = 2π/|b| = 2π/2 = π. Comparação: sen(x) tem período 2π, sen(2x) oscila 2× mais rápido → período π."
  },
  {
    "id": "matematica__Funções__Médio__6",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Médio",
    "question": "Determine a função inversa de f(x) = 3x - 6.",
    "options": [
      "f⁻¹(x) = (x + 6)/3",
      "f⁻¹(x) = (x - 6)/3",
      "f⁻¹(x) = 3x + 6",
      "f⁻¹(x) = x/3 - 6"
    ],
    "correctIndex": 0,
    "explanation": "y = 3x - 6. Troque x e y: x = 3y - 6. Isole y: 3y = x + 6 → y = (x + 6)/3. Logo f⁻¹(x) = (x + 6)/3. Verifica: f(f⁻¹(x)) = 3×(x+6)/3 - 6 = x + 6 - 6 = x ✓.",
    "example": "f(4) = 3(4) - 6 = 6. f⁻¹(6) = (6+6)/3 = 12/3 = 4 ✓. A inversa 'desfaz' a função original."
  },
  {
    "id": "matematica__Funções__Médio__7",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Médio",
    "question": "A função f(x) = x² - 4x + 7 tem valor mínimo ou máximo? Qual é?",
    "options": [
      "Mínimo = 3",
      "Máximo = 3",
      "Mínimo = 7",
      "Máximo = 7"
    ],
    "correctIndex": 0,
    "explanation": "a = 1 > 0 → parábola abre para cima → MÍNIMO. xv = -(-4)/(2×1) = 2. yv = (2)² - 4(2) + 7 = 4 - 8 + 7 = 3. Valor mínimo = 3.",
    "example": "Vértice (2, 3). f(0) = 7, f(1) = 4, f(2) = 3 (mínimo), f(3) = 4, f(4) = 7. Parábola simétrica em torno de x = 2."
  },
  {
    "id": "matematica__Funções__Médio__8",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Médio",
    "question": "Dada f(x) = 2x + 1 e g(x) = x², quanto vale (f∘g)(3)?",
    "options": [
      "19",
      "49",
      "7",
      "10"
    ],
    "correctIndex": 0,
    "explanation": "(f∘g)(x) = f(g(x)) = f(x²) = 2x² + 1. (f∘g)(3) = 2(9) + 1 = 19.",
    "example": "g(3) = 9. f(9) = 2(9)+1 = 19. Atenção: (g∘f)(3) = g(f(3)) = g(7) = 49 — composicão não é comutativa. f∘g ≠ g∘f em geral."
  },
  {
    "id": "matematica__Funções__Difícil__1",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Difícil",
    "question": "Dada f(x) = (2x + 1)/(x - 3), determine f⁻¹(x) (função inversa).",
    "options": [
      "f⁻¹(x) = (3x + 1)/(x - 2)",
      "f⁻¹(x) = (x - 3)/(2x + 1)",
      "f⁻¹(x) = (3x - 1)/(x + 2)",
      "f⁻¹(x) = (2x - 1)/(x + 3)"
    ],
    "correctIndex": 0,
    "explanation": "Para encontrar a inversa, troque x e y e isole y. x = (2y + 1)/(y - 3) → x(y - 3) = 2y + 1 → xy - 3x = 2y + 1 → xy - 2y = 3x + 1 → y(x - 2) = 3x + 1 → y = (3x + 1)/(x - 2). Logo f⁻¹(x) = (3x + 1)/(x - 2).",
    "example": "Verificação: f(f⁻¹(5)) = f((15+1)/(5-2)) = f(16/3) = (2×16/3 + 1)/(16/3 - 3) = (32/3 + 3/3)/(16/3 - 9/3) = (35/3)/(7/3) = 35/7 = 5 ✓."
  },
  {
    "id": "matematica__Funções__Difícil__2",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Difícil",
    "question": "Qual é a assíntota horizontal da função f(x) = (3x + 1)/(x - 2)?",
    "options": [
      "y = 3",
      "y = 0",
      "y = 1",
      "Não tem assíntota horizontal"
    ],
    "correctIndex": 0,
    "explanation": "Para funções racionais onde grau do numerador = grau do denominador, a assíntota horizontal é a razão dos coeficientes líderes. AH: y = 3/1 = 3. Quando x → ±∞, f(x) → 3.",
    "example": "f(100) = 301/98 ≈ 3,07. f(1000) = 3001/998 ≈ 3,007. Conforme x cresce, f(x) → 3, confirmando AH: y = 3."
  },
  {
    "id": "matematica__Funções__Difícil__3",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Difícil",
    "question": "Resolva log₃(x) + log₃(x - 6) = 3.",
    "options": [
      "x = 9",
      "x = 27",
      "x = 6",
      "x = 12"
    ],
    "correctIndex": 0,
    "explanation": "log₃[x(x-6)] = 3 → x(x-6) = 3³ = 27 → x² - 6x - 27 = 0 → (x-9)(x+3) = 0. x = 9 ou x = -3. Como x > 6 (domínio do log), x = 9.",
    "example": "x² - 6x - 27 = 0 → x = 9. Verifica: log₃(9) + log₃(3) = 2 + 1 = 3 ✓."
  },
  {
    "id": "matematica__Funções__Difícil__4",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Difícil",
    "question": "Determine o domínio de f(x) = ln(x² - 4).",
    "options": [
      "x < -2 ou x > 2",
      "x > 2",
      "-2 < x < 2",
      "x ≠ ±2"
    ],
    "correctIndex": 0,
    "explanation": "O argumento do ln deve ser positivo: x² - 4 > 0 → x² > 4 → |x| > 2 → x < -2 ou x > 2. Domínio: (-∞, -2) ∪ (2, +∞).",
    "example": "x = 3: 9-4 = 5 > 0 ✓. x = 0: 0-4 = -4 < 0 ✗. x = -3: 9-4 = 5 > 0 ✓. Confirma: |x| > 2."
  },
  {
    "id": "matematica__Funções__Difícil__5",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Difícil",
    "question": "Se f(x) = 2ˣ e g(x) = log₂(x), qual é f(g(8))?",
    "options": [
      "8",
      "3",
      "256",
      "16"
    ],
    "correctIndex": 0,
    "explanation": "g(8) = log₂(8) = 3. f(3) = 2³ = 8. Note que f e g são funções inversas: f(g(x)) = 2^(log₂(x)) = x para todo x > 0.",
    "example": "g(8) = log₂(8) = 3 (pois 2³=8). f(3) = 2³ = 8. Como f e g são inversas, f(g(x)) = x sempre."
  },
  {
    "id": "matematica__Funções__Difícil__6",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Difícil",
    "question": "Qual é o conjunto imagem da função f(x) = sen(x)?",
    "options": [
      "[-1, 1]",
      "[0, 1]",
      "Todos os reais",
      "[0, +∞)"
    ],
    "correctIndex": 0,
    "explanation": "A função seno oscila entre -1 e 1 para qualquer valor de x. Imagem = [-1, 1]. sen(x) atinge -1 em x = 3π/2 + 2kπ e 1 em x = π/2 + 2kπ.",
    "example": "sen(0) = 0. sen(π/2) = 1 (máximo). sen(π) = 0. sen(3π/2) = -1 (mínimo). Nunca ultrapassa [-1, 1]."
  },
  {
    "id": "matematica__Funções__Difícil__7",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Difícil",
    "question": "Determine a composta g(f(x)) onde f(x) = x + 1 e g(x) = x² - 2x.",
    "options": [
      "g(f(x)) = x² - 1",
      "g(f(x)) = x² + 2x - 1",
      "g(f(x)) = x² - 2x + 1",
      "g(f(x)) = x² + 1"
    ],
    "correctIndex": 0,
    "explanation": "g(f(x)) = g(x+1) = (x+1)² - 2(x+1) = x² + 2x + 1 - 2x - 2 = x² - 1. Note: g(f(x)) ≠ f(g(x)) em geral.",
    "example": "Teste x=3: f(3)=4, g(4)=16-8=8. Direto: 3²-1=8 ✓. Teste x=0: f(0)=1, g(1)=1-2=-1. Direto: 0²-1=-1 ✓."
  },
  {
    "id": "matematica__Funções__Difícil__8",
    "track": "matematica",
    "category": "Funções",
    "difficulty": "Difícil",
    "question": "Qual o periódo e amplitude da função f(x) = 3 sen(2x + π/4)?",
    "options": [
      "Período = π, Amplitude = 3",
      "Período = 2π, Amplitude = 3",
      "Período = π, Amplitude = 6",
      "Período = 4π, Amplitude = 3"
    ],
    "correctIndex": 0,
    "explanation": "f(x)=A·sen(Bx+C): Amplitude = |A| = 3. Período = 2π/B = 2π/2 = π. Fase = C/B = (π/4)/2 = π/8 (deslocamento horizontal).",
    "example": "A=3: oscila entre -3 e +3. B=2: comprime o período pela metade (f(x)=sen(x) tem período 2π; B=2 ⇒ período = 2π/2 = π). C=π/4: fase. Gráfico: 2 ciclos completos em [0, 2π]."
  },
  {
    "id": "matematica__Geometria Plana__Fácil__1",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Fácil",
    "question": "Qual é a área de um triângulo com base 10 cm e altura 6 cm?",
    "options": [
      "30 cm²",
      "60 cm²",
      "16 cm²",
      "20 cm²"
    ],
    "correctIndex": 0,
    "explanation": "A área de um triângulo é dada por A = (base × altura) / 2. A = (10 × 6) / 2 = 60 / 2 = 30 cm². A fórmula representa metade da área do retângulo que contém o triângulo.",
    "example": "Base = 10, Altura = 6. A = (10 × 6) / 2 = 30 cm². Se fosse um retângulo 10×6, a área seria 60 cm² — o triângulo é exatamente metade."
  },
  {
    "id": "matematica__Geometria Plana__Fácil__2",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Fácil",
    "question": "Qual é a área de um círculo com raio de 5 cm?",
    "options": [
      "25π cm²",
      "10π cm²",
      "50π cm²",
      "5π cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área do círculo: A = πr² = π × 5² = 25π ≈ 78,54 cm². O perímetro (circunferência) seria C = 2πr = 10π ≈ 31,42 cm.",
    "example": "r = 5 cm. A = π × 25 = 25π ≈ 78,54 cm²."
  },
  {
    "id": "matematica__Geometria Plana__Fácil__3",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Fácil",
    "question": "Qual a soma dos ângulos internos de um triângulo?",
    "options": [
      "180°",
      "360°",
      "90°",
      "270°"
    ],
    "correctIndex": 0,
    "explanation": "A soma dos ângulos internos de qualquer triângulo é sempre 180°. Para polígonos com n lados: soma = (n-2) × 180°. Triângulo: (3-2) × 180° = 180°. Quadrilátero: 360°.",
    "example": "Triângulo equilátero: 60° + 60° + 60° = 180°. Triângulo retângulo: 90° + 45° + 45° = 180°. Sempre 180°."
  },
  {
    "id": "matematica__Geometria Plana__Fácil__4",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Fácil",
    "question": "Qual é o perímetro de um retângulo com largura 5 cm e comprimento 12 cm?",
    "options": [
      "34 cm",
      "60 cm",
      "17 cm",
      "24 cm"
    ],
    "correctIndex": 0,
    "explanation": "Perímetro do retângulo = 2 × (comprimento + largura) = 2 × (12 + 5) = 2 × 17 = 34 cm.",
    "example": "P = 2(L + C) = 2(5 + 12) = 2 × 17 = 34 cm. Área seria 5 × 12 = 60 cm² (não confundir)."
  },
  {
    "id": "matematica__Geometria Plana__Fácil__5",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Fácil",
    "question": "Um quadrado tem diagonal medindo 10 cm. Qual é o lado do quadrado?",
    "options": [
      "5√2 cm",
      "5 cm",
      "10√2 cm",
      "10 cm"
    ],
    "correctIndex": 0,
    "explanation": "No quadrado, d = L√2. Então L = d/√2 = 10/√2 = 10√2/2 = 5√2 ≈ 7,07 cm.",
    "example": "d = L√2 → L = 10/√2 = 5√2 ≈ 7,07 cm. Verifica: (5√2)² + (5√2)² = 50 + 50 = 100 = 10² ✓."
  },
  {
    "id": "matematica__Geometria Plana__Fácil__6",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Fácil",
    "question": "Qual a área de um quadrado com lado 8 cm?",
    "options": [
      "64 cm²",
      "32 cm²",
      "16 cm²",
      "128 cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área do quadrado = lado² = 8² = 64 cm². O perímetro seria 4 × 8 = 32 cm. Não confundir área (cm²) com perímetro (cm).",
    "example": "A = 8 × 8 = 64 cm². Diagonal = 8√2 ≈ 11,31 cm."
  },
  {
    "id": "matematica__Geometria Plana__Fácil__7",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Fácil",
    "question": "Qual o comprimento (perímetro) de uma circunferência com raio 7 cm?",
    "options": [
      "14π cm",
      "7π cm",
      "49π cm",
      "28π cm"
    ],
    "correctIndex": 0,
    "explanation": "Comprimento da circunferência: C = 2πr = 2π(7) = 14π ≈ 43,98 cm. Não confundir com área: A = πr² = 49π.",
    "example": "C = 2 × π × 7 = 14π ≈ 43,98 cm. Se diâmetro = 14 cm, C = πd = 14π (mesmo resultado)."
  },
  {
    "id": "matematica__Geometria Plana__Fácil__8",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Fácil",
    "question": "Qual a área de um triângulo com base 8 cm e altura 5 cm?",
    "options": [
      "20 cm²",
      "40 cm²",
      "13 cm²",
      "10 cm²"
    ],
    "correctIndex": 0,
    "explanation": "A = base × altura / 2 = 8 × 5 / 2 = 20 cm².",
    "example": "A = (b×h)/2 = 40/2 = 20 cm². Para qualquer triângulo (equilátero, retângulo, etc.) a fórmula é a mesma. Área por Heron: A=√(s(s-a)(s-b)(s-c)), s=semi-perímetro."
  },
  {
    "id": "matematica__Geometria Plana__Médio__1",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Médio",
    "question": "Em um triângulo retângulo com catetos de 5 cm e 12 cm, qual é o comprimento da hipotenusa?",
    "options": [
      "13 cm",
      "17 cm",
      "15 cm",
      "10 cm"
    ],
    "correctIndex": 0,
    "explanation": "Pelo Teorema de Pitágoras: h² = a² + b² = 5² + 12² = 25 + 144 = 169. h = √169 = 13 cm. (5, 12, 13) é uma tripla pitagórica clássica.",
    "example": "a² + b² = c². 25 + 144 = 169. √169 = 13. Verificação: 5² + 12² = 25 + 144 = 169 = 13² ✓."
  },
  {
    "id": "matematica__Geometria Plana__Médio__2",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Médio",
    "question": "Qual é a área de um trapézio com bases 8 cm e 12 cm e altura 5 cm?",
    "options": [
      "50 cm²",
      "60 cm²",
      "100 cm²",
      "40 cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área do trapézio: A = [(B + b) × h] / 2 = [(12 + 8) × 5] / 2 = [20 × 5] / 2 = 100/2 = 50 cm².",
    "example": "Bases: 12 e 8. Altura: 5. A = (12+8) × 5 / 2 = 20 × 5 / 2 = 50 cm²."
  },
  {
    "id": "matematica__Geometria Plana__Médio__3",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Médio",
    "question": "Em um triângulo, dois lados medem 7 cm e 10 cm. Quais valores são possíveis para o terceiro lado?",
    "options": [
      "3 < x < 17",
      "0 < x < 17",
      "3 ≤ x ≤ 17",
      "7 < x < 10"
    ],
    "correctIndex": 0,
    "explanation": "Desigualdade triangular: a soma de dois lados deve ser maior que o terceiro. |7-10| < x < 7+10 → 3 < x < 17. O terceiro lado deve ser maior que 3 e menor que 17.",
    "example": "x < 7+10 = 17 (se não, não fecha). x > |10-7| = 3 (se não, degenera). Logo 3 < x < 17."
  },
  {
    "id": "matematica__Geometria Plana__Médio__4",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Médio",
    "question": "Qual é a área de um losango com diagonais de 10 cm e 16 cm?",
    "options": [
      "80 cm²",
      "160 cm²",
      "40 cm²",
      "120 cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área do losango = (d₁ × d₂) / 2 = (10 × 16) / 2 = 160 / 2 = 80 cm². As diagonais do losango se cruzam perpendicularmente.",
    "example": "A = (D × d) / 2 = (16 × 10) / 2 = 80 cm². O losango é dividido em 4 triângulos retângulos iguais."
  },
  {
    "id": "matematica__Geometria Plana__Médio__5",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Médio",
    "question": "Um polígono regular tem cada ângulo interno medindo 120°. Quantos lados ele tem?",
    "options": [
      "6",
      "5",
      "8",
      "4"
    ],
    "correctIndex": 0,
    "explanation": "Ângulo interno do polígono regular: α = (n-2)×180°/n. 120 = (n-2)×180/n → 120n = 180n - 360 → 60n = 360 → n = 6. É um hexágono regular.",
    "example": "120n = 180n - 360 → 60n = 360 → n = 6 lados (hexágono). Valida: (6-2)×180/6 = 720/6 = 120° ✓."
  },
  {
    "id": "matematica__Geometria Plana__Médio__6",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Médio",
    "question": "Qual a área de um triângulo equilátero com lado 6 cm?",
    "options": [
      "9√3 cm²",
      "18√3 cm²",
      "36 cm²",
      "12√3 cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área do triângulo equilátero: A = (√3/4) × L². A = (√3/4) × 36 = 9√3 ≈ 15,59 cm². A altura é h = L√3/2 = 3√3.",
    "example": "A = (√3/4) × 6² = 9√3 ≈ 15,59 cm². Conferindo: A = (base × altura)/2 = (6 × 3√3)/2 = 9√3 ✓."
  },
  {
    "id": "matematica__Geometria Plana__Médio__7",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Médio",
    "question": "Um triângulo retângulo tem hipotenusa 10 cm e um cateto 6 cm. Qual o outro cateto?",
    "options": [
      "8 cm",
      "4 cm",
      "7 cm",
      "√136 cm"
    ],
    "correctIndex": 0,
    "explanation": "Pitágoras: c² = a² + b² → 10² = 6² + b² → 100 = 36 + b² → b² = 64 → b = 8 cm. Terna pitagórica clássica: (6, 8, 10) = 2×(3, 4, 5).",
    "example": "b² = 100 - 36 = 64. b = √64 = 8 cm. Verifica: 6² + 8² = 36 + 64 = 100 = 10² ✓."
  },
  {
    "id": "matematica__Geometria Plana__Médio__8",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Médio",
    "question": "Um círculo tem área igual a 36π cm². Qual o comprimento de seu diâmetro?",
    "options": [
      "12 cm",
      "6 cm",
      "18 cm",
      "9 cm"
    ],
    "correctIndex": 0,
    "explanation": "Área = πr² = 36π ⇒ r² = 36 ⇒ r = 6 cm. Diâmetro = 2r = 12 cm.",
    "example": "πr²=36π ⇒ r²=36 ⇒ r=6. Diâmetro=12 cm. Circunferência: C=2πr=12π cm. Setor circular: A_setor = (θ/360)×πr² para θ em graus."
  },
  {
    "id": "matematica__Geometria Plana__Difícil__1",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Difícil",
    "question": "Um hexágono regular tem lado 8 cm. Qual é sua área?",
    "options": [
      "96√3 cm²",
      "192 cm²",
      "48√3 cm²",
      "64√3 cm²"
    ],
    "correctIndex": 0,
    "explanation": "A área de um hexágono regular de lado L é A = (3√3/2) × L². A = (3√3/2) × 64 = (3√3 × 64)/2 = 192√3/2 = 96√3 cm². Um hexágono regular pode ser dividido em 6 triângulos equiláteros iguais.",
    "example": "Cada um dos 6 triângulos equiláteros tem lado 8. Área do triângulo equilátero = (√3/4) × 8² = 16√3. Área total = 6 × 16√3 = 96√3 ≈ 166,28 cm²."
  },
  {
    "id": "matematica__Geometria Plana__Difícil__2",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Difícil",
    "question": "Dois triângulos semelhantes têm lados na razão 2:5. Se a área do menor é 12 cm², qual a área do maior?",
    "options": [
      "75 cm²",
      "30 cm²",
      "48 cm²",
      "120 cm²"
    ],
    "correctIndex": 0,
    "explanation": "Em figuras semelhantes, a razão das áreas é o quadrado da razão de semelhança: (2/5)² = 4/25. Logo 12/A = 4/25 → A = 12 × 25/4 = 75 cm².",
    "example": "Razão de lados: 2:5. Razão de áreas: 4:25. 12/A = 4/25 → A = 75 cm²."
  },
  {
    "id": "matematica__Geometria Plana__Difícil__3",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Difícil",
    "question": "Calcule a área de um setor circular com raio 10 cm e ângulo central de 72°.",
    "options": [
      "20π cm²",
      "36π cm²",
      "10π cm²",
      "72π cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área do setor = (θ/360°) × πr² = (72/360) × π × 100 = (1/5) × 100π = 20π ≈ 62,83 cm².",
    "example": "72°/360° = 1/5 do círculo. Área total = π × 10² = 100π. Setor = 100π/5 = 20π cm²."
  },
  {
    "id": "matematica__Geometria Plana__Difícil__4",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Difícil",
    "question": "Num triângulo com lados 7, 8 e 9 cm, calcule a área usando a fórmula de Heron.",
    "options": [
      "12√5 cm²",
      "36 cm²",
      "24√3 cm²",
      "28 cm²"
    ],
    "correctIndex": 0,
    "explanation": "Semiperímetro: s = (7+8+9)/2 = 12. A = √[s(s-a)(s-b)(s-c)] = √[12×5×4×3] = √720 = √(144×5) = 12√5 ≈ 26,83 cm².",
    "example": "s = 12. s-a = 5, s-b = 4, s-c = 3. Produto = 12×5×4×3 = 720. √720 = 12√5 ≈ 26,83 cm²."
  },
  {
    "id": "matematica__Geometria Plana__Difícil__5",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Difícil",
    "question": "Uma circunferência de raio 5 cm tem uma corda distante 3 cm do centro. Qual o comprimento da corda?",
    "options": [
      "8 cm",
      "6 cm",
      "10 cm",
      "4 cm"
    ],
    "correctIndex": 0,
    "explanation": "O segmento do centro à corda é perpendicular e divide a corda ao meio. Triângulo retângulo: d² + (c/2)² = r² → 9 + (c/2)² = 25 → (c/2)² = 16 → c/2 = 4 → c = 8 cm.",
    "example": "d = 3, r = 5. (c/2)² = 25 - 9 = 16. c/2 = 4. c = 8 cm. Se d = 0 (corda pelo centro), c = 2r = 10 (diâmetro)."
  },
  {
    "id": "matematica__Geometria Plana__Difícil__6",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Difícil",
    "question": "Um arco tem comprimento 4π cm em uma circunferência de raio 12 cm. Qual o ângulo central em graus?",
    "options": [
      "60°",
      "90°",
      "120°",
      "45°"
    ],
    "correctIndex": 0,
    "explanation": "Comprimento do arco: L = rθ (em radianos). 4π = 12θ → θ = 4π/12 = π/3 rad. Em graus: π/3 × (180/π) = 60°.",
    "example": "Também: L/C = θ/360°. C = 2π(12) = 24π. 4π/24π = θ/360°. 1/6 = θ/360°. θ = 60°."
  },
  {
    "id": "matematica__Geometria Plana__Difícil__7",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Difícil",
    "question": "Calcule o apótema de um hexágono regular com lado 10 cm.",
    "options": [
      "5√3 cm",
      "10√3 cm",
      "5 cm",
      "10 cm"
    ],
    "correctIndex": 0,
    "explanation": "No hexágono regular, o apótema (distância do centro ao meio do lado) é a = L√3/2. a = 10√3/2 = 5√3 ≈ 8,66 cm. O raio (distância do centro ao vértice) é igual ao lado.",
    "example": "O hexágono regular é formado por 6 triângulos equiláteros de lado 10. A altura de cada triângulo = 10√3/2 = 5√3 = apótema."
  },
  {
    "id": "matematica__Geometria Plana__Difícil__8",
    "track": "matematica",
    "category": "Geometria Plana",
    "difficulty": "Difícil",
    "question": "Num trapézio retângulo, as bases medem 10 e 6 cm, e a altura é 4 cm. Qual a área?",
    "options": [
      "32 cm²",
      "40 cm²",
      "24 cm²",
      "28 cm²"
    ],
    "correctIndex": 0,
    "explanation": "A = (B+b) × h / 2 = (10+6) × 4 / 2 = 16 × 2 = 32 cm².",
    "example": "(B+b)/2 é a média das bases = média lógica (mediana do trapézio). (10+6)/2=8. 8×4=32 cm². Trapézio retângulo: dois ângulos retos (um lado perpendicular às bases). Área independe do tipo de trapézio."
  },
  {
    "id": "matematica__Geometria Espacial__Fácil__1",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Fácil",
    "question": "Qual é o volume de um cubo com aresta de 5 cm?",
    "options": [
      "125 cm³",
      "75 cm³",
      "150 cm³",
      "25 cm³"
    ],
    "correctIndex": 0,
    "explanation": "O volume de um cubo é V = a³, onde a é a aresta. V = 5³ = 5 × 5 × 5 = 125 cm³. Todas as arestas do cubo têm o mesmo comprimento.",
    "example": "Aresta = 5 cm. Volume = 5 × 5 × 5 = 125 cm³. É como empilhar 5 camadas de 5×5 = 25 cubinhos de 1 cm³ cada."
  },
  {
    "id": "matematica__Geometria Espacial__Fácil__2",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Fácil",
    "question": "Qual é a área total da superfície de um cubo com aresta de 4 cm?",
    "options": [
      "96 cm²",
      "64 cm²",
      "48 cm²",
      "16 cm²"
    ],
    "correctIndex": 0,
    "explanation": "O cubo tem 6 faces quadradas iguais. Área de cada face = 4² = 16 cm². Área total = 6 × 16 = 96 cm².",
    "example": "6 faces × (4 × 4) = 6 × 16 = 96 cm²."
  },
  {
    "id": "matematica__Geometria Espacial__Fácil__3",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Fácil",
    "question": "Qual é o volume de uma pirâmide de base quadrada com lado 6 cm e altura 10 cm?",
    "options": [
      "120 cm³",
      "360 cm³",
      "180 cm³",
      "60 cm³"
    ],
    "correctIndex": 0,
    "explanation": "Volume da pirâmide = (1/3) × Área_base × h = (1/3) × 6² × 10 = (1/3) × 36 × 10 = 360/3 = 120 cm³. A pirâmide tem 1/3 do volume do prisma correspondente.",
    "example": "Base = 6² = 36 cm². V = 36 × 10 / 3 = 120 cm³."
  },
  {
    "id": "matematica__Geometria Espacial__Fácil__4",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Fácil",
    "question": "Qual é o volume de um paralelepípedo com dimensões 3 cm, 4 cm e 5 cm?",
    "options": [
      "60 cm³",
      "12 cm³",
      "30 cm³",
      "48 cm³"
    ],
    "correctIndex": 0,
    "explanation": "Volume do paralelepípedo retangular = comprimento × largura × altura = 3 × 4 × 5 = 60 cm³.",
    "example": "V = 3 × 4 × 5 = 60 cm³. Área total = 2(3×4 + 3×5 + 4×5) = 2(12+15+20) = 94 cm²."
  },
  {
    "id": "matematica__Geometria Espacial__Fácil__5",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Fácil",
    "question": "Quantas faces, arestas e vértices tem um prisma triangular?",
    "options": [
      "5 faces, 9 arestas, 6 vértices",
      "4 faces, 6 arestas, 4 vértices",
      "6 faces, 12 arestas, 8 vértices",
      "5 faces, 8 arestas, 5 vértices"
    ],
    "correctIndex": 0,
    "explanation": "Prisma triangular: 2 bases triangulares + 3 faces laterais retangulares = 5 faces. Arestas: 3×3 = 9. Vértices: 3×2 = 6. Confere com Euler: V-A+F = 6-9+5 = 2 ✓.",
    "example": "5 faces (2 triângulos + 3 retângulos), 9 arestas (3+3+3), 6 vértices (3+3). Euler: 6-9+5 = 2 ✓."
  },
  {
    "id": "matematica__Geometria Espacial__Fácil__6",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Fácil",
    "question": "Qual o volume de uma esfera com raio 3 cm?",
    "options": [
      "36π cm³",
      "27π cm³",
      "108π cm³",
      "12π cm³"
    ],
    "correctIndex": 0,
    "explanation": "Volume da esfera: V = (4/3)πr³ = (4/3)π(27) = 108π/3 = 36π ≈ 113,10 cm³. Área da superfície seria 4π(9) = 36π.",
    "example": "V = (4/3) × π × 3³ = (4/3) × 27π = 36π cm³. Curiosamente, V e Área são ambos 36π para r=3."
  },
  {
    "id": "matematica__Geometria Espacial__Fácil__7",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Fácil",
    "question": "Quantas faces, vértices e arestas tem um cubo?",
    "options": [
      "6 faces, 8 vértices, 12 arestas",
      "4 faces, 4 vértices, 6 arestas",
      "8 faces, 6 vértices, 12 arestas",
      "6 faces, 12 vértices, 8 arestas"
    ],
    "correctIndex": 0,
    "explanation": "O cubo (hexaedro) tem 6 faces quadradas, 8 vértices e 12 arestas. Confere com a fórmula de Euler: V - A + F = 8 - 12 + 6 = 2 ✓.",
    "example": "6 faces (frente, trás, cima, baixo, esquerda, direita). 8 vértices (4 em cima, 4 em baixo). 12 arestas (4 em cima, 4 em baixo, 4 verticais). Euler: 8 - 12 + 6 = 2."
  },
  {
    "id": "matematica__Geometria Espacial__Fácil__8",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Fácil",
    "question": "Qual o volume de um cubo de aresta 4 cm?",
    "options": [
      "64 cm³",
      "48 cm³",
      "96 cm³",
      "16 cm³"
    ],
    "correctIndex": 0,
    "explanation": "V = a³ = 4³ = 64 cm³.",
    "example": "Cubo: todas as arestas iguais. V=a³. Área total = 6a² = 6×16 = 96 cm². Diagonal do cubo: d=a√3=4√3. Diagonal da face: d_f=a√2=4√2."
  },
  {
    "id": "matematica__Geometria Espacial__Médio__1",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Médio",
    "question": "Qual é o volume de um cilindro com raio da base 3 cm e altura 10 cm?",
    "options": [
      "90π cm³",
      "30π cm³",
      "60π cm³",
      "120π cm³"
    ],
    "correctIndex": 0,
    "explanation": "O volume do cilindro é V = π × r² × h. V = π × 3² × 10 = π × 9 × 10 = 90π cm³ ≈ 282,74 cm³. É a área da base circular multiplicada pela altura.",
    "example": "Área da base = π × 3² = 9π cm². Volume = 9π × 10 = 90π ≈ 282,74 cm³."
  },
  {
    "id": "matematica__Geometria Espacial__Médio__2",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Médio",
    "question": "Qual é a área lateral de um cone com raio 3 cm e geratçiz 5 cm?",
    "options": [
      "15π cm²",
      "9π cm²",
      "45π cm²",
      "30π cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área lateral do cone = π × r × g = π × 3 × 5 = 15π ≈ 47,12 cm². A geratriz é a medida da 'linha inclinada' do vértice até a base.",
    "example": "A_lat = π × 3 × 5 = 15π cm². A geratriz se relaciona com r e h: g² = r² + h²."
  },
  {
    "id": "matematica__Geometria Espacial__Médio__3",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Médio",
    "question": "Qual é o volume de um cone com raio 6 cm e altura 8 cm?",
    "options": [
      "96π cm³",
      "288π cm³",
      "48π cm³",
      "144π cm³"
    ],
    "correctIndex": 0,
    "explanation": "Volume do cone = (1/3) × πr² × h = (1/3) × π × 36 × 8 = (1/3) × 288π = 96π ≈ 301,59 cm³. O cone tem 1/3 do volume do cilindro correspondente.",
    "example": "V = (1/3) × π × 6² × 8 = (1/3) × 288π = 96π cm³."
  },
  {
    "id": "matematica__Geometria Espacial__Médio__4",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Médio",
    "question": "Qual é o volume de uma esfera com raio 6 cm?",
    "options": [
      "288π cm³",
      "216π cm³",
      "144π cm³",
      "864 cm³"
    ],
    "correctIndex": 0,
    "explanation": "Volume da esfera: V = (4/3)πr³ = (4/3)π(6)³ = (4/3)π(216) = 864π/3 = 288π ≈ 904,78 cm³.",
    "example": "V = (4/3) × π × 216 = 288π cm³. Comparação: área = 4π(36) = 144π cm²."
  },
  {
    "id": "matematica__Geometria Espacial__Médio__5",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Médio",
    "question": "Um cone tem raio da base 3 cm e geratriz 5 cm. Qual é sua altura?",
    "options": [
      "4 cm",
      "8 cm",
      "2 cm",
      "√34 cm"
    ],
    "correctIndex": 0,
    "explanation": "Relação entre geratriz, raio e altura: g² = r² + h² → 25 = 9 + h² → h² = 16 → h = 4 cm. É o mesmo Teorema de Pitágoras.",
    "example": "g² = r² + h². 5² = 3² + h². h² = 25 - 9 = 16. h = 4 cm. Terna pitagórica: (3, 4, 5)."
  },
  {
    "id": "matematica__Geometria Espacial__Médio__6",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Médio",
    "question": "Qual a área total de um cilindro com raio 4 cm e altura 6 cm?",
    "options": [
      "80π cm²",
      "48π cm²",
      "64π cm²",
      "96π cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área total = 2πrh (lateral) + 2πr² (duas bases) = 2π(4)(6) + 2π(16) = 48π + 32π = 80π ≈ 251,33 cm².",
    "example": "Lateral: 2π × 4 × 6 = 48π. Duas bases: 2 × π × 16 = 32π. Total: 48π + 32π = 80π cm²."
  },
  {
    "id": "matematica__Geometria Espacial__Médio__7",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Médio",
    "question": "Qual a diagonal de um paralelepípedo retângulo com dimensões 3, 4 e 12 cm?",
    "options": [
      "13 cm",
      "19 cm",
      "√169 cm",
      "Ambas A e C estão corretas"
    ],
    "correctIndex": 3,
    "explanation": "Diagonal do paralelepípedo: d = √(a²+b²+c²) = √(9+16+144) = √169 = 13 cm. Tanto 13 cm quanto √169 cm estão corretos.",
    "example": "d² = 3² + 4² + 12² = 9 + 16 + 144 = 169. d = 13 cm."
  },
  {
    "id": "matematica__Geometria Espacial__Médio__8",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Médio",
    "question": "Uma esfera tem raio 3 cm. Qual seu volume (use π = 3)?",
    "options": [
      "108 cm³",
      "36 cm³",
      "72 cm³",
      "324 cm³"
    ],
    "correctIndex": 0,
    "explanation": "V = (4/3)πr³ = (4/3)×3×27 = 4×27 = 108 cm³.",
    "example": "V=(4/3)πr³=(4/3)×3×3³=(4/3)×3×27. (4/3)×3=4. 4×27=108. Área da superfície: A=4πr²=4×3×9=108 cm² (coincidência neste caso). Com π=3,14159: V≈113,1 cm³."
  },
  {
    "id": "matematica__Geometria Espacial__Difícil__1",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Difícil",
    "question": "Uma esfera está inscrita em um cubo de aresta 10 cm. Qual é o volume da esfera?",
    "options": [
      "(500/3)π cm³",
      "1000π cm³",
      "(4000/3)π cm³",
      "250π cm³"
    ],
    "correctIndex": 0,
    "explanation": "Se a esfera está inscrita no cubo, ela toca todas as faces do cubo. O diâmetro da esfera = aresta do cubo = 10 cm, então r = 5 cm. V = (4/3)πr³ = (4/3)π(125) = 500π/3 cm³.",
    "example": "Raio = 10/2 = 5 cm. V = (4/3) × π × 5³ = (4/3) × 125π = 500π/3 ≈ 523,6 cm³. Volume do cubo = 1000 cm³. A esfera ocupa ~52,36% do cubo."
  },
  {
    "id": "matematica__Geometria Espacial__Difícil__2",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Difícil",
    "question": "Um prisma hexagonal regular tem aresta da base 4 cm e altura 12 cm. Qual seu volume?",
    "options": [
      "288√3 cm³",
      "192√3 cm³",
      "576 cm³",
      "144√3 cm³"
    ],
    "correctIndex": 0,
    "explanation": "Volume = Área_base × h. Área do hexágono regular = (3√3/2) × L² = (3√3/2) × 16 = 24√3. V = 24√3 × 12 = 288√3 cm³.",
    "example": "Base hexagonal: A = (3√3/2) × 4² = 24√3 cm². V = 24√3 × 12 = 288√3 ≈ 498,83 cm³."
  },
  {
    "id": "matematica__Geometria Espacial__Difícil__3",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Difícil",
    "question": "Qual a razão entre o volume de uma esfera e o volume do cilindro que a circunscreve?",
    "options": [
      "2/3",
      "1/2",
      "3/4",
      "π/4"
    ],
    "correctIndex": 0,
    "explanation": "Cilindro circunscrito: raio = r, altura = 2r. V_cil = πr² × 2r = 2πr³. V_esfera = (4/3)πr³. Razão = (4/3)πr³ / (2πr³) = (4/3)/2 = 2/3. Resultado descoberto por Arquimedes.",
    "example": "V_esf / V_cil = (4πr³/3) / (2πr³) = 4/(3×2) = 2/3. A esfera ocupa 2/3 do cilindro que a contém."
  },
  {
    "id": "matematica__Geometria Espacial__Difícil__4",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Difícil",
    "question": "Um tronco de cone tem raios 3 cm e 6 cm, e altura 4 cm. Qual seu volume?",
    "options": [
      "84π cm³",
      "108π cm³",
      "63π cm³",
      "252 cm³"
    ],
    "correctIndex": 0,
    "explanation": "Volume do tronco de cone: V = (πh/3)(R² + Rr + r²) = (4π/3)(36 + 18 + 9) = (4π/3)(63) = 252π/3 = 84π ≈ 263,89 cm³.",
    "example": "R=6, r=3, h=4. R²+Rr+r² = 36+18+9 = 63. V = (4π/3)×63 = 84π cm³."
  },
  {
    "id": "matematica__Geometria Espacial__Difícil__5",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Difícil",
    "question": "Duas esferas têm raios na razão 1:3. Qual a razão entre seus volumes?",
    "options": [
      "1/27",
      "1/9",
      "1/3",
      "1/6"
    ],
    "correctIndex": 0,
    "explanation": "A razão entre volumes de sólidos semelhantes é o cubo da razão linear: (1/3)³ = 1/27. Se os raios dobram, o volume multiplica por 8.",
    "example": "V₁/V₂ = (r₁/r₂)³ = (1/3)³ = 1/27. A esfera maior tem 27× o volume da menor."
  },
  {
    "id": "matematica__Geometria Espacial__Difícil__6",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Difícil",
    "question": "A diagonal de um cubo mede 10√3 cm. Qual é a aresta do cubo?",
    "options": [
      "10 cm",
      "5√3 cm",
      "10√2 cm",
      "30 cm"
    ],
    "correctIndex": 0,
    "explanation": "Diagonal do cubo: d = a√3. Então a = d/√3 = 10√3/√3 = 10 cm. Verificação: 10√3 = 10 × 1,732 ≈ 17,32 cm.",
    "example": "d = a√3 → a = 10√3/√3 = 10 cm. Volume = 10³ = 1000 cm³. Área total = 6 × 100 = 600 cm²."
  },
  {
    "id": "matematica__Geometria Espacial__Difícil__7",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Difícil",
    "question": "Um prisma reto tem base hexagonal regular com aresta 5 cm e altura 10 cm. Qual sua área lateral?",
    "options": [
      "300 cm²",
      "150√3 cm²",
      "250 cm²",
      "200 cm²"
    ],
    "correctIndex": 0,
    "explanation": "Área lateral do prisma = perímetro da base × altura. Perímetro do hexágono = 6 × 5 = 30 cm. A_lat = 30 × 10 = 300 cm².",
    "example": "6 faces laterais retangulares de 5 × 10 = 50 cm² cada. Total = 6 × 50 = 300 cm²."
  },
  {
    "id": "matematica__Geometria Espacial__Difícil__8",
    "track": "matematica",
    "category": "Geometria Espacial",
    "difficulty": "Difícil",
    "question": "Um cilindro tem raio 5 cm e altura 10 cm. Qual a área total de sua superfície (use π = 3,14)?",
    "options": [
      "471 cm²",
      "314 cm²",
      "628 cm²",
      "942 cm²"
    ],
    "correctIndex": 0,
    "explanation": "A_lat = 2πrh = 2×3,14×5×10 = 314. A_bases = 2πr² = 2×3,14×25 = 157. Total = 314 + 157 = 471 cm².",
    "example": "A_lateral = 2πrh = 2×3,14×5×10 = 314 cm². A_base = πr² = 3,14×25 = 78,5 cm². 2 bases = 157 cm². Total = 314+157 = 471 cm²."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Fácil__1",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Fácil",
    "question": "Qual é o montante de uma aplicação de R$ 1.000 a juros simples de 2% ao mês durante 5 meses?",
    "options": [
      "R$ 1.100",
      "R$ 1.200",
      "R$ 1.050",
      "R$ 1.104,08"
    ],
    "correctIndex": 0,
    "explanation": "Juros simples: J = C × i × t = 1000 × 0,02 × 5 = R$ 100. Montante M = C + J = 1000 + 100 = R$ 1.100. Nos juros simples, os juros são sempre calculados sobre o capital inicial.",
    "example": "Mês 1: J = 1000 × 0,02 = R$ 20. Mês 2: R$ 20. Mês 3: R$ 20. Mês 4: R$ 20. Mês 5: R$ 20. Total de juros: 5 × 20 = R$ 100. M = R$ 1.100."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Fácil__2",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Fácil",
    "question": "Qual é o juro de uma aplicação de R$ 5.000 a juros simples de 1,5% ao mês por 8 meses?",
    "options": [
      "R$ 600",
      "R$ 500",
      "R$ 800",
      "R$ 450"
    ],
    "correctIndex": 0,
    "explanation": "J = C × i × t = 5000 × 0,015 × 8 = R$ 600. Montante: M = 5000 + 600 = R$ 5.600.",
    "example": "J = 5000 × 0,015 = 75 por mês. Total em 8 meses: 75 × 8 = R$ 600."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Fácil__3",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Fácil",
    "question": "Qual a diferença fundamental entre juros simples e compostos?",
    "options": [
      "Simples: juros sobre o capital inicial. Compostos: juros sobre o montante acumulado (juros sobre juros)",
      "São idênticos",
      "Simples rende mais",
      "Compostos só funcionam para prazos longos"
    ],
    "correctIndex": 0,
    "explanation": "Juros simples: J = C × i × t (linear, juros sempre sobre C). Juros compostos: M = C(1+i)ⁿ (exponencial, juros sobre montante acumulado). Compostos rendem mais a partir do 2º período.",
    "example": "R$ 1000 a 10%/mês. Simples: Mês 1: 100, Mês 2: 100, Total: 200. Compostos: Mês 1: 100, Mês 2: 110 (10% de 1100), Total: 210."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Fácil__4",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Fácil",
    "question": "Qual o juro simples de R$ 5.000 a 1,5% ao mês durante 8 meses?",
    "options": [
      "R$ 600",
      "R$ 750",
      "R$ 400",
      "R$ 500"
    ],
    "correctIndex": 0,
    "explanation": "J = C × i × t = 5000 × 0,015 × 8 = R$ 600. Montante: M = 5000 + 600 = R$ 5.600.",
    "example": "J = 5000 × 0,015 = 75 por mês. Total em 8 meses: 75 × 8 = R$ 600. M = 5000 + 600 = R$ 5.600."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Fácil__5",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Fácil",
    "question": "Se um capital de R$ 800 rendeu R$ 192 em juros simples de 2% ao mês, por quantos meses ficou aplicado?",
    "options": [
      "12 meses",
      "8 meses",
      "10 meses",
      "24 meses"
    ],
    "correctIndex": 0,
    "explanation": "J = C × i × t → 192 = 800 × 0,02 × t → 192 = 16t → t = 192/16 = 12 meses.",
    "example": "Juros mensais: 800 × 0,02 = R$ 16. Meses: 192 / 16 = 12 meses. Verifica: 16 × 12 = 192 ✓."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Fácil__6",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Fácil",
    "question": "Qual o montante de R$ 2.000 aplicados a juros simples de 3% ao mês durante 10 meses?",
    "options": [
      "R$ 2.600",
      "R$ 2.300",
      "R$ 2.060",
      "R$ 2.500"
    ],
    "correctIndex": 0,
    "explanation": "J = C × i × t = 2000 × 0,03 × 10 = R$ 600. Montante: M = C + J = 2000 + 600 = R$ 2.600.",
    "example": "Juros mensais: 2000 × 0,03 = R$ 60. Em 10 meses: 60 × 10 = R$ 600. M = 2000 + 600 = R$ 2.600."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Fácil__7",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Fácil",
    "question": "R$ 4.000 a juros simples de 1% ao mês renderam R$ 480. Qual a taxa anual equivalente simples?",
    "options": [
      "12% ao ano",
      "1% ao ano",
      "14,4% ao ano",
      "10% ao ano"
    ],
    "correctIndex": 0,
    "explanation": "Em juros simples, a taxa anual é simplesmente 12× a taxa mensal: 1% × 12 = 12% ao ano. Verifica: J = 4000 × 0,12 × 1 = R$ 480 ✓ (1 ano = 12 meses).",
    "example": "Juros simples: taxa proporcional. 1%/mês = 12%/ano. J = 4000 × 0,01 × 12 = 480 ✓. Em compostos seria (1,01)¹²-1 ≈ 12,68%."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Fácil__8",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Fácil",
    "question": "Um capital de R$ 2.000 é aplicado a juros simples de 3% ao mês por 4 meses. Qual o montante final?",
    "options": [
      "R$ 2.240",
      "R$ 2.060",
      "R$ 2.400",
      "R$ 2.120"
    ],
    "correctIndex": 0,
    "explanation": "Juros = P×i×n = 2000×0,03×4 = 240. Montante = 2000 + 240 = R$ 2.240.",
    "example": "J = 2000×3%×4 = 2000×0,12 = 240. M = 2000+240 = 2240. Taxa mensal 3%, período 4 meses: simples não capitaliza juros. Composto: M = 2000×(1,03)^4 = 2000×1,1255 ≈ 2251."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Médio__1",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Médio",
    "question": "Qual é o montante de R$ 2.000 aplicados a juros compostos de 3% ao mês durante 4 meses?",
    "options": [
      "R$ 2.251,02",
      "R$ 2.240,00",
      "R$ 2.260,00",
      "R$ 2.120,00"
    ],
    "correctIndex": 0,
    "explanation": "Juros compostos: M = C × (1 + i)ⁿ = 2000 × (1,03)⁴ = 2000 × 1,12550881 ≈ R$ 2.251,02. Nos juros compostos, os juros de cada período incidem sobre o montante acumulado (juros sobre juros).",
    "example": "Mês 1: 2000 × 1,03 = 2060. Mês 2: 2060 × 1,03 = 2121,80. Mês 3: 2121,80 × 1,03 = 2185,45. Mês 4: 2185,45 × 1,03 ≈ 2251,02."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Médio__2",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Médio",
    "question": "Quanto rende a mais R$ 10.000 aplicados a juros compostos de 2% ao mês por 6 meses, comparado a juros simples na mesma taxa?",
    "options": [
      "R$ 61,62",
      "R$ 100",
      "R$ 0",
      "R$ 200"
    ],
    "correctIndex": 0,
    "explanation": "Simples: J = 10000 × 0,02 × 6 = R$ 1.200 → M = R$ 11.200. Compostos: M = 10000 × (1,02)⁶ = 10000 × 1,126162 = R$ 11.261,62. Diferença: 11.261,62 - 11.200 = R$ 61,62.",
    "example": "Simples: R$ 11.200. Compostos: R$ 11.261,62. Diferença: R$ 61,62 a mais nos compostos (juros sobre juros)."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Médio__3",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Médio",
    "question": "Um investimento rende 0,8% ao mês. Qual a taxa equivalente anual?",
    "options": [
      "(1,008)¹² - 1 ≈ 10,03%",
      "0,8% × 12 = 9,6%",
      "12%",
      "8%"
    ],
    "correctIndex": 0,
    "explanation": "Taxa equivalente em juros compostos: (1+i_anual) = (1+i_mensal)¹². Logo i_anual = (1,008)¹² - 1 ≈ 1,1003 - 1 = 0,1003 = 10,03%. Não é 9,6% (isso seria juros simples).",
    "example": "(1,008)¹² = 1,1003. Taxa anual = 10,03%. Simples daria 9,6% (0,8×12). Compostos rendem 10,03% — 0,43% a mais por causa do efeito composto."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Médio__4",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Médio",
    "question": "Qual a taxa mensal de juros compostos de uma aplicação que transformou R$ 1.000 em R$ 1.331 após 3 meses?",
    "options": [
      "10%",
      "11%",
      "33,1%",
      "15%"
    ],
    "correctIndex": 0,
    "explanation": "M = C(1+i)ⁿ → 1331 = 1000(1+i)³ → (1+i)³ = 1,331 → 1+i = ³√1,331 = 1,1 → i = 0,10 = 10% a.m.",
    "example": "(1+i)³ = 1,331. ³√1,331 = 1,1. i = 0,1 = 10%. Verifica: 1000 × 1,1³ = 1000 × 1,331 = 1331 ✓."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Médio__5",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Médio",
    "question": "R$ 3.000 aplicados a juros compostos de 5% ao mês por 2 meses rendem quanto de juros?",
    "options": [
      "R$ 307,50",
      "R$ 300",
      "R$ 315",
      "R$ 150"
    ],
    "correctIndex": 0,
    "explanation": "M = 3000 × (1,05)² = 3000 × 1,1025 = R$ 3.307,50. Juros = M - C = 3307,50 - 3000 = R$ 307,50. Simples daria 300.",
    "example": "Mês 1: 3000 × 1,05 = 3150. Mês 2: 3150 × 1,05 = 3307,50. Juros = 307,50. Simples: 3000 × 0,05 × 2 = 300."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Médio__6",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Médio",
    "question": "Qual a taxa efetiva de um investimento que rende 6% ao semestre, capitalização composta?",
    "options": [
      "12,36% ao ano",
      "12% ao ano",
      "6% ao ano",
      "36% ao ano"
    ],
    "correctIndex": 0,
    "explanation": "Taxa efetiva anual = (1 + i_semestral)² - 1 = (1,06)² - 1 = 1,1236 - 1 = 0,1236 = 12,36%. Não é simplesmente 6% × 2 = 12% (isso seria taxa nominal/proporcional).",
    "example": "(1,06)² = 1,1236. Taxa efetiva = 12,36%. Os 0,36% extras são o efeito dos juros compostos (juros sobre juros do 1º semestre)."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Médio__7",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Médio",
    "question": "Um carro perde 15% de valor a cada ano. Se custou R$ 60.000 novo, quanto vale após 3 anos?",
    "options": [
      "R$ 36.823,50",
      "R$ 33.000",
      "R$ 42.000",
      "R$ 38.250"
    ],
    "correctIndex": 0,
    "explanation": "Depreciação composta: V = 60000 × (1 - 0,15)³ = 60000 × (0,85)³ = 60000 × 0,614125 = R$ 36.847,50. (Arredondamento pode variar.)",
    "example": "Ano 1: 60000 × 0,85 = 51000. Ano 2: 51000 × 0,85 = 43350. Ano 3: 43350 × 0,85 = 36847,50. Perdeu 38,6% do valor (não 45%)."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Médio__8",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Médio",
    "question": "Qual o capital inicial que, aplicado a 2% ao mês por 6 meses a juros compostos, resulta em R$ 2.252,32?",
    "options": [
      "R$ 2.000",
      "R$ 2.100",
      "R$ 1.900",
      "R$ 2.250"
    ],
    "correctIndex": 0,
    "explanation": "M = C×(1+i)^n ⇒ C = M/(1+i)^n = 2252,32/(1,02)^6. (1,02)^6 ≈ 1,1262. C = 2252,32/1,1262 ≈ 2000.",
    "example": "(1,02)^6 = 1,126162. C = 2252,32/1,126162 ≈ 2000,00. Verificação: 2000×1,126162 = 2252,32 ✓. Capitalização composta: juros sobre juros — difere de simples que seria 2000×1,12=2240."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Difícil__1",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Difícil",
    "question": "Em quanto tempo um capital dobra a juros compostos de 5% ao mês? Use log(1,05) ≈ 0,0212 e log(2) ≈ 0,3010.",
    "options": [
      "Aproximadamente 14,2 meses",
      "20 meses",
      "10 meses",
      "15,5 meses"
    ],
    "correctIndex": 0,
    "explanation": "M = C(1,05)ⁿ. Para dobrar: 2C = C(1,05)ⁿ → 2 = (1,05)ⁿ → log(2) = n × log(1,05) → n = log(2)/log(1,05) = 0,3010/0,0212 ≈ 14,2 meses.",
    "example": "n = log(2) / log(1,05) = 0,3010 / 0,0212 ≈ 14,2. Verificação: (1,05)¹⁴ ≈ 1,9799 e (1,05)¹⁵ ≈ 2,0789. Confirma: entre 14 e 15 meses."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Difícil__2",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Difícil",
    "question": "Qual o montante de R$ 8.000 aplicados a juros compostos de 4% ao mês por 3 meses, com aportes mensais de R$ 2.000?",
    "options": [
      "R$ 15.118,85",
      "R$ 14.000",
      "R$ 15.000",
      "R$ 16.000"
    ],
    "correctIndex": 0,
    "explanation": "Mês 1: 8000 × 1,04 + 2000 = 8320 + 2000 = 10.320. Mês 2: 10320 × 1,04 + 2000 = 10.732,80 + 2000 = 12.732,80. Mês 3: 12732,80 × 1,04 + 2000 = 13.242,11 + 2000 = 15.242,11. (Ou usar fórmula de anuidade).",
    "example": "Início: 8000. M1: 8000×1,04+2000 = 10320. M2: 10320×1,04+2000 = 12732,80. M3: 12732,80×1,04+2000 ≈ 15242,11."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Difícil__3",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Difícil",
    "question": "Um empréstimo de R$ 20.000 será pago em uma única parcela após 2 anos, com juros compostos de 1% ao mês. Qual o valor a pagar?",
    "options": [
      "R$ 25.394,69",
      "R$ 24.800",
      "R$ 26.000",
      "R$ 24.000"
    ],
    "correctIndex": 0,
    "explanation": "M = 20000 × (1,01)²⁴ = 20000 × 1,269735 ≈ R$ 25.394,69. São 24 meses (2 anos × 12 meses) a 1% ao mês.",
    "example": "(1,01)²⁴ ≈ 1,2697. M = 20000 × 1,2697 = R$ 25.394,69. Juros totais: R$ 5.394,69 (26,97% do capital)."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Difícil__4",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Difícil",
    "question": "Um preço aumenta 20% ao ano por 3 anos consecutivos. Qual o aumento total percentual?",
    "options": [
      "72,8%",
      "60%",
      "80%",
      "66%"
    ],
    "correctIndex": 0,
    "explanation": "Fator acumulado: (1,20)³ = 1,728. Aumento total: 72,8%. Não é 60% (3×20%) porque cada aumento incide sobre o valor já aumentado.",
    "example": "Ano 1: ×1,20. Ano 2: ×1,20. Ano 3: ×1,20. Total: 1,20³ = 1,728 → 72,8% de aumento. R$ 100 vira R$ 172,80."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Difícil__5",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Difícil",
    "question": "Quanto se deve aplicar hoje a juros compostos de 2% ao mês para ter R$ 10.000 daqui a 6 meses?",
    "options": [
      "R$ 8.879,71",
      "R$ 8.800",
      "R$ 9.000",
      "R$ 8.500"
    ],
    "correctIndex": 0,
    "explanation": "Valor presente: C = M / (1+i)ⁿ = 10000 / (1,02)⁶ = 10000 / 1,126162 ≈ R$ 8.879,71. Esse é o conceito de desconto composto.",
    "example": "(1,02)⁶ = 1,1262. C = 10000/1,1262 ≈ R$ 8.879,71. Verifica: 8879,71 × 1,1262 ≈ 10000 ✓."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Difícil__6",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Difícil",
    "question": "Um investimento rende 0,5% ao mês a juros compostos. Após quantos meses o investimento rende 10%? Use log(1,005) ≈ 0,00217.",
    "options": [
      "≈ 44 meses",
      "20 meses",
      "100 meses",
      "60 meses"
    ],
    "correctIndex": 0,
    "explanation": "M = C(1,005)ⁿ. Para 10%: 1,10 = (1,005)ⁿ → log(1,10) = n × log(1,005). n = log(1,10)/log(1,005) = 0,04139/0,00217 ≈ 19,07... Ops, isso dá ~19. Mas 0,0953 = log(1,10)... Recalculando: log(1,10) ≈ 0,04139. n = 0,04139/0,00217 ≈ 19,07 meses.",
    "example": "Corrigindo valor: ln(1,10)/ln(1,005) = 0,09531/0,004988 ≈ 19,1 meses. Usando log₁₀: 0,04139/0,002166 ≈ 19,1 meses. Em ~19 meses o investimento rende 10%."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Difícil__7",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Difícil",
    "question": "Compare: R$ 10.000 a 12% ao ano simples vs 1% ao mês composto, após 2 anos. Qual rende mais e por quê?",
    "options": [
      "Compostos rendem mais (R$ 12.697,35 vs R$ 12.400) devido aos juros sobre juros",
      "Simples rende mais",
      "Rendem igualmente",
      "Depende do banco"
    ],
    "correctIndex": 0,
    "explanation": "Simples: M = 10000(1 + 0,12 × 2) = 10000 × 1,24 = R$ 12.400. Compostos: M = 10000 × (1,01)²⁴ = 10000 × 1,2697 = R$ 12.697,35. Diferença: R$ 297,35 a favor dos compostos.",
    "example": "Simples: R$ 12.400. Compostos: R$ 12.697,35. Quanto maior o prazo, maior a diferença. Em 5 anos: Simples R$ 16.000 vs Compostos R$ 18.166,97."
  },
  {
    "id": "matematica__Juros Simples e Compostos__Difícil__8",
    "track": "matematica",
    "category": "Juros Simples e Compostos",
    "difficulty": "Difícil",
    "question": "Em quanto tempo um capital dobra aplicado a juros compostos de 10% ao ano (use regra do 72)?",
    "options": [
      "Aproximadamente 7,2 anos",
      "Exatamente 10 anos",
      "Aproximadamente 10 anos",
      "5 anos"
    ],
    "correctIndex": 0,
    "explanation": "Regra do 72: t ≈ 72/taxa = 72/10 = 7,2 anos. Valor exato: 2 = (1,10)^t ⇒ t = ln(2)/ln(1,10) = 0,693/0,0953 ≈ 7,27 anos.",
    "example": "Regra do 72: hâ (um heurística): t = 72/r%. Para 10%: 7,2 anos. Para 6%: 12 anos. Para 12%: 6 anos. Exato: ln(2)/ln(1+i). Diferença: regra 72 dá 7,2; valor exato 7,27 — erro de 1%. Útil para cálculos rápidos de finanças pessoais."
  },
  {
    "id": "matematica__Lógica Matemática__Fácil__1",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Fácil",
    "question": "Na lógica proposicional, qual é o valor-verdade de 'P → Q' (P implica Q) quando P é falso e Q é verdadeiro?",
    "options": [
      "Verdadeiro",
      "Falso",
      "Indeterminado",
      "Depende do contexto"
    ],
    "correctIndex": 0,
    "explanation": "A implicação P → Q só é falsa quando P é verdadeiro e Q é falso. Em todos os outros casos (F→V, F→F, V→V), a implicação é verdadeira. Lembre: 'de uma premissa falsa, tudo se segue' (ex falso quodlibet).",
    "example": "Tabela-verdade de P → Q: V→V = V, V→F = F, F→V = V, F→F = V. O único caso falso é V→F: 'Se chove, levo guarda-chuva'. Se chove e não levo → promessa quebrada (falso)."
  },
  {
    "id": "matematica__Lógica Matemática__Fácil__2",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Fácil",
    "question": "Qual é o valor-verdade de P ∧ Q (P E Q) quando P é verdadeiro e Q é falso?",
    "options": [
      "Falso",
      "Verdadeiro",
      "Indeterminado",
      "Depende de P"
    ],
    "correctIndex": 0,
    "explanation": "A conjunção (P ∧ Q) só é verdadeira quando AMBAS as proposições são verdadeiras. V ∧ F = F. Tabela completa: V∧V=V, V∧F=F, F∧V=F, F∧F=F.",
    "example": "'Eu estudo E passo no exame'. Se estudo (V) mas não passo (F): V ∧ F = F. A frase toda é falsa pois ambas as partes precisam ser verdadeiras."
  },
  {
    "id": "matematica__Lógica Matemática__Fácil__3",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Fácil",
    "question": "O que é uma tautologia em lógica proposicional?",
    "options": [
      "Fórmula que é sempre verdadeira independente dos valores de suas variáveis",
      "Fórmula sempre falsa",
      "Fórmula que depende do contexto",
      "Sinônimo de contradição"
    ],
    "correctIndex": 0,
    "explanation": "Tautologia é uma proposição composta que é verdadeira para TODAS as combinações de valores-verdade de suas variáveis. Exemplo: P ∨ ¬P (terceiro excluído). Contradição: sempre falsa (P ∧ ¬P). Contingência: depende dos valores.",
    "example": "P ∨ ¬P: se P=V → V∨F=V. Se P=F → F∨V=V. Sempre verdadeira = tautologia. P ∧ ¬P: V∧F=F, F∧V=F. Sempre falsa = contradição."
  },
  {
    "id": "matematica__Lógica Matemática__Fácil__4",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Fácil",
    "question": "Qual é o valor-verdade de 'P ∨ Q' (P ou Q) quando P é falso e Q é verdadeiro?",
    "options": [
      "Verdadeiro",
      "Falso",
      "Indeterminado",
      "Depende do contexto"
    ],
    "correctIndex": 0,
    "explanation": "A disjunção (P ∨ Q) é verdadeira quando pelo menos um dos operandos é verdadeiro. F ∨ V = V. Só é falsa quando ambos são falsos.",
    "example": "P=F, Q=V: F ∨ V = V. Tabela completa: V∨V=V, V∨F=V, F∨V=V, F∨F=F. Apenas F∨F é falso."
  },
  {
    "id": "matematica__Lógica Matemática__Fácil__5",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Fácil",
    "question": "Na lógica, qual conectivo corresponde a 'se e somente se'?",
    "options": [
      "Bicondicional (↔)",
      "Condicional (→)",
      "Conjunção (∧)",
      "Disjunção (∨)"
    ],
    "correctIndex": 0,
    "explanation": "O bicondicional (P ↔ Q) é verdadeiro quando P e Q têm o MESMO valor-verdade. P ↔ Q ≡ (P → Q) ∧ (Q → P). É a 'igualdade lógica'.",
    "example": "P↔Q: V↔V=V, V↔F=F, F↔V=F, F↔F=V. Mesmo valor = verdadeiro, valores diferentes = falso."
  },
  {
    "id": "matematica__Lógica Matemática__Fácil__6",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Fácil",
    "question": "Qual o valor-verdade de '¬P' (negação de P) quando P é verdadeiro?",
    "options": [
      "Falso",
      "Verdadeiro",
      "Indeterminado",
      "Depende de P"
    ],
    "correctIndex": 0,
    "explanation": "A negação inverte o valor-verdade: ¬V = F e ¬F = V. Se P = 'Chove' (V), então ¬P = 'Não chove' (F).",
    "example": "¬V = F. ¬F = V. A negação é o conectivo mais simples: é unário (opera sobre uma única proposição)."
  },
  {
    "id": "matematica__Lógica Matemática__Fácil__7",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Fácil",
    "question": "A proposição 'P → Q' é verdadeira quando P=V e Q=V?",
    "options": [
      "Sim, verdadeira",
      "Não, falsa",
      "Indeterminado",
      "Depende do contexto"
    ],
    "correctIndex": 0,
    "explanation": "P → Q só é FALSA quando P=V e Q=F. Quando ambos são verdadeiros (V→V), a implicação é verdadeira. 'Se estudo (V), passo (V)' → promessa cumprida.",
    "example": "Tabela de P→Q: V→V=V ✓, V→F=F, F→V=V, F→F=V. Único caso falso: premissa verdadeira e conclusão falsa."
  },
  {
    "id": "matematica__Lógica Matemática__Fácil__8",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Fácil",
    "question": "Qual a negação da proposição 'Todos os alunos passaram na prova'?",
    "options": [
      "Existe pelo menos um aluno que não passou na prova",
      "Nenhum aluno passou na prova",
      "A maioria dos alunos não passou na prova",
      "Todos os alunos não passaram na prova"
    ],
    "correctIndex": 0,
    "explanation": "Negação do quantificador universal [∀x P(x)]: ∃x ¬P(x). 'Todos passaram' ⇒ 'Existe ao menos um que não passou'.",
    "example": "'Todos aprovados' → nega: 'existe algum reprovado'. Erro comum: 'nenhum passou' é mais forte que a negação. Negação exata: pelo menos 1 não passou. Quantificador existencial [∃x P(x)] → nega: ∀x ¬P(x) = 'nenhum'."
  },
  {
    "id": "matematica__Lógica Matemática__Médio__1",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Médio",
    "question": "Qual é a negação da proposição 'Todos os alunos passaram no exame'?",
    "options": [
      "Existe pelo menos um aluno que não passou no exame",
      "Nenhum aluno passou no exame",
      "Todos os alunos não passaram",
      "Alguns alunos passaram"
    ],
    "correctIndex": 0,
    "explanation": "A negação de ∀x P(x) (para todo x, P(x)) é ∃x ¬P(x) (existe x tal que não P(x)). Basta um contraexemplo para negar uma afirmação universal. Não é necessário que TODOS falhem, apenas que PELO MENOS UM não tenha passado.",
    "example": "Original: 'Todos os alunos passaram' (∀x: passou(x)). Negação: 'Existe pelo menos um aluno que não passou' (∃x: ¬passou(x)). Bastou um aluno reprovar para a afirmação original ser falsa."
  },
  {
    "id": "matematica__Lógica Matemática__Médio__2",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Médio",
    "question": "Qual é a contrapositiva da proposição 'Se chove, então a rua está molhada'?",
    "options": [
      "Se a rua não está molhada, então não chove",
      "Se não chove, a rua não está molhada",
      "Se a rua está molhada, então chove",
      "Chove se e somente se a rua está molhada"
    ],
    "correctIndex": 0,
    "explanation": "A contrapositiva de P → Q é ¬Q → ¬P. São logicamente equivalentes. A contrapositiva de 'Se chove, a rua está molhada' é 'Se a rua NÃO está molhada, então NÃO chove'. Não confundir com inversa (¬P→¬Q) ou recíproca (Q→P).",
    "example": "P→Q: 'Se chove → rua molhada'. Contrapositiva (¬Q→¬P): 'Rua seca → não chove' (equivalente). Recíproca (Q→P): 'Rua molhada → chove' (não equivalente, rua pode estar molhada por outro motivo)."
  },
  {
    "id": "matematica__Lógica Matemática__Médio__3",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Médio",
    "question": "Complete o silogismo: 'Todos os mamíferos são vertebrados. Todos os cães são mamíferos. Logo, ___'",
    "options": [
      "Todos os cães são vertebrados",
      "Todos os vertebrados são cães",
      "Alguns vertebrados são mamíferos",
      "Nenhum cão é vertebrado"
    ],
    "correctIndex": 0,
    "explanation": "Silogismo válido (Barbara): Premissa 1: Todo M é V. Premissa 2: Todo C é M. Conclusão: Todo C é V (silogismo transitivo). Se A ⊆ B e B ⊆ C, então A ⊆ C.",
    "example": "Cães ⊂ Mamíferos ⊂ Vertebrados. Logo, Cães ⊂ Vertebrados. Todo cão é vertebrado. Forma lógica: (C→M) ∧ (M→V) → (C→V)."
  },
  {
    "id": "matematica__Lógica Matemática__Médio__4",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Médio",
    "question": "Qual é a negação de 'Se chove, então fico em casa' (P → Q)?",
    "options": [
      "Chove e não fico em casa (P ∧ ¬Q)",
      "¬P → ¬Q",
      "¬P ∨ Q",
      "Não chove ou fico em casa"
    ],
    "correctIndex": 0,
    "explanation": "A negação de P → Q é P ∧ ¬Q (e não ¬P → ¬Q). Para negar um condicional, mantemos a hipótese e negamos a conclusão, usando conjunção.",
    "example": "¬(P→Q) = ¬(¬P∨Q) = P∧¬Q (De Morgan). Exemplo: 'Chove E não fico em casa' é a única situação que contradiz a promessa."
  },
  {
    "id": "matematica__Lógica Matemática__Médio__5",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Médio",
    "question": "Se '(P → Q) ∧ P' é verdade, o que podemos concluir?",
    "options": [
      "Q é verdadeiro",
      "Q é falso",
      "P é falso",
      "Nada"
    ],
    "correctIndex": 0,
    "explanation": "Modus Ponens: Se P → Q é verdadeiro e P é verdadeiro, então Q deve ser verdadeiro. É uma das regras de inferência mais fundamentais da lógica.",
    "example": "P→Q verdadeiro + P verdadeiro: pela tabela, P=V e P→Q=V só se Q=V. Logo Q=V (Modus Ponens)."
  },
  {
    "id": "matematica__Lógica Matemática__Médio__6",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Médio",
    "question": "Se '(P → Q) ∧ ¬Q' é verdade, o que podemos concluir?",
    "options": [
      "¬P (P é falso)",
      "P é verdadeiro",
      "Q é verdadeiro",
      "Nada"
    ],
    "correctIndex": 0,
    "explanation": "Modus Tollens: Se P → Q é verdadeiro e Q é falso, então P deve ser falso. Pois se P fosse V e Q fosse F, P→Q seria F — contradição.",
    "example": "P→Q=V e Q=F. Se P=V: V→F=F (contrário à premissa). Logo P=F. Exemplo: 'Se chove → rua molhada'. Rua seca (¬Q) → não choveu (¬P)."
  },
  {
    "id": "matematica__Lógica Matemática__Médio__7",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Médio",
    "question": "Quais são as Leis de De Morgan na lógica proposicional?",
    "options": [
      "¬(P ∧ Q) ≡ ¬P ∨ ¬Q e ¬(P ∨ Q) ≡ ¬P ∧ ¬Q",
      "¬(P ∧ Q) ≡ ¬P ∧ ¬Q",
      "P ∧ Q ≡ P ∨ Q",
      "¬(P ∨ Q) ≡ ¬P ∨ ¬Q"
    ],
    "correctIndex": 0,
    "explanation": "Leis de De Morgan: (1) ¬(P ∧ Q) ≡ ¬P ∨ ¬Q — negação do 'E' vira 'OU' com negações. (2) ¬(P ∨ Q) ≡ ¬P ∧ ¬Q — negação do 'OU' vira 'E' com negações.",
    "example": "Exemplo: 'Não é verdade que (chove E faz frio)' ≡ 'Não chove OU não faz frio'. 'Nem chove nem faz frio' ≡ 'Não chove E não faz frio'."
  },
  {
    "id": "matematica__Lógica Matemática__Médio__8",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Médio",
    "question": "Dadas as proposições p = V e q = F, qual o valor de (p → q) ∧ (¬q → p)?",
    "options": [
      "V ∧ V = V",
      "F ∧ V = F",
      "V ∧ F = F",
      "F ∧ F = F"
    ],
    "correctIndex": 1,
    "explanation": "p→q: V→F = F. ¬q=V; V→V = V. (F)∧(V) = F.",
    "example": "p=V, q=F. p→q: só falsa quando V→F: F. ¬q=¬F=V. V→p=V→V=V. Conjunção F∧V=F."
  },
  {
    "id": "matematica__Lógica Matemática__Difícil__1",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Difícil",
    "question": "Na forma normal conjuntiva (FNC), como se expressa (P ∨ Q) → R?",
    "options": [
      "(¬P ∨ R) ∧ (¬Q ∨ R)",
      "P ∧ Q ∧ R",
      "(P ∨ Q) ∧ R",
      "¬P ∧ ¬Q ∧ R"
    ],
    "correctIndex": 0,
    "explanation": "(P ∨ Q) → R ≡ ¬(P ∨ Q) ∨ R ≡ (¬P ∧ ¬Q) ∨ R (De Morgan). Distribuindo: (¬P ∨ R) ∧ (¬Q ∨ R) — que é a FNC: conjunção de cláusulas disjuntivas.",
    "example": "Passo 1: A → B ≡ ¬A ∨ B. Passo 2: ¬(P ∨ Q) ∨ R. Passo 3: (¬P ∧ ¬Q) ∨ R (De Morgan). Passo 4: Distributiva — (¬P ∨ R) ∧ (¬Q ∨ R). FNC ✓."
  },
  {
    "id": "matematica__Lógica Matemática__Difícil__2",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Difícil",
    "question": "Simplifique a expressão lógica P ∧ (P ∨ Q) usando leis da lógica.",
    "options": [
      "P",
      "P ∨ Q",
      "P ∧ Q",
      "Q"
    ],
    "correctIndex": 0,
    "explanation": "Lei da absorção: P ∧ (P ∨ Q) ≡ P. Demonstração por tabela-verdade: Se P=V: V ∧ (V∨Q) = V ∧ V = V. Se P=F: F ∧ (F∨Q) = F ∧ Q = F. Resultado = P em ambos os casos.",
    "example": "P=V, Q=V: V ∧ (V∨V) = V ∧ V = V = P. P=V, Q=F: V ∧ (V∨F) = V ∧ V = V = P. P=F, Q=V: F ∧ (F∨V) = F ∧ V = F = P. Sempre = P."
  },
  {
    "id": "matematica__Lógica Matemática__Difícil__3",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Difícil",
    "question": "Usando as leis de De Morgan, qual é a negação de (P ∨ Q) ∧ R?",
    "options": [
      "(¬P ∧ ¬Q) ∨ ¬R",
      "¬P ∨ ¬Q ∨ ¬R",
      "¬P ∧ ¬Q ∧ ¬R",
      "(P ∧ Q) ∨ ¬R"
    ],
    "correctIndex": 0,
    "explanation": "¬[(P ∨ Q) ∧ R] = ¬(P ∨ Q) ∨ ¬R (De Morgan na conjunção) = (¬P ∧ ¬Q) ∨ ¬R (De Morgan na disjunção). As leis de De Morgan trocam ∧ por ∨ e negam cada componente.",
    "example": "Passo 1: ¬(A ∧ B) = ¬A ∨ ¬B. Com A=(P∨Q), B=R: ¬(P∨Q) ∨ ¬R. Passo 2: ¬(P∨Q) = ¬P ∧ ¬Q. Final: (¬P ∧ ¬Q) ∨ ¬R."
  },
  {
    "id": "matematica__Lógica Matemática__Difícil__4",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Difícil",
    "question": "A proposição 'P → Q' é logicamente equivalente a qual expressão?",
    "options": [
      "¬P ∨ Q",
      "P ∧ Q",
      "¬P ∧ ¬Q",
      "P ∨ ¬Q"
    ],
    "correctIndex": 0,
    "explanation": "P → Q ≡ ¬P ∨ Q. Demonstre por tabela-verdade: ambas são falsas apenas quando P=V e Q=F. Essa equivalência é fundamental para simplificação de expressões lógicas.",
    "example": "P=V,Q=V: V→V=V e ¬V∨V=V. P=V,Q=F: V→F=F e ¬V∨F=F. P=F,Q=V: F→V=V e V∨V=V. P=F,Q=F: F→F=V e V∨F=V. Todas iguais ✓."
  },
  {
    "id": "matematica__Lógica Matemática__Difícil__5",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Difícil",
    "question": "Quantas linhas tem a tabela-verdade de uma expressão com 4 variáveis proposicionais?",
    "options": [
      "16",
      "8",
      "32",
      "4"
    ],
    "correctIndex": 0,
    "explanation": "Uma tabela-verdade com n variáveis tem 2ⁿ linhas. Com 4 variáveis: 2⁴ = 16 linhas. Cada variável pode ser V ou F, gerando todas as combinações possíveis.",
    "example": "2¹=2, 2²=4, 2³=8, 2⁴=16, 2⁵=32. Com 4 variáveis (P,Q,R,S): 16 combinações de V/F."
  },
  {
    "id": "matematica__Lógica Matemática__Difícil__6",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Difícil",
    "question": "Verifique se (P ∨ Q) ∧ (¬P ∨ R) ∧ (¬Q ∨ R) implica logicamente R.",
    "options": [
      "Sim, por resolução: de (P∨Q) e (¬P∨R) obtemos (Q∨R); de (Q∨R) e (¬Q∨R) obtemos R",
      "Não, há contraexemplo",
      "Só vale quando P=V",
      "Só vale quando Q=V"
    ],
    "correctIndex": 0,
    "explanation": "Resolução (regra de inferência): (P∨Q) com (¬P∨R) → eliminamos P → (Q∨R). Depois (Q∨R) com (¬Q∨R) → eliminamos Q → (R∨R) ≡ R. Logo R é consequência lógica.",
    "example": "Passo 1: Resolvent de (P∨Q) e (¬P∨R) = Q∨R. Passo 2: Resolvent de (Q∨R) e (¬Q∨R) = R∨R = R. Prova completa em 2 passos de resolução."
  },
  {
    "id": "matematica__Lógica Matemática__Difícil__7",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Difícil",
    "question": "Qual a forma normal disjuntiva (FND) de P → Q?",
    "options": [
      "(¬P ∧ ¬Q) ∨ (¬P ∧ Q) ∨ (P ∧ Q)",
      "P ∨ Q",
      "¬P ∨ Q",
      "(P ∧ Q) ∨ (¬P ∧ ¬Q)"
    ],
    "correctIndex": 0,
    "explanation": "FND: disjunção de cláusulas conjuntivas (mintermos). P→Q é V em 3 casos da tabela: (F,F), (F,V), (V,V). FND = (¬P∧¬Q) ∨ (¬P∧Q) ∨ (P∧Q). Pode simplificar para ¬P ∨ Q.",
    "example": "Tabela P→Q: V→V=V, V→F=F, F→V=V, F→F=V. Mintermos verdadeiros: (¬P∧¬Q), (¬P∧Q), (P∧Q). FND = união desses 3 mintermos."
  },
  {
    "id": "matematica__Lógica Matemática__Difícil__8",
    "track": "matematica",
    "category": "Lógica Matemática",
    "difficulty": "Difícil",
    "question": "Qual das afirmações representa corretamente a lei do silogismo hipotético?",
    "options": [
      "Se p→q e q→r, então p→r",
      "Se p→q e p, então q (modus ponens)",
      "Se ¬q e p→q, então ¬p (modus tollens)",
      "p∨q e ¬p, então q (silogismo disjuntivo)"
    ],
    "correctIndex": 0,
    "explanation": "Silogismo hipotético: [(p→q) ∧ (q→r)] → (p→r). Transitividade da implicação. As outras descrevem modus ponens, modus tollens e silogismo disjuntivo.",
    "example": "Ex: p='Estuda', q='Passa', r='Formatura'. Estuda→Passa; Passa→Formatura; logo Estuda→Formatura. Modus ponens: p→q; p; logo q. Modus tollens: p→q; ¬q; logo ¬p. Silogismo disjuntivo: p∨q; ¬p; logo q."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Fácil__1",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Fácil",
    "question": "Qual é o resultado da soma das matrizes A = [[1, 2], [3, 4]] e B = [[5, 6], [7, 8]]?",
    "options": [
      "[[6, 8], [10, 12]]",
      "[[5, 12], [21, 32]]",
      "[[6, 8], [7, 12]]",
      "[[4, 4], [4, 4]]"
    ],
    "correctIndex": 0,
    "explanation": "A soma de matrizes é feita elemento a elemento: (A+B)ᵢⱼ = Aᵢⱼ + Bᵢⱼ. [1+5, 2+6] = [6, 8] e [3+7, 4+8] = [10, 12]. As matrizes devem ter a mesma dimensão para serem somadas.",
    "example": "A + B = [[1+5, 2+6], [3+7, 4+8]] = [[6, 8], [10, 12]]."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Fácil__2",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Fácil",
    "question": "Se A = [[2, 0], [1, 3]], qual é o resultado de 3A?",
    "options": [
      "[[6, 0], [3, 9]]",
      "[[6, 3], [0, 9]]",
      "[[5, 3], [4, 6]]",
      "[[2, 0], [3, 9]]"
    ],
    "correctIndex": 0,
    "explanation": "A multiplicação de uma matriz por um escalar multiplica CADA elemento pelo escalar: 3A = [[3×2, 3×0], [3×1, 3×3]] = [[6, 0], [3, 9]].",
    "example": "3 × [[2,0],[1,3]] = [[6,0],[3,9]]. Cada elemento multiplicado por 3."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Fácil__3",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Fácil",
    "question": "Qual é a matriz identidade de ordem 2?",
    "options": [
      "[[1, 0], [0, 1]]",
      "[[1, 1], [1, 1]]",
      "[[0, 0], [0, 0]]",
      "[[2, 0], [0, 2]]"
    ],
    "correctIndex": 0,
    "explanation": "A matriz identidade I tem 1 na diagonal principal e 0 nas demais posições. Para qualquer matriz A: A × I = I × A = A. É o 'elemento neutro' da multiplicação de matrizes.",
    "example": "I₂ = [[1,0],[0,1]]. Verificação: [[a,b],[c,d]] × [[1,0],[0,1]] = [[a,b],[c,d]] ✓."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Fácil__4",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Fácil",
    "question": "Qual é a transposta da matriz A = [[1, 2, 3], [4, 5, 6]]?",
    "options": [
      "[[1, 4], [2, 5], [3, 6]]",
      "[[6, 5, 4], [3, 2, 1]]",
      "[[1, 2], [3, 4], [5, 6]]",
      "[[4, 1], [5, 2], [6, 3]]"
    ],
    "correctIndex": 0,
    "explanation": "A transposta troca linhas por colunas: Aᵀᵢⱼ = Aⱼᵢ. Matriz 2×3 vira 3×2. A 1ª linha [1,2,3] vira a 1ª coluna.",
    "example": "Linhas de A viram colunas de Aᵀ. [1,2,3] → coluna 1. [4,5,6] → coluna 2. Resultado: [[1,4],[2,5],[3,6]]."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Fácil__5",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Fácil",
    "question": "Qual é o resultado de 2 × [[3, -1], [0, 4]]?",
    "options": [
      "[[6, -2], [0, 8]]",
      "[[6, -1], [0, 8]]",
      "[[5, 1], [2, 6]]",
      "[[3, -2], [0, 4]]"
    ],
    "correctIndex": 0,
    "explanation": "Na multiplicação por escalar, cada elemento da matriz é multiplicado pelo escalar: 2×3=6, 2×(-1)=-2, 2×0=0, 2×4=8.",
    "example": "2 × [[3,-1],[0,4]] = [[2×3, 2×(-1)], [2×0, 2×4]] = [[6,-2],[0,8]]."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Fácil__6",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Fácil",
    "question": "Qual é a ordem (dimensão) de uma matriz com 3 linhas e 4 colunas?",
    "options": [
      "3×4",
      "4×3",
      "12",
      "7"
    ],
    "correctIndex": 0,
    "explanation": "A ordem de uma matriz é dada por linhas × colunas. Uma matriz com 3 linhas e 4 colunas tem ordem 3×4. Ela contém 3×4 = 12 elementos.",
    "example": "Matriz 3×4 tem 3 linhas e 4 colunas = 12 elementos. Exemplo: [[a,b,c,d],[e,f,g,h],[i,j,k,l]]."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Fácil__7",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Fácil",
    "question": "Qual é o elemento a₂₃ da matriz [[1,2,3],[4,5,6]]?",
    "options": [
      "6",
      "3",
      "5",
      "2"
    ],
    "correctIndex": 0,
    "explanation": "a₂₃ significa o elemento na 2ª linha e 3ª coluna. Linha 2: [4,5,6]. Coluna 3: 6º elemento. a₂₃ = 6.",
    "example": "aᵢⱼ = elemento na linha i, coluna j. a₂₃ = linha 2, coluna 3 = 6."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Fácil__8",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Fácil",
    "question": "Qual o determinante da matriz [[3, 1], [2, 4]]?",
    "options": [
      "10",
      "12",
      "14",
      "8"
    ],
    "correctIndex": 0,
    "explanation": "det = ad - bc = 3×4 - 1×2 = 12 - 2 = 10.",
    "example": "Regra para matriz 2x2: [[a,b],[c,d]] → det = ad-bc. 3×4=12; 1×2=2; det=12-2=10. det=0 ⇒ matriz singular (não invertível). det≠0 ⇒ sistema tem solução única."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Médio__1",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Médio",
    "question": "Qual é o determinante da matriz 2×2: [[3, 7], [1, 5]]?",
    "options": [
      "8",
      "15",
      "22",
      "-2"
    ],
    "correctIndex": 0,
    "explanation": "Para uma matriz 2×2 [[a, b], [c, d]], det = ad - bc. det = (3)(5) - (7)(1) = 15 - 7 = 8. O determinante indica se a matriz é invertível (det ≠ 0) e mede a mudança de escala na transformação linear.",
    "example": "det([[3, 7], [1, 5]]) = 3×5 - 7×1 = 15 - 7 = 8. Como det = 8 ≠ 0, a matriz é invertível."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Médio__2",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Médio",
    "question": "Qual é o produto das matrizes A = [[1, 2], [3, 4]] e B = [[2, 0], [1, 3]]?",
    "options": [
      "[[4, 6], [10, 12]]",
      "[[2, 0], [3, 12]]",
      "[[3, 2], [4, 7]]",
      "[[2, 6], [10, 12]]"
    ],
    "correctIndex": 0,
    "explanation": "Multiplicação de matrizes: Cᵢⱼ = Σ Aᵢₖ × Bₖⱼ. C₁₁ = 1×2+2×1 = 4. C₁₂ = 1×0+2×3 = 6. C₂₁ = 3×2+4×1 = 10. C₂₂ = 3×0+4×3 = 12.",
    "example": "[[1×2+2×1, 1×0+2×3], [3×2+4×1, 3×0+4×3]] = [[4, 6], [10, 12]]. Nota: A×B ≠ B×A em geral."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Médio__3",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Médio",
    "question": "Uma matriz 3×2 multiplicada por uma matriz 2×4 resulta em uma matriz de que dimensão?",
    "options": [
      "3×4",
      "2×2",
      "3×2",
      "2×4"
    ],
    "correctIndex": 0,
    "explanation": "A×B: (m×n) × (n×p) = (m×p). As colunas de A devem igualar as linhas de B. Resultado: linhas de A × colunas de B. (3×2) × (2×4) = 3×4.",
    "example": "(3×2) × (2×4): o '2' interno combina → resultado 3×4. Se fosse (3×2) × (3×4), a multiplicação seria impossível."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Médio__4",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Médio",
    "question": "Se det(A) = 3 e det(B) = 4, qual é det(A × B)?",
    "options": [
      "12",
      "7",
      "1",
      "64"
    ],
    "correctIndex": 0,
    "explanation": "Propriedade fundamental: det(A×B) = det(A) × det(B). Logo det(AB) = 3 × 4 = 12. Vale para matrizes quadradas de mesma ordem.",
    "example": "det(AB) = det(A) × det(B) = 3 × 4 = 12. Também: det(BA) = 4 × 3 = 12 (mesmo resultado)."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Médio__5",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Médio",
    "question": "Qual é o traço (soma da diagonal principal) de [[5, 2, 1], [0, 3, 7], [4, 6, 8]]?",
    "options": [
      "16",
      "15",
      "10",
      "21"
    ],
    "correctIndex": 0,
    "explanation": "O traço (trace) é a soma dos elementos da diagonal principal: tr(A) = a₁₁ + a₂₂ + a₃₃ = 5 + 3 + 8 = 16.",
    "example": "Diagonal principal: 5, 3, 8. Traço = 5 + 3 + 8 = 16. O traço também é a soma dos autovalores."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Médio__6",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Médio",
    "question": "A multiplicação de matrizes é comutativa? Justifique.",
    "options": [
      "Não, em geral A×B ≠ B×A",
      "Sim, sempre A×B = B×A",
      "Só para matrizes 2×2",
      "Só quando det ≠ 0"
    ],
    "correctIndex": 0,
    "explanation": "A multiplicação de matrizes NÃO é comutativa. A×B ≠ B×A na maioria dos casos. Pode nem ter a mesma dimensão (3×2 × 2×4 = 3×4, mas 2×4 × 3×2 é impossível). Exceção: matrizes diagonais entre si.",
    "example": "A=[[1,2],[3,4]], B=[[0,1],[1,0]]. AB=[[2,1],[4,3]]. BA=[[3,4],[1,2]]. AB ≠ BA."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Médio__7",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Médio",
    "question": "Se det(A) = 0, o que isso indica sobre a matriz A?",
    "options": [
      "A é singular (não invertível) e suas linhas/colunas são linearmente dependentes",
      "A é a matriz identidade",
      "A tem inversa",
      "A é ortogonal"
    ],
    "correctIndex": 0,
    "explanation": "det(A) = 0 significa que A é singular: não possui inversa, suas linhas (ou colunas) são linearmente dependentes, e o sistema Ax = b pode não ter solução única.",
    "example": "[[1,2],[2,4]]: L₂ = 2×L₁, det = 4-4 = 0. Não tem inversa. Sistema: infinitas soluções ou nenhuma."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Médio__8",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Médio",
    "question": "Qual a soma dos elementos da diagonal principal da matriz produto A×B, onde A = [[1,2],[3,4]] e B = [[2,0],[1,3]]?",
    "options": [
      "16",
      "18",
      "20",
      "14"
    ],
    "correctIndex": 0,
    "explanation": "A×B: linha 1 de A × colunas de B. (1,2)×(2,1)T=4; (1,2)×(0,3)T=6. (3,4)×(2,1)T=10; (3,4)×(0,3)T=12. Diagonal: 4 e 12. Soma=16.",
    "example": "C[1][1]=1×2+2×1=4; C[1][2]=1×0+2×3=6; C[2][1]=3×2+4×1=10; C[2][2]=3×0+4×3=12. Traço (traço = soma diagonal): 4+12=16. Traço tem propriedade: tr(AB)=tr(BA)."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Difícil__1",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Difícil",
    "question": "Dada a matriz A = [[2, 1], [5, 3]], qual é A⁻¹ (matriz inversa)?",
    "options": [
      "[[3, -1], [-5, 2]]",
      "[[2, -1], [-5, 3]]",
      "[[3, 1], [5, 2]]",
      "[[-3, 1], [5, -2]]"
    ],
    "correctIndex": 0,
    "explanation": "Para matriz 2×2: A⁻¹ = (1/det) × [[d, -b], [-c, a]]. det(A) = 2×3 - 1×5 = 6 - 5 = 1. A⁻¹ = (1/1) × [[3, -1], [-5, 2]] = [[3, -1], [-5, 2]].",
    "example": "Verificação: A × A⁻¹ = [[2,1],[5,3]] × [[3,-1],[-5,2]] = [[2×3+1×(-5), 2×(-1)+1×2], [5×3+3×(-5), 5×(-1)+3×2]] = [[1, 0], [0, 1]] = I ✓."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Difícil__2",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Difícil",
    "question": "Calcule o determinante da matriz 3×3: [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
    "options": [
      "0",
      "18",
      "-18",
      "6"
    ],
    "correctIndex": 0,
    "explanation": "Regra de Sarrus: (1×5×9 + 2×6×7 + 3×4×8) - (3×5×7 + 2×4×9 + 1×6×8) = (45 + 84 + 96) - (105 + 72 + 48) = 225 - 225 = 0. det = 0 → matriz singular (não invertível).",
    "example": "Diag principal: 1×5×9=45, 2×6×7=84, 3×4×8=96 → 225. Diag secundária: 3×5×7=105, 2×4×9=72, 1×6×8=48 → 225. 225-225=0."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Difícil__3",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Difícil",
    "question": "Se det(A) = 5, qual é det(2A) para uma matriz A de ordem 3?",
    "options": [
      "40",
      "10",
      "20",
      "80"
    ],
    "correctIndex": 0,
    "explanation": "Para uma matriz n×n: det(kA) = kⁿ × det(A). Ordem 3: det(2A) = 2³ × det(A) = 8 × 5 = 40. Cada linha é multiplicada por k, e o determinante é multilinear.",
    "example": "Regra: det(kA) = kⁿ × det(A). n=3, k=2: det(2A) = 2³ × 5 = 8 × 5 = 40. Para n=2 seria 4×5=20."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Difícil__4",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Difícil",
    "question": "Qual é o posto (rank) da matriz [[1, 2, 3], [2, 4, 6], [0, 1, 1]]?",
    "options": [
      "2",
      "3",
      "1",
      "0"
    ],
    "correctIndex": 0,
    "explanation": "A 2ª linha é o dobro da 1ª (linearmente dependente), portanto só há 2 linhas LI. Posto = número de linhas (ou colunas) linearmente independentes = 2.",
    "example": "L₂ = 2×L₁ → L₂ não traz informação nova. L₁ e L₃ são LI. Posto = 2. Det 3×3 = 0 (confirma que posto < 3)."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Difícil__5",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Difícil",
    "question": "Se A é uma matriz 3×3 com det(A) = 4, qual é det(A⁻¹)?",
    "options": [
      "1/4",
      "4",
      "-4",
      "1"
    ],
    "correctIndex": 0,
    "explanation": "Como A × A⁻¹ = I e det(I) = 1, temos det(A) × det(A⁻¹) = 1, logo det(A⁻¹) = 1/det(A) = 1/4.",
    "example": "det(A×A⁻¹) = det(I) = 1. det(A) × det(A⁻¹) = 1. det(A⁻¹) = 1/4 = 0,25."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Difícil__6",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Difícil",
    "question": "Qual é o determinante de uma matriz triangular (superior ou inferior) 3×3?",
    "options": [
      "Produto dos elementos da diagonal principal",
      "Soma dos elementos",
      "Sempre 1",
      "Sempre 0"
    ],
    "correctIndex": 0,
    "explanation": "O determinante de qualquer matriz triangular (superior, inferior ou diagonal) é o produto dos elementos da diagonal principal: det = a₁₁ × a₂₂ × a₃₃.",
    "example": "[[2,3,5],[0,4,7],[0,0,6]]: det = 2 × 4 × 6 = 48. Não precisa de Sarrus ou cofatores para matrizes triangulares."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Difícil__7",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Difícil",
    "question": "Se A é uma matriz ortogonal (AᵀA = I), qual é |det(A)|?",
    "options": [
      "1",
      "0",
      "Depende de A",
      "√2"
    ],
    "correctIndex": 0,
    "explanation": "AᵀA = I → det(Aᵀ) × det(A) = det(I) = 1. Como det(Aᵀ) = det(A), temos [det(A)]² = 1 → det(A) = ±1. Logo |det(A)| = 1.",
    "example": "Matriz de rotação 2D: [[cosθ,-sinθ],[sinθ,cosθ]]. det = cos²θ + sin²θ = 1. Reflexão: det = -1. Ambos |det| = 1."
  },
  {
    "id": "matematica__Matrizes e Determinantes__Difícil__8",
    "track": "matematica",
    "category": "Matrizes e Determinantes",
    "difficulty": "Difícil",
    "question": "Usando a Regra de Cramer, qual o valor de x no sistema: x+2y=5 e 3x+4y=7?",
    "options": [
      "x = -3",
      "x = 1",
      "x = 3",
      "x = -1"
    ],
    "correctIndex": 0,
    "explanation": "D = det([[1,2],[3,4]]) = 4-6 = -2. Dx = det([[5,2],[7,4]]) = 20-14 = 6. x = Dx/D = 6/(-2) = -3.",
    "example": "D = 1×4 - 2×3 = -2. Dx: substitui 1ª coluna pelos termos independentes: [[5,2],[7,4]]. det=20-14=6. x=6/(-2)=-3. Dy: [[1,5],[3,7]]. det=7-15=-8. y=(-8)/(-2)=4. Verificação: (-3)+2(4)=-3+8=5 ✓; 3(-3)+4(4)=-9+16=7 ✓."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Fácil__1",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Fácil",
    "question": "Quanto é 15% de R$ 300?",
    "options": [
      "R$ 45",
      "R$ 30",
      "R$ 50",
      "R$ 40"
    ],
    "correctIndex": 0,
    "explanation": "15% de 300 = (15/100) × 300 = 0,15 × 300 = R$ 45. Alternativa: 10% = 30, 5% = 15. Total: 30 + 15 = 45.",
    "example": "15% = 15/100 = 0,15. 0,15 × 300 = R$ 45. Ou: 1% de 300 = 3, logo 15% = 15 × 3 = 45."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Fácil__2",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Fácil",
    "question": "Se um produto custa R$ 120 e está com 30% de desconto, qual o preço final?",
    "options": [
      "R$ 84",
      "R$ 90",
      "R$ 96",
      "R$ 36"
    ],
    "correctIndex": 0,
    "explanation": "Desconto = 30% de 120 = 36. Preço final = 120 - 36 = R$ 84. Ou diretamente: 120 × 0,70 = R$ 84 (pagar 70% do valor).",
    "example": "30% de desconto = pagar 70%. 120 × 0,70 = R$ 84. Desconto de R$ 36."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Fácil__3",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Fácil",
    "question": "Se 4 canetas custam R$ 12, quanto custam 10 canetas?",
    "options": [
      "R$ 30",
      "R$ 24",
      "R$ 40",
      "R$ 36"
    ],
    "correctIndex": 0,
    "explanation": "Regra de três simples direta: 4 canetas → R$ 12, 10 canetas → x. x = (10 × 12) / 4 = 120/4 = R$ 30.",
    "example": "Preço unitário: 12/4 = R$ 3 cada. 10 canetas: 10 × 3 = R$ 30."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Fácil__4",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Fácil",
    "question": "Se 60% dos 40 alunos de uma classe são meninas, quantas meninas há?",
    "options": [
      "24",
      "16",
      "20",
      "28"
    ],
    "correctIndex": 0,
    "explanation": "60% de 40 = 0,60 × 40 = 24 meninas. Os outros 40% (16 alunos) são meninos.",
    "example": "60% de 40: 0,60 × 40 = 24. Ou: 10% de 40 = 4, logo 60% = 6 × 4 = 24 meninas."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Fácil__5",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Fácil",
    "question": "Um produto custa R$ 50. Qual será o preço após um aumento de 10%?",
    "options": [
      "R$ 55",
      "R$ 60",
      "R$ 45",
      "R$ 50,10"
    ],
    "correctIndex": 0,
    "explanation": "Aumento de 10%: novo preço = 50 × 1,10 = R$ 55. O aumento em reais foi de 50 × 0,10 = R$ 5.",
    "example": "10% de 50 = 5. Preço final: 50 + 5 = R$ 55. Fator multiplicativo: 50 × 1,10 = R$ 55."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Fácil__6",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Fácil",
    "question": "Um número aumentado em 25% dá 150. Qual era o número original?",
    "options": [
      "120",
      "112,50",
      "125",
      "100"
    ],
    "correctIndex": 0,
    "explanation": "N × 1,25 = 150 → N = 150 / 1,25 = 120. Verificação: 120 + 25% de 120 = 120 + 30 = 150 ✓.",
    "example": "N = 150/1,25 = 120. Erro comum: 150 - 25% de 150 = 150 - 37,5 = 112,50 (errado! A base do % é o número original)."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Fácil__7",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Fácil",
    "question": "Um carro faz 12 km/L. Quantos litros precisa para percorrer 450 km?",
    "options": [
      "37,5 L",
      "36 L",
      "40 L",
      "54 L"
    ],
    "correctIndex": 0,
    "explanation": "Regra de três direta: 12 km → 1 L, 450 km → x L. x = 450/12 = 37,5 litros.",
    "example": "450 ÷ 12 = 37,5 L. Custo a R$ 6/L: 37,5 × 6 = R$ 225."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Fácil__8",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Fácil",
    "question": "Um produto custava R$ 80 e teve aumento de 15%. Qual o novo preço?",
    "options": [
      "R$ 92",
      "R$ 88",
      "R$ 90",
      "R$ 95"
    ],
    "correctIndex": 0,
    "explanation": "Aumento = 80 × 0,15 = 12. Novo preço = 80 + 12 = R$ 92. Ou: 80 × 1,15 = 92.",
    "example": "Multiplicador: 1 + 15% = 1,15. 80×1,15=92. Desconto de 15%: 80×0,85=68. Aumentos sucessivos de 10% e 10%: 80×1,1×1,1=96,8 (não é 80×1,2=96)."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Médio__1",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Médio",
    "question": "Um produto custava R$ 80 e sofreu aumento de 25%, depois desconto de 20% sobre o novo preço. Qual o preço final?",
    "options": [
      "R$ 80",
      "R$ 84",
      "R$ 76",
      "R$ 100"
    ],
    "correctIndex": 0,
    "explanation": "Após aumento: 80 × 1,25 = R$ 100. Após desconto: 100 × 0,80 = R$ 80. Atenção: aumento de 25% seguido de desconto de 20% NÃO volta ao preço original em geral, mas neste caso 1,25 × 0,80 = 1,00 exatamente. Coincidência numérica!",
    "example": "Fator multiplicativo: 1,25 × 0,80 = 1,00. Preço final = 80 × 1,00 = R$ 80. Se fosse 30% de aumento e 20% de desconto: 1,30 × 0,80 = 1,04 → R$ 83,20."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Médio__2",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Médio",
    "question": "Um salário de R$ 2.500 teve reajuste de 12%. Qual o novo salário?",
    "options": [
      "R$ 2.800",
      "R$ 2.700",
      "R$ 3.000",
      "R$ 2.600"
    ],
    "correctIndex": 0,
    "explanation": "Novo salário = 2500 × 1,12 = R$ 2.800. O aumento em reais foi de 2500 × 0,12 = R$ 300.",
    "example": "12% de 2500 = 300. Novo salário: 2500 + 300 = R$ 2.800. Ou: 2500 × 1,12 = R$ 2.800."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Médio__3",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Médio",
    "question": "Se 6 pedreiros constroem um muro em 10 dias, em quantos dias 15 pedreiros fariam o mesmo muro?",
    "options": [
      "4 dias",
      "6 dias",
      "25 dias",
      "8 dias"
    ],
    "correctIndex": 0,
    "explanation": "Grandezas inversamente proporcionais: mais pedreiros → menos dias. 6 × 10 = 15 × x → x = 60/15 = 4 dias.",
    "example": "Total de 'pedreiro-dias': 6 × 10 = 60. Com 15 pedreiros: 60/15 = 4 dias. Inverso: dobrar pedreiros = metade do tempo."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Médio__4",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Médio",
    "question": "Uma mercadoria de R$ 200 sofre dois aumentos sucessivos de 10%. Qual o preço final?",
    "options": [
      "R$ 242",
      "R$ 240",
      "R$ 220",
      "R$ 244"
    ],
    "correctIndex": 0,
    "explanation": "Dois aumentos de 10%: fator = 1,10 × 1,10 = 1,21. Preço = 200 × 1,21 = R$ 242. Não é 20% de aumento (que daria R$ 240).",
    "example": "1º aumento: 200 × 1,10 = 220. 2º aumento: 220 × 1,10 = 242. Ou direto: 200 × 1,21 = R$ 242."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Médio__5",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Médio",
    "question": "Uma população cresceu de 10.000 para 12.100 em 2 anos. Qual a taxa anual de crescimento?",
    "options": [
      "10%",
      "21%",
      "11%",
      "20%"
    ],
    "correctIndex": 0,
    "explanation": "10000 × (1+i)² = 12100 → (1+i)² = 1,21 → 1+i = 1,1 → i = 0,10 = 10% ao ano. Não é 21/2 = 10,5%.",
    "example": "(1+i)² = 12100/10000 = 1,21. √1,21 = 1,1. i = 10%. Verifica: 10000 × 1,1² = 12100 ✓."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Médio__6",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Médio",
    "question": "Se 3 torneiras enchem um tanque em 4 horas, em quanto tempo 6 torneiras enchem o mesmo tanque?",
    "options": [
      "2 horas",
      "8 horas",
      "1 hora",
      "3 horas"
    ],
    "correctIndex": 0,
    "explanation": "Grandezas inversamente proporcionais: mais torneiras → menos tempo. 3 × 4 = 6 × x → 12 = 6x → x = 2 horas.",
    "example": "'Torneira-horas': 3 × 4 = 12. Com 6 torneiras: 12/6 = 2 horas. Dobrou torneiras = metade do tempo."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Médio__7",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Médio",
    "question": "Um produto custa R$ 180 após um aumento de 20%. Qual era o preço original?",
    "options": [
      "R$ 150",
      "R$ 144",
      "R$ 160",
      "R$ 140"
    ],
    "correctIndex": 0,
    "explanation": "Preço original × 1,20 = 180. P = 180/1,20 = R$ 150. Erro comum: 180 - 20% de 180 = 180 - 36 = R$ 144 (errado!).",
    "example": "P = 180/1,20 = 150. Verifica: 150 × 1,20 = 180 ✓. O desconto de 20% sobre 180 (= 144) não desfaz o aumento de 20%."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Médio__8",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Médio",
    "question": "Se 3 trabalhadores constroem uma parede em 8 dias, em quantos dias 6 trabalhadores constroem a mesma parede?",
    "options": [
      "4 dias",
      "6 dias",
      "16 dias",
      "12 dias"
    ],
    "correctIndex": 0,
    "explanation": "Regra de três inversa (mais trabalhadores = menos dias). 3×8 = 6×x ⇒ x = 24/6 = 4 dias.",
    "example": "Grandezas inversamente proporcionais: 3×8=24 (total de dias-homem). 6 trabalhadores: 24/6=4 dias. Direto seria 16 dias (errado). Checar: inversamente prop. pois dobrar trabalho à metade do tempo."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Difícil__1",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Difícil",
    "question": "Se 8 máquinas, trabalhando 6 horas por dia, produzem 4800 peças em 5 dias, quantas peças 12 máquinas produzirão, trabalhando 8 horas por dia, em 3 dias?",
    "options": [
      "5760",
      "4320",
      "7200",
      "3600"
    ],
    "correctIndex": 0,
    "explanation": "Grandezas diretamente proporcionais: mais máquinas → mais peças; mais horas → mais peças; mais dias → mais peças. 4800 × (12/8) × (8/6) × (3/5) = 4800 × 1,5 × 1,333 × 0,6 = 4800 × 1,2 = 5760 peças.",
    "example": "Proporções: máquinas 12/8 = 1,5; horas 8/6 ≈ 1,333; dias 3/5 = 0,6. Peças = 4800 × 1,5 × 1,333 × 0,6 = 4800 × 1,2 = 5760."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Difícil__2",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Difícil",
    "question": "Um produto que custava R$ 250 passou a custar R$ 300. Qual foi o percentual de aumento?",
    "options": [
      "20%",
      "25%",
      "50%",
      "16,7%"
    ],
    "correctIndex": 0,
    "explanation": "Variação percentual = (valor final - valor inicial) / valor inicial × 100. (300 - 250) / 250 × 100 = 50/250 × 100 = 20%.",
    "example": "Aumento absoluto: 300 - 250 = 50. Percentual: 50/250 = 0,20 = 20%. Atenção: 50/300 = 16,7% seria errado (base é o valor inicial)."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Difícil__3",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Difícil",
    "question": "Dois descontos sucessivos de 10% e 20% equivalem a um desconto único de quanto?",
    "options": [
      "28%",
      "30%",
      "25%",
      "32%"
    ],
    "correctIndex": 0,
    "explanation": "Descontos sucessivos: fator = 0,90 × 0,80 = 0,72. Desconto equivalente = 1 - 0,72 = 0,28 = 28%. Não é 30% (soma simples errada).",
    "example": "Pagar 90% depois 80% = pagar 72% do original. Desconto total: 100% - 72% = 28%. Exemplo: R$ 100 → R$ 90 → R$ 72."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Difícil__4",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Difícil",
    "question": "Um preço à vista é R$ 510 após desconto de 15%. Qual era o preço original?",
    "options": [
      "R$ 600",
      "R$ 586,50",
      "R$ 585",
      "R$ 650"
    ],
    "correctIndex": 0,
    "explanation": "Preço com desconto = Preço original × 0,85. Logo: Preço original = 510 / 0,85 = R$ 600.",
    "example": "510 = P × 0,85. P = 510/0,85 = 600. Verifica: 600 × 0,85 = 510 ✓. Erro comum: 510 + 15% de 510 = 586,50 (✗)."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Difícil__5",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Difícil",
    "question": "Uma loja compra um produto por R$ 80 e quer vender com lucro de 40% sobre o preço de venda. Qual o preço de venda?",
    "options": [
      "R$ 133,33",
      "R$ 112",
      "R$ 120",
      "R$ 128"
    ],
    "correctIndex": 0,
    "explanation": "Lucro sobre preço de venda: Custo = PV - 40%×PV = 0,60×PV. 80 = 0,60×PV → PV = 80/0,60 ≈ R$ 133,33. Se fosse lucro sobre o custo: PV = 80 × 1,40 = R$ 112.",
    "example": "80 = PV × 0,60. PV = 80/0,60 ≈ R$ 133,33. Lucro = 133,33 - 80 = 53,33. 53,33/133,33 = 40% ✓."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Difícil__6",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Difícil",
    "question": "Uma população cresce 5% ao ano. Em quantos anos dobra? Use log(1,05) ≈ 0,0212 e log(2) ≈ 0,3010.",
    "options": [
      "≈ 14,2 anos",
      "10 anos",
      "20 anos",
      "40 anos"
    ],
    "correctIndex": 0,
    "explanation": "(1,05)ⁿ = 2 → n = log(2)/log(1,05) = 0,3010/0,0212 ≈ 14,2 anos. Regra prática (Regra dos 70): 70/taxa ≈ 70/5 = 14 anos.",
    "example": "n = 0,3010/0,0212 ≈ 14,2 anos. Regra dos 70: 70/5 = 14. Regra dos 72: 72/5 = 14,4. Todas dão ≈14 anos."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Difícil__7",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Difícil",
    "question": "Três aumentos sucessivos de 10%, 20% e 30% equivalem a um aumento único de quanto?",
    "options": [
      "71,6%",
      "60%",
      "72%",
      "50%"
    ],
    "correctIndex": 0,
    "explanation": "Fator acumulado: 1,10 × 1,20 × 1,30 = 1,716. Aumento equivalente: 71,6%. Não é 10+20+30 = 60% (soma simples é sempre menor que o real em aumentos compostos).",
    "example": "1,10 × 1,20 = 1,32. 1,32 × 1,30 = 1,716. Aumento total: 71,6%. R$ 100 → R$ 110 → R$ 132 → R$ 171,60."
  },
  {
    "id": "matematica__Porcentagem e Regra de Três__Difícil__8",
    "track": "matematica",
    "category": "Porcentagem e Regra de Três",
    "difficulty": "Difícil",
    "question": "Uma peça sofreu desconto de 20% e depois aumento de 20%. Qual a variação percentual total?",
    "options": [
      "-4%",
      "0%",
      "+4%",
      "-20%"
    ],
    "correctIndex": 0,
    "explanation": "Multiplicadores: 0,80 × 1,20 = 0,96. Variação: 0,96 - 1 = -0,04 = -4% (redução de 4%).",
    "example": "P’ = P×0,8×1,2 = P×0,96. Não é 0%! Desconto e aumento iguais resultam em perda líquida. Ex: 100×0,8=80; 80×1,2=96. Perda: R$4 (4%). Quanto seria necessário para voltar ao original após 20% de desconto: 80×x=100 ⇒ x=1,25 (aumento de 25%)."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Fácil__1",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Fácil",
    "question": "Qual é o 10º termo da PA (3, 7, 11, 15, ...)?",
    "options": [
      "39",
      "43",
      "35",
      "41"
    ],
    "correctIndex": 0,
    "explanation": "Na PA, aₙ = a₁ + (n-1)×r. a₁ = 3, r = 7 - 3 = 4. a₁₀ = 3 + (10-1)×4 = 3 + 36 = 39.",
    "example": "a₁₀ = 3 + 9 × 4 = 3 + 36 = 39. Verificação parcial: a₅ = 3 + 4×4 = 19 → 3, 7, 11, 15, 19 ✓."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Fácil__2",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Fácil",
    "question": "Qual é a razão da PA (10, 7, 4, 1, ...)?",
    "options": [
      "-3",
      "3",
      "-7",
      "4"
    ],
    "correctIndex": 0,
    "explanation": "A razão r = a₂ - a₁ = 7 - 10 = -3. PA decrescente pois r < 0. Os termos diminuem de 3 em 3.",
    "example": "r = 7 - 10 = -3. Verificação: 10, 10+(-3)=7, 7+(-3)=4, 4+(-3)=1 ✓. PA decrescente."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Fácil__3",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Fácil",
    "question": "Numa PG de razão 2 e primeiro termo 5, qual é o 4º termo?",
    "options": [
      "40",
      "20",
      "80",
      "10"
    ],
    "correctIndex": 0,
    "explanation": "Na PG: aₙ = a₁ × qⁿ⁻¹. a₄ = 5 × 2³ = 5 × 8 = 40. Sequência: 5, 10, 20, 40.",
    "example": "a₁=5, a₂=5×2=10, a₃=10×2=20, a₄=20×2=40. Ou direto: 5 × 2³ = 40."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Fácil__4",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Fácil",
    "question": "Os primeiros termos de uma PA são 2, 5, 8, 11. Qual é o 7º termo?",
    "options": [
      "20",
      "23",
      "17",
      "21"
    ],
    "correctIndex": 0,
    "explanation": "r = 5 - 2 = 3. a₇ = a₁ + (7-1)×r = 2 + 6×3 = 2 + 18 = 20.",
    "example": "a₇ = 2 + 6×3 = 20. Sequência: 2, 5, 8, 11, 14, 17, 20. Cada termo soma 3."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Fácil__5",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Fácil",
    "question": "Qual é a soma 1 + 2 + 4 + 8 + 16 (PG finita)?",
    "options": [
      "31",
      "32",
      "30",
      "16"
    ],
    "correctIndex": 0,
    "explanation": "PG com a₁ = 1, q = 2, n = 5. S₅ = a₁(q⁵ - 1)/(q - 1) = 1×(32-1)/(2-1) = 31.",
    "example": "1 + 2 + 4 + 8 + 16 = 31. Pela fórmula: S = (2⁵ - 1)/(2-1) = 31. Note: 2⁵ - 1 = 31."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Fácil__6",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Fácil",
    "question": "Qual é a razão da PG (2, 6, 18, 54, ...)?",
    "options": [
      "3",
      "2",
      "6",
      "4"
    ],
    "correctIndex": 0,
    "explanation": "Na PG, a razão q = a₂/a₁ = 6/2 = 3. Verificação: 2×3=6, 6×3=18, 18×3=54. Cada termo é o triplo do anterior.",
    "example": "q = 6/2 = 3. Também: 18/6 = 3, 54/18 = 3. PG crescente com q > 1."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Fácil__7",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Fácil",
    "question": "Quantos termos tem a PA (5, 9, 13, ..., 41)?",
    "options": [
      "10",
      "9",
      "11",
      "8"
    ],
    "correctIndex": 0,
    "explanation": "r = 9 - 5 = 4. aₙ = a₁ + (n-1)r → 41 = 5 + (n-1)×4 → 36 = (n-1)×4 → n-1 = 9 → n = 10.",
    "example": "n = (aₙ - a₁)/r + 1 = (41-5)/4 + 1 = 36/4 + 1 = 9 + 1 = 10 termos."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Fácil__8",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Fácil",
    "question": "Numa PA de primeiro termo 3 e razão 4, qual o 6º termo?",
    "options": [
      "23",
      "27",
      "19",
      "24"
    ],
    "correctIndex": 0,
    "explanation": "a_n = a_1 + (n-1)×r = 3 + (6-1)×4 = 3 + 20 = 23.",
    "example": "a_1=3, r=4. Sequência: 3,7,11,15,19,23. a_6=23. Soma dos n primeiros: S_n = n(a_1+a_n)/2 = 6(3+23)/2 = 6×13 = 78."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Médio__1",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Médio",
    "question": "Qual é a soma dos 20 primeiros termos da PA (2, 5, 8, 11, ...)?",
    "options": [
      "610",
      "590",
      "620",
      "580"
    ],
    "correctIndex": 0,
    "explanation": "S_n = n(a₁ + aₙ)/2. Primeiro: a₂₀ = 2 + 19×3 = 59. Depois: S₂₀ = 20(2 + 59)/2 = 20 × 61/2 = 610.",
    "example": "r = 3, a₁ = 2. a₂₀ = 2 + 19×3 = 59. S₂₀ = 20 × (2+59)/2 = 20 × 30,5 = 610."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Médio__2",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Médio",
    "question": "Encontre a razão da PG sabendo que a₁ = 3 e a₄ = 81.",
    "options": [
      "3",
      "9",
      "27",
      "6"
    ],
    "correctIndex": 0,
    "explanation": "aₙ = a₁ × qⁿ⁻¹. a₄ = 3 × q³ = 81 → q³ = 27 → q = 3. Sequência: 3, 9, 27, 81.",
    "example": "3 × q³ = 81. q³ = 81/3 = 27. q = ∛27 = 3. Verificação: 3, 9, 27, 81 ✓."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Médio__3",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Médio",
    "question": "A PA tem primeiro termo 5 e último termo 95, com 10 termos. Qual a soma?",
    "options": [
      "500",
      "950",
      "475",
      "450"
    ],
    "correctIndex": 0,
    "explanation": "S_n = n × (a₁ + aₙ)/2 = 10 × (5 + 95)/2 = 10 × 50 = 500. A razão seria r = (95-5)/(10-1) = 90/9 = 10.",
    "example": "S = 10 × (5+95)/2 = 10 × 50 = 500. Termos: 5, 15, 25, 35, 45, 55, 65, 75, 85, 95."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Médio__4",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Médio",
    "question": "Em uma PA, a₃ = 10 e a₇ = 22. Qual é o primeiro termo (a₁)?",
    "options": [
      "4",
      "1",
      "7",
      "2"
    ],
    "correctIndex": 0,
    "explanation": "a₇ = a₃ + 4r → 22 = 10 + 4r → r = 3. a₁ = a₃ - 2r = 10 - 6 = 4.",
    "example": "De a₃ até a₇: 4 passos. r = (22-10)/4 = 3. a₁ = 10 - 2×3 = 4. PA: 4, 7, 10, 13, 16, 19, 22 ✓."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Médio__5",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Médio",
    "question": "Qual é a soma dos 5 primeiros termos da PG (3, 6, 12, 24, ...)?",
    "options": [
      "93",
      "96",
      "48",
      "45"
    ],
    "correctIndex": 0,
    "explanation": "a₁ = 3, q = 2. S₅ = a₁(q⁵ - 1)/(q - 1) = 3(32-1)/1 = 3×31 = 93.",
    "example": "3 + 6 + 12 + 24 + 48 = 93. Pela fórmula: S₅ = 3(2⁵-1)/(2-1) = 3×31 = 93."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Médio__6",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Médio",
    "question": "Em uma PG, a₂ = 6 e a₅ = 162. Qual é o primeiro termo (a₁)?",
    "options": [
      "2",
      "3",
      "1",
      "6"
    ],
    "correctIndex": 0,
    "explanation": "a₅ = a₂ × q³ → 162 = 6 × q³ → q³ = 27 → q = 3. a₁ = a₂/q = 6/3 = 2.",
    "example": "q = ∛(162/6) = ∛27 = 3. a₁ = 6/3 = 2. Sequência: 2, 6, 18, 54, 162 ✓."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Médio__7",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Médio",
    "question": "Qual é o 15º termo da PA (100, 95, 90, 85, ...)?",
    "options": [
      "30",
      "25",
      "35",
      "20"
    ],
    "correctIndex": 0,
    "explanation": "r = 95 - 100 = -5. a₁₅ = 100 + (15-1)×(-5) = 100 - 70 = 30.",
    "example": "a₁₅ = 100 + 14×(-5) = 100 - 70 = 30. PA decrescente, cada termo diminui 5."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Médio__8",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Médio",
    "question": "Numa PG de primeiro termo 2 e razão 3, qual a soma dos 4 primeiros termos?",
    "options": [
      "80",
      "40",
      "26",
      "54"
    ],
    "correctIndex": 0,
    "explanation": "S_n = a_1(q^n - 1)/(q - 1) = 2(3^4 - 1)/(3-1) = 2×80/2 = 80.",
    "example": "Termos: 2, 6, 18, 54. Soma = 2+6+18+54 = 80. Fórmula: S = a_1×(q^n-1)/(q-1) = 2×(81-1)/2 = 2×40 = 80 ✓."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Difícil__1",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Difícil",
    "question": "Na PG (2, 6, 18, ...), qual é a soma dos 8 primeiros termos?",
    "options": [
      "6560",
      "4920",
      "8748",
      "3280"
    ],
    "correctIndex": 0,
    "explanation": "Na PG: S_n = a₁(qⁿ - 1)/(q - 1). a₁ = 2, q = 3. S₈ = 2(3⁸ - 1)/(3-1) = 2(6561 - 1)/2 = 6560.",
    "example": "q = 6/2 = 3. 3⁸ = 6561. S₈ = 2 × (6561-1) / (3-1) = 2 × 6560 / 2 = 6560."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Difícil__2",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Difícil",
    "question": "Qual é a soma de uma PG infinita com a₁ = 12 e q = 1/3?",
    "options": [
      "18",
      "36",
      "12",
      "24"
    ],
    "correctIndex": 0,
    "explanation": "PG infinita convergente (|q| < 1): S∞ = a₁/(1-q) = 12/(1 - 1/3) = 12/(2/3) = 12 × 3/2 = 18.",
    "example": "S∞ = 12 / (1 - 1/3) = 12 / (2/3) = 18. Parciais: 12 + 4 + 4/3 + 4/9 + ... → 18."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Difícil__3",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Difícil",
    "question": "Insira 3 meios aritméticos entre 4 e 20.",
    "options": [
      "8, 12, 16",
      "6, 10, 14",
      "7, 11, 15",
      "9, 13, 17"
    ],
    "correctIndex": 0,
    "explanation": "PA com a₁ = 4, a₅ = 20, n = 5. r = (20-4)/(5-1) = 16/4 = 4. Termos: 4, 8, 12, 16, 20. Os 3 meios são 8, 12, 16.",
    "example": "r = (20-4)/4 = 4. Meios: 4+4=8, 8+4=12, 12+4=16. PA completa: 4, 8, 12, 16, 20 ✓."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Difícil__4",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Difícil",
    "question": "Qual é a soma dos infinitos termos da PG 8, 4, 2, 1, 1/2, ...?",
    "options": [
      "16",
      "15",
      "32",
      "8"
    ],
    "correctIndex": 0,
    "explanation": "PG infinita convergente (|q| < 1): a₁ = 8, q = 1/2. S∞ = a₁/(1-q) = 8/(1-1/2) = 8/(1/2) = 16.",
    "example": "S∞ = 8/(1/2) = 16. Parciais: 8+4=12, +2=14, +1=15, +0,5=15,5... converge → 16."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Difícil__5",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Difícil",
    "question": "Numa PA, S₁₀ = 100 e S₂₀ = 400. Qual é S₃₀?",
    "options": [
      "900",
      "700",
      "600",
      "800"
    ],
    "correctIndex": 0,
    "explanation": "Em PA, as somas parciais S₁₀, S₂₀-S₁₀, S₃₀-S₂₀ formam PA. S₂₀-S₁₀ = 300. Diferença = 300-100 = 200. S₃₀-S₂₀ = 300+200 = 500. S₃₀ = 400+500 = 900.",
    "example": "Blocos de 10 termos: 100, 300 (difere 200). Próximo bloco: 300+200 = 500. S₃₀ = 100+300+500 = 900."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Difícil__6",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Difícil",
    "question": "Determine o valor de x para que (x, x+3, x+9) forme uma PG.",
    "options": [
      "3",
      "1",
      "6",
      "9"
    ],
    "correctIndex": 0,
    "explanation": "Em PG: (a₂)² = a₁ × a₃. (x+3)² = x(x+9). x²+6x+9 = x²+9x → 9 = 3x → x = 3. PG: 3, 6, 12 (q = 2).",
    "example": "(x+3)² = x(x+9) → 6x + 9 = 9x → x = 3. Verificação: 3, 6, 12 → q = 6/3 = 12/6 = 2 ✓."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Difícil__7",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Difícil",
    "question": "Se Sₙ = 3n² + 2n é a soma dos n primeiros termos de uma PA, qual é a₅?",
    "options": [
      "29",
      "27",
      "31",
      "35"
    ],
    "correctIndex": 0,
    "explanation": "aₙ = Sₙ - Sₙ₋₁ = (3n²+2n) - [3(n-1)²+2(n-1)] = 3n²+2n - 3n²+6n-3-2n+2 = 6n-1. a₅ = 6×5-1 = 29.",
    "example": "S₅ = 3×25+10 = 85. S₄ = 3×16+8 = 56. a₅ = 85-56 = 29. Ou: aₙ = 6n-1 → a₅ = 29."
  },
  {
    "id": "matematica__Progressões (PA e PG)__Difícil__8",
    "track": "matematica",
    "category": "Progressões (PA e PG)",
    "difficulty": "Difícil",
    "question": "A soma de uma PG infinita de primeiro termo 10 e razão 1/2 é qual?",
    "options": [
      "20",
      "15",
      "30",
      "Infinita"
    ],
    "correctIndex": 0,
    "explanation": "PG infinita converge quando |q| < 1. S = a_1 / (1 - q) = 10 / (1 - 1/2) = 10 / (1/2) = 20.",
    "example": "q=1/2 < 1 ⇒ converge. S = 10/(1-0,5) = 10/0,5 = 20. Termos: 10+5+2,5+1,25+...= 20. Zeno's paradox: soma infinita de frações pode convergir. |q|≥1 ⇒ diverge para infinito."
  },
  {
    "id": "matematica__Razão e Proporção__Fácil__1",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Fácil",
    "question": "Se a razão entre meninos e meninas em uma sala é 3:5 e há 15 meninos, quantas meninas há?",
    "options": [
      "25",
      "20",
      "30",
      "9"
    ],
    "correctIndex": 0,
    "explanation": "Razão 3:5 significa meninos/meninas = 3/5. Se meninos = 15: 3/5 = 15/x → 3x = 75 → x = 25 meninas.",
    "example": "3 partes = 15 alunos → 1 parte = 5 alunos. Meninas = 5 partes = 5 × 5 = 25."
  },
  {
    "id": "matematica__Razão e Proporção__Fácil__2",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Fácil",
    "question": "Qual é a razão entre 150 e 250 na forma simplificada?",
    "options": [
      "3:5",
      "3:4",
      "5:3",
      "15:25"
    ],
    "correctIndex": 0,
    "explanation": "150/250 = 15/25 = 3/5. Simplificando: MDC(150, 250) = 50. 150÷50 = 3, 250÷50 = 5. Razão: 3:5.",
    "example": "150 ÷ 50 = 3. 250 ÷ 50 = 5. Razão simplificada: 3:5 (ou 3/5 = 0,6)."
  },
  {
    "id": "matematica__Razão e Proporção__Fácil__3",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Fácil",
    "question": "Se 2 litros de tinta pintam 5 m² de parede, quantos litros são necessários para 20 m²?",
    "options": [
      "8 litros",
      "10 litros",
      "6 litros",
      "4 litros"
    ],
    "correctIndex": 0,
    "explanation": "Regra de três direta: 2/5 = x/20 → x = (2 × 20)/5 = 40/5 = 8 litros. Proporção: tinta e área são grandezas diretamente proporcionais.",
    "example": "Rendimento: 2L → 5 m². 1L → 2,5 m². Para 20 m²: 20/2,5 = 8 litros."
  },
  {
    "id": "matematica__Razão e Proporção__Fácil__4",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Fácil",
    "question": "Em uma turma, a razão entre aprovados e reprovados é 4:1. Se há 30 alunos, quantos foram aprovados?",
    "options": [
      "24",
      "20",
      "25",
      "28"
    ],
    "correctIndex": 0,
    "explanation": "Total de partes: 4 + 1 = 5. Cada parte: 30/5 = 6 alunos. Aprovados = 4 × 6 = 24. Reprovados = 1 × 6 = 6.",
    "example": "5 partes = 30 alunos. 1 parte = 6. Aprovados = 4 × 6 = 24. Reprovados = 6. 24/6 = 4/1 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Fácil__5",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Fácil",
    "question": "Se 3 kg de carne custam R$ 90, quanto custam 5 kg?",
    "options": [
      "R$ 150",
      "R$ 120",
      "R$ 135",
      "R$ 180"
    ],
    "correctIndex": 0,
    "explanation": "Proporção direta: 3/90 = 5/x → x = (5 × 90)/3 = 450/3 = R$ 150. Preço por kg: 90/3 = R$ 30.",
    "example": "Preço/kg: 90/3 = R$ 30. 5 kg: 5 × 30 = R$ 150."
  },
  {
    "id": "matematica__Razão e Proporção__Fácil__6",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Fácil",
    "question": "Uma receita para 6 pessoas usa 600g de arroz. Qual a quantidade para 4 pessoas?",
    "options": [
      "400g",
      "300g",
      "500g",
      "450g"
    ],
    "correctIndex": 0,
    "explanation": "Proporção direta: 6/600 = 4/x → x = (4×600)/6 = 400g. Rendimento: 100g por pessoa.",
    "example": "Por pessoa: 600/6 = 100g. Para 4 pessoas: 4 × 100 = 400g. Fator: 4/6 × 600 = 400g."
  },
  {
    "id": "matematica__Razão e Proporção__Fácil__7",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Fácil",
    "question": "Qual é a razão entre 800 mL e 2 litros?",
    "options": [
      "2:5",
      "4:10",
      "8:2",
      "1:3"
    ],
    "correctIndex": 0,
    "explanation": "Converter para mesma unidade: 2 L = 2000 mL. Razão: 800/2000 = 8/20 = 2/5. Logo, 2:5.",
    "example": "800 ÷ 400 = 2, 2000 ÷ 400 = 5. MDC(800,2000) = 400. Razão simplificada: 2:5."
  },
  {
    "id": "matematica__Razão e Proporção__Fácil__8",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Fácil",
    "question": "Se x/4 = 3/6, qual o valor de x?",
    "options": [
      "2",
      "3",
      "4",
      "8"
    ],
    "correctIndex": 0,
    "explanation": "Proporção: meios e extremos. 6x = 4×3 = 12. x = 2.",
    "example": "Produto cruzado (médio por extremo): x×6 = 4×3 ⇒ 6x=12 ⇒ x=2. Verificação: 2/4=0,5 e 3/6=0,5 ✓. Proporção: a/b = c/d ⇒ ad = bc."
  },
  {
    "id": "matematica__Razão e Proporção__Médio__1",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Médio",
    "question": "Divida R$ 720 entre A, B e C na proporção 2:3:4. Quanto recebe B?",
    "options": [
      "R$ 240",
      "R$ 160",
      "R$ 320",
      "R$ 180"
    ],
    "correctIndex": 0,
    "explanation": "Total de partes: 2 + 3 + 4 = 9. Valor de cada parte: 720/9 = R$ 80. B recebe 3 partes: 3 × 80 = R$ 240.",
    "example": "A = 2 × 80 = R$ 160. B = 3 × 80 = R$ 240. C = 4 × 80 = R$ 320. Verificação: 160 + 240 + 320 = 720 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Médio__2",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Médio",
    "question": "Se a/b = 3/4 e a + b = 35, qual é o valor de a?",
    "options": [
      "15",
      "20",
      "12",
      "21"
    ],
    "correctIndex": 0,
    "explanation": "Se a/b = 3/4, então a = 3k e b = 4k. a + b = 3k + 4k = 7k = 35 → k = 5. Logo a = 3 × 5 = 15.",
    "example": "a = 3k, b = 4k. 7k = 35 → k = 5. a = 15, b = 20. Verificação: 15/20 = 3/4 ✓ e 15+20 = 35 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Médio__3",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Médio",
    "question": "Uma receita para 4 pessoas usa 300g de farinha. Quanta farinha é necessária para 10 pessoas?",
    "options": [
      "750g",
      "600g",
      "500g",
      "1200g"
    ],
    "correctIndex": 0,
    "explanation": "Proporção direta: 4/300 = 10/x → x = (10 × 300)/4 = 3000/4 = 750g.",
    "example": "Por pessoa: 300/4 = 75g. Para 10 pessoas: 75 × 10 = 750g. Fator de escala: 10/4 = 2,5. 300 × 2,5 = 750g."
  },
  {
    "id": "matematica__Razão e Proporção__Médio__4",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Médio",
    "question": "Divida 90 em partes diretamente proporcionais a 1, 2 e 3.",
    "options": [
      "15, 30, 45",
      "10, 30, 50",
      "20, 30, 40",
      "30, 30, 30"
    ],
    "correctIndex": 0,
    "explanation": "Total de partes: 1 + 2 + 3 = 6. Cada parte: 90/6 = 15. Valores: 1×15 = 15, 2×15 = 30, 3×15 = 45.",
    "example": "6 partes = 90. 1 parte = 15. Divisão: 15, 30, 45. Soma: 15+30+45 = 90 ✓. Proporção: 1:2:3 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Médio__5",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Médio",
    "question": "Se a/b = 5/3, qual é o valor de (a + b)/(a - b)?",
    "options": [
      "4",
      "8/2",
      "5/3",
      "2"
    ],
    "correctIndex": 0,
    "explanation": "Faça a = 5k, b = 3k. (a+b)/(a-b) = (5k+3k)/(5k-3k) = 8k/2k = 4. O valor de k cancela.",
    "example": "a = 5k, b = 3k. Numerador: 8k. Denominador: 2k. Resultado: 4. Exemplo: a=10, b=6: (16)/(4) = 4 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Médio__6",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Médio",
    "question": "A escala de um mapa é 1:50000. Se a distância no mapa é 6 cm, qual a distância real em km?",
    "options": [
      "3 km",
      "30 km",
      "0,3 km",
      "300 km"
    ],
    "correctIndex": 0,
    "explanation": "Escala 1:50000 → 1 cm no mapa = 50000 cm reais = 500 m. 6 cm × 50000 = 300000 cm = 3000 m = 3 km.",
    "example": "6 × 50000 = 300000 cm. Converter: 300000 ÷ 100 = 3000 m. 3000 ÷ 1000 = 3 km."
  },
  {
    "id": "matematica__Razão e Proporção__Médio__7",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Médio",
    "question": "Se x e y são grandezas diretamente proporcionais e x = 12 quando y = 8, qual o valor de x quando y = 20?",
    "options": [
      "30",
      "24",
      "16",
      "40"
    ],
    "correctIndex": 0,
    "explanation": "Proporção direta: x/y = constante. 12/8 = x/20 → x = (12×20)/8 = 240/8 = 30.",
    "example": "k = x/y = 12/8 = 3/2. Para y=20: x = (3/2)×20 = 30. Verifica: 30/20 = 3/2 = 12/8 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Médio__8",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Médio",
    "question": "Divida R$ 280 em partes diretamente proporcionais a 2, 3 e 5.",
    "options": [
      "R$ 56, R$ 84, R$ 140",
      "R$ 70, R$ 70, R$ 140",
      "R$ 50, R$ 90, R$ 140",
      "R$ 56, R$ 98, R$ 126"
    ],
    "correctIndex": 0,
    "explanation": "Soma das partes: 2+3+5=10. Valor da unidade: 280/10=28. Partes: 2×28=56; 3×28=84; 5×28=140. Total: 56+84+140=280 ✓.",
    "example": "Proporcional a 2:3:5. Unidade=28. 2u=56, 3u=84, 5u=140. Dividir em partes inversamente proporcionais a 2,3,5: 1/2:1/3:1/5 ⇒ mão-comúm 30 ⇒ 15:10:6 ⇒ soma=31 ⇒ 280/31... diferente."
  },
  {
    "id": "matematica__Razão e Proporção__Difícil__1",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Difícil",
    "question": "Três números são inversamente proporcionais a 2, 3 e 6, e sua soma é 220. Qual é o maior número?",
    "options": [
      "120",
      "110",
      "60",
      "40"
    ],
    "correctIndex": 0,
    "explanation": "Inversamente proporcionais a 2, 3, 6 → proporcionais a 1/2, 1/3, 1/6. Simplificando com MMC(2,3,6)=6: 3, 2, 1. Total de partes: 3+2+1 = 6. Valor/parte: 220/6 ≈ 36,67. Maior = 3 partes = 3 × 220/6 = 660/6 = 110. Hmm, corrigindo: Proporcionais a 1/2, 1/3, 1/6 → multiplicando por 6: 3, 2, 1. Partes: 6. Cada parte: 220/6. Maior: 3 × 220/6 = 110.",
    "example": "Inversamente prop. a 2,3,6 → diretamente prop. a 1/2, 1/3, 1/6 → multiplicando por 6: 3, 2, 1. Soma partes = 6. Cada parte = 220/6 ≈ 36,67. Números: 110, 73,33, 36,67. Maior = 110."
  },
  {
    "id": "matematica__Razão e Proporção__Difícil__2",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Difícil",
    "question": "A, B e C são diretamente proporcionais a 2, 5 e 3. Se B - A = 60, qual é C?",
    "options": [
      "60",
      "40",
      "100",
      "30"
    ],
    "correctIndex": 0,
    "explanation": "A = 2k, B = 5k, C = 3k. B - A = 5k - 2k = 3k = 60 → k = 20. C = 3 × 20 = 60.",
    "example": "3k = 60 → k = 20. A = 40, B = 100, C = 60. Verificação: B-A = 100-40 = 60 ✓. Proporções: 40:100:60 = 2:5:3 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Difícil__3",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Difícil",
    "question": "Se x/y = 2/3 e y/z = 4/5, qual é a razão x:y:z?",
    "options": [
      "8:12:15",
      "2:3:5",
      "4:6:5",
      "2:4:5"
    ],
    "correctIndex": 0,
    "explanation": "Igualar o valor de y nas duas razões. x/y = 2/3 → x:y = 2:3 (×4 → 8:12). y/z = 4/5 → y:z = 4:5 (×3 → 12:15). Com y = 12 em ambas: x:y:z = 8:12:15.",
    "example": "x:y = 2:3 → ×4 → 8:12. y:z = 4:5 → ×3 → 12:15. y igualado em 12. x:y:z = 8:12:15."
  },
  {
    "id": "matematica__Razão e Proporção__Difícil__4",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Difícil",
    "question": "Divida 180 em partes inversamente proporcionais a 2, 3 e 6.",
    "options": [
      "90, 60, 30",
      "60, 60, 60",
      "30, 60, 90",
      "80, 60, 40"
    ],
    "correctIndex": 0,
    "explanation": "IP a 2,3,6 → DP a 1/2, 1/3, 1/6. Multiplicando por 6: 3, 2, 1. Total = 6 partes. 180/6 = 30. Valores: 90, 60, 30.",
    "example": "Partes: 3, 2, 1 (total 6). 3×30 = 90, 2×30 = 60, 1×30 = 30. Verifica: 90×2=180, 60×3=180, 30×6=180 (produtos iguais) ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Difícil__5",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Difícil",
    "question": "Se a/b = 2/3, b/c = 3/5 e a + b + c = 100, qual é o valor de c?",
    "options": [
      "50",
      "30",
      "20",
      "40"
    ],
    "correctIndex": 0,
    "explanation": "a:b = 2:3 e b:c = 3:5. O valor de b já é 3 em ambas, então a:b:c = 2:3:5. Total: 10. c = (5/10)×100 = 50.",
    "example": "a:b:c = 2:3:5. Total = 10 partes. 100/10 = 10 por parte. a=20, b=30, c=50. Verifica: 20/30=2/3 ✓, 30/50=3/5 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Difícil__6",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Difícil",
    "question": "Dois números estão na razão 5:8. Adicionando 10 a cada, a razão passa a ser 2:3. Quais são os números?",
    "options": [
      "50 e 80",
      "25 e 40",
      "30 e 48",
      "15 e 24"
    ],
    "correctIndex": 0,
    "explanation": "5k e 8k. (5k+10)/(8k+10) = 2/3. 3(5k+10) = 2(8k+10) → 15k+30 = 16k+20 → k = 10. Números: 50 e 80.",
    "example": "k=10: 50 e 80. Razão original: 50/80 = 5/8 ✓. Com +10: 60/90 = 2/3 ✓."
  },
  {
    "id": "matematica__Razão e Proporção__Difícil__7",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Difícil",
    "question": "Se x/y = 3/5 e (2x + 3y)/(x + y) = k, qual o valor de k?",
    "options": [
      "21/8",
      "9/5",
      "3",
      "15/8"
    ],
    "correctIndex": 0,
    "explanation": "Faça x = 3t e y = 5t. (2×3t + 3×5t)/(3t + 5t) = (6t + 15t)/(8t) = 21t/8t = 21/8.",
    "example": "x=3t, y=5t. Numerador: 6t+15t = 21t. Denominador: 3t+5t = 8t. k = 21/8 = 2,625."
  },
  {
    "id": "matematica__Razão e Proporção__Difícil__8",
    "track": "matematica",
    "category": "Razão e Proporção",
    "difficulty": "Difícil",
    "question": "Uma máquina produz 300 peças em 5 horas com 4 operários. Quantas peças produzem 6 operários em 8 horas?",
    "options": [
      "720 peças",
      "900 peças",
      "600 peças",
      "480 peças"
    ],
    "correctIndex": 0,
    "explanation": "Taxa: 300/(5×4) = 15 peças/hora/operário. 6 operários × 8 horas × 15 = 720 peças.",
    "example": "300 peças = 4 operários × 5 horas ⇒ 1 opérário×1 hora = 15 peças. 6×8 = 48 opérário-horas. 48×15 = 720. Regra de três dupla direta: X/300 = (6/4)×(8/5). X = 300×1,5×1,6 = 300×2,4 = 720."
  },
  {
    "id": "portugues__Acentuação Gráfica__Fácil__1",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Fácil",
    "question": "Qual das palavras abaixo é acentuada por ser proparoxítona?",
    "options": [
      "Lâmpada",
      "Café",
      "Também",
      "Júri"
    ],
    "correctIndex": 0,
    "explanation": "Proparoxítonas são palavras cuja sílaba tônica é a antepenúltima. Lâm-pa-da: a sílaba tônica é 'Lâm' (antepenúltima). Todas as proparoxítonas são acentuadas em português. Café é oxítona, também é paroxítona, júri é paroxítona.",
    "example": "'Lâmpada' → Lâm·pa·da (antepenúltima tônica = proparoxítona). Outros exemplos: médico, sílaba, árvore, matemática."
  },
  {
    "id": "portugues__Acentuação Gráfica__Fácil__2",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Fácil",
    "question": "Qual palavra é oxítona terminada em 'a' e, por isso, recebe acento?",
    "options": [
      "Sofá",
      "Casa",
      "Capa",
      "Mesa"
    ],
    "correctIndex": 0,
    "explanation": "'Sofá' é oxítona (última sílaba tônica: so-FÁ) terminada em 'a', por isso recebe acento. Oxítonas são acentuadas quando terminam em a(s), e(s), o(s), em/ens. Casa, capa e mesa são paroxítonas.",
    "example": "Sofá → so·fá (última tônica, terminada em 'a' = oxítona acentuada). Outros: café, dominó, armazém, parabéns."
  },
  {
    "id": "portugues__Acentuação Gráfica__Fácil__3",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Fácil",
    "question": "Em qual das palavras abaixo o acento é usado para indicar hiato?",
    "options": [
      "Saúde",
      "Também",
      "Lâmpada",
      "Café"
    ],
    "correctIndex": 0,
    "explanation": "'Saúde' (sa-ú-de) tem acento no 'ú' para indicar que o 'u' forma hiato com o 'a', ou seja, são vogais em sílabas diferentes. O acento marca a vogal 'i' ou 'u' tônica em hiato.",
    "example": "Hiato: sa·ú·de, ba·ú, sa·í·da. O 'i' e 'u' tônicos recebem acento quando formam hiato. Exceção: antes de 'nh' (rainha, moinho)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Fácil__4",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Fácil",
    "question": "Qual palavra é acentuada por ser proparoxítona?",
    "options": [
      "Árvore",
      "Café",
      "Também",
      "Avô"
    ],
    "correctIndex": 0,
    "explanation": "'Árvore' é proparoxítona (ár-vo-re: sílaba tônica na antepenúltima posição). Regra: TODAS as proparoxítonas são acentuadas, sem exceção. Café (oxítona), também (oxítona) e avô (oxítona) seguem outras regras.",
    "example": "Proparoxítonas (todas acentuadas): árvore, lâmpada, médico, paralelepípedo, pêssego, sílaba. É a regra mais fácil: encontrou proparoxítona, acentue."
  },
  {
    "id": "portugues__Acentuação Gráfica__Fácil__5",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Fácil",
    "question": "Na palavra 'café', por que há acento?",
    "options": [
      "É oxítona terminada em 'e'",
      "É paroxítona terminada em 'e'",
      "É proparoxítona",
      "Tem acento diferencial"
    ],
    "correctIndex": 0,
    "explanation": "'Café' (ca-fé) é oxítona — a sílaba tônica é a última. Oxítonas são acentuadas quando terminam em: a(s), e(s), o(s), em/ens. 'Café' termina em 'e', por isso recebe acento.",
    "example": "Oxítonas acentuadas: café (-é), sofá (-á), avô (-ô), armazém (-ém), parabéns (-éns). Sem acento: abacaxi (-i), urubu (-u), talvez (-z)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Fácil__6",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Fácil",
    "question": "A palavra 'saída' recebe acento por quê?",
    "options": [
      "O 'i' tônico forma hiato com a vogal anterior",
      "É proparoxítona",
      "É oxítona terminada em 'a'",
      "Tem acento diferencial"
    ],
    "correctIndex": 0,
    "explanation": "'Saída' (sa·í·da) tem acento porque o 'i' tônico forma hiato com o 'a'. Regra: 'i' e 'u' tônicos são acentuados quando formam hiato, sozinhos na sílaba ou com 's'.",
    "example": "sa·í·da: hiato a-í. Outros: ba·ú, ju·í·za, sa·ís·te. Exceção: antes de 'nh' (rainha, moinho)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Fácil__7",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Fácil",
    "question": "A palavra 'também' é acentuada por quê?",
    "options": [
      "É oxítona terminada em 'em'",
      "É paroxítona terminada em 'em'",
      "É proparoxítona",
      "Tem acento diferencial"
    ],
    "correctIndex": 0,
    "explanation": "'Também' (tam·bém) é oxítona — sílaba tônica é a última. Oxítonas terminadas em 'em' ou 'ens' recebem acento: armazém, parabéns, também.",
    "example": "Oxítonas em -em/-ens: também, armazém, parabéns. Paroxítonas em -em/-ens NÃO: item, jovem, homens."
  },
  {
    "id": "portugues__Acentuação Gráfica__Fácil__8",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Fácil",
    "question": "Por que a palavra 'herói' perde o acento no novo Acordo Ortográfico?",
    "options": [
      "Pela regra do hiato: encontros vocálicos 'oi', 'ei' tônicos em palavras paroxítonas deixam de ser acentuados após o Acordo de 1990/2009",
      "Porque 'herói' passou a ser palavra oxítona",
      "Porque ditongos nunca são acentuados no português",
      "O h inicial suprime o acento por regra especial"
    ],
    "correctIndex": 0,
    "explanation": "Acordo Ortográfico de 1990 (vigente no Brasil desde 2009): ditongos abertos 'éi', 'ói' em palavras paroxítonas (acento na penúltima sílaba) perderam o acento. Herói (oxítona) manteve. Assembléia, ideia, jiboia — sem acento. Herói: oxitona, é conservado pois regra só suprime em paroxítonas.",
    "example": "Antes: assembléia, ideia, plateia, heróis (paroxítona). Após 2009: assembleia, ideia, plateia — sem acento. Herói (oxítona) e país (hiato) mantiveram acento. Regra geral: acento diferencial também eliminou: pôr/por, pêle/pele, pêlo/pelo — acento diferencial suprimido."
  },
  {
    "id": "portugues__Acentuação Gráfica__Médio__1",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Médio",
    "question": "Após o Novo Acordo Ortográfico, qual palavra perdeu o acento?",
    "options": [
      "Ideia",
      "Herói",
      "Céu",
      "Papéis"
    ],
    "correctIndex": 0,
    "explanation": "O Novo Acordo Ortográfico (2009) eliminou o acento dos ditongos abertos 'ei' e 'oi' em paroxítonas. 'Ideia' (antes 'idéia') perdeu o acento. Herói, céu e papéis mantêm o acento por serem oxítonas ou monossílabos tônicos.",
    "example": "Antes: idéia, assembléia, jibóia. Depois: ideia, assembleia, jiboia. Mantêm acento: herói, anéis, céu (oxítonas/monossílabos)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Médio__2",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Médio",
    "question": "Qual é a regra de acentuação para paroxítonas?",
    "options": [
      "São acentuadas quando NÃO terminam em a(s), e(s), o(s), em/ens",
      "São sempre acentuadas",
      "Nunca são acentuadas",
      "São acentuadas quando terminam em a(s), e(s), o(s)"
    ],
    "correctIndex": 0,
    "explanation": "Paroxítonas são acentuadas quando terminam em: l, n, r, x, ps, ã(s), ão(s), i(s), u(s), um/uns, ditongo. Ou seja, quando NÃO terminam nas terminações típicas (a, e, o, em, ens). Exemplos: fácil, hífen, caráter.",
    "example": "Acentuadas: fácil (-l), hífen (-n), caráter (-r), tórax (-x), bíceps (-ps), órgão (-ão), júri (-i), bônus (-us). Não acentuadas: casa (-a), parede (-e), livro (-o)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Médio__3",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Médio",
    "question": "Qual palavra recebe acento diferencial?",
    "options": [
      "Pôr (verbo)",
      "Para (preposição)",
      "Pelo (substantivo)",
      "Polo (substantivo)"
    ],
    "correctIndex": 0,
    "explanation": "Após o Novo Acordo, poucos acentos diferenciais permanecem. 'Pôr' (verbo) mantém o acento para diferenciar de 'por' (preposição). 'Pôde' (passado) diferencia de 'pode' (presente). 'Para', 'pelo' e 'polo' perderam o acento diferencial.",
    "example": "Acentos diferenciais mantidos: pôr/por, pôde/pode, têm/tem, vêm/vem (3ª pessoa plural vs singular). Abolidos: pára/para, pélo/pelo, pólo/polo."
  },
  {
    "id": "portugues__Acentuação Gráfica__Médio__4",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Médio",
    "question": "Qual das palavras abaixo manteve o acento após o Novo Acordo Ortográfico?",
    "options": [
      "Herói",
      "Ideia",
      "Jiboia",
      "Assembleia"
    ],
    "correctIndex": 0,
    "explanation": "'Herói' manteve o acento porque é oxítona terminada em ditongo aberto 'ói'. O Novo Acordo só retirou o acento dos ditongos abertos 'ei' e 'oi' em paroxítonas (ideia, jiboia, assembleia).",
    "example": "Mantêm acento (oxítonas/monossílabos): herói, anéis, chapéu, céu, dói. Perderam acento (paroxítonas): ideia, jiboia, assembleia, estreia, paranoia."
  },
  {
    "id": "portugues__Acentuação Gráfica__Médio__5",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Médio",
    "question": "A palavra 'bíceps' recebe acento por quê?",
    "options": [
      "É paroxítona terminada em 'ps'",
      "É proparoxítona",
      "É oxítona terminada em 's'",
      "Tem acento diferencial"
    ],
    "correctIndex": 0,
    "explanation": "'Bíceps' (bí-ceps) é paroxítona terminada em 'ps' — uma das terminações que exigem acento em paroxítonas. Outras terminações: l, n, r, x, i(s), u(s), ã(s), ão(s), um/uns, ditongo.",
    "example": "Paroxítonas terminadas em 'ps': bíceps, fórceps, tríceps. Compare com paroxítonas sem acento: casa (-a), parede (-e), livro (-o), homem (-em)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Médio__6",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Médio",
    "question": "Qual regra justifica o acento em 'túnel'?",
    "options": [
      "Paroxítona terminada em 'l'",
      "Oxítona terminada em 'l'",
      "Proparoxítona",
      "Acento diferencial"
    ],
    "correctIndex": 0,
    "explanation": "'Túnel' (tú·nel) é paroxítona terminada em 'l' — uma das terminações que obrigam acento em paroxítonas. Outras: n, r, x, ps, ã, ão, i, u, um/uns, ditongo.",
    "example": "Paroxítonas com 'l': túnel, fácil, amável, possível. Com 'n': hífen, pólen. Com 'r': caráter, açúcar."
  },
  {
    "id": "portugues__Acentuação Gráfica__Médio__7",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Médio",
    "question": "Após o Novo Acordo Ortográfico, o trema foi abolido. Qual grafia está correta?",
    "options": [
      "Linguiça",
      "Lingüiça",
      "Freqüente",
      "Seqüência"
    ],
    "correctIndex": 0,
    "explanation": "O trema (¨) foi totalmente abolido pelo Novo Acordo. Antes: lingüiça, freqüente, seqüência. Agora: linguiça, frequente, sequência. A pronúncia não muda.",
    "example": "Antes → depois: lingüiça → linguiça, freqüente → frequente, tranqüilo → tranquilo. Exceção: nomes próprios estrangeiros (Müller)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Médio__8",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Médio",
    "question": "Qual das palavras a seguir está acentuada corretamente segundo a norma vigente?",
    "options": [
      "idôneo",
      "Idôneo",
      "idôneo",
      "idóeno"
    ],
    "correctIndex": 0,
    "explanation": "'Idôneo' está correta. Palavra proparoxítona (acento na antepenúltima sílaba): i-DÔ-ne-o. Todas as proparoxítonas são acentuadas obrigatoriamente. 'ô' é a vogal tônica correta; 'idoeno' incorreto.",
    "example": "Proparoxítonas: sempre acentuadas. Idôneo, médico, equívoco, índice. Paroxítonas terminadas em L, N, R, X, PS, ã(s), ão(s), ditongo: acentuadas. Oxítonas terminadas em A(s), E(s), O(s), EM, ENS: acentuadas."
  },
  {
    "id": "portugues__Acentuação Gráfica__Difícil__1",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Difícil",
    "question": "Assinale a alternativa em que TODAS as palavras estão corretamente acentuadas conforme o Novo Acordo Ortográfico:",
    "options": [
      "Frequência, bônus, compreensível, ritmo",
      "Freqüência, bônus, compreensível, rítmo",
      "Frequência, bonus, compreensível, ritmo",
      "Frequência, bônus, compreensivel, ritmo"
    ],
    "correctIndex": 0,
    "explanation": "Frequência (paroxítona terminada em ditongo), bônus (paroxítona terminada em 'us'), compreensível (paroxítona terminada em 'l'), ritmo (paroxítona terminada em 'o' — não acentuada). O trema foi abolido e 'rítmo' nunca teve acento.",
    "example": "Erros comuns: 'freqüência' (trema abolido), 'rítmo' (paroxítona terminada em 'o' não leva acento), 'bonus' (paroxítona terminada em 'us' obriga acento: bônus)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Difícil__2",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Difícil",
    "question": "Por que a palavra 'feiura' perdeu o acento no Novo Acordo Ortográfico?",
    "options": [
      "O hiato com 'u' tônico após ditongo não é mais acentuado",
      "Tornou-se paroxítona terminada em 'a'",
      "O trema foi abolido",
      "Passou a ser oxítona"
    ],
    "correctIndex": 0,
    "explanation": "Antes: 'feiúra'. O Novo Acordo eliminou o acento do hiato quando o 'i' ou 'u' vem após ditongo: fei-u-ra (ditongo 'ei' + hiato 'u'). A regra do hiato acentuado não se aplica mais após ditongo.",
    "example": "Antes: feiúra, baiúca. Depois: feiura, baiuca. Mas mantém-se: Piauí (oxítona), saúde (não há ditongo antes do 'u')."
  },
  {
    "id": "portugues__Acentuação Gráfica__Difícil__3",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Difícil",
    "question": "Em qual alternativa há ERRO de acentuação?",
    "options": [
      "Ítem",
      "Armazém",
      "Hífen",
      "Bônus"
    ],
    "correctIndex": 0,
    "explanation": "'Item' é paroxítona terminada em 'em' — não recebe acento (segue a regra: paroxítonas terminadas em 'em/ens' NÃO são acentuadas). O plural 'itens' também não tem acento. 'Armazém' é oxítona terminada em 'em' — acentuada.",
    "example": "Item (paroxítona, -em, sem acento). Armazém (oxítona, -em, com acento). Compare: jovem (parox. sem acento) × também (oxít. com acento). Hífen e bônus: paroxítonas acentuadas (-n e -us)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Difícil__4",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Difícil",
    "question": "Qual regra justifica o acento em 'saíste'?",
    "options": [
      "Hiato com 'i' tônico formando sílaba sozinha ou com 's'",
      "Paroxítona terminada em 'e'",
      "Proparoxítona",
      "Acento diferencial"
    ],
    "correctIndex": 0,
    "explanation": "'Saíste' (sa-ís-te) tem acento porque o 'i' tônico forma hiato com a vogal anterior ('a'). A regra: 'i' e 'u' tônicos recebem acento quando formam hiato, sozinhos na sílaba ou seguidos de 's'.",
    "example": "Hiato com i/u acentuado: sa·í·da, ba·ú, sa·ís·te, ju·í·za. Exceções: antes de 'nh' (rainha), após ditongo em paroxítonas (feiura)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Difícil__5",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Difícil",
    "question": "Em 'Eles intervêm no processo', por que 'intervêm' tem acento circunflexo?",
    "options": [
      "Acento diferencial de plural: 3ª pessoa do plural de 'intervir'",
      "Oxítona terminada em 'em'",
      "Paroxítona terminada em 'em'",
      "Proparoxítona"
    ],
    "correctIndex": 0,
    "explanation": "'Intervêm' (3ª pessoa do plural de 'intervir') recebe acento circunflexo para diferenciá-lo do singular 'intervém' (acento agudo). É acento diferencial de número em verbos derivados de 'ter' e 'vir'.",
    "example": "Ele vem/tem → Eles vêm/têm. Ele intervém/mantém → Eles intervêm/mantêm. O circunflexo marca o plural; o agudo marca o singular dos derivados."
  },
  {
    "id": "portugues__Acentuação Gráfica__Difícil__6",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Difícil",
    "question": "Em 'Eles têm razão', por que 'têm' (verbo ter) recebe acento circunflexo?",
    "options": [
      "Acento diferencial de número: 3ª pessoa do plural",
      "É oxítona terminada em 'em'",
      "É paroxítona terminada em 'em'",
      "É proparoxítona"
    ],
    "correctIndex": 0,
    "explanation": "'Têm' recebe acento circunflexo para diferenciar do singular 'tem'. É acento diferencial de número, mantido pelo Novo Acordo para os verbos 'ter' e 'vir' (e derivados).",
    "example": "Ele tem/vem (sem acento) → Eles têm/vêm (circunflexo). Derivados: ele mantém (agudo) → eles mantêm (circunflexo)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Difícil__7",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Difícil",
    "question": "Em qual caso o 'i' ou 'u' tônico em hiato NÃO recebe acento?",
    "options": [
      "Quando seguido de 'nh': rainha, moinho",
      "Quando precedido de consoante",
      "Quando está no início da palavra",
      "Quando está em monossílabo"
    ],
    "correctIndex": 0,
    "explanation": "O 'i' e 'u' tônicos em hiato NÃO recebem acento quando seguidos de 'nh' na sílaba seguinte: rainha (ra·i·nha), moinho (mo·i·nho), tainha. Também não quando após ditongo em paroxítonas (feiura).",
    "example": "Sem acento: rainha, moinho, tainha, feiura, baiuca. Com acento: saída, baú, juíza (não há 'nh' nem ditongo anterior)."
  },
  {
    "id": "portugues__Acentuação Gráfica__Difícil__8",
    "track": "portugues",
    "category": "Acentuação Gráfica",
    "difficulty": "Difícil",
    "question": "Em qual das alternativas todos os vocábulos são acentuados por regras diferentes?",
    "options": [
      "Café (oxítona), árido (proparoxítona), lápis (paroxítona term. 's')",
      "Café (oxítona), líder (oxítona), médico (proparoxítona)",
      "éramos (proparoxítona), pensão (ditongo), árido (proparoxítona)",
      "Saúde (hiato), pá (oxítona term. a), médico (proparoxítona)"
    ],
    "correctIndex": 0,
    "explanation": "Café: oxítona terminada em E. Árido: proparoxítona. Lápis: paroxítona terminada em S precedida de vogal. Três regras distintas. Opção B: 'líder' é paroxítona, não oxítona; regra B repete duas oxítonas.",
    "example": "Café: oxítona (acento na última), termina em E. Árido: proparoxítona, sempre acentuada. Lápis: paroxítona terminada em S precedido de vogal — regra de paroxítona. Identificá-las separadamente é fundamental para prova de acentuação."
  },
  {
    "id": "portugues__Classes de Palavras__Fácil__1",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Fácil",
    "question": "Na frase 'O gato preto dormiu no sofá', qual é a classe gramatical de 'preto'?",
    "options": [
      "Adjetivo",
      "Substantivo",
      "Advérbio",
      "Pronome"
    ],
    "correctIndex": 0,
    "explanation": "'Preto' qualifica o substantivo 'gato', atribuindo-lhe uma característica. Palavras que modificam substantivos indicando qualidade, estado ou característica são adjetivos.",
    "example": "Gato → substantivo (ser). Preto → adjetivo (qualidade do ser). Dormiu → verbo (ação). No = em + o → contração de preposição + artigo."
  },
  {
    "id": "portugues__Classes de Palavras__Fácil__2",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Fácil",
    "question": "Qual é a classe gramatical da palavra 'rapidamente'?",
    "options": [
      "Advérbio",
      "Adjetivo",
      "Substantivo",
      "Pronome"
    ],
    "correctIndex": 0,
    "explanation": "'Rapidamente' é um advérbio de modo — modifica o verbo indicando como a ação é realizada. Advérbios terminados em '-mente' são formados a partir de adjetivos: rápido → rapidamente, feliz → felizmente.",
    "example": "Ele correu rapidamente. 'Rapidamente' modifica o verbo 'correu' (como correu?). Advérbio é invariável: não muda em gênero nem número."
  },
  {
    "id": "portugues__Classes de Palavras__Fácil__3",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Fácil",
    "question": "Na frase 'Aqueles livros são meus', qual é a classe de 'aqueles'?",
    "options": [
      "Pronome demonstrativo",
      "Artigo definido",
      "Pronome possessivo",
      "Adjetivo"
    ],
    "correctIndex": 0,
    "explanation": "'Aqueles' é pronome demonstrativo — indica posição espacial ou temporal em relação ao falante. Pronomes demonstrativos: este/esse/aquele (e flexões). 'Aquele' indica algo distante do falante e do ouvinte.",
    "example": "Este (perto de quem fala), esse (perto de quem ouve), aquele (longe de ambos). Aqueles livros = livros distantes. Meus = pronome possessivo."
  },
  {
    "id": "portugues__Classes de Palavras__Fácil__4",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Fácil",
    "question": "Em 'Maria corre rápido', qual é a classe gramatical de 'rápido'?",
    "options": [
      "Advérbio",
      "Adjetivo",
      "Substantivo",
      "Verbo"
    ],
    "correctIndex": 0,
    "explanation": "'Rápido' aqui funciona como advérbio de modo — modifica o verbo 'corre', indicando a maneira como Maria corre. Compare: 'carro rápido' (adjetivo, modifica substantivo) × 'corre rápido' (advérbio, modifica verbo).",
    "example": "Advérbio modifica verbo, adjetivo ou outro advérbio. Adjetivo modifica substantivo. 'Rápido' é adjetivo em 'carro rápido' e advérbio em 'fala rápido'."
  },
  {
    "id": "portugues__Classes de Palavras__Fácil__5",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Fácil",
    "question": "Na frase 'Aquela casa é bonita', qual é a classe gramatical de 'casa'?",
    "options": [
      "Substantivo",
      "Verbo",
      "Adjetivo",
      "Advérbio"
    ],
    "correctIndex": 0,
    "explanation": "'Casa' é um substantivo — nomeia um ser/objeto. É o núcleo do sujeito 'aquela casa'. Substantivos designam seres, objetos, lugares, sentimentos e conceitos.",
    "example": "'Casa' pode ser substantivo ('A casa é grande') ou verbo ('Ela se casa amanhã'). Aqui, precedido do demonstrativo 'aquela', é substantivo."
  },
  {
    "id": "portugues__Classes de Palavras__Fácil__6",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Fácil",
    "question": "Na frase 'Ela comprou três livros', qual é a classe gramatical de 'três'?",
    "options": [
      "Numeral cardinal",
      "Adjetivo",
      "Pronome indefinido",
      "Advérbio"
    ],
    "correctIndex": 0,
    "explanation": "'Três' é numeral cardinal — indica quantidade exata. Numerais cardinais: um, dois, três, quatro... Diferem dos pronomes indefinidos, que indicam quantidade vaga (alguns, muitos).",
    "example": "Cardinais: três livros (quantidade exata). Ordinais: terceiro lugar (posição). Multiplicativos: triplo (multiplicação). Fracionários: um terço (fração)."
  },
  {
    "id": "portugues__Classes de Palavras__Fácil__7",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Fácil",
    "question": "Em 'O sol brilha forte', qual é a classe gramatical de 'sol'?",
    "options": [
      "Substantivo",
      "Adjetivo",
      "Verbo",
      "Pronome"
    ],
    "correctIndex": 0,
    "explanation": "'Sol' é um substantivo — nomeia um ser/coisa. É o núcleo do sujeito 'O sol'. Está acompanhado do artigo definido 'O', confirmando sua função substantiva.",
    "example": "Sol = substantivo concreto, comum, simples, primitivo. Artigo 'O' + substantivo 'sol' = sintagma nominal (sujeito)."
  },
  {
    "id": "portugues__Classes de Palavras__Fácil__8",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Fácil",
    "question": "Na frase 'Ele correu rapidamente', qual a classe gramatical de 'rapidamente'?",
    "options": [
      "Advérbio de modo",
      "Adjetivo",
      "Locução adverbial",
      "Predicativo do sujeito"
    ],
    "correctIndex": 0,
    "explanation": "Advérbios de modo geralmente terminam em '-mente'. Modificam o verbo 'correu' indicando como a ação aconteceu. Adjetivos modificam substantivos; aqui não modifica substantivo.",
    "example": "Rapidamente: advérbio de modo. Outros modos: bem, mal, assim, devagar. 'Correu rápido': rápido como predicativo do sujeito (informal) ou advérbio de modo. '-mente' = morfema de advérbio em português."
  },
  {
    "id": "portugues__Classes de Palavras__Médio__1",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Médio",
    "question": "Em 'Ela mesma fez o bolo', a palavra 'mesma' é classificada como:",
    "options": [
      "Pronome demonstrativo de reforço",
      "Advérbio",
      "Adjetivo",
      "Conjunção"
    ],
    "correctIndex": 0,
    "explanation": "'Mesma' funciona como pronome demonstrativo de reforço (enfático), concordando em gênero e número com o pronome 'ela'. Reforça que a ação foi praticada pela própria pessoa. Seria advérbio se fosse invariável (ex: 'mesmo assim').",
    "example": "Ela mesma (pronome de reforço, concorda: ele mesmo, elas mesmas). Compare com: 'Fiz mesmo o trabalho' (advérbio = realmente, invariável)."
  },
  {
    "id": "portugues__Classes de Palavras__Médio__2",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Médio",
    "question": "Na frase 'Comprei dois quilos de arroz', a palavra 'dois' é:",
    "options": [
      "Numeral cardinal",
      "Adjetivo",
      "Pronome indefinido",
      "Advérbio"
    ],
    "correctIndex": 0,
    "explanation": "'Dois' é um numeral cardinal — indica quantidade exata. Numerais podem ser cardinais (um, dois), ordinais (primeiro, segundo), multiplicativos (dobro, triplo) ou fracionários (meio, terço).",
    "example": "Dois quilos: numeral cardinal (quantidade). Segundo lugar: numeral ordinal (ordem). O dobro: numeral multiplicativo. Um terço: numeral fracionário."
  },
  {
    "id": "portugues__Classes de Palavras__Médio__3",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Médio",
    "question": "Em 'Ninguém sabe a verdade', a palavra 'ninguém' é:",
    "options": [
      "Pronome indefinido",
      "Substantivo",
      "Advérbio de negação",
      "Conjunção"
    ],
    "correctIndex": 0,
    "explanation": "'Ninguém' é pronome indefinido — refere-se a pessoa de forma vaga, indeterminada. Pronomes indefinidos: ninguém, alguém, nenhum, todo, cada, qualquer, algo, nada, outro, vários.",
    "example": "Pronomes indefinidos: alguém/ninguém (pessoas), algo/nada (coisas), algum/nenhum, todo, cada, qualquer. Indicam quantidade ou identidade de forma imprecisa."
  },
  {
    "id": "portugues__Classes de Palavras__Médio__4",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Médio",
    "question": "Em 'Choveu muito ontem', qual a classe gramatical de 'muito'?",
    "options": [
      "Advérbio de intensidade",
      "Pronome indefinido",
      "Adjetivo",
      "Numeral"
    ],
    "correctIndex": 0,
    "explanation": "'Muito' aqui é advérbio de intensidade — modifica o verbo 'choveu', indicando a intensidade da ação. Quando invariável e modificando verbo, adjetivo ou advérbio, 'muito' é advérbio.",
    "example": "'Muito' como advérbio (invariável): choveu muito, muito bonito. 'Muito' como pronome indefinido (variável): muitos alunos, muitas casas. Dica: se flexiona, é pronome."
  },
  {
    "id": "portugues__Classes de Palavras__Médio__5",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Médio",
    "question": "Na frase 'Saímos cedo, porém voltamos tarde', a palavra 'porém' é:",
    "options": [
      "Conjunção adversativa",
      "Advérbio",
      "Preposição",
      "Pronome relativo"
    ],
    "correctIndex": 0,
    "explanation": "'Porém' é conjunção coordenativa adversativa — indica oposição entre as orações. Conecta ideias contrárias: saímos cedo (ideia 1) × voltamos tarde (ideia oposta).",
    "example": "Conjunções adversativas: mas, porém, contudo, todavia, entretanto, no entanto. Todas expressam oposição/contraste."
  },
  {
    "id": "portugues__Classes de Palavras__Médio__6",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Médio",
    "question": "Em 'Ele estudou bastante para a prova', a palavra 'bastante' é:",
    "options": [
      "Advérbio de intensidade",
      "Pronome indefinido",
      "Adjetivo",
      "Numeral"
    ],
    "correctIndex": 0,
    "explanation": "'Bastante' aqui é advérbio de intensidade — modifica o verbo 'estudou', indicando intensidade. É invariável neste contexto. Compare: 'bastantes livros' (pronome, variável).",
    "example": "Advérbio (invariável): estudou bastante, é bastante bonito. Pronome (variável): bastantes razões, bastantes alunos. Dica: se flexiona, é pronome."
  },
  {
    "id": "portugues__Classes de Palavras__Médio__7",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Médio",
    "question": "Na frase 'Embora chova, sairemos', a palavra 'embora' é:",
    "options": [
      "Conjunção subordinativa concessiva",
      "Advérbio de lugar",
      "Preposição",
      "Conjunção coordenativa adversativa"
    ],
    "correctIndex": 0,
    "explanation": "'Embora' é conjunção subordinativa concessiva — introduz uma oração que expressa concessão (apesar de chover, ainda assim sairemos). Outras concessivas: ainda que, mesmo que, conquanto.",
    "example": "Concessivas: embora, ainda que, mesmo que, conquanto, se bem que. 'Embora' também pode ser advérbio: 'Vá embora' (= vá daqui)."
  },
  {
    "id": "portugues__Classes de Palavras__Médio__8",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Médio",
    "question": "Em 'Comprei três livros interessantes', identifique corretamente as classes de 'três' e 'interessantes'.",
    "options": [
      "Numeral cardinal e adjetivo qualificativo",
      "Adjetivo e substantivo",
      "Pronome e adjetivo",
      "Numeral e substantivo"
    ],
    "correctIndex": 0,
    "explanation": "'Três': numeral cardinal (quantidade exata). 'Interessantes': adjetivo qualificativo (atribui qualidade ao substantivo 'livros'). Numerais quantificam; adjetivos qualificam ou determinam.",
    "example": "Numerais: um, dois, três... (cardinais); primeiro, segundo... (ordinais); dobro, triplo... (multiplicativos); metade, terço... (fracionários). Adjetivos qualificativos: belo, inteligente, interessante."
  },
  {
    "id": "portugues__Classes de Palavras__Difícil__1",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Difícil",
    "question": "Em 'O jantar foi servido às oito', qual é a classe gramatical da palavra 'jantar'?",
    "options": [
      "Substantivo",
      "Verbo",
      "Adjetivo",
      "Advérbio"
    ],
    "correctIndex": 0,
    "explanation": "'Jantar', originalmente um verbo, aqui funciona como substantivo — é precedido pelo artigo 'O'. Esse fenômeno se chama derivação imprópria (ou conversão): a mudança de classe gramatical sem alteração na forma da palavra.",
    "example": "Compare: 'Vou jantar às oito' (verbo) × 'O jantar está pronto' (substantivo). A presença do artigo 'O' antes de 'jantar' indica substantivação. Outros exemplos: 'o saber', 'o andar', 'o viver'."
  },
  {
    "id": "portugues__Classes de Palavras__Difícil__2",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Difícil",
    "question": "Em 'Ele ficou triste com a notícia', a palavra 'triste' funciona como:",
    "options": [
      "Predicativo do sujeito",
      "Objeto direto",
      "Adjunto adnominal",
      "Advérbio"
    ],
    "correctIndex": 0,
    "explanation": "'Triste' é adjetivo funcionando como predicativo do sujeito — atribui uma qualidade ao sujeito ('ele') por meio do verbo de ligação 'ficou'. Verbos de ligação: ser, estar, ficar, parecer, permanecer, continuar, tornar-se.",
    "example": "Ele ficou triste. Sujeito = ele, VL = ficou, predicativo = triste (estado atribuído ao sujeito). Predicativo do sujeito sempre acompanha verbo de ligação."
  },
  {
    "id": "portugues__Classes de Palavras__Difícil__3",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre 'mau' e 'mal'?",
    "options": [
      "'Mau' é adjetivo (oposto de bom); 'mal' é advérbio (oposto de bem)",
      "São sinônimos e intercambiáveis",
      "'Mau' é advérbio e 'mal' é adjetivo",
      "Ambos são conjunções"
    ],
    "correctIndex": 0,
    "explanation": "'Mau' é adjetivo (modifica substantivo): 'mau aluno' (oposto: 'bom aluno'). 'Mal' é advérbio (modifica verbo): 'dormiu mal' (oposto: 'dormiu bem'). Dica: substitua por bom/bem para saber qual usar.",
    "example": "Mau humor (bom humor → adjetivo). Mal-educado (bem-educado → advérbio). 'Mal' também pode ser substantivo: 'O mal do século.' ou conjunção temporal: 'Mal chegou, saiu.'"
  },
  {
    "id": "portugues__Classes de Palavras__Difícil__4",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Difícil",
    "question": "Em 'Os porquês da ciência são fascinantes', a classe gramatical de 'porquês' é:",
    "options": [
      "Substantivo",
      "Conjunção",
      "Advérbio",
      "Preposição"
    ],
    "correctIndex": 0,
    "explanation": "'Porquês' é substantivo — está precedido pelo artigo 'os' e recebe flexão de plural. Quando substantivado, 'porquê' significa 'motivo, razão'. Aceita plural e determinantes.",
    "example": "4 porquês: por que (separado, pergunta/relativo), porque (junto, causa), por quê (separado + acento, fim de frase), porquê (junto + acento, substantivo = motivo)."
  },
  {
    "id": "portugues__Classes de Palavras__Difícil__5",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Difícil",
    "question": "Na frase 'Há bastantes razões para sair', a palavra 'bastantes' funciona como:",
    "options": [
      "Pronome indefinido adjetivo",
      "Advérbio",
      "Adjetivo qualificativo",
      "Numeral"
    ],
    "correctIndex": 0,
    "explanation": "'Bastantes' é pronome indefinido adjetivo — acompanha e concorda com o substantivo 'razões'. Quando variável (concordando com o substantivo), 'bastante' é pronome indefinido. Quando invariável (Ela é bastante inteligente), é advérbio.",
    "example": "Bastantes (variável) = pronome indefinido: bastantes livros/bastantes razões. Bastante (invariável) = advérbio de intensidade: bastante cansada. Dica: se flexiona, é pronome."
  },
  {
    "id": "portugues__Classes de Palavras__Difícil__6",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Difícil",
    "question": "Na frase 'O andar dele é elegante', a palavra 'andar' é:",
    "options": [
      "Substantivo",
      "Verbo",
      "Adjetivo",
      "Advérbio"
    ],
    "correctIndex": 0,
    "explanation": "'Andar' aqui é substantivo — precedido pelo artigo 'O', sofreu derivação imprópria (substantivação do verbo). Compare: 'Ele vai andar' (verbo). O artigo antes de um verbo indica substantivação.",
    "example": "Substantivação: O andar (modo de caminhar), O saber (conhecimento), O viver (existência). Artigo + infinitivo = substantivo."
  },
  {
    "id": "portugues__Classes de Palavras__Difícil__7",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Difícil",
    "question": "Em 'Estou meio cansada', a palavra 'meio' funciona como:",
    "options": [
      "Advérbio de intensidade (= um pouco)",
      "Numeral fracionário (= metade)",
      "Adjetivo",
      "Substantivo"
    ],
    "correctIndex": 0,
    "explanation": "'Meio' aqui é advérbio de intensidade (= um pouco). Advérbio é invariável — não concorda com 'cansada'. 'Meia cansada' seria erro, pois advérbio não flexiona. Compare: 'meia hora' (numeral, variável).",
    "example": "Advérbio (invariável): meio cansada, meio triste. Numeral (variável): meia hora, meio litro, meias palavras. Dica: substitua por 'um pouco' — se funcionar, é advérbio."
  },
  {
    "id": "portugues__Classes de Palavras__Difícil__8",
    "track": "portugues",
    "category": "Classes de Palavras",
    "difficulty": "Difícil",
    "question": "Qual a função sintática de 'que' em 'Não foi ela que disse isso'?",
    "options": [
      "Pronome relativo exercendo função de sujeito da oração subordinada adjetiva",
      "Conjunção integrante introduzindo oração substantiva",
      "Pronome interrogativo",
      "Partícula de realce (expletivo) sem função sintática"
    ],
    "correctIndex": 0,
    "explanation": "'que disse isso' é oração subordinada adjetiva restritiva (caracteriza 'ela'). 'que' = pronome relativo retomando 'ela', exercendo função de sujeito de 'disse'. Conjunção integrante 'que' introduz orações substantivas e não tem função sintática própria.",
    "example": "'Não foi ela que disse isso': construção clivada (ênfase). 'ela' = antecedente de 'que'. 'que disse isso' = adjetiva. 'que' = sujeito de 'disse'. Compare: 'Acredito que ela disse' → 'que' = conjunção integrante (subst. objetiva)."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Fácil__1",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Fácil",
    "question": "Qual elemento de coesão expressa ideia de OPOSIÇÃO na frase: 'Ele estuda muito, ___ não passa nas provas'?",
    "options": [
      "mas",
      "pois",
      "porque",
      "logo"
    ],
    "correctIndex": 0,
    "explanation": "'Mas' é uma conjunção adversativa que introduz ideia de contraste/oposição entre duas orações. 'Pois' e 'porque' são causais/explicativas. 'Logo' é conclusiva.",
    "example": "Conectivos de oposição: mas, porém, contudo, todavia, entretanto, no entanto. Todos indicam contraste entre as ideias apresentadas."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Fácil__2",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Fácil",
    "question": "Qual conectivo expressa ideia de CONCLUSÃO?",
    "options": [
      "Portanto",
      "Porque",
      "Embora",
      "Quando"
    ],
    "correctIndex": 0,
    "explanation": "'Portanto' é uma conjunção coordenativa conclusiva — introduz uma conclusão baseada no que foi dito antes. Outros conclusivos: logo, assim, por conseguinte, então. 'Porque' é causal. 'Embora' é concessiva. 'Quando' é temporal.",
    "example": "Ela estudou muito, portanto passou. (conclusão). Ela estudou muito porque queria passar. (causa). Embora estudasse, não passou. (concessão)."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Fácil__3",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Fácil",
    "question": "O que é coesão referencial?",
    "options": [
      "Uso de termos que retomam ou antecipam outros no texto",
      "Uso de conectivos lógicos entre orações",
      "Repetição excessiva de palavras",
      "Organização dos parágrafos em ordem cronológica"
    ],
    "correctIndex": 0,
    "explanation": "Coesão referencial ocorre quando palavras retomam (anáfora) ou antecipam (catáfora) elementos do texto, evitando repetições. Pronomes, sinônimos e hiperônimos são os principais mecanismos de coesão referencial.",
    "example": "'Maria chegou. ELA estava cansada.' (anáfora — 'ela' retoma 'Maria'). 'Só quero ISTO: paz.' (catáfora — 'isto' antecipa 'paz')."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Fácil__4",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Fácil",
    "question": "Qual é a função dos conectivos em um texto?",
    "options": [
      "Ligar ideias e estabelecer relações entre as partes do texto",
      "Substituir substantivos repetidos",
      "Indicar a autoria de uma citação",
      "Separar sílabas no final da linha"
    ],
    "correctIndex": 0,
    "explanation": "Conectivos (conjunções, preposições, advérbios) têm a função de ligar orações, períodos ou parágrafos, estabelecendo relações lógicas (causa, consequência, oposição, adição etc.). São essenciais para a coesão sequencial.",
    "example": "Conectivos por relação: adição (e, também), oposição (mas, porém), causa (porque, pois), consequência (logo, portanto), tempo (quando, enquanto)."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Fácil__5",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Fácil",
    "question": "Em 'Pedro é médico. Ele trabalha no hospital', o pronome 'ele' é um recurso de:",
    "options": [
      "Coesão referencial por anáfora",
      "Coesão por catáfora",
      "Coesão sequencial",
      "Incoerência textual"
    ],
    "correctIndex": 0,
    "explanation": "O pronome 'ele' retoma 'Pedro', já mencionado na frase anterior. Isso é anáfora — referência a um elemento anterior do texto —, um tipo de coesão referencial que evita repetições.",
    "example": "Anáfora: retoma algo já dito. 'Pedro estuda. ELE é dedicado.' Catáfora: antecipa algo. 'ELE é dedicado: Pedro.' A anáfora é o mecanismo mais comum de coesão referencial."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Fácil__6",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Fácil",
    "question": "Qual conectivo indica ADIÇÃO entre duas ideias?",
    "options": [
      "E",
      "Mas",
      "Portanto",
      "Embora"
    ],
    "correctIndex": 0,
    "explanation": "'E' é conjunção coordenativa aditiva — liga ideias que se somam: 'Estudou e passou.' Outros aditivos: nem, também, além disso, não só... mas também.",
    "example": "Aditivas: e, nem, também, além disso. Adversativas: mas, porém. Conclusivas: logo, portanto. Concessivas: embora, ainda que."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Fácil__7",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Fácil",
    "question": "Na frase 'Maria gosta de dançar. Além disso, canta muito bem.', a expressão 'além disso' tem função de:",
    "options": [
      "Adicionar uma informação nova à anterior",
      "Opor duas ideias",
      "Concluir o raciocínio",
      "Indicar causa"
    ],
    "correctIndex": 0,
    "explanation": "'Além disso' é um conector de adição — acrescenta uma informação nova que complementa a anterior sem contraditá-la. É sinônimo de 'também', 'adicionalmente'.",
    "example": "Conectivos de adição: e, além disso, também, ademais, outrossim, não só... mas também/como também."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Fácil__8",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Fácil",
    "question": "Qual é a função do conector 'portanto' no texto?",
    "options": [
      "Indicar conclusão ou consequência do que foi dito anteriormente",
      "Introduzir uma oposição ou contraste",
      "Explicar a causa de um evento",
      "Indicar condição para o evento seguinte"
    ],
    "correctIndex": 0,
    "explanation": "'Portanto' é conjunção conclusiva: conecta uma conclusão (ou consequência lógica) ao argumento anterior. Oposição: mas, porém, contudo. Causalidade: pois, porque, já que. Condição: se, caso.",
    "example": "'Estudou muito; portanto, passou.' Portanto: logo, assim, consequentemente, por isso. Coerentes no texto: o conector 'portanto' exige que a oração anterior justifique a conclusão. Erro: 'choveu; portanto, fez sol' — incoerente."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Médio__1",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Médio",
    "question": "Em 'Maria comprou um livro. Ela o leu em dois dias', o pronome 'o' exerce função de:",
    "options": [
      "Referência anafórica (retoma 'livro')",
      "Referência catafórica",
      "Dêitico situacional",
      "Coesão lexical por sinonímia"
    ],
    "correctIndex": 0,
    "explanation": "O pronome 'o' retoma o substantivo 'livro' mencionado anteriormente. Essa referência a um elemento já citado chama-se anáfora. Catáfora seria se o pronome antecipasse algo que ainda seria mencionado.",
    "example": "Anáfora: retoma (olha para trás). 'Maria leu o livro. Ela o adorou.' ('Ela' retoma 'Maria', 'o' retoma 'livro'). Catáfora: antecipa (olha para frente). 'Ele chegou cedo: Pedro queria ajudar.'"
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Médio__2",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Médio",
    "question": "Em 'Pedro é bom aluno. O rapaz estuda todos os dias.', qual mecanismo de coesão está presente?",
    "options": [
      "Coesão lexical por sinonímia",
      "Coesão por elipse",
      "Coesão catafórica",
      "Coesão sequencial"
    ],
    "correctIndex": 0,
    "explanation": "'O rapaz' substitui 'Pedro' por um sinônimo/hiperônimo contextual, evitando repetição. Isso é coesão lexical — usar palavras diferentes para se referir ao mesmo elemento: nomes, sinônimos, hiperônimos ou expressões descritivas.",
    "example": "Pedro → o rapaz → o estudante → ele. Todas retomam o mesmo referente por mecanismos diferentes: sinônimo, hiperônimo, pronome."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Médio__3",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Médio",
    "question": "Qual conectivo estabelece relação de CAUSA?",
    "options": [
      "Pois",
      "Entretanto",
      "Logo",
      "Conforme"
    ],
    "correctIndex": 0,
    "explanation": "'Pois' (anteposto ao verbo) funciona como conjunção causal/explicativa: 'Não saiu, pois estava chovendo.' 'Entretanto' é adversativa. 'Logo' é conclusiva. 'Conforme' é conformativa.",
    "example": "Ele faltou, pois estava doente. (causa/explicação). Conectivos causais: porque, pois, já que, uma vez que, visto que, como (= já que)."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Médio__4",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Médio",
    "question": "Qual conectivo estabelece relação de CONCESSÃO?",
    "options": [
      "Embora",
      "Portanto",
      "Porque",
      "Assim"
    ],
    "correctIndex": 0,
    "explanation": "'Embora' é conjunção concessiva — introduz uma ideia que poderia impedir a principal, mas não impede: 'Embora estivesse cansado, continuou trabalhando.' 'Portanto' é conclusiva, 'porque' é causal, 'assim' é conclusiva.",
    "example": "Conjunções concessivas: embora, conquanto, ainda que, mesmo que, se bem que, por mais que. Sempre com subjuntivo: 'Embora ESTIVESSE' (não 'estava')."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Médio__5",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Médio",
    "question": "Na frase 'Cheguei, vi, venci', qual recurso de coesão dá ritmo ao texto?",
    "options": [
      "Assíndeto (omissão de conectivos)",
      "Polissíndeto (repetição de conectivos)",
      "Anáfora pronominal",
      "Catáfora"
    ],
    "correctIndex": 0,
    "explanation": "Assíndeto é a omissão de conjunções entre termos ou orações coordenadas. 'Cheguei, vi, venci' (César) usa vírgulas no lugar de 'e', criando ritmo acelerado e ênfase na sequência de ações.",
    "example": "Assíndeto: 'Cheguei, vi, venci.' (sem 'e'). Polissíndeto: 'Cheguei e vi e venci.' (repetição do 'e'). Ambos são recursos estilísticos e de coesão."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Médio__6",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Médio",
    "question": "O que é coesão por elipse?",
    "options": [
      "Omissão de um termo já mencionado, recuperável pelo contexto",
      "Repetição de palavras-chave",
      "Uso de sinônimos",
      "Uso de conectivos temporais"
    ],
    "correctIndex": 0,
    "explanation": "Coesão por elipse é a omissão de um termo para evitar repetição, sendo o termo recuperado pelo contexto. 'João leu o livro. Maria também [leu o livro].' O verbo 'leu o livro' está elíptico.",
    "example": "'Pedro comprou frutas e Maria, [comprou] legumes.' O verbo 'comprou' está elíptico antes de 'legumes'. A vírgula antes de 'legumes' marca a elipse."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Médio__7",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Médio",
    "question": "Em 'João estuda Direito. O futuro advogado é dedicado.', a expressão 'O futuro advogado' é exemplo de:",
    "options": [
      "Coesão lexical por perífrase",
      "Coesão por elipse",
      "Catáfora",
      "Coesão sequencial por conjunção"
    ],
    "correctIndex": 0,
    "explanation": "'O futuro advogado' substitui 'João' por uma expressão descritiva (perífrase). É coesão lexical — o referente é retomado por uma expressão equivalente, mais específica ou informativa.",
    "example": "Perífrase: 'João → o futuro advogado', 'Brasil → o gigante sul-americano'. Difere da sinonímia (sinônimo direto) e do hiperônimo (termo geral)."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Médio__8",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Médio",
    "question": "O que caracteriza a progressão temática referencial como mecanismo de coesão textual?",
    "options": [
      "Retomada de elementos já mencionados no texto por meio de pronomes, sinônimos ou expressões nominais, garantindo continuação sem repetição caótica",
      "Introdução de novas informações sem relação com o contexto anterior",
      "Uso exclusivo de pronomes pessoais para substituir todos os substantivos",
      "Repetição sistemática do mesmo substantivo para reforçar a coerência"
    ],
    "correctIndex": 0,
    "explanation": "Coesão referencial: anáfora (retomada) e catáfora (antecipação). 'Pedro chegou. Ele estava cansado.' — 'Ele' retoma 'Pedro' (anáfora pronominal). Expressão nominal: 'O presidente discursou. O líder do governo apontou...' (sinônimo contextual). Sem coesão: repetição excessiva ou ref. ambígua.",
    "example": "Correferentes: pronome, sinônimo, hiperônimo, expressão nominal. 'Ana chegou. A professora (sinônimo contextual) sentou-se.' Coesão sequencial: conectores lógicos (portanto, mas, pois). Coerência: organização lógica do conteúdo. Um texto pode ser coeso mas incoerente."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Difícil__1",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Difícil",
    "question": "Identifique o problema de coerência: 'O candidato defende a liberdade de expressão. Por isso, propõe censurar jornais que publiquem críticas ao governo.'",
    "options": [
      "Contradição argumentativa",
      "Falta de coesão referencial",
      "Progressão temática inadequada",
      "Redundância"
    ],
    "correctIndex": 0,
    "explanation": "Há uma contradição: defender liberdade de expressão é incompatível com propor censura. Isso quebra a coerência interna do texto. A coerência exige que as ideias sejam compatíveis entre si, sem contradições lógicas.",
    "example": "Liberdade de expressão ↔ censurar jornais: ideias mutuamente excludentes. O 'por isso' agrava a incoerência, pois apresenta a conclusão como consequência lógica da premissa — quando, na verdade, é uma contradição."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Difícil__2",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Difícil",
    "question": "O que é progressão temática em um texto?",
    "options": [
      "O avanço organizado de informações novas a partir de informações já dadas",
      "A repetição do tema em cada parágrafo",
      "O uso exclusivo de conectivos",
      "A organização alfabética das ideias"
    ],
    "correctIndex": 0,
    "explanation": "Progressão temática é o fluxo de informações novas que se somam ao que já foi dito (dado/novo). Um texto coerente alterna entre retomar o que já foi dito (dado) e acrescentar informação nova, avançando o tema de forma organizada.",
    "example": "Parágrafo 1: introduz o tema. Parágrafo 2: desenvolve com dados novos. Parágrafo 3: aprofunda. Sem progressão: o texto fica circular, repetindo o mesmo sem avançar."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Difícil__3",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Difícil",
    "question": "Em 'João gosta de Maria. Pedro gosta de Ana. Amanhã vai chover.', qual problema de coerência há?",
    "options": [
      "Falta de conexão temática entre as frases",
      "Contradição argumentativa",
      "Redundância",
      "Falta de conjunção"
    ],
    "correctIndex": 0,
    "explanation": "A terceira frase ('Amanhã vai chover') não tem relação temática com as anteriores. Não há fio condutor que una as ideias. A coerência textual exige que todas as partes do texto se relacionem e contribuam para um sentido global.",
    "example": "Frases 1-2: tema = relacionamentos. Frase 3: tema = clima. Ruptura temática sem transição = incoerência. Para funcionar, precisaria de um elo: 'e o piquenique será cancelado.'"
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Difícil__4",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Difícil",
    "question": "O que é coesão sequencial?",
    "options": [
      "Encadeamento de ideias por meio de conectivos que estabelecem progressão",
      "Repetição de palavras para dar ênfase",
      "Substituição de termos por sinônimos",
      "Uso exclusivo de pronomes demonstrativos"
    ],
    "correctIndex": 0,
    "explanation": "Coesão sequencial é o encadeamento lógico das partes do texto por meio de conectivos (conjunções, advérbios, preposições) que estabelecem relações de causa, contraste, adição, tempo, conclusão etc., garantindo a progressão do texto.",
    "example": "Coesão referencial: retoma/antecipa (pronomes, sinônimos). Coesão sequencial: encadeia (conectivos: mas, porém, além disso, portanto). Ambas são necessárias para um texto coeso."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Difícil__5",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Difícil",
    "question": "Em 'A cidade. O bairro. A rua. A casa. O quarto. A solidão.', qual recurso coesivo predomina?",
    "options": [
      "Progressão por focalização (do geral ao específico)",
      "Anáfora pronominal",
      "Polissíndeto",
      "Coesão por elipse verbal"
    ],
    "correctIndex": 0,
    "explanation": "O texto progride do geral (cidade) ao específico (quarto) e culmina em um estado (solidão). Essa focalização progressiva é uma forma de coesão sequencial que cria efeito de zoom — cada elemento afunila o espaço até o íntimo.",
    "example": "Cidade → bairro → rua → casa → quarto → solidão. Enumeração descendente (zoom in). O último elemento quebra a expectativa (abstrato após concretos), criando impacto expressivo."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Difícil__6",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Difícil",
    "question": "Em 'Disse-me isto: que não viria.', o pronome 'isto' exerce função de:",
    "options": [
      "Catáfora (antecipa o que vem depois)",
      "Anáfora (retoma o que foi dito)",
      "Elipse",
      "Coesão sequencial"
    ],
    "correctIndex": 0,
    "explanation": "'Isto' é catáfora — antecipa o conteúdo que virá em seguida ('que não viria'). Catáfora aponta para frente no texto, ao contrário da anáfora, que aponta para trás.",
    "example": "Catáfora: 'Disse-me ISTO: que não viria.' (isto antecipa). Anáfora: 'Não viria. Disse-me ISSO.' (isso retoma). Isto/este = catáfora. Isso/esse = anáfora."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Difícil__7",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre coesão e coerência?",
    "options": [
      "Coesão é a articulação linguística; coerência é a lógica/sentido global",
      "São a mesma coisa",
      "Coerência trata da gramática; coesão trata do sentido",
      "Coesão é mais importante que coerência"
    ],
    "correctIndex": 0,
    "explanation": "Coesão se refere às ligações linguísticas entre as partes do texto (conectivos, pronomes, sinônimos). Coerência se refere ao sentido global, à lógica interna e à ausência de contradições. Um texto pode ter coesão sem coerência.",
    "example": "'Choveu, portanto saí sem guarda-chuva.' Coesão: ok ('portanto' conecta). Coerência: falha (choveu → deveria levar guarda-chuva). A coesão não garante coerência."
  },
  {
    "id": "portugues__Coesão e Coerência Textual__Difícil__8",
    "track": "portugues",
    "category": "Coesão e Coerência Textual",
    "difficulty": "Difícil",
    "question": "Qual é o recurso de coesão em 'Os cientistas estudaram o fenômeno. O estudo revelou...'?",
    "options": [
      "Encapsulação por substantivo abstrato (nominalização anafórica): 'o estudo' retoma toda a proposição 'estudaram o fenômeno'",
      "Anáfora pronominal (substituição por pronome)",
      "Catáfora: 'o estudo' antecipa o que será dito",
      "Coesão lexical por repetição do mesmo campo semântico"
    ],
    "correctIndex": 0,
    "explanation": "Encapsulação (Francis, 1994): sintagma nominal que retoma porção anterior do texto transformando-a em entidade. 'os cientistas estudaram' → 'o estudo' nominaliza e encapsula a ação. Difere de anáfora pronominal (pronome substitui substantivo) e repetição lexical.",
    "example": "Outros encapsulamentos: 'A empresa anunciou demissões. A decisão gerou protestos.' ('a decisão' encapsula o anúncio). Nominalização progressiva: condensar argumentos em nomes para depois referenciá-los. Recurso intenso em textos acadêmicos e jornalísticos."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Fácil__1",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Fácil",
    "question": "Leia: 'A leitura é a viagem de quem não pode pegar o trem.' (Machado de Assis). O autor quer dizer que:",
    "options": [
      "A leitura permite conhecer mundos sem sair do lugar",
      "Ler é algo inferior a viajar",
      "Livros substituem trens",
      "Somente pobres precisam ler"
    ],
    "correctIndex": 0,
    "explanation": "Machado usa uma metáfora: 'viagem' não é literal, mas representa a experiência de descoberta e conhecimento. A leitura transporta o leitor para outros lugares e realidades, mesmo sem deslocamento físico.",
    "example": "A frase é metafórica: 'viagem' = experiência ampla; 'pegar o trem' = viajar fisicamente. A leitura é uma forma de 'viajar' intelectualmente."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Fácil__2",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Fácil",
    "question": "Qual é a diferença entre compreensão e interpretação de texto?",
    "options": [
      "Compreensão extrai o que está explícito; interpretação deduz o que está implícito",
      "São a mesma coisa",
      "Compreensão é mais difícil que interpretação",
      "Interpretação se limita ao que está escrito"
    ],
    "correctIndex": 0,
    "explanation": "Compreender é captar o sentido literal, o que está dito diretamente (explícito). Interpretar é ir além, deduzindo significados implícitos, intenções do autor, inferências e subentendidos. Ambas são habilidades de leitura complementares.",
    "example": "'O céu está escuro.' Compreensão: o céu está sem luz. Interpretação: provavelmente vai chover, o autor pode estar criando uma atmosfera de tensão."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Fácil__3",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Fácil",
    "question": "O que é uma informação implícita em um texto?",
    "options": [
      "Uma ideia que não está escrita diretamente, mas pode ser deduzida pelo contexto",
      "Uma informação escrita no primeiro parágrafo",
      "Um dado estatístico citado pelo autor",
      "Uma opinião declarada explicitamente"
    ],
    "correctIndex": 0,
    "explanation": "Informação implícita é aquela que não está expressa literalmente, mas pode ser inferida pelo leitor a partir de pistas textuais, contexto e conhecimento prévio. Inclui pressupostos e subentendidos.",
    "example": "'Ele parou de fumar.' Explícito: ele não fuma mais. Implícito (pressuposto): ele fumava antes. O 'parou de' pressupõe uma ação anterior."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Fácil__4",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Fácil",
    "question": "Um texto que busca convencer o leitor sobre um ponto de vista é chamado de:",
    "options": [
      "Texto argumentativo",
      "Texto narrativo",
      "Texto descritivo",
      "Texto injuntivo"
    ],
    "correctIndex": 0,
    "explanation": "O texto argumentativo tem como objetivo principal persuadir ou convencer o leitor, defendendo uma tese com argumentos. Narrativo conta histórias, descritivo detalha características, injuntivo dá instruções.",
    "example": "Tipos textuais: narrativo (conta fatos), descritivo (detalha), argumentativo (convence), expositivo (informa), injuntivo (instrui). A dissertação do ENEM é argumentativa."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Fácil__5",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Fácil",
    "question": "Qual é a função do título em um texto?",
    "options": [
      "Antecipar o assunto e despertar o interesse do leitor",
      "Resumir o texto inteiro em uma frase",
      "Substituir a conclusão",
      "Indicar o número de páginas"
    ],
    "correctIndex": 0,
    "explanation": "O título tem função de apresentar o tema, gerar expectativa e orientar a leitura. Um bom título antecipa o assunto sem entregar todo o conteúdo, despertando curiosidade e interesse.",
    "example": "Funções do título: informar o tema, atrair o leitor, orientar a interpretação. Títulos podem ser informativos ('Inflação sobe 0,5%') ou criativos ('O preço de viver')."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Fácil__6",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Fácil",
    "question": "Na frase 'Ele engoliu um sapo no trabalho', o sentido da expressão é:",
    "options": [
      "Figurado — ele teve que aceitar algo desagradável sem reagir",
      "Literal — ele comeu um sapo",
      "Irônico — ele está feliz",
      "Técnico — expressão de biologia"
    ],
    "correctIndex": 0,
    "explanation": "'Engolir um sapo' é uma expressão idiomática (linguagem figurada) que significa aceitar algo desagradável em silêncio. Não deve ser interpretada literalmente.",
    "example": "Expressões idiomáticas: 'engolir um sapo' (aceitar humilhação), 'chutar o balde' (desistir), 'pisar na bola' (errar). Sentido figurado: não é interpretável ao pé da letra."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Fácil__7",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Fácil",
    "question": "O que é um texto informativo?",
    "options": [
      "Texto que apresenta informações de forma objetiva, sem opinião do autor",
      "Texto que conta uma história com personagens",
      "Texto que defende uma tese com argumentos",
      "Texto que dá instruções passo a passo"
    ],
    "correctIndex": 0,
    "explanation": "O texto informativo (ou expositivo) tem como objetivo transmitir informações e conhecimentos de forma clara e objetiva, sem expressar opinião. Exemplos: notícias, verbetes, relatórios.",
    "example": "Informativo (expositivo): transmite conhecimento. Narrativo: conta fatos. Argumentativo: defende tese. Injuntivo: dá instruções. Descritivo: detalha características."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Fácil__8",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Fácil",
    "question": "O que significa 'inferir' na leitura de um texto?",
    "options": [
      "Deduzir informações implícitas a partir do contexto e de conhecimento prévio, não dito explicitamente",
      "Localizar informações explícitas presentes literalmente no texto",
      "Criticar o ponto de vista do autor",
      "Identificar a estrutura gramatical das frases"
    ],
    "correctIndex": 0,
    "explanation": "Inferência: leitura nas entrelinhas. O leitor vai além do que está escrito usando pistas textuais + contexto + conhecimento de mundo. 'João entrou no hospital com gesso no braço.' → inferência: ele quebrou o braço (não dito).",
    "example": "Explicitamente dito: 'O texto trata de clima.' Inferido: tom, atitude do autor, causa e efeito implícito. Níveis de leitura: denotativo (literal), conotativo (figurado), inferencial. Prova distingue: 'de acordo com o texto' (explícito) vs 'conclui-se que' (inferência)."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Médio__1",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Médio",
    "question": "Quando um texto diz 'A situação do país é preocupante, segundo especialistas', o uso de 'segundo especialistas' indica:",
    "options": [
      "Argumento de autoridade",
      "Opinião pessoal do autor",
      "Fato inquestionável",
      "Generalização apressada"
    ],
    "correctIndex": 0,
    "explanation": "A expressão 'segundo especialistas' é um recurso de argumento de autoridade (argumentum ad verecundiam), em que se cita fontes consideradas competentes para dar credibilidade à afirmação. O autor atribui o conteúdo a terceiros, não a si mesmo.",
    "example": "Argumento de autoridade: citar especialistas, pesquisadores, estudos. Serve para dar credibilidade. Cuidado: nem toda autoridade citada torna o argumento automaticamente válido."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Médio__2",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Médio",
    "question": "Quando um texto utiliza dados estatísticos, qual estratégia argumentativa está sendo empregada?",
    "options": [
      "Argumento por evidência/comprovação",
      "Argumento de autoridade",
      "Argumento emocional",
      "Argumento por analogia"
    ],
    "correctIndex": 0,
    "explanation": "Dados estatísticos são evidências concretas que servem para comprovar uma tese. O argumento por evidência usa fatos, números e pesquisas para fundamentar a ideia. Difere do argumento de autoridade (que cita fontes) e do emocional (que apela aos sentimentos).",
    "example": "'70% dos brasileiros leem menos de 5 livros por ano.' → argumento por evidência (dado comprova a tese de que a leitura é insuficiente). Diferente de: 'Segundo o MEC...' (autoridade)."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Médio__3",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Médio",
    "question": "O que significa 'ler nas entrelinhas'?",
    "options": [
      "Captar sentidos implícitos que o autor não disse diretamente",
      "Ler apenas as linhas ímpares",
      "Ler o texto rapidamente",
      "Copiar trechos do texto"
    ],
    "correctIndex": 0,
    "explanation": "'Ler nas entrelinhas' é uma expressão que significa perceber o que está subentendido, o que o autor quis dizer sem dizer explicitamente. Envolve interpretar ironias, intenções ocultas, críticas veladas e mensagens indiretas.",
    "example": "'Que belo trabalho!' (dito sobre algo ruim) → lendo nas entrelinhas, percebe-se a ironia. O sentido literal é elogio, o sentido implícito é crítica."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Médio__4",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Médio",
    "question": "Qual a diferença entre FATO e OPINIÃO em um texto?",
    "options": [
      "Fato é verificável e objetivo; opinião expressa julgamento pessoal",
      "São a mesma coisa",
      "Fato é sempre falso; opinião é sempre verdadeira",
      "Fato é subjetivo; opinião é objetiva"
    ],
    "correctIndex": 0,
    "explanation": "Fato é uma informação verificável, comprovável, independente de quem observa. Opinião é um julgamento pessoal, subjetivo, que varia conforme quem o emite. Distinguir os dois é essencial para leitura crítica.",
    "example": "Fato: 'O Brasil tem 26 estados e 1 DF.' (verificável). Opinião: 'O Brasil é o melhor país do mundo.' (juízo de valor). Marcas de opinião: 'eu acho', 'na minha visão', adjetivos avaliativos."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Médio__5",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Médio",
    "question": "Quando um autor usa perguntas retóricas no texto, qual é o efeito pretendido?",
    "options": [
      "Provocar reflexão no leitor sem esperar resposta direta",
      "Solicitar que o leitor responda por escrito",
      "Indicar que o autor não sabe a resposta",
      "Encerrar o texto abruptamente"
    ],
    "correctIndex": 0,
    "explanation": "Perguntas retóricas não esperam resposta — são usadas para provocar reflexão, enfatizar um argumento ou envolver o leitor. É um recurso argumentativo que sugere que a resposta é óbvia ou que a questão merece ponderação.",
    "example": "'Até quando vamos aceitar isso?' → não espera resposta, mas provoca indignação/reflexão. Pergunta retórica = recurso argumentativo de envolvimento do leitor."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Médio__6",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Médio",
    "question": "O que é um pressuposto em um texto?",
    "options": [
      "Informação implícita deduzível a partir de marcas linguísticas",
      "Informação explícita no título",
      "Opinião pessoal do autor",
      "Informação inventada pelo leitor"
    ],
    "correctIndex": 0,
    "explanation": "Pressuposto é uma informação implícita acionada por marcas linguísticas. Em 'Ele parou de fumar', o pressuposto é que ele fumava antes. O verbo 'parou de' carrega essa informação.",
    "example": "Pressuposto (marca linguística): 'Ele VOLTOU a estudar' → pressupõe que já estudava antes. Subentendido (dependência contextual): 'Está quente aqui' → subentende 'abra a janela'."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Médio__7",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Médio",
    "question": "Qual a função do parágrafo de conclusão em um texto argumentativo?",
    "options": [
      "Retomar a tese e apresentar uma síntese ou proposta final",
      "Introduzir um novo tema",
      "Repetir a introdução na íntegra",
      "Citar dados estatísticos"
    ],
    "correctIndex": 0,
    "explanation": "A conclusão de um texto argumentativo retoma a tese (idéia central) e apresenta uma síntese dos argumentos ou uma proposta de intervenção (como no ENEM). Não deve introduzir ideias novas.",
    "example": "Estrutura argumentativa: introdução (tese) → desenvolvimento (argumentos) → conclusão (reafirmação + proposta). ENEM: a proposta de intervenção é obrigatória na conclusão."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Médio__8",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Médio",
    "question": "A pressuposição em 'João parou de fumar' implica que:",
    "options": [
      "João fumava antes (pressuposto)",
      "João começou a fumar",
      "João nunca fumou",
      "Não há inferência possível"
    ],
    "correctIndex": 0,
    "explanation": "Pressuposição: informação dada como verdadeira na frase. 'Parou de fumar' pressupõe 'estava fumando'. Subentendidos são diferentes (interpretados, não garantidos). Teste da negação: 'João não parou de fumar' — pressuposto persiste: ainda implica que fumava.",
    "example": "'João já voltou de Paris' → pressup: esteve em Paris. 'O rei da França é careca' → pressup: existe rei da França (falso — pressuposição de existência). Importante em interpretação de textos argumentativos e jurídicos."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Difícil__1",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Difícil",
    "question": "Considere: 'Nunca me vi tão perdido. Mas perder-se também é caminho.' Qual recurso estilístico é empregado?",
    "options": [
      "Paradoxo",
      "Metonímia",
      "Hipérbole",
      "Eufemismo"
    ],
    "correctIndex": 0,
    "explanation": "Paradoxo: afirmação aparentemente contraditória que revela uma verdade. 'Perder-se é caminho' une dois conceitos opostos (estar perdido × seguir um caminho). Difere da antítese, que apenas contrapõe ideias sem uni-las em contradição lógica.",
    "example": "Paradoxos famosos: 'Eu sei que nada sei' (Sócrates). 'Perder-se é caminho' → estar perdido pode levar a descobertas. A contradição aparente expressa uma verdade profunda."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Difícil__2",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Difícil",
    "question": "O que é intertextualidade?",
    "options": [
      "Diálogo entre textos — quando um texto faz referência a outro",
      "Texto escrito por dois autores",
      "Texto publicado em duas línguas",
      "Repetição de palavras no mesmo texto"
    ],
    "correctIndex": 0,
    "explanation": "Intertextualidade é a relação entre textos — quando um texto faz referência, citação, paródia ou paráfrase de outro. É um recurso muito usado na literatura, música, publicidade e no cotidiano.",
    "example": "Machado escreveu 'Dom Casmurro'. Um autor moderno escreve 'Capitu: minha versão'. Há intertextualidade: o segundo texto dialoga com o primeiro. Tipos: citação, paródia, paráfrase, alusão."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Difícil__3",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre denotação e conotação?",
    "options": [
      "Denotação: sentido literal/dicionário. Conotação: sentido figurado/contextual",
      "São a mesma coisa",
      "Denotação é sentido figurado",
      "Conotação só existe em poesia"
    ],
    "correctIndex": 0,
    "explanation": "Denotação é o sentido real, objetivo, encontrado no dicionário. Conotação é o sentido figurado, subjetivo, construído pelo contexto. 'Aquela cobra me picou' (denotação: animal). 'Ela é uma cobra' (conotação: pessoa traiçoeira).",
    "example": "'Pé da mesa' (conotação — mesa não tem pé biológico). 'Pé do corpo' (denotação — parte do corpo humano). A linguagem figurada (conotação) é a base das figuras de linguagem."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Difícil__4",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Difícil",
    "question": "O que é paráfrase?",
    "options": [
      "Reescrita de um texto com outras palavras, mantendo o sentido original",
      "Cópia literal de um texto",
      "Crítica humorística de um texto",
      "Texto escrito em verso sobre outro em prosa"
    ],
    "correctIndex": 0,
    "explanation": "Paráfrase é a reformulação de um texto usando palavras diferentes, mas preservando o mesmo sentido. Difere de paródia (altera o sentido, geralmente com humor) e de plágio (cópia sem crédito).",
    "example": "Original: 'Penso, logo existo.' Paráfrase: 'O fato de eu pensar prova minha existência.' Paródia: 'Como, logo existo.' (alteração humorística do sentido)."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Difícil__5",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Difícil",
    "question": "Considere: 'A educação é a arma mais poderosa que você pode usar para mudar o mundo.' (Mandela). Qual tipo de linguagem predomina?",
    "options": [
      "Linguagem conotativa (figurada)",
      "Linguagem denotativa (literal)",
      "Linguagem técnica",
      "Linguagem coloquial"
    ],
    "correctIndex": 0,
    "explanation": "'Arma mais poderosa' é uma metáfora — educação não é literalmente uma arma. A linguagem conotativa (figurada) atribui sentidos novos às palavras, criando imagens e efeitos expressivos.",
    "example": "'Arma' = instrumento de transformação (conotativo). Se fosse denotativo: 'A educação é importante para mudar o mundo.' A metáfora intensifica o argumento."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Difícil__6",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Difícil",
    "question": "O que é paródia?",
    "options": [
      "Recriação cômica ou crítica de um texto, alterando o sentido original",
      "Cópia literal do texto original",
      "Reescrita mantendo o sentido original",
      "Tradução de um texto para outra língua"
    ],
    "correctIndex": 0,
    "explanation": "Paródia é a recriação de um texto preexistente com alteração de sentido, geralmente com finalidade humorística ou crítica. Difere da paráfrase (mantém o sentido) e da cópia.",
    "example": "Original: 'Penso, logo existo.' Paródia: 'Como, logo existo.' Paráfrase: 'O ato de pensar comprova minha existência.' Paródia altera; paráfrase preserva."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Difícil__7",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Difícil",
    "question": "Em 'Como, logo existo', tomando como base 'Penso, logo existo' (Descartes), qual tipo de intertextualidade está presente?",
    "options": [
      "Paródia",
      "Paráfrase",
      "Citação direta",
      "Plágio"
    ],
    "correctIndex": 0,
    "explanation": "Trata-se de paródia — a frase original foi alterada com mudança de sentido (humorística). 'Penso' foi substituído por 'como', criando um novo significado irônico.",
    "example": "Paródia: altera o sentido (geralmente com humor). Paráfrase: mantém o sentido com outras palavras. Citação: reprodução literal com crédito. Plágio: cópia sem crédito."
  },
  {
    "id": "portugues__Compreensão e Interpretação de Texto__Difícil__8",
    "track": "portugues",
    "category": "Compreensão e Interpretação de Texto",
    "difficulty": "Difícil",
    "question": "Qual o recurso argumentativo de um texto que apresenta a tese do adversário antes de refutá-la?",
    "options": [
      "Concessão: reconhecer o ponto de vista oposto para depois contrastá-lo com argumento mais forte",
      "Exemplificação: usar caso concreto para ilustrar a tese",
      "Generalização indevida: aplicar caso particular como regra universal",
      "Argumento de autoridade: citar especialista para validar a tese"
    ],
    "correctIndex": 0,
    "explanation": "Concessão argumentativa: 'Embora a tecnologia facilite o isolamento, ela também aproxima pessoas distantes.' Primeiro admite o ponto adversário ('facilita o isolamento') e depois apresenta argumento mais forte ('também aproxima'). Conectores de concessão: embora, ainda que, conquanto.",
    "example": "Estrutura: 'Certamente... No entanto / Todavia... Portanto'. Concessão persuade mais que negação direta pois mostra fairness. Exemplificação: 'Como ocorreu na pandemia...'. Argumento de autoridade: 'Segundo o cientista X...'. Generalização: 'Todo político é corrupto' — falácia."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Fácil__1",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual frase está com a concordância verbal CORRETA?",
    "options": [
      "Faltam dois dias para a prova.",
      "Falta dois dias para a prova.",
      "Fazem dois dias que não chove.",
      "Houveram muitos problemas."
    ],
    "correctIndex": 0,
    "explanation": "'Faltam dois dias' — o sujeito é 'dois dias' (plural), então o verbo concorda no plural. 'Faz dois dias' (verbo impessoal, fica no singular). 'Houve muitos problemas' (verbo impessoal no sentido de existir, fica no singular).",
    "example": "Faltar (pessoal): concorda com sujeito. 'Faltam livros.' / 'Falta um livro.' Fazer (tempo): impessoal. 'Faz anos.' Haver (existir): impessoal. 'Houve festas.'"
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Fácil__2",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual frase está CORRETA quanto à concordância verbal?",
    "options": [
      "Faz dez anos que não viajo.",
      "Fazem dez anos que não viajo.",
      "Houveram muitas reclamações.",
      "Existia muitos problemas."
    ],
    "correctIndex": 0,
    "explanation": "'Fazer' indicando tempo é impessoal — fica sempre no singular: 'Faz dez anos.' 'Haver' no sentido de existir também é impessoal: 'Houve reclamações.' Já 'existir' é pessoal e concorda: 'Existiam muitos problemas.'",
    "example": "Faz/Havia (impessoais, sempre singular): 'Faz 3 meses', 'Havia problemas'. Existir/Acontecer (pessoais, concordam): 'Existem falhas', 'Aconteceram acidentes'."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Fácil__3",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Em 'Os meninos e as meninas ___ ao parque', o verbo deve concordar com:",
    "options": [
      "O sujeito composto (plural): 'foram'",
      "Apenas o mais próximo: 'foi'",
      "O primeiro substantivo: 'foram'",
      "Não há regra"
    ],
    "correctIndex": 0,
    "explanation": "Sujeito composto antes do verbo: o verbo vai para o plural, concordando com a totalidade. 'Os meninos e as meninas foram ao parque.' Se o sujeito composto vier depois do verbo, aceita-se plural ou concordância com o mais próximo.",
    "example": "Sujeito composto anteposto: plural. 'João e Maria saíram.' Sujeito composto posposto: 'Saiu/Saíram João e Maria.' (ambos aceitos)."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Fácil__4",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Na frase 'Maria e Ana ___ estudiosas', qual a forma correta?",
    "options": [
      "são",
      "é",
      "está",
      "foi"
    ],
    "correctIndex": 0,
    "explanation": "Sujeito composto (Maria e Ana) antes do verbo exige verbo no plural: 'são'. O verbo concorda com o sujeito composto como um todo — e não com apenas um dos núcleos.",
    "example": "Maria e Ana são estudiosas. Pedro e João são estudantes. Regra geral: sujeito composto anteposto → verbo no plural, sem exceção."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Fácil__5",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual a concordância correta: 'Nós vai' ou 'Nós vamos'?",
    "options": [
      "'Nós vamos' — o verbo concorda com o sujeito",
      "'Nós vai' — o verbo fica no singular",
      "Ambas estão corretas",
      "Nenhuma está correta"
    ],
    "correctIndex": 0,
    "explanation": "'Nós vamos' é a forma correta na norma culta. O verbo concorda em pessoa e número com o sujeito: 'nós' (1ª pessoa do plural) → 'vamos'. 'Nós vai' é um desvio de concordância verbal.",
    "example": "Eu vou, tu vais, ele vai, nós vamos, vós ides, eles vão. O verbo se flexiona para concordar com o sujeito em pessoa e número."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Fácil__6",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Na frase 'As flores ___ lindas', complete com o verbo 'estar':",
    "options": [
      "estão",
      "está",
      "esteve",
      "estando"
    ],
    "correctIndex": 0,
    "explanation": "O sujeito 'As flores' é feminino plural, então o verbo de ligação 'estar' deve concordar no plural: 'estão'. O predicativo 'lindas' também concorda no feminino plural.",
    "example": "As flores estão lindas (f. pl.). A flor está linda (f. sing.). Os jardins estão lindos (m. pl.). Verbo + predicativo concordam com o sujeito."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Fácil__7",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Em 'Pedro e eu ___ ao cinema', complete corretamente:",
    "options": [
      "fomos",
      "foram",
      "foi",
      "fui"
    ],
    "correctIndex": 0,
    "explanation": "Sujeito composto com 'eu' leva o verbo para a 1ª pessoa do plural: 'fomos'. 'Eu' prevalece sobre as demais pessoas gramaticais na concordância (eu > tu > ele).",
    "example": "Pedro e eu fomos (1ª pl.). Pedro e tu fostes/foram (2ª/3ª pl.). Pedro e Maria foram (3ª pl.). Ordem de precedência: eu > tu > ele."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Fácil__8",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual a forma verbal correta para 'A maioria dos alunos ___ presente'?",
    "options": [
      "esteve (concordância com o núcleo 'maioria' — singular)",
      "estiveram (concordância com 'alunos' — plural)",
      "Ambas são corretas",
      "Não há forma correta"
    ],
    "correctIndex": 2,
    "explanation": "Com substantivos coletivos (maioria, parte, metade), a concordância pode ser com o núcleo (singular: 'esteve') ou com o complemento (plural: 'estiveram'). Ambas são aceitas pela gramática normativa.",
    "example": "'A maioria dos alunos faltou.' (singular — com núcleo). 'A maioria dos alunos faltaram.' (plural — com complemento). Banca FCC costuma aceitar ambas; preferência pelo singular em contextos formais."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Médio__1",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Na frase 'A maioria dos alunos ___ a prova', o verbo pode estar no singular ou plural. Qual é a regra?",
    "options": [
      "Ambas as concordâncias são corretas (silepse)",
      "Apenas singular é correto",
      "Apenas plural é correto",
      "Deve concordar com 'maioria' obrigatoriamente"
    ],
    "correctIndex": 0,
    "explanation": "Com expressões partitivas (a maioria de, grande parte de, metade de) seguidas de adjunto no plural, aceita-se concordância com o núcleo do sujeito (singular) ou com o adjunto (plural): 'A maioria dos alunos fez/fizeram a prova'. É um caso de silepse gramaticalmente aceita.",
    "example": "'A maioria dos alunos fez a prova' (concorda com 'maioria'). 'A maioria dos alunos fizeram a prova' (concorda com 'alunos'). Ambas são aceitas pela gramática normativa."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Médio__2",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Médio",
    "question": "'Meio-dia e ___ soaram no relógio.' Complete corretamente:",
    "options": [
      "meia",
      "meio",
      "meias",
      "meios"
    ],
    "correctIndex": 0,
    "explanation": "'Meia' = meia hora (30 minutos). Concorda com 'hora' (feminino): meio-dia e meia (hora). 'Meio' como advérbio (é invariável): 'Ela está meio cansada' (= um pouco). Aqui, 'meia' é numeral fracionário que concorda com 'hora'.",
    "example": "Meio-dia e meia (hora) = 12h30. Erro comum: 'meio-dia e meio'. 'Meio' advérbio: 'A porta ficou meio aberta' (= um pouco). 'Meia' numeral: 'Comi meia pizza.'"
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Médio__3",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Em qual frase a concordância nominal está CORRETA?",
    "options": [
      "É necessário paciência.",
      "É necessária a paciência.",
      "Ambas estão corretas.",
      "Nenhuma está correta."
    ],
    "correctIndex": 2,
    "explanation": "Com expressões como 'é necessário', 'é bom', 'é preciso': se o substantivo vier sem artigo, o predicativo fica no masculino singular ('É necessário paciência'). Com artigo, concorda normalmente ('É necessária a paciência'). Ambas corretas.",
    "example": "Sem artigo: 'É necessário paciência', 'É proibido entrada'. Com artigo: 'É necessária a paciência', 'É proibida a entrada'. Regra do artigo + predicativo."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Médio__4",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Em 'Um bando de pássaros ___ o céu', o verbo pode ser:",
    "options": [
      "Singular ou plural (ambos aceitos)",
      "Apenas singular",
      "Apenas plural",
      "Depende do tempo verbal"
    ],
    "correctIndex": 0,
    "explanation": "Com coletivos seguidos de adjunto no plural (um bando DE PÁSSAROS), aceita-se concordância no singular ('cruzou' — concorda com 'bando') ou no plural ('cruzaram' — concorda com 'pássaros'). É caso de silepse.",
    "example": "Um bando de pássaros cruzou/cruzaram o céu. Um grupo de alunos fez/fizeram a prova. Coletivo + 'de' + plural = concordância flexível."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Médio__5",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Em 'Mais de um aluno ___ a prova', o verbo fica no:",
    "options": [
      "Singular: 'fez'",
      "Plural: 'fizeram'",
      "Infinitivo: 'fazer'",
      "Depende do contexto"
    ],
    "correctIndex": 0,
    "explanation": "'Mais de um' pede verbo no singular: 'Mais de um aluno fez a prova.' A lógica é que 'mais de um' contém o numeral 'um', que é singular. Exceção: quando há reciprocidade ('Mais de um jogador se abraçaram').",
    "example": "Mais de um aluno fez (singular). Mais de dois alunos fizeram (plural). Mais de um aluno se cumprimentaram (reciprocidade → plural)."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Médio__6",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Na frase 'Cada um dos alunos ___ sua tarefa', o verbo fica no:",
    "options": [
      "Singular: 'fez'",
      "Plural: 'fizeram'",
      "Ambos são aceitos",
      "Infinitivo: 'fazer'"
    ],
    "correctIndex": 0,
    "explanation": "'Cada um' individualiza — o verbo fica obrigatoriamente no singular: 'Cada um dos alunos fez.' A expressão 'cada um' funciona como pronome indefinido singular.",
    "example": "Cada um fez sua tarefa. Cada aluno trouxe seu material. 'Cada' sempre individualiza = verbo no singular."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Médio__7",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Médio",
    "question": "'10% da população ___ vacinada.' Qual concordância é aceita?",
    "options": [
      "Ambas: 'foi' (concorda com 'população') ou 'foram' (com '10%')",
      "Apenas singular",
      "Apenas plural",
      "O verbo fica no infinitivo"
    ],
    "correctIndex": 0,
    "explanation": "Com porcentagem seguida de adjunto, aceita-se concordância com o numeral (10% foram) ou com o adjunto (da população foi). Quando a porcentagem vem sozinha: '10% faltaram' (concorda com o numeral).",
    "example": "10% dos alunos faltaram/faltou. 1% dos votos foi/foram nulo(s). Com porcentagem: concordância flexível quando há adjunto."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Médio__8",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Em 'São proibidos qualquer tipo de arma', há erro de concordância? Corrija se necessário.",
    "options": [
      "Sim; correto: 'É proibido qualquer tipo de arma' (VB concorda com 'tipo', núcleo do sujeito)",
      "Não; 'armas' no plural exige o plural do verbo",
      "Sim; correto: 'São proibidas quaisquer armas'",
      "Não; qualquer tipo de pluraliza o verbo"
    ],
    "correctIndex": 0,
    "explanation": "Sujeito: 'qualquer tipo de arma'. Núcleo do sujeito: 'tipo' (singular). VB concordar com núcleo: é proibido. 'São proibidos' concorda erroneamente com elementos sem essa justificativa gramatical.",
    "example": "'Qualquer tipo de arma é proibido.' Concordância com núcleo 'tipo' (singular). Erro frequente: atrair o verbo para o número do complemento mais próximo. ABN: 'Nenhum tipo de bebida é recomendado.'"
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Difícil__1",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Qual alternativa apresenta concordância nominal CORRETA?",
    "options": [
      "Seguem anexas as cópias do documento.",
      "Seguem anexo as cópias do documento.",
      "Seguem em anexas as cópias.",
      "As cópias estão anexas ao documento. (e a alternativa A)"
    ],
    "correctIndex": 3,
    "explanation": "'Anexo' é adjetivo e concorda com o substantivo: 'anexas as cópias' (feminino plural). 'Seguem anexo' está errado pois não concorda. 'Em anexo' seria invariável (locução adverbial), mas 'em anexas' não existe. Tanto A quanto 'As cópias estão anexas' estão corretas.",
    "example": "Anexo concorda: documentos anexos, carta anexa, fotografias anexas. 'Em anexo' é invariável: 'Seguem em anexo as cópias.' Cuidado: 'em anexas' NÃO existe."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Difícil__2",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Em 'Os alunos estavam ___ para a prova, e as alunas estavam ___ também.', complete:",
    "options": [
      "preparados / preparadas",
      "preparado / preparada",
      "preparados / preparados",
      "preparado / preparado"
    ],
    "correctIndex": 0,
    "explanation": "O predicativo do sujeito concorda em gênero e número com o sujeito. 'Os alunos' (masculino plural) → 'preparados'. 'As alunas' (feminino plural) → 'preparadas'. A concordância nominal é obrigatória.",
    "example": "Preparados (m. pl.) concorda com 'os alunos'. Preparadas (f. pl.) concorda com 'as alunas'. Predicativo sempre concorda com o sujeito."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Difícil__3",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Na frase 'Segue as cópias ___ do contrato', qual é a forma correta?",
    "options": [
      "Seguem as cópias anexas",
      "Segue as cópias anexo",
      "Segue as cópia anexas",
      "Seguem as cópias anexo"
    ],
    "correctIndex": 0,
    "explanation": "Sujeito: 'as cópias' (feminino plural). Verbo: 'seguem' (concorda com sujeito no plural). 'Anexas' concorda com 'cópias' (feminino plural). Concordância verbal e nominal devem estar corretas simultaneamente.",
    "example": "Seguem (verbo no plural) + as cópias (sujeito f. pl.) + anexas (predicativo f. pl.). Tudo concorda com o núcleo 'cópias'."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Difícil__4",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Na frase 'V. Exa. está ___ de que estamos de acordo?', como completar (referindo-se a um homem)?",
    "options": [
      "convicto (concorda com o referente masculino)",
      "convicta (concorda com 'Excelência')",
      "convictos (concorda com 'nós')",
      "convencidos"
    ],
    "correctIndex": 0,
    "explanation": "Com pronomes de tratamento, a concordância de gênero se faz com o SEXO da pessoa, não com a palavra 'Excelência'. Se é homem: 'V. Exa. está convicto'. Se é mulher: 'convicta'. O verbo fica na 3ª pessoa.",
    "example": "V. Exa. está convicto (homem) / convicta (mulher). V. Magª está satisfeito/satisfeita. Pronome de tratamento: verbo na 3ª pessoa, adjetivo concorda com o sexo do referente."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Difícil__5",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Em 'Aluga-se salas comerciais', a concordância está correta?",
    "options": [
      "Não. Correto: 'Alugam-se salas comerciais'",
      "Sim, o verbo fica no singular com 'se'",
      "Sim, 'salas' é objeto direto",
      "Não. Correto: 'Alugou-se salas comerciais'"
    ],
    "correctIndex": 0,
    "explanation": "'Alugam-se salas' é voz passiva sintética (= 'Salas são alugadas'). 'Salas' é sujeito paciente no plural, então o verbo vai para o plural: 'alugam-se'. Só fica no singular se o verbo for intransitivo ou transitivo indireto.",
    "example": "Alugam-se salas (VTD + se = passiva sintética, sujeito plural). Precisa-se de funcionários (VTI + se = índice de indeterminação, singular). Dica: substitua por passiva analítica para testar."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Difícil__6",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Em '___ existir muitas soluções para o problema', complete com 'pode' ou 'podem':",
    "options": [
      "Podem existir (concorda com 'soluções')",
      "Pode existir (auxiliar no singular)",
      "Pode existirem",
      "Ambas estão erradas"
    ],
    "correctIndex": 0,
    "explanation": "'Existir' é verbo pessoal — concorda com o sujeito 'muitas soluções' (plural). O auxiliar 'poder' segue a concordância: 'Podem existir muitas soluções.' Compare: 'Pode haver soluções.' ('haver' é impessoal, singular contamina auxiliar).",
    "example": "Podem existir soluções (pessoal = plural). Pode haver soluções (impessoal = singular). Devem ocorrer mudanças (pessoal). Deve haver mudanças (impessoal)."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Difícil__7",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "'Haja vista os erros cometidos' ou 'Hajam vistas os erros'? Qual forma está correta?",
    "options": [
      "'Haja vista os erros' (é locução invariável)",
      "'Hajam vistas os erros' (concorda com 'erros')",
      "Ambas estão corretas",
      "Nenhuma está correta"
    ],
    "correctIndex": 0,
    "explanation": "'Haja vista' é locução invariavél — não flexiona: 'Haja vista os erros cometidos.' Nunca 'hajam vistas'. Equivale a 'tendo em vista', 'considerando'.",
    "example": "Haja vista os resultados (invariavél). Erros comuns: 'hajam vistas', 'haja visto'. Forma correta única: 'haja vista' + substantivo."
  },
  {
    "id": "portugues__Concordância Nominal e Verbal__Difícil__8",
    "track": "portugues",
    "category": "Concordância Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Em 'Você e eu precisamos conversar', o verbo está correto? Por quê?",
    "options": [
      "Sim; sujeito composto com 'eu' como um dos núcleos exige verbo na 1ª pessoa do plural",
      "Não; deveria ser 'precisa' concordando com o núcleo mais próximo",
      "Não; deveria ser 'precisam' pois o sujeito é de 3ª pessoa",
      "Sim; qualquer pessoa pode ser usada com sujeito composto"
    ],
    "correctIndex": 0,
    "explanation": "Sujeito composto com diferentes pessoas verbais: quando há 'eu' entre os núcleos, o verbo vai para a 1ª pessoa do plural (nós). 'Você e eu' = nós → 'precisamos'. Regra: 1ª > 2ª > 3ª pessoa.",
    "example": "'Ele, tu e eu iremos' → 'nós iremos'. 'Ela e você foram' → 3ª (sem 1ª nem 2ª). Hierarquia de pessoas: 1ª domina. 'Tu e ela sois/são' → plural da 2ª ou 3ª."
  },
  {
    "id": "portugues__Crase__Fácil__1",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Fácil",
    "question": "Em qual frase a crase está empregada CORRETAMENTE?",
    "options": [
      "Fui à escola ontem.",
      "Fui à pé para casa.",
      "Ele assistiu à um filme.",
      "Ela vendeu à prazo."
    ],
    "correctIndex": 0,
    "explanation": "Crase = preposição 'a' + artigo definido 'a'. 'Fui à escola' → fui a (preposição) + a (artigo) escola. 'A pé' não tem crase (não há artigo antes de palavra masculina). 'A um' não tem crase (artigo indefinido). 'A prazo' não tem crase (palavra masculina).",
    "example": "Dica: substitua a palavra feminina por uma masculina. 'Fui ao colégio' → tem 'ao', então tem crase no feminino: 'Fui à escola'. 'Fui a pé' → 'a pé' (sem artigo = sem crase)."
  },
  {
    "id": "portugues__Crase__Fácil__2",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Fácil",
    "question": "Crase é obrigatória em qual das frases?",
    "options": [
      "Ele foi à farmacía.",
      "Ele foi a Roma.",
      "Ele foi a pé.",
      "Ele foi a Marte."
    ],
    "correctIndex": 0,
    "explanation": "'Ir à farmácia' — verbo 'ir' pede preposição 'a', e 'farmácia' aceita artigo 'a'. Crase = a + a. 'A Roma' não tem crase pois cidades sem determinante não aceitam artigo. 'A pé' não tem artigo (masculino). 'Marte' não aceita artigo.",
    "example": "Teste: 'Fui ao cinema' (é masculino e tem 'ao') = 'Fui à farmácia'. 'Fui a Roma' = sem artigo. 'Fui à bela Roma' = com determinante, há crase."
  },
  {
    "id": "portugues__Crase__Fácil__3",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Fácil",
    "question": "Existe crase antes de palavras masculinas?",
    "options": [
      "Sim, em expressões como 'à moda de', 'às avessas'",
      "Nunca",
      "Apenas antes de artigos",
      "Somente em linguagem informal"
    ],
    "correctIndex": 0,
    "explanation": "Em expressões adverbiais femininas subentendidas, a crase pode aparecer antes de palavra masculina: 'Bife à milanesa' (à moda milanesa), 'Escreveu à (maneira de) Machado', 'Às avessas', 'Às pressas'. O feminino está implícito.",
    "example": "Bife à (moda) milanesa. Sapato à (moda de) Luís XV. 'À moda de' subentendido antes de palavra masculina permite crase. Sem esse subentendido: nunca crase antes de masculino."
  },
  {
    "id": "portugues__Crase__Fácil__4",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Fácil",
    "question": "Em 'Paguei a conta do restaurante', há crase no 'a'?",
    "options": [
      "Não — 'a' é apenas artigo, sem preposição",
      "Sim — há preposição + artigo",
      "Depende do contexto",
      "Crase facultativa"
    ],
    "correctIndex": 0,
    "explanation": "'Pagar' é verbo transitivo direto: 'pagar algo'. O 'a' antes de 'conta' é apenas o artigo definido, sem preposição. Para haver crase, é preciso preposição 'a' + artigo 'a'. Sem preposição, não há crase.",
    "example": "Paguei a conta (VTD: artigo apenas). Referi-me à conta (VTI 'referir-se a': preposição + artigo = crase). A crase depende da regência do verbo (se exige ou não preposição 'a')."
  },
  {
    "id": "portugues__Crase__Fácil__5",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Fácil",
    "question": "Em 'Ele fez referência a essa obra', há crase?",
    "options": [
      "Não — não se usa crase antes de 'esse/essa'",
      "Sim — preposição + artigo",
      "Crase facultativa",
      "Sim — antes de pronome demonstrativo sempre tem crase"
    ],
    "correctIndex": 0,
    "explanation": "Não há crase antes dos demonstrativos 'esse/essa/este/esta', pois eles não são precedidos de artigo. Só há crase com 'aquele/aquela/aquilo' (a + aquele = àquele). 'Esse' e 'este' só têm preposição, sem artigo.",
    "example": "Sem crase: a essa, a esta, a esse, a este. Com crase: àquele, àquela, àquilo (a + aquele). Macete: se começa com 'aqu-', pode craseiar."
  },
  {
    "id": "portugues__Crase__Fácil__6",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Fácil",
    "question": "Em 'Entreguei o relatório a diretora', falta crase?",
    "options": [
      "Sim: 'à diretora' (preposição + artigo)",
      "Não — o 'a' é só artigo",
      "Crase facultativa",
      "Não — 'diretora' não aceita artigo"
    ],
    "correctIndex": 0,
    "explanation": "'Entregar' pede preposição 'a' (entregar algo A alguém). 'Diretora' aceita artigo 'a'. Logo: entreguei a (prep.) + a (artigo) diretora = 'à diretora'. Crase obrigatória.",
    "example": "Teste: 'Entreguei ao diretor' (ao = a + o). Se no masculino tem 'ao', no feminino tem crase: 'à diretora'."
  },
  {
    "id": "portugues__Crase__Fácil__7",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Fácil",
    "question": "Há crase em 'Chegou a casa dos pais cansado'?",
    "options": [
      "Sim: 'à casa dos pais' (casa com adjunto aceita artigo)",
      "Não — 'casa' nunca tem crase",
      "Crase facultativa",
      "Não — 'chegou' não pede preposição"
    ],
    "correctIndex": 0,
    "explanation": "'Casa' sem adjunto não aceita artigo: 'Voltou a casa' (sem crase). Com adjunto (especificação), aceita artigo: 'Voltou à casa dos pais', 'à casa de Maria'. 'Chegou' pede preposição 'a'.",
    "example": "Sem adjunto: 'Voltou a casa' (sem crase). Com adjunto: 'Voltou à casa paterna/dos pais/de infância'. Mesma regra para 'terra': 'Voltou a terra' vs 'Voltou à terra natal'."
  },
  {
    "id": "portugues__Crase__Fácil__8",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Fácil",
    "question": "Ocorre crase em 'Fui ___ escola'?",
    "options": [
      "Sim: 'Fui à escola' (prepos. 'a' + artigo 'a' = à, pois 'escola' aceita artigo feminino)",
      "Não: substantivo feminino não exige artigo definido após verbos de movimento",
      "Depende do contexto; apenas em linguagem formal",
      "Não: antes de vogal nunca há crase"
    ],
    "correctIndex": 0,
    "explanation": "Crase: fusão da preposição 'a' com o artigo definido feminino 'a'. Teste: substitua por substantivo masculino. 'Fui ao (a+o) colégio' → 'ao' → crase na feminina. 'Fui à escola' ✓.",
    "example": "Teste pronominal: 'Fui à escola' → 'Fui a ela' — confirma crase. Sem crase: antes de verbo ('começou a correr'), antes de pronome que não admita artigo definido. Facultativo: 'Vou a/à sua casa' (pronome possessivo)."
  },
  {
    "id": "portugues__Crase__Médio__1",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Médio",
    "question": "Em qual caso a crase é FACULTATIVA?",
    "options": [
      "Refiro-me à/a sua proposta.",
      "Vou à padaria.",
      "Estamos à espera dele.",
      "Às vezes chove."
    ],
    "correctIndex": 0,
    "explanation": "A crase é facultativa antes de pronomes possessivos femininos: 'Refiro-me à sua proposta' ou 'Refiro-me a sua proposta'. Nos demais casos: 'à padaria' (obrigatória), 'à espera' (obrigatória — locução feminina), 'Às vezes' (obrigatória — locução adverbial feminina).",
    "example": "Crase facultativa: 1) Pronomes possessivos femininos (sua, minha). 2) Nomes próprios femininos: 'Dei o livro à/a Maria.' 3) Após 'até': 'Fui até à/a escola.'"
  },
  {
    "id": "portugues__Crase__Médio__2",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Médio",
    "question": "Por que NÃO há crase em 'Ele se refere a você'?",
    "options": [
      "Porque não se usa crase antes de pronome pessoal",
      "Porque 'você' é masculino",
      "Porque o verbo não pede preposição",
      "Porque 'você' é paroxítona"
    ],
    "correctIndex": 0,
    "explanation": "Não há crase antes de pronomes pessoais (eu, tu, ele, nós, você, etc.) porque não aceitam artigo. Crase = preposição 'a' + artigo 'a'. Sem artigo, é impossível haver crase.",
    "example": "Pronomes pessoais não aceitam artigo: 'a você' (só preposição), 'a ela' (só preposição). Também sem crase: antes de verbos ('a correr'), pronomes indefinidos ('a alguém')."
  },
  {
    "id": "portugues__Crase__Médio__3",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Médio",
    "question": "Qual a diferença entre 'a' e 'à' na frase 'Fui a/à cidade'?",
    "options": [
      "Com crase (à): há preposição + artigo. Sem crase (a): só preposição",
      "Não há diferença",
      "Com crase é informal",
      "Sem crase é mais formal"
    ],
    "correctIndex": 0,
    "explanation": "'Fui à cidade' (com crase): preposição 'a' + artigo 'a' + 'cidade'. 'Fui a uma cidade' (sem crase): preposição 'a' + artigo indefinido 'uma'. A crase marca a presença de dois 'a' juntos (fusão).",
    "example": "'Fui à cidade' = 'Fui ao bairro' (com artigo definido). 'Fui a uma cidade' = 'Fui a um bairro' (artigo indefinido, sem crase). O artigo definido é essencial para a crase."
  },
  {
    "id": "portugues__Crase__Médio__4",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Médio",
    "question": "Em 'Assistimos à peça de teatro', a crase está correta?",
    "options": [
      "Sim — 'assistir a' (VTI) + artigo 'a' = crase",
      "Não — 'assistir' é VTD, sem preposição",
      "Crase facultativa",
      "Não — não se usa crase antes de substantivo"
    ],
    "correctIndex": 0,
    "explanation": "'Assistir a' (no sentido de ver/presenciar) é VTI — exige preposição 'a'. 'Peça' aceita artigo 'a'. Logo: assistir a (prep.) + a (artigo) peça = 'assistir à peça'. Crase obrigatória.",
    "example": "Assistir à peça (VTI, prep. + artigo). Assistir ao filme (masculino confirma preposição). Assistir o paciente (VTD no sentido de prestar assistência, sem preposição)."
  },
  {
    "id": "portugues__Crase__Médio__5",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Médio",
    "question": "Por que NÃO há crase em 'Ela saiu a correr'?",
    "options": [
      "Não se usa crase antes de verbos",
      "Porque 'correr' é masculino",
      "Porque falta artigo",
      "Crase é facultativa antes de verbos"
    ],
    "correctIndex": 0,
    "explanation": "Verbos não aceitam artigo, portanto é impossível haver crase antes deles. O 'a' em 'a correr' é apenas preposição. Crase = preposição + artigo; sem artigo, não há crase.",
    "example": "Sem crase antes de verbos: saiu a correr, começou a estudar, aprendeu a nadar. O infinitivo nunca aceita artigo (exceto quando substantivado: 'O correr do tempo')."
  },
  {
    "id": "portugues__Crase__Médio__6",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Médio",
    "question": "Em 'Fui a Itália nas férias', deveria haver crase?",
    "options": [
      "Sim: 'à Itália' (país feminino com artigo: 'vim DA Itália')",
      "Não — nomes de países não têm crase",
      "Crase facultativa",
      "Não — 'Itália' é nome próprio"
    ],
    "correctIndex": 0,
    "explanation": "Países e regiões femininos que aceitam artigo têm crase: 'Fui à Itália' (vim DA Itália = de + a). Compare: 'Fui a Israel' (vim DE Israel = sem artigo, sem crase).",
    "example": "Com artigo (crase): à França, à Argentina, à Itália, à Bahia. Sem artigo (sem crase): a Portugal, a Israel, a Curitiba. Teste com 'vim de/da'."
  },
  {
    "id": "portugues__Crase__Médio__7",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Médio",
    "question": "Em 'Estou à disposição para ajudar', a crase está correta?",
    "options": [
      "Sim — 'à disposição' é locução prepositiva feminina",
      "Não — não há preposição",
      "Crase facultativa",
      "Não — 'disposição' não aceita artigo"
    ],
    "correctIndex": 0,
    "explanation": "'À disposição' é locução prepositiva feminina — crase obrigatória. Assim como: à espera de, à mercê de, à custa de, à procura de. São expressões fixas.",
    "example": "Locuções prepositivas femininas com crase: à espera de, à procura de, à mercê de, à custa de, à disposição de, à beira de. Sempre crase."
  },
  {
    "id": "portugues__Crase__Médio__8",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Médio",
    "question": "Em qual frase a crase é obrigatória?",
    "options": [
      "'Cheguei à conclusão certa.' (locução verbal + subst. feminino com artigo)",
      "'Enviou cartas a diversas empresas.' (plural sem artigo definido)",
      "'Assistiu a excelente filme.' (sem artigo antes de 'excelente')",
      "'Correu a perder de vista.' (modo adverbial com artigo fem. opcional)"
    ],
    "correctIndex": 0,
    "explanation": "'Cheguei à conclusão' = a+a: verbo 'chegar' exige preposição 'a', 'conclusão' admite artigo 'a' → crase obrigatória. 'A diversas empresas': antes de plural com artigo indeterminado — sem crase.",
    "example": "Obrigatória: verbos de movimento/ating. + subst. fem. com artigo. Locuções: às vezes, à medida que, à vista. Facultativa: 'Escrevo a/à Mariana.' Proibida: antes de masculino, antes de verbo, antes de pronome sem artigo."
  },
  {
    "id": "portugues__Crase__Difícil__1",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Difícil",
    "question": "Marque a alternativa em que a crase está CORRETA:",
    "options": [
      "Pintou o quadro à óleo, mas entregou a tela à diretora.",
      "Refiro-me àquilo que disse ontem.",
      "Ele chegou à casa cansado.",
      "Vou à Curitiba amanhã."
    ],
    "correctIndex": 1,
    "explanation": "'Àquilo' = preposição 'a' + pronome demonstrativo 'aquilo' → crase obrigatória. 'A óleo' = sem crase (palavra masculina). 'Chegou a casa' = sem crase (casa sem adjunto). 'Vou a Curitiba' = sem crase (cidade sem determinante).",
    "example": "Crase com demonstrativos aquele/aquela/aquilo: a + aquilo = àquilo, a + aquele = àquele, a + aquela = àquela. Sempre craseados quando a regência pede preposição 'a'."
  },
  {
    "id": "portugues__Crase__Difícil__2",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Difícil",
    "question": "Crase é usada antes de horário. Qual frase está correta?",
    "options": [
      "Chegarei às 14 horas.",
      "Chegarei as 14 horas.",
      "Chegarei a 14 horas.",
      "Chegarei nas 14 horas."
    ],
    "correctIndex": 0,
    "explanation": "Antes de horas determinadas, usa-se crase: 'às 14 horas', 'à meia-noite', 'às 8h'. Teste: 'ao meio-dia' (com artigo + preposição no masculino) confirma a crase no feminino 'às 14 horas'.",
    "example": "Com horário específico: 'às 8h', 'à 1h', 'às 14h'. Sem crase: 'a partir das 8h' (não é preposição 'a' + artigo). Dica: 'Cheguei ao meio-dia' → 'Cheguei à meia-noite' (crase)."
  },
  {
    "id": "portugues__Crase__Difícil__3",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Difícil",
    "question": "Identifique onde há crase OBRIGATÓRIA:",
    "options": [
      "Às vezes, ele é desatento.",
      "Fui a alguma loja.",
      "Ele se dedicou a esta causa.",
      "Dei o livro a ela."
    ],
    "correctIndex": 0,
    "explanation": "'Às vezes' é locução adverbial feminina — crase obrigatória. Locuções adverbiais femininas: à toa, à noite, às pressas, às vezes, à tarde, à esquerda, à direita. Os demais não têm crase: pronome indefinido, pronome demonstrativo, pronome pessoal.",
    "example": "Locuções adverbiais femininas com crase: à toa, à noite/tarde/meia-noite, às claras, à vista, à beça, à risca, à vontade. São expressões fixas."
  },
  {
    "id": "portugues__Crase__Difícil__4",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Difícil",
    "question": "Em 'Fui à Bahia, mas não fui a São Paulo', por que a crase muda?",
    "options": [
      "'Bahia' aceita artigo ('a Bahia'); 'São Paulo' não aceita",
      "Ambas deveriam ter crase",
      "Nenhuma deveria ter crase",
      "'São Paulo' é masculino"
    ],
    "correctIndex": 0,
    "explanation": "Alguns estados/cidades aceitam artigo (a Bahia, a França, a Argentina) e outros não (São Paulo, Curitiba, Israel). Se o nome aceita artigo, há crase com preposição 'a'. Teste: 'Vim da Bahia' (= de + a → aceita artigo). 'Vim de São Paulo' (sem artigo).",
    "example": "Com artigo (crase): à Bahia, à França, à Itália. Sem artigo (sem crase): a São Paulo, a Curitiba, a Israel. Teste: se 'vim DA', crase; se 'vim DE', sem crase."
  },
  {
    "id": "portugues__Crase__Difícil__5",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Difícil",
    "question": "Em 'à distância de 100 metros' vs 'a distância', quando há crase?",
    "options": [
      "Quando 'distância' está determinada/especificada: 'à distância de 100m'",
      "Sempre há crase com 'distância'",
      "Nunca há crase com 'distância'",
      "Crase facultativa em todos os casos"
    ],
    "correctIndex": 0,
    "explanation": "'A distância' sem determinação: sem crase (locução adverbial genérica). 'À distância de 100 metros': com crase, pois 'distância' está determinada pela expressão 'de 100 metros'. A determinação do substantivo exige artigo, gerando crase.",
    "example": "'Viu a distância' (sem especificar = sem crase). 'Viu à distância de 50m' (especificada = crase). Regra análoga: 'à vista de todos' (determinado) vs 'a vista' (genérico)."
  },
  {
    "id": "portugues__Crase__Difícil__6",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Difícil",
    "question": "Em 'Fez referência à que chegou primeiro', a crase está correta?",
    "options": [
      "Sim: 'à que' = preposição 'a' + demonstrativo 'a' (= aquela) + 'que'",
      "Não — não há crase antes de 'que'",
      "Crase facultativa",
      "Não — o 'a' é apenas preposição"
    ],
    "correctIndex": 0,
    "explanation": "'À que' = a (preposição) + a (pronome demonstrativo = 'aquela') + que (pronome relativo). 'Fez referência àquela que chegou primeiro.' A crase ocorre pela presença do demonstrativo 'a' (= aquela) após preposição.",
    "example": "'Referência à que chegou' = 'referência àquela que chegou'. O 'a' antes de 'que' é demonstrativo, não artigo. Teste: substitua por 'aquela que' — se funcionar, há crase."
  },
  {
    "id": "portugues__Crase__Difícil__7",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Difícil",
    "question": "Em 'Ele se refere à mesma pessoa de ontem', a crase está correta?",
    "options": [
      "Sim: preposição 'a' + artigo 'a' antes de 'mesma'",
      "Não — 'mesma' é pronome, não aceita artigo",
      "Crase facultativa",
      "Não — o verbo não pede preposição"
    ],
    "correctIndex": 0,
    "explanation": "'Referir-se a' (VTI) pede preposição 'a'. 'A mesma pessoa' aceita artigo definido 'a'. Crase: a (prep.) + a (artigo) mesma pessoa = 'à mesma pessoa'. A pala­v­ra 'mesma' não impede a crase.",
    "example": "Teste: 'refere-se ao mesmo homem' (ao = a + o). Se no masculino usa 'ao', no feminino usa crase: 'à mesma pessoa'. 'Mesma' não impede artigo."
  },
  {
    "id": "portugues__Crase__Difícil__8",
    "track": "portugues",
    "category": "Crase",
    "difficulty": "Difícil",
    "question": "Em 'À medida que crescia, aprendia mais', a crase ocorre porque:",
    "options": [
      "'À medida que' é locução conjuntiva proporcional que exige artigo feminino antes de 'medida'; preposição+artigo = à",
      "'Medida' é substantivo feminino qualquer e o verbo rege preposição 'a'",
      "Há crase facultativa em locuções adverbiais femininas",
      "A crase ocorre por eufonia antes de vogal"
    ],
    "correctIndex": 0,
    "explanation": "'À medida que' é locução conjuntiva proporcional fixa: a + medida + que. 'Medida' recebe artigo definido por ser nome feminino usado com preposição. Não confundir com 'na medida em que' (causa, sem crase).",
    "example": "'À medida que' = proporção simultânea. 'Na medida em que' = causa. São expressões diferentes. Erro usual: 'a medida que' (sem acento) = errado nestas locuções consolidadas."
  },
  {
    "id": "portugues__Figuras de Linguagem__Fácil__1",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Fácil",
    "question": "Em 'Aquele homem é um touro na força', a figura de linguagem presente é:",
    "options": [
      "Metáfora",
      "Metonímia",
      "Hipérbole",
      "Antítese"
    ],
    "correctIndex": 0,
    "explanation": "Metáfora: comparação implícita (sem 'como', 'tal qual'). O homem é comparado a um touro em força, sem usar conectivo de comparação. Se fosse 'forte como um touro', seria comparação (símile).",
    "example": "Metáfora: 'Ele é um touro.' (comparação implícita). Comparação/Símile: 'Ele é forte como um touro.' (comparação explícita com 'como')."
  },
  {
    "id": "portugues__Figuras de Linguagem__Fácil__2",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Fácil",
    "question": "O que é uma hipérbole?",
    "options": [
      "Exagero intencional para dar ênfase",
      "Comparação entre dois elementos",
      "Substituição de um termo por outro",
      "Atribuição de características humanas a objetos"
    ],
    "correctIndex": 0,
    "explanation": "Hipérbole é o exagero proposital na expressão para dar ênfase ou dramaticidade. Exemplos: 'Estou morrendo de fome', 'Chorei rios de lágrimas', 'Já te disse um milhão de vezes'. O exagero não é literal.",
    "example": "'Morrendo de fome' (não está literalmente morrendo). 'Demorou séculos' (não foram séculos). 'Está mil graus lá fora' (exagero da temperatura)."
  },
  {
    "id": "portugues__Figuras de Linguagem__Fácil__3",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Fácil",
    "question": "Em 'As estrelas sorriam no céu', a figura de linguagem é:",
    "options": [
      "Prosopopeia",
      "Metáfora",
      "Metonímia",
      "Hipérbole"
    ],
    "correctIndex": 0,
    "explanation": "Prosopopeia (ou personificação): atribui características humanas a seres inanimados ou irracionais. Estrelas não sorriem — sorrir é uma ação humana. A prosopopeia dá vida e humanidade a elementos não humanos.",
    "example": "Prosopopeia: 'O vento sussurrava', 'A natureza chora', 'O sol nos abraça'. Sempre que algo não humano realiza ação humana = personificação."
  },
  {
    "id": "portugues__Figuras de Linguagem__Fácil__4",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Fácil",
    "question": "Em 'Eu morri de rir ontem', a figura de linguagem é:",
    "options": [
      "Hipérbole",
      "Metáfora",
      "Metonímia",
      "Eufemismo"
    ],
    "correctIndex": 0,
    "explanation": "Hipérbole é o exagero intencional para dar ênfase. 'Morri de rir' não é literal — ninguém morre de rir. O exagero enfatiza a intensidade da risada. Hipérbole é muito usada na linguagem coloquial.",
    "example": "Hipérboles: 'chorei rios de lágrimas', 'já falei mil vezes', 'morrendo de fome', 'te esperei uma eternidade'. Todas são exageros expressivos."
  },
  {
    "id": "portugues__Figuras de Linguagem__Fácil__5",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Fácil",
    "question": "Na frase 'A vida é uma montanha-russa', que figura de linguagem há?",
    "options": [
      "Metáfora",
      "Comparação",
      "Metonímia",
      "Hipérbole"
    ],
    "correctIndex": 0,
    "explanation": "Metáfora: comparação implícita SEM conectivo comparativo. 'A vida É uma montanha-russa' (não usa 'como'). Se fosse 'A vida é COMO uma montanha-russa', seria comparação (símile).",
    "example": "Metáfora: 'A vida é uma montanha-russa.' (sem 'como'). Comparação/símile: 'A vida é COMO uma montanha-russa.' A diferença é a presença do conectivo comparativo."
  },
  {
    "id": "portugues__Figuras de Linguagem__Fácil__6",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Fácil",
    "question": "Em 'Ele é forte como um leão', a figura de linguagem é:",
    "options": [
      "Comparação (símile)",
      "Metáfora",
      "Metonímia",
      "Hipérbole"
    ],
    "correctIndex": 0,
    "explanation": "Comparação (ou símile) usa conectivo comparativo ('como', 'tal qual', 'feito'). 'Forte COMO um leão' compara explicitamente. Se fosse 'Ele é um leão', seria metáfora (sem conectivo).",
    "example": "Comparação: 'forte COMO um leão' (explícita, com 'como'). Metáfora: 'Ele é um leão' (implícita, sem conectivo). O 'como' é a chave da distinção."
  },
  {
    "id": "portugues__Figuras de Linguagem__Fácil__7",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Fácil",
    "question": "O que é antítese?",
    "options": [
      "Aproximação de palavras de sentido oposto na mesma frase",
      "Exagero intencional",
      "Comparação implícita",
      "Substituição de um termo por outro"
    ],
    "correctIndex": 0,
    "explanation": "Antítese é a aproximação de palavras ou ideias contrárias na mesma frase para criar contraste: 'Chorar e rir', 'guerra e paz', 'claro e escuro'. Difere do paradoxo, que une ideias logicamente contraditórias.",
    "example": "Antítese: 'Nasci para chorar e rir.' (oposição de palavras). Paradoxo: 'O amor é fogo que arde sem se ver.' (contradição lógica)."
  },
  {
    "id": "portugues__Figuras de Linguagem__Fácil__8",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Fácil",
    "question": "Em 'As ondas cantavam na praia', qual figura de linguagem está presente?",
    "options": [
      "Personificação (prosopopeia): atribui ação humana ('cantavam') a ser inanimado (ondas)",
      "Metáfora: comparação implícita sem 'como'",
      "Hipérbole: exagero para ênfase",
      "Eufemismo: suavização de ideia desagradável"
    ],
    "correctIndex": 0,
    "explanation": "Personificação/Prosopopeia: atribuição de características humanas a seres inanimados, animais ou abstratos. 'Ondas cantavam': ondas não cantam literalmente. Difere da metáfora que apenas compara implicitamente sem atribuir ação humana.",
    "example": "Outros exemplos: 'O vento suspirava.', 'A natureza chora.' Metáfora: 'A vida é uma viagem' (comparação implícita). Símile: 'A vida é como uma viagem'. Hipérbole: 'Tenho um oceano de problemas.' Eufemismo: 'Ele nos deixou' (= morreu)."
  },
  {
    "id": "portugues__Figuras de Linguagem__Médio__1",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Médio",
    "question": "Em 'Li Machado de Assis nas férias', qual figura de linguagem está presente?",
    "options": [
      "Metonímia",
      "Metáfora",
      "Catacrese",
      "Prosopopeia"
    ],
    "correctIndex": 0,
    "explanation": "Metonímia: substituição de um termo por outro que mantém relação de contiguidade. 'Machado de Assis' substitui 'a obra de Machado de Assis'. Trocou-se o autor pela obra. É uma relação lógica (autor → obra), não uma comparação.",
    "example": "Tipos de metonímia: autor pela obra ('li Machado'), continente pelo conteúdo ('bebi dois copos'), parte pelo todo ('mil cabeças de gado'), marca pelo produto ('me passa o Bombril')."
  },
  {
    "id": "portugues__Figuras de Linguagem__Médio__2",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Médio",
    "question": "O que é eufemismo?",
    "options": [
      "Suavização de uma expressão desagradável",
      "Exagero proposital",
      "Repetição de sons",
      "Contradição aparente"
    ],
    "correctIndex": 0,
    "explanation": "Eufemismo é o uso de expressões mais suaves para amenizar algo desagradável, trágico ou grosseiro. Exemplo: 'Ele descansou' em vez de 'Ele morreu'. 'Pessoa de baixa renda' em vez de 'pobre'.",
    "example": "'Faltou com a verdade' (mentiu). 'Passou desta para melhor' (morreu). 'Funcionamento intestinal' (diarreia). O eufemismo suaviza, a disfemia agrava."
  },
  {
    "id": "portugues__Figuras de Linguagem__Médio__3",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Médio",
    "question": "Em 'Aquela música tocou meu coração', qual figura de linguagem há?",
    "options": [
      "Catacrese",
      "Antítese",
      "Aliteração",
      "Sinestesia"
    ],
    "correctIndex": 0,
    "explanation": "Catacrese é o uso de uma palavra em sentido figurado que se tornou tão comum que já não é percebida como figura. 'Tocar o coração' (emocionar) é uma metáfora desgastada = catacrese. Outros: pé da mesa, dente de alho, embarcar no avião.",
    "example": "Catacreses do dia a dia: 'pé da mesa' (mesa não tem pé), 'asa do xícara', 'céu da boca', 'embarcar no avião' (embarcar vem de barco). Metáforas que viraram linguagem corrente."
  },
  {
    "id": "portugues__Figuras de Linguagem__Médio__4",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Médio",
    "question": "Qual a diferença entre metáfora e comparação (símile)?",
    "options": [
      "Comparação usa conectivo (como, tal qual); metáfora substitui diretamente",
      "São a mesma coisa",
      "Metáfora usa 'como'",
      "Comparação não relaciona dois termos"
    ],
    "correctIndex": 0,
    "explanation": "Comparação (ou símile) usa conectivo: 'Ele é COMO um leão.' Metáfora faz a substituição direta: 'Ele é um leão.' Ambas aproximam dois seres, mas a metáfora é mais compacta e expressiva.",
    "example": "Comparação: 'Seus olhos são COMO estrelas.' Metáfora: 'Seus olhos são estrelas.' Conectivos comparativos: como, assim como, tal qual, feito, que nem."
  },
  {
    "id": "portugues__Figuras de Linguagem__Médio__5",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Médio",
    "question": "Em 'Ele tem coração de pedra', qual figura de linguagem está presente?",
    "options": [
      "Metáfora",
      "Metonímia",
      "Prosopopeia",
      "Sinestesia"
    ],
    "correctIndex": 0,
    "explanation": "'Coração de pedra' é metáfora — comparação implícita entre o coração (sentimentos) e a pedra (dureza/insensibilidade). Não há conectivo comparativo. O sentido é que a pessoa é fria e insensível.",
    "example": "Metáforas com 'coração': coração de pedra (frio), coração de ouro (bondoso), coração partido (sofrendo). Todas atribuem qualidades por associação implícita, sem 'como'."
  },
  {
    "id": "portugues__Figuras de Linguagem__Médio__6",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Médio",
    "question": "O que é ironia como figura de linguagem?",
    "options": [
      "Afirmação cujo sentido real é o oposto do literal",
      "Exagero intencional",
      "Repetição de sons",
      "Substituição do todo pela parte"
    ],
    "correctIndex": 0,
    "explanation": "Ironia é dizer o contrário do que se pensa ou sente, geralmente com intenção humorística ou crítica. 'Que belo trabalho!' (dito sobre algo ruim) é ironia — o sentido real é o oposto do literal.",
    "example": "'Que belo dia!' (em dia de tempestade). 'Como você é inteligente!' (após um erro). A ironia depende do contexto para ser percebida."
  },
  {
    "id": "portugues__Figuras de Linguagem__Médio__7",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Médio",
    "question": "Em 'Bebeu três copos de leite', qual figura de linguagem está presente?",
    "options": [
      "Metonímia",
      "Metáfora",
      "Hipérbole",
      "Prosopopeia"
    ],
    "correctIndex": 0,
    "explanation": "Metonímia: substituição do conteúdo (leite) pelo continente (copos). Ele não bebeu os copos, bebeu o leite que estava neles. É uma relação de contígüidade (proximidade lógica).",
    "example": "Metonímia continente/conteúdo: 'bebeu três copos' (= o líquido dos copos). Outros tipos: autor/obra ('li Shakespeare'), marca/produto ('me dá um Band-Aid')."
  },
  {
    "id": "portugues__Figuras de Linguagem__Médio__8",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Médio",
    "question": "Identifique a figura de linguagem em 'Comprei o jornal ontem' (quando o leitor interpreta 'li o jornal').",
    "options": [
      "Metonímia: uso do continente (jornal) pelo conteúdo (notícias/leitura)",
      "Sinédoque: parte pelo todo",
      "Metáfora: comparação implícita",
      "Ironia: sentido contrário ao dito"
    ],
    "correctIndex": 0,
    "explanation": "Metonímia: substituição por contiguidade (relação lógica: continente/conteúdo, causa/efeito, autor/obra). 'Comprei o jornal' para 'li o jornal': continente pelo conteúdo. 'Ler Machado de Assis' = obra pelo autor. Sinédoque: substituição por inclusão (parte/todo, gênero/espécie).",
    "example": "Metonímia exemplos: 'Beber um copo' (continente), 'Ganhou o pão' (alimento = trabalho). Sinédoque: 'Comprou um Ford' (marca pelo carro). Metáfora: 'Ela é um anjinho.' Ironia: 'Que bela palestra!' (entediante)."
  },
  {
    "id": "portugues__Figuras de Linguagem__Difícil__1",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Difícil",
    "question": "Em 'O silêncio gritava nos corredores vazios', há uma combinação de figuras de linguagem. Quais são?",
    "options": [
      "Prosopopeia e sinestesia",
      "Prosopopeia e paradoxo",
      "Hipérbole e metonímia",
      "Antítese e metáfora"
    ],
    "correctIndex": 1,
    "explanation": "Prosopopeia (personificação): o silêncio 'grita' — atribuir ação humana a algo abstrato. Paradoxo: silêncio que grita — conceitos contraditórios coexistindo (silêncio = ausência de som; gritar = produzir som intenso). Sinestesia seria mistura de sentidos (visão/audição/tato), que não ocorre aqui.",
    "example": "Prosopopeia: 'o silêncio gritava' (silêncio não grita). Paradoxo: gritar + silêncio são contraditórios. A combinação intensifica a sensação de vazio e desolação no ambiente."
  },
  {
    "id": "portugues__Figuras de Linguagem__Difícil__2",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Difícil",
    "question": "O que é sinestesia?",
    "options": [
      "Mistura de sensações de sentidos diferentes",
      "Repetição de consoantes",
      "Inversão da ordem sintática",
      "Comparação explícita"
    ],
    "correctIndex": 0,
    "explanation": "Sinestesia é a figura que mistura sensações de sentidos diferentes (visão, audição, tato, olfato, paladar). Exemplo: 'voz doce' (audição + paladar), 'cor quente' (visão + tato), 'perfume suave' (olfato + tato).",
    "example": "'Voz macia' (audição + tato). 'Olhar frio' (visão + tato). 'Som colorido' (audição + visão). Dois sentidos corporais se cruzam na descrição."
  },
  {
    "id": "portugues__Figuras de Linguagem__Difícil__3",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Difícil",
    "question": "Identifique a antítese: 'A guerra e a paz vivem no mesmo coração.'",
    "options": [
      "Guerra × paz (termos opostos na mesma frase)",
      "A frase inteira é uma metáfora",
      "Não há figura de linguagem",
      "É uma hipérbole"
    ],
    "correctIndex": 0,
    "explanation": "Antítese é a aproximação de palavras ou expressões de sentido oposto. 'Guerra' e 'paz' são antônimos colocados na mesma frase para criar contraste. Difere do paradoxo, que é uma contradição lógica entre as ideias (não apenas entre as palavras).",
    "example": "Antítese: oposição de palavras. 'Chorar e rir', 'nascer e morrer', 'claro e escuro'. Paradoxo: oposição lógica. 'O amor é fogo que arde sem se ver.' (fogo invisível = contradição)."
  },
  {
    "id": "portugues__Figuras de Linguagem__Difícil__4",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Difícil",
    "question": "Em 'E ríamos, e cantávamos, e dancávamos sem parar', qual figura está presente?",
    "options": [
      "Polissíndeto",
      "Assíndeto",
      "Elipse",
      "Alteração"
    ],
    "correctIndex": 0,
    "explanation": "Polissíndeto é a repetição intencional de conjunções ('e... e... e...'). Cria efeito de enumeração enfatizada, prolongamento e ritmo. O oposto é o assíndeto (omissão de conjunções: 'cheguei, vi, venci').",
    "example": "Polissíndeto: 'E chove, e para, e chove novamente.' (repete 'e'). Assíndeto: 'Cheguei, vi, venci.' (omite 'e'). O polissíndeto prolonga; o assíndeto acelera."
  },
  {
    "id": "portugues__Figuras de Linguagem__Difícil__5",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Difícil",
    "question": "O que é gradação (ou clímax)?",
    "options": [
      "Sequência de ideias em ordem crescente ou decrescente de intensidade",
      "Repetição de sons consonantais",
      "Inversão da ordem natural das palavras",
      "Substituição do todo pela parte"
    ],
    "correctIndex": 0,
    "explanation": "Gradação é a disposição de palavras ou ideias em sequência ascendente (clímax) ou descendente (anticlímax). Intensifica progressivamente: 'Um sopro, uma brisa, um vendaval, um furacão.' (crescente).",
    "example": "Crescente (clímax): 'Olhou, sorriu, apaixonou-se.' Decrescente (anticlímax): 'Furacão, tempestade, chuva, garoa, brisa.' A gradação cria efeito dramático."
  },
  {
    "id": "portugues__Figuras de Linguagem__Difícil__6",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Difícil",
    "question": "O que é aliteração?",
    "options": [
      "Repetição de sons consonantais no início ou interior das palavras",
      "Repetição de vogais",
      "Exagero intencional",
      "Substituição de um termo por outro"
    ],
    "correctIndex": 0,
    "explanation": "Aliteração é a repetição de sons consonantais, criando ritmo e musicalidade. 'O rato roeu a roupa do rei de Roma' (repetição do /r/). É figura de som (figura fônica), muito usada em poesia e trava-línguas.",
    "example": "Aliteração (consoantes): 'O rato roeu a roupa' (/r/). Assonância (vogais): 'Sou um mulato nato no sentido lato' (/a/). Ambas são figuras de som."
  },
  {
    "id": "portugues__Figuras de Linguagem__Difícil__7",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Difícil",
    "question": "Em 'Foi o não querer que me fez querer', qual figura há?",
    "options": [
      "Paradoxo",
      "Antítese",
      "Hipérbole",
      "Metonímia"
    ],
    "correctIndex": 0,
    "explanation": "Paradoxo: ideias logicamente contraditórias coexistem. 'Não querer que fez querer' — a recusa gerou o desejo. É uma contradição aparente que revela uma verdade. Difere da antítese (mera oposição de palavras sem contradição lógica).",
    "example": "Paradoxo: 'O não querer me fez querer.' (contradição lógica). Antítese: 'Chorar e rir são humanos.' (oposto sem contradição). O paradoxo une ideias incompatíveis; a antítese apenas as contrasta."
  },
  {
    "id": "portugues__Figuras de Linguagem__Difícil__8",
    "track": "portugues",
    "category": "Figuras de Linguagem",
    "difficulty": "Difícil",
    "question": "'Não é feio o que é belo; é belo o que é feio' é exemplo de qual figura de construção?",
    "options": [
      "Quiasmo: inversão simétrica dos elementos numa segunda proposição (padrão A-B / B-A)",
      "Antítese: oposição de ideias",
      "Paralelismo: repetição de estruturas sem inversão",
      "Anacoluto: quebra da estrutura sintática"
    ],
    "correctIndex": 0,
    "explanation": "Quiasmo: figura de construção em que os termos de uma proposição se repetem na seguinte em ordem invertida (AB|BA). Origem: letra grega Qui (X). 'feio-belo / belo-feio'. Difere da antítese que apenas contrasta sem inverter estrutura.",
    "example": "'Um por todos, todos por um' (quiasmo). Camões usa o quiasmo para criar paralelismo invertido. Quiasmo pode ser sintático, semântico ou fonético. Antítese: 'O Amor é fogo que arde sem ver'; quiasmo = é estruturalmente simétrico e invertido."
  },
  {
    "id": "portugues__Ortografia__Fácil__1",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Fácil",
    "question": "Qual palavra está grafada CORRETAMENTE?",
    "options": [
      "Privilégio",
      "Previlégio",
      "Pivilégio",
      "Prevelégio"
    ],
    "correctIndex": 0,
    "explanation": "A grafia correta é 'privilégio' (com 'i' na primeira e segunda sílaba: pri-vi-lé-gio). É um dos erros ortográficos mais comuns na língua portuguesa, frequentemente escrito erroneamente como 'previlégio'.",
    "example": "Palavras que geram dúvida semelhante: beneficente (não 'beneficiente'), meritocracia, disenteria (não 'desinteria')."
  },
  {
    "id": "portugues__Ortografia__Fácil__2",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Fácil",
    "question": "Qual é a grafia correta: 'concerto' ou 'conserto'?",
    "options": [
      "Ambas existem: 'concerto' (musical) e 'conserto' (reparo)",
      "Apenas 'concerto' existe",
      "Apenas 'conserto' existe",
      "São a mesma palavra"
    ],
    "correctIndex": 0,
    "explanation": "'Concerto' = apresentação musical ou harmônica ('concerto de piano'). 'Conserto' = reparo, correção ('conserto do carro'). São parônimos (palavras parecidas na grafia/pronúncia, mas com significados diferentes).",
    "example": "Concerto musical × conserto do encanamento. Outros parônimos: comprimento (extensão) × cumprimento (saudação). Tráfego (ânsito) × tráfico (ilícito)."
  },
  {
    "id": "portugues__Ortografia__Fácil__3",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Fácil",
    "question": "Qual é a grafia correta: 'em baixo' ou 'embaixo'?",
    "options": [
      "Ambas existem com sentidos diferentes",
      "Apenas 'embaixo' existe",
      "Apenas 'em baixo' existe",
      "São sinônimos e intercambiáveis"
    ],
    "correctIndex": 0,
    "explanation": "'Embaixo' (junto) é advérbio de lugar: 'Olhe embaixo da mesa.' 'Em baixo' (separado) só se usa quando 'baixo' é adjetivo: 'Falou em baixo tom.' A maioria das vezes, usa-se 'embaixo' junto.",
    "example": "'O gato está embaixo da cama' (advérbio, junto). 'Falou em baixo tom' (adj., separado). Similar: 'acima' (junto) × 'a cima' (não existe separado nesse contexto)."
  },
  {
    "id": "portugues__Ortografia__Fácil__4",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Fácil",
    "question": "Qual é a grafia correta: 'xícara' ou 'chícara'?",
    "options": [
      "Xícara",
      "Chícara",
      "Ambas estão corretas",
      "Nenhuma está correta"
    ],
    "correctIndex": 0,
    "explanation": "A grafia correta é 'xícara', com 'x'. É um dos casos em que o 'x' tem som de 'ch' (/ʃ/). Outras: xarope, xale, enxame, mexer, xadrez.",
    "example": "Palavras com 'x' som de 'ch': xícara, xarope, xale, mexer, enxame, caixa, peixe, ameixa. Após 'en-' usa-se 'x': enxame, enxaqueca, enxugar (exceção: encher, derivados de 'cheio')."
  },
  {
    "id": "portugues__Ortografia__Fácil__5",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Fácil",
    "question": "Complete: 'Eles ___ (viajam/viajem) amanhã.'",
    "options": [
      "viajam — presente do indicativo",
      "viajem — presente do subjuntivo",
      "Ambas estão corretas",
      "Nenhuma está correta"
    ],
    "correctIndex": 0,
    "explanation": "'Viajam' (com 'a') é presente do indicativo: 'Eles viajam amanhã.' (fato). 'Viajem' (com 'e') é presente do subjuntivo: 'Espero que eles viajem.' (desejo/possibilidade). O contexto pede indicativo.",
    "example": "Viajam (indicativo): 'Eles viajam sempre.' Viajem (subjuntivo): 'Que eles viajem bem.' Viagem (substantivo): 'A viagem foi boa.' Três palavras diferentes!"
  },
  {
    "id": "portugues__Ortografia__Fácil__6",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Fácil",
    "question": "Qual é a grafia correta: 'enxergar' ou 'enchergar'?",
    "options": [
      "Enxergar",
      "Enchergar",
      "Ambas estão corretas",
      "Depende do contexto"
    ],
    "correctIndex": 0,
    "explanation": "'Enxergar' se escreve com 'x'. Regra: após o prefixo 'en-', geralmente se usa 'x': enxergar, enxame, enxaqueca, enxugar. Exceção: derivados de palavras com 'ch' (encher, enchente ← cheio).",
    "example": "Após 'en-' + x: enxergar, enxame, enxoval, enxugar. Após 'en-' + ch (exceções): encher, enchente (de cheio). 'Enxergar' não deriva de palavra com 'ch'."
  },
  {
    "id": "portugues__Ortografia__Fácil__7",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Fácil",
    "question": "Complete: 'A ___ (viagem/viajem) foi maravilhosa.'",
    "options": [
      "viagem — substantivo (com 'g')",
      "viajem — verbo (com 'j')",
      "Ambas estão corretas",
      "Nenhuma está correta"
    ],
    "correctIndex": 0,
    "explanation": "'Viagem' (com 'g') é substantivo: 'A viagem foi boa.' 'Viajem' (com 'j') é verbo no subjuntivo: 'Que eles viajem bem.' Aqui o contexto pede o substantivo.",
    "example": "Viagem (substantivo, -gem): 'Boa viagem!' Viajem (subjuntivo, -jem): 'Quero que viajem.' Regra: substantivos → -gem (viagem, garagem). Verbos → -jem (viajem, viajem)."
  },
  {
    "id": "portugues__Ortografia__Fácil__8",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Fácil",
    "question": "Qual a grafia correta: 'encerrar' ou 'inserrar'?",
    "options": [
      "'Encerrar' — prefixo en- + cerrar; 'inserrar' não existe",
      "'Inserrar' — prefixo in- + serrar",
      "Ambas corretas com significados distintos",
      "'En-serrar' com hífen após prefixo em consoantal"
    ],
    "correctIndex": 0,
    "explanation": "'Encerrar': en- + cerrar = fechar completamente. Não há 'inserrar'. Prefixo en-/em- antes de b/p: 'embrulhar', 'empapar'. en- antes de outras consoantes: encerrar, encontrar.",
    "example": "Encerrar: fechar (encerrou a reunião). Outros com en-: encher, enriquecer, encontro. Erros comuns: 'incerrar' (errado), 'en-cerrar' (hífen desnecessário). Regra prefixos in-/en-: in- = negação (incapaz); en-/em- = ação (embalar)."
  },
  {
    "id": "portugues__Ortografia__Médio__1",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Médio",
    "question": "Complete: 'Os documentos foram _____ pelo diretor, que agiu com muita _____.'",
    "options": [
      "analisados / discrição",
      "analizados / discrição",
      "analisados / descrição",
      "analizados / descrição"
    ],
    "correctIndex": 0,
    "explanation": "'Analisar' se escreve com 's' (e seus derivados: análise, analisados). 'Discrição' (qualidade de discreto) ≠ 'descrição' (ato de descrever). Verbos terminados em '-isar' levam 's' quando derivam de palavras com 's': análise → analisar, pesquisa → pesquisar.",
    "example": "Discrição = reserva, prudência (ser discreto). Descrição = relato detalhado (descrever algo). Analisar com 's' porque vem de análise (com 's')."
  },
  {
    "id": "portugues__Ortografia__Médio__2",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Médio",
    "question": "Quando se usa 'onde' e 'aonde'?",
    "options": [
      "'Onde' = posição estática. 'Aonde' = ideia de movimento/destino",
      "São sinônimos",
      "'Aonde' está sempre errado",
      "'Onde' só se usa com verbos"
    ],
    "correctIndex": 0,
    "explanation": "'Onde' indica posição (lugar em que se está): 'Onde você mora?' 'Aonde' indica direção/movimento (lugar para onde se vai): 'Aonde você vai?' 'A + onde' = preposição de destino.",
    "example": "Onde (estar em): 'Onde você está?' (posição). Aonde (ir a): 'Aonde você vai?' (movimento). Dica: se o verbo pede 'a' (ir a), use 'aonde'. Se não, use 'onde'."
  },
  {
    "id": "portugues__Ortografia__Médio__3",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Médio",
    "question": "Qual a regra para uso de 'ss' e 'ç'?",
    "options": [
      "'SS' nunca inicia palavra; 'ç' nunca inicia palavra nem vem antes de 'e/i'",
      "São intercambiáveis",
      "'SS' só aparece no final",
      "'Ç' pode iniciar palavras"
    ],
    "correctIndex": 0,
    "explanation": "Regras: 'SS' só aparece entre vogais (assas-sino, mas-sa). 'Ç' nunca inicia palavra e nunca vem antes de 'e' ou 'i' (nesse caso usa-se 'c': cebola, cidade). 'Ç' vem antes de 'a', 'o', 'u': caça, berço, açúcar.",
    "example": "SS entre vogais: passo, assunto, professor. Ç antes de a/o/u: berço, criança, açúcar. C antes de e/i: cena, cidade (mesmo som de ç). Nunca: çe, çi, ss no início."
  },
  {
    "id": "portugues__Ortografia__Médio__4",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Médio",
    "question": "Qual é a grafia correta: 'jeito' ou 'geito'?",
    "options": [
      "Jeito",
      "Geito",
      "Ambas estão corretas",
      "Depende do contexto"
    ],
    "correctIndex": 0,
    "explanation": "A grafia correta é 'jeito', com J. A palavra vem do latim 'jactu'. Palavras de origem latina, tupi ou africana geralmente usam J. G antes de 'e/i' aparece em palavras de origem grega ou latina com G.",
    "example": "Com J: jeito, jeitoso, ajeitar, loja, gorjeta, jibia, jiló. Com G: gesto, gente, girassol, girafa, ferrugem, viagem (substantivo). Dica: se a palavra tem formas com 'ja/jo/ju', usa J em todas: viajar → viajo (J)."
  },
  {
    "id": "portugues__Ortografia__Médio__5",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Médio",
    "question": "Complete: 'A ___ de cinema começou às 20h.' (seção / sessão / cessão)",
    "options": [
      "sessão (período de tempo/exibição)",
      "seção (divisão/departamento)",
      "cessão (ato de ceder)",
      "Todas estão corretas"
    ],
    "correctIndex": 0,
    "explanation": "'Sessão' = período de tempo dedicado a uma atividade (sessão de cinema, sessão de terapia). 'Seção' = divisão, parte (seção de roupas, seção eleitoral). 'Cessão' = ato de ceder (cessão de direitos).",
    "example": "Sessão de cinema (tempo). Seção de brinquedos (divisão). Cessão de imóvel (ceder). São parônimos — grafia e som semelhantes, significados distintos."
  },
  {
    "id": "portugues__Ortografia__Médio__6",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Médio",
    "question": "Qual a diferença entre 'afim' e 'a fim de'?",
    "options": [
      "'Afim' = semelhante/afinidade. 'A fim de' = com a finalidade de",
      "São sinônimos",
      "'Afim' indica finalidade",
      "'A fim de' indica semelhança"
    ],
    "correctIndex": 0,
    "explanation": "'Afim' (junto) é adjetivo que significa semelhante, parecido: 'Temos gostos afins.' 'A fim de' (separado) é locução que indica finalidade: 'Estudou a fim de passar.'",
    "example": "Afim (junto): 'Línguas afins' (semelhantes), 'ideias afins'. A fim de (separado): 'A fim de melhorar' (com o objetivo de). Coloquial: 'Estou a fim de você' (interessado)."
  },
  {
    "id": "portugues__Ortografia__Médio__7",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Médio",
    "question": "Qual é a grafia correta: 'exceção' ou 'excessão'?",
    "options": [
      "Exceção",
      "Excessão",
      "Ambas existem",
      "Nenhuma está correta"
    ],
    "correctIndex": 0,
    "explanation": "A grafia correta é 'exceção' (com 'ç'), derivada de 'exceto'. 'Excessão' não existe. Cuidado: 'excesso' (com 'ss') existe e é outra palavra (= demasiado).",
    "example": "Exceção (de exceto, com ç). Excesso (quantidade demasiada, com ss). São palavras diferentes! 'Exceção à regra' vs 'excesso de velocidade'."
  },
  {
    "id": "portugues__Ortografia__Médio__8",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Médio",
    "question": "Qual a grafia correta do grupo de palavras apresentado?",
    "options": [
      "Descreditar, discriminar, desculpa",
      "Desacreditar, desstampar, descriminar",
      "Dezacordo, descobrir, descrever",
      "Descreditar, disscriminar, desculpa"
    ],
    "correctIndex": 0,
    "explanation": "Descreditar (des+creditar — retirar crédito), discriminar (dis+criminar), desculpa (des+culpa). Dezacordo: incorreto; correto=desacordo. Discriminar = diferenciar; descriminar = retirar criminalização (ambas existem com significados distintos).",
    "example": "Discriminar (dis- + criminare): distinguir, separar com preconceito. Descriminar (des- + criminar): inocentar de crime. Regra: des- antes de vogal = des+; antes de s = dis: 'dissuadir', 'dissabor'."
  },
  {
    "id": "portugues__Ortografia__Difícil__1",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Difícil",
    "question": "Assinale a alternativa em que todas as palavras estão grafadas CORRETAMENTE:",
    "options": [
      "Hesitar, exceção, ascensão, pretensão",
      "Hesitar, excessão, ascensão, pretenção",
      "Ezitar, exceção, ascenção, pretensão",
      "Hesitar, exceção, ascenção, pretenção"
    ],
    "correctIndex": 0,
    "explanation": "Hesitar (com 'h' e 's'). Exceção (com 'ç' — derivado de exceto). Ascensão (com 's' — de ascender). Pretensão (com 's' — de pretender). As demais opções contêm erros: 'excessão', 'ascenção' e 'pretenção' não existem.",
    "example": "Regra: -tender → -tensão (pretender→pretensão, estender→extensão). -ceder → -cessão (conceder→concessão). -ceto → -ceção (exceto→exceção). -cender → -censão (ascender→ascensão)."
  },
  {
    "id": "portugues__Ortografia__Difícil__2",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre 'mas' e 'mais'?",
    "options": [
      "'Mas' = conjunção adversativa. 'Mais' = advérbio de intensidade",
      "São sinônimos",
      "'Mas' indica adição",
      "'Mais' indica oposição"
    ],
    "correctIndex": 0,
    "explanation": "'Mas' é conjunção adversativa (= porém, contudo): 'Estudei, mas não passei.' 'Mais' é advérbio de intensidade ou pronome indefinido: 'Quero mais café.' As duas palavras têm funções completamente diferentes.",
    "example": "'Ele é inteligente, MAS preguiçoso.' (oposição). 'Ela quer MAIS tempo.' (quantidade). Erro comum: 'Estudei, mais não passei' (errado, deveria ser 'mas')."
  },
  {
    "id": "portugues__Ortografia__Difícil__3",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Difícil",
    "question": "Em qual alternativa todas as palavras estão com o hífen CORRETO conforme o Novo Acordo?",
    "options": [
      "Auto-escola → autoescola; anti-inflamatório → anti-inflamatório",
      "Auto-escola; antiinflamatório",
      "Autoescola; antiinflamatório",
      "Auto-escola; anti-inflamatório"
    ],
    "correctIndex": 0,
    "explanation": "Novo Acordo: prefixo + vogal diferente = sem hífen (autoescola). Prefixo terminado em vogal + mesma vogal = com hífen (anti-inflamatório: i+i). Exceção: co- e re- geralmente juntam: cooperar, reeleger.",
    "example": "Mesma vogal: anti-inflamatório (i+i), micro-ondas (o+o). Vogais diferentes: autoescola (o+e), semiaberto (i+a). Antes de H: anti-herói, sobre-humano."
  },
  {
    "id": "portugues__Ortografia__Difícil__4",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Difícil",
    "question": "Quando usar 'por que', 'porque', 'por quê' e 'porquê'?",
    "options": [
      "'Por que' (pergunta/relativo), 'porque' (causa), 'por quê' (fim de frase), 'porquê' (substantivo)",
      "Todos são intercambiáveis",
      "'Porque' é para perguntas",
      "'Porquê' é usado em respostas"
    ],
    "correctIndex": 0,
    "explanation": "'Por que' (separado, sem acento): em perguntas diretas/indiretas e como 'pelo qual'. 'Porque' (junto): explica causa/motivo. 'Por quê' (separado + acento): no fim de frase. 'Porquê' (junto + acento): substantivo (= motivo).",
    "example": "Por que você saiu? (pergunta). Saí porque choveu. (causa). Saiu por quê? (fim de frase). Não sei o porquê. (substantivo = motivo)."
  },
  {
    "id": "portugues__Ortografia__Difícil__5",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Difícil",
    "question": "Qual alternativa apresenta uso CORRETO de 'x' e 'ch'?",
    "options": [
      "Enxaqueca, mexer, enchente, brochura",
      "Enchaqueca, mexer, enxente, broxura",
      "Enxaqueca, mecher, enchente, brochura",
      "Enxaqueca, mexer, enxente, brochura"
    ],
    "correctIndex": 0,
    "explanation": "Enxaqueca (após 'en-', usa 'x'). Mexer (com 'x'). Enchente (deriva de 'cheio', então mantém 'ch' mesmo após 'en-'). Brochura (com 'ch'). A regra geral é: após 'en-' usa-se 'x', EXCETO derivados de palavras com 'ch'.",
    "example": "Após 'en-' + x: enxame, enxaqueca, enxugar, enxoval. Após 'en-' + ch (exceções, derivadas de 'ch'): encher (cheio), enchente (cheio), enchouricar (chouriço)."
  },
  {
    "id": "portugues__Ortografia__Difícil__6",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre 'há' e 'a' indicando tempo?",
    "options": [
      "'Há' = tempo passado. 'A' = tempo futuro",
      "São sinônimos",
      "'Há' = futuro. 'A' = passado",
      "Ambos indicam passado"
    ],
    "correctIndex": 0,
    "explanation": "'Há' (verbo haver) indica tempo passado: 'Há 3 anos não viajo.' 'A' (preposição) indica tempo futuro: 'Daqui a 3 anos viajarei.' Dica: se puder trocar por 'faz', use 'há'. Se não, use 'a'.",
    "example": "Há 2 meses não chove (passado = faz 2 meses). Daqui a 2 meses choverá (futuro). Teste: 'Faz 2 meses...' → funciona = 'Há'. 'Faz 2 meses viajarei' → não funciona = 'A'."
  },
  {
    "id": "portugues__Ortografia__Difícil__7",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Difícil",
    "question": "Quando se usa 'mim' e quando se usa 'eu' após preposição?",
    "options": [
      "'Para mim' (complemento). 'Para eu fazer' (sujeito do infinitivo)",
      "Sempre 'para mim'",
      "Sempre 'para eu'",
      "São intercambiáveis"
    ],
    "correctIndex": 0,
    "explanation": "'Mim' é pronome oblíquo (objeto): 'Traga para mim.' 'Eu' é pronome do caso reto (sujeito): 'Traga para eu analisar.' Quando há verbo no infinitivo cujo sujeito é o pronome, usa-se 'eu'. Senão, 'mim'.",
    "example": "'Dê para mim.' (mim = complemento). 'Dê para eu ler.' (eu = sujeito de 'ler'). 'Mim não faz nada' é ERRADO — 'mim' nunca é sujeito. Correto: 'Eu não faço nada.'"
  },
  {
    "id": "portugues__Ortografia__Difícil__8",
    "track": "portugues",
    "category": "Ortografia",
    "difficulty": "Difícil",
    "question": "Após o acordo ortográfico de 2009, quando se usa hífen em palavras formadas com 're-'?",
    "options": [
      "Não se usa hífen com 're-' quando o elemento seguinte começa por consoante diferente de 'h' ou 'r'; usa-se hífen apenas antes de 'r' (re-resolver) e 'h' (re-hidratar)",
      "Usa-se sempre hífen após 're-' antes de qualquer vogal",
      "Nunca se usa hífen com o prefixo 're-'",
      "Hífen obrigatório quando o radical começa por vogal idêntica ao prefixo"
    ],
    "correctIndex": 0,
    "explanation": "Regra pós-acordo 2009: hífen com 're-' somente antes de 'h' (re-hidratar) e 'r' (re-resolver, re-regredir). Antes de vogal diferente: reeleger, reeleicão (sem hífen no Brasil). Antes de consoante: retornar (sem hífen).",
    "example": "Reeleição (sem hífen, Brasil). Re-hidratar: hífen antes de 'h' mudo. Re-resolver: hífen antes de r. Regra geral prefixos: hífen antes de r, h; sem hífen antes de vogais e consoantes. Pós-2009 reforma simplificou muitas regras."
  },
  {
    "id": "portugues__Pontuação__Fácil__1",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Fácil",
    "question": "A vírgula é obrigatória em qual das frases abaixo?",
    "options": [
      "Maria, venha aqui!",
      "Eu quero que Maria venha aqui.",
      "Maria quer vir aqui.",
      "Eu e Maria viemos aqui."
    ],
    "correctIndex": 0,
    "explanation": "Em 'Maria, venha aqui!', Maria é vocativo (chamamento direto). O vocativo SEMPRE é isolado por vírgula. Nas demais frases, 'Maria' é sujeito e não se separa do verbo por vírgula.",
    "example": "Vocativo: 'Maria, venha!' / 'Venha aqui, Maria!' / 'Venha, Maria, aqui!' — sempre com vírgula. Sujeito: 'Maria veio.' — nunca com vírgula entre sujeito e verbo."
  },
  {
    "id": "portugues__Pontuação__Fácil__2",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Fácil",
    "question": "Em qual frase a vírgula está usada INCORRETAMENTE?",
    "options": [
      "Os alunos, estudaram para a prova.",
      "Ontem, fui ao cinema.",
      "Maria, minha amiga, chegou.",
      "Eu quero pão, queijo e leite."
    ],
    "correctIndex": 0,
    "explanation": "'Os alunos, estudaram' — vírgula entre sujeito e verbo é PROIBIDA na língua portuguesa. O sujeito nunca pode ser separado do verbo por vírgula. As demais estão corretas: adjunto adverbial deslocado, aposto e enumeração.",
    "example": "NUNCA: sujeito + vírgula + verbo. 'Os alunos estudaram.' (correto). 'Os alunos, estudaram.' (ERRADO). Já 'Os alunos, que se prepararam, passaram.' é correto (oração intercalada)."
  },
  {
    "id": "portugues__Pontuação__Fácil__3",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Fácil",
    "question": "Para que serve a vírgula na frase 'São Paulo, a maior cidade do Brasil, é muito movimentada'?",
    "options": [
      "Isolar o aposto explicativo",
      "Separar sujeito do verbo",
      "Indicar enumeração",
      "Marcar vocativo"
    ],
    "correctIndex": 0,
    "explanation": "'A maior cidade do Brasil' é um aposto explicativo — uma informação adicional sobre 'São Paulo'. Apostos explicativos são sempre isolados por vírgulas (ou travessões). Não confundir com vocativo (chamamento).",
    "example": "Aposto: 'Machado de Assis, grande escritor, nasceu no Rio.' 'Grande escritor' explica quem é Machado. Vocativo: 'Machado, venha cá!' (chamamento direto)."
  },
  {
    "id": "portugues__Pontuação__Fácil__4",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Fácil",
    "question": "Em 'Maria, traga o café!', para que serve a vírgula?",
    "options": [
      "Isolar o vocativo",
      "Separar sujeito do verbo",
      "Indicar enumeração",
      "Isolar aposto"
    ],
    "correctIndex": 0,
    "explanation": "'Maria' é vocativo — chamamento direto. O vocativo SEMPRE é isolado por vírgula: no início ('Maria, venha'), no meio ('Venha, Maria, agora') ou no fim ('Venha, Maria'). Não confundir com sujeito.",
    "example": "Vocativo: 'Maria, venha!' (chamando Maria). Sujeito: 'Maria veio.' (Maria pratica a ação, sem vírgula). O vocativo sempre tem vírgula; o sujeito nunca é separado do verbo por vírgula."
  },
  {
    "id": "portugues__Pontuação__Fácil__5",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Fácil",
    "question": "Qual sinal de pontuação introduz uma enumeração?",
    "options": [
      "Dois-pontos",
      "Ponto-e-vírgula",
      "Travessão",
      "Reticencias"
    ],
    "correctIndex": 0,
    "explanation": "Os dois-pontos (:) introduzem enumerações: 'Comprei frutas: banana, maçã e uva.' Também introduzem citações e explicações. Ponto-e-vírgula separa itens da enumeração, não a introduz.",
    "example": "Dois-pontos para iniciar: 'Trouxe: pão, leite.'. Ponto-e-vírgula para separar itens longos: 'Trouxe: pão integral, de centeio; leite desnatado, integral.'"
  },
  {
    "id": "portugues__Pontuação__Fácil__6",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Fácil",
    "question": "Para que serve o ponto de interrogação?",
    "options": [
      "Indicar pergunta direta",
      "Encerrar frases afirmativas",
      "Indicar suspense",
      "Separar orações coordenadas"
    ],
    "correctIndex": 0,
    "explanation": "O ponto de interrogação (?) marca perguntas diretas: 'Você vem?' Em perguntas indiretas, não se usa: 'Gostaria de saber se você vem.' (ponto final).",
    "example": "Direta: 'Onde você mora?' (com ?). Indireta: 'Perguntou onde você mora.' (sem ?). O ponto de interrogação só aparece em perguntas diretas."
  },
  {
    "id": "portugues__Pontuação__Fácil__7",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Fácil",
    "question": "Em 'Comprei pão, queijo e leite', qual a função da vírgula?",
    "options": [
      "Separar itens de uma enumeração",
      "Isolar aposto",
      "Marcar vocativo",
      "Separar sujeito do verbo"
    ],
    "correctIndex": 0,
    "explanation": "A vírgula separa itens de uma enumeração (série de termos de mesma função): pão, queijo e leite. O último item é ligado por 'e' (sem vírgula antes dele, na regra geral).",
    "example": "Enumeração: 'Comprei pão, queijo e leite.' Vírgula entre itens, 'e' antes do último. Também: 'Comprei pão, queijo, leite e ovos.' (vírgula só entre itens, não antes do 'e')."
  },
  {
    "id": "portugues__Pontuação__Fácil__8",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Fácil",
    "question": "Quando deve ser usada a vírgula entre sujeito e predicado?",
    "options": [
      "Nunca; separar sujeito do predicado com vírgula é erro gramatical",
      "Sempre que o sujeito for longo",
      "Quando o predicado começar por verbo de ligação",
      "Quando há adjunto adverbial antes do predicado"
    ],
    "correctIndex": 0,
    "explanation": "Regra: NÃO se usa vírgula entre sujeito e verbo (predicado). '* O aluno, estudou muito' — errado. Exceções aparentes: vírgula por intercalação de adjunto adverbial ou aposto entre S e V: 'O aluno, cansado, dormiu.' — as vírgulas delimitam o adjunto/aposto.",
    "example": "Errado: 'O mercado, fechou cedo.' Correto: 'O mercado fechou cedo.' Com adjunto intercalado: 'O mercado, inesperadamente, fechou cedo.' Aposto: 'Paulo, meu amigo, chegou.'"
  },
  {
    "id": "portugues__Pontuação__Médio__1",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Médio",
    "question": "Em qual alternativa o ponto-e-vírgula está empregado corretamente?",
    "options": [
      "Alguns preferem café; outros, chá.",
      "Ele disse; que viria.",
      "O livro é bom; e interessante.",
      "Comprei; pão e leite."
    ],
    "correctIndex": 0,
    "explanation": "O ponto-e-vírgula separa orações coordenadas com sentidos opostos ou paralelos, especialmente quando há vírgula interna. 'Alguns preferem café; outros, chá' — separa duas orações coordenadas, e a segunda tem zeugma (omissão de 'preferem'), marcada pela vírgula.",
    "example": "Uso do ponto-e-vírgula: 1) Separar orações com vírgula interna. 2) Separar itens de listas longas. 'Trabalhei de manhã; estudei à tarde; descansei à noite.'"
  },
  {
    "id": "portugues__Pontuação__Médio__2",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Médio",
    "question": "Quando se usam dois-pontos?",
    "options": [
      "Antes de citações, enumerações e explicações",
      "Apenas para indicar hora",
      "Para separar sujeito do predicado",
      "Para substituir a vírgula"
    ],
    "correctIndex": 0,
    "explanation": "Dois-pontos introduzem: 1) Citações diretas: 'Ele disse: ...' 2) Enumerações: 'Comprei: pão, leite e ovos.' 3) Explicações/esclarecimentos: 'O motivo é simples: não havia tempo.' Também indicam hora (14:30).",
    "example": "'Ele disse: \"Vou sair.\"' (citação). 'Tenho três irmãos: João, Pedro e Ana.' (enumeração). 'O problema é claro: falta investimento.' (explicação)."
  },
  {
    "id": "portugues__Pontuação__Médio__3",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Médio",
    "question": "Em qual frase o travessão está usado corretamente?",
    "options": [
      "A cidade — que é linda — fica no litoral.",
      "A cidade, — que é linda, fica no litoral.",
      "A cidade que — é linda fica no litoral.",
      "A cidade que é — linda — fica no litoral."
    ],
    "correctIndex": 0,
    "explanation": "O travessão pode substituir vírgulas ou parênteses para isolar orações ou expressões intercaladas: 'A cidade — que é linda — fica no litoral.' Também é usado para marcar a fala do interlocutor em diálogos.",
    "example": "Travessão duplo (intercalação): 'O Brasil — país tropical — é diverso.' Travessão em diálogo: '— Você vem? — perguntou Maria.' Nunca misturar travessão com vírgula no mesmo trecho."
  },
  {
    "id": "portugues__Pontuação__Médio__4",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Médio",
    "question": "Quando se usam reticências (...)?",
    "options": [
      "Para indicar interrupção, suspense ou hesitação",
      "Para encerrar frases afirmativas",
      "Para substituir o ponto final",
      "Para indicar enumeração"
    ],
    "correctIndex": 0,
    "explanation": "Reticências (...) indicam: 1) Interrupção do pensamento: 'Eu queria dizer que...' 2) Suspense/expectativa: 'E o vencedor é...' 3) Hesitação: 'Bem... acho que sim.' 4) Omissão de trecho citado: '[...] como disse o autor.'",
    "example": "Suspense: 'E então...' Hesitação: 'Talvez... não sei.' Omissão em citação: '[...] a vida continua.' Reticências são sempre três pontos, nunca mais."
  },
  {
    "id": "portugues__Pontuação__Médio__5",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Médio",
    "question": "Na frase 'João — o melhor aluno da turma — foi premiado', os travessões podem ser substituídos por:",
    "options": [
      "Vírgulas ou parênteses",
      "Ponto-e-vírgula",
      "Dois-pontos",
      "Aspas"
    ],
    "correctIndex": 0,
    "explanation": "Travessões, vírgulas e parênteses podem isolar intercalações/apostos. 'João, o melhor aluno, foi premiado' (vírgulas). 'João (o melhor aluno) foi premiado' (parênteses). O grau de destaque varia: travessão > vírgula > parênteses.",
    "example": "Travessão: maior destaque. Vírgula: destaque padrão. Parênteses: menor destaque (informação acessória). Os três isolam intercalações, mas com ênfases diferentes."
  },
  {
    "id": "portugues__Pontuação__Médio__6",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Médio",
    "question": "Em 'Ontem, fui ao cinema', a vírgula é obrigatória?",
    "options": [
      "Facultativa — adjunto adverbial curto deslocado",
      "Obrigatória sempre",
      "Proibida",
      "Só obrigatória em textos formais"
    ],
    "correctIndex": 0,
    "explanation": "Adjuntos adverbiais curtos (uma ou duas palavras) deslocados para o início da frase têm vírgula facultativa: 'Ontem(,) fui ao cinema.' Quando o adjunto é longo, a vírgula é obrigatória: 'No último sábado à noite, fui ao cinema.'",
    "example": "Curto (facultativa): 'Ontem(,) fui.' 'Ali(,) encontrei.' Longo (obrigatória): 'No último fim de semana, viajei.' 'Apesar de tudo, continuei.'"
  },
  {
    "id": "portugues__Pontuação__Médio__7",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Médio",
    "question": "Qual a diferença entre ponto final e ponto-e-vírgula?",
    "options": [
      "Ponto encerra período; ponto-e-vírgula separa orações dentro do período",
      "São intercambiáveis",
      "Ponto-e-vírgula encerra parágrafos",
      "Ponto final substitui vírgula"
    ],
    "correctIndex": 0,
    "explanation": "O ponto final encerra um período completo. O ponto-e-vírgula indica pausa maior que a vírgula, mas menor que o ponto, mantendo as orações no mesmo período. É usado entre orações independentes com relação entre si.",
    "example": "Ponto: 'Estudei. Passei.' (2 períodos). Ponto-e-vírgula: 'Estudei; por isso, passei.' (1 período, 2 orações). Vírgula: pausa menor. Ponto-e-vírgula: pausa média. Ponto: pausa maior."
  },
  {
    "id": "portugues__Pontuação__Médio__8",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Médio",
    "question": "O uso do ponto e vírgula em 'Aprendeu teoria; praticou exercícios; passou na prova' é correto? Por quê?",
    "options": [
      "Sim; separa orações coordenadas justapostas de conteúdo paralelo, indicando pausa intermediária entre vírgula e ponto",
      "Não; deveria ser vírgula em todos os casos",
      "Não; o ponto e vírgula é usado somente em listas de itens numerados",
      "Sim; obrigatório entre todas as orações coordenadas"
    ],
    "correctIndex": 0,
    "explanation": "Ponto e vírgula: pausa intermediária entre vírgula e ponto. Separa orações coordenadas longas ou com relação paralela de conteúdo. Também usado em listas com itens complexos. Não obrigatório entre todas as coordenadas.",
    "example": "Paralelo: 'Quem muito fala, muito erra; quem muito erra, muito aprende; quem muito aprende, muito sabe.' Ponto e vírgula em listas: quando cada item tem vírgula interna. Vírgula seria insuficiente para distinguir os níveis."
  },
  {
    "id": "portugues__Pontuação__Difícil__1",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Difícil",
    "question": "Em qual frase as aspas e demais pontuações estão empregadas CORRETAMENTE conforme a norma culta?",
    "options": [
      "O professor disse: 'A prova será amanhã'.",
      "O professor disse: \"A prova será amanhã.\"",
      "O professor disse, 'A prova será amanhã.'",
      "O professor disse - \"A prova será amanhã\"."
    ],
    "correctIndex": 1,
    "explanation": "Na norma culta do português brasileiro: usa-se dois-pontos antes da fala e aspas duplas para citação direta. O ponto final fica DENTRO das aspas quando a citação é uma frase completa. Formato: Fulano disse: \"Frase completa.\"",
    "example": "Correto: O professor disse: \"A prova será amanhã.\" (dois-pontos + aspas duplas + ponto dentro das aspas). As aspas simples são reservadas para citações dentro de citações."
  },
  {
    "id": "portugues__Pontuação__Difícil__2",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Difícil",
    "question": "Qual é a função dos parênteses na frase 'O presidente (eleito em 2022) tomou posse'?",
    "options": [
      "Intercalar informação acessória/explicativa",
      "Isolar o sujeito",
      "Substituir aspas",
      "Indicar citação direta"
    ],
    "correctIndex": 0,
    "explanation": "Parênteses isolam informações acessórias, complementares ou explicativas que poderiam ser retiradas sem prejudicar o sentido principal da frase. São intercalações que acrescentam detalhes não essenciais.",
    "example": "'O presidente (eleito em 2022) tomou posse.' = 'O presidente tomou posse.' + informação extra. Parênteses, travessões e vírgulas podem isolar intercalações, em graus diferentes de destaque."
  },
  {
    "id": "portugues__Pontuação__Difícil__3",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Difícil",
    "question": "Quando não se usa vírgula antes de 'e'?",
    "options": [
      "Quando o 'e' liga orações com o mesmo sujeito",
      "Nunca se usa vírgula antes de 'e'",
      "Sempre se usa vírgula antes de 'e'",
      "Quando 'e' inicia a frase"
    ],
    "correctIndex": 0,
    "explanation": "Não se usa vírgula antes de 'e' quando ele liga orações com o MESMO sujeito: 'Ele estudou e passou.' Usa-se vírgula quando os sujeitos são diferentes: 'Ele estudou, e ela descansou.' Ou quando 'e' tem valor adversativo: 'Tentou, e não conseguiu.'",
    "example": "Mesmo sujeito: 'João leu e escreveu.' (sem vírgula). Sujeitos diferentes: 'João leu, e Maria escreveu.' (com vírgula). 'E' adversativo: 'Tentou, e falhou.' (= mas falhou)."
  },
  {
    "id": "portugues__Pontuação__Difícil__4",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Difícil",
    "question": "Em 'Ele não veio porque estava doente', a vírgula antes de 'porque' é necessária?",
    "options": [
      "Não — oração causal restritiva dispensa vírgula",
      "Sim — sempre se usa vírgula antes de 'porque'",
      "Depende do tamanho da frase",
      "Só se usa vírgula em perguntas"
    ],
    "correctIndex": 0,
    "explanation": "Quando 'porque' introduz a razão direta (causal restritiva), normalmente não se usa vírgula. Com vírgula, 'porque' passa a explicativo: 'Não veio, porque estava doente' (explicação). Sem vírgula, a causa é restritiva.",
    "example": "Sem vírgula (causal): 'Saiu porque quis.' (motivo direto). Com vírgula (explicativa): 'Deve estar chovendo, porque as ruas estão molhadas.' (constatação que explica). A vírgula muda o sentido!"
  },
  {
    "id": "portugues__Pontuação__Difícil__5",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Difícil",
    "question": "Qual a função das aspas no texto 'O 'milagre econômico' não beneficiou a todos'?",
    "options": [
      "Indicar ironia ou ressalva sobre o termo",
      "Marcar citação direta",
      "Destacar palavra estrangeira",
      "Indicar título de obra"
    ],
    "correctIndex": 0,
    "explanation": "As aspas em 'milagre econômico' indicam que o autor não endossa o termo — há ironia ou ressalva. As aspas sinalizam que a palavra está sendo usada em sentido diferente do literal, com distância crítica.",
    "example": "Aspas de sentido figurado/ironia: 'O 'herói' fugiu.' (não é heroísmo real). Aspas de citação: 'Machado disse: \"Marcela amou-me.\"' Aspas de estrangeirismo: 'Faça o 'check-in'.'"
  },
  {
    "id": "portugues__Pontuação__Difícil__6",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Difícil",
    "question": "Em 'O aluno que estudou passou' vs 'O aluno, que estudou, passou', qual a diferença semântica?",
    "options": [
      "Sem vírgula: restritiva (só o que estudou). Com vírgula: explicativa (todos)",
      "Não há diferença",
      "Com vírgula é informal",
      "Sem vírgula é informal"
    ],
    "correctIndex": 0,
    "explanation": "Sem vírgula: oração restritiva — apenas o aluno que estudou passou (os outros não). Com vírgula: oração explicativa — o aluno (que, aliás, estudou) passou. A vírgula muda completamente o sentido.",
    "example": "'Os alunos que estudaram passaram.' (restritiva: só os que estudaram). 'Os alunos, que estudaram, passaram.' (explicativa: todos, que aliás estudaram). Vírgula = informação extra."
  },
  {
    "id": "portugues__Pontuação__Difícil__7",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Difícil",
    "question": "Na frase 'Comprei frutas, verduras, legumes, etc.', a vírgula antes de 'etc.' está correta?",
    "options": [
      "Sim — a norma padrão aceita vírgula antes de 'etc.'",
      "Não — 'etc.' já contém 'e' (et), então a vírgula é redundante",
      "Só em textos informais",
      "Nunca se usa vírgula antes de 'etc.'"
    ],
    "correctIndex": 0,
    "explanation": "A norma padrão brasileira (ABNT, gramáticos renomados) aceita vírgula antes de 'etc.': 'frutas, verduras, etc.' Embora 'et cetera' signifique 'e outras coisas', a vírgula é consagrada pelo uso.",
    "example": "'Etc.' = et cetera (latim: 'e outras coisas'). Vírgula aceita: 'pão, leite, ovos, etc.' Nunca usar: 'e etc.' (pleonaísmo: 'e e outras coisas'). Sempre com ponto: 'etc.' (abreviação)."
  },
  {
    "id": "portugues__Pontuação__Difícil__8",
    "track": "portugues",
    "category": "Pontuação",
    "difficulty": "Difícil",
    "question": "Qual o efeito de sentido ao usar reticências em 'Eu ia dizer algo, mas...'?",
    "options": [
      "Suspensão do pensamento: indica hesitação, incompletude, ideia subentendida ou emoção contida",
      "Indica citação abreviada de texto original",
      "Marca o fim de uma enumeração exaustiva",
      "Corresponde a ponto final em estilo informal"
    ],
    "correctIndex": 0,
    "explanation": "Reticências: indicam suspensão do pensamento (interrupção), hesitação, ideia implícita (subentendido), emoção (lágrimas, timidez). Também: enumeração incompleta ('Comprei pão, leite, ovos...'). Citação com supressão: [...] usa colchetes em textos acadêmicos.",
    "example": "'Eu ia dizer algo, mas...' — o leitor infere o conteúdo omitido (recurso retórico). Machado de Assis utilizava para subentendidos maliciosos. Ponto final: certeza; reticências: dúvida ou suspensão."
  },
  {
    "id": "portugues__Redação Oficial__Fácil__1",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Fácil",
    "question": "Qual fecho de comunicação oficial é adequado para uma autoridade de MESMA hierarquia?",
    "options": [
      "Atenciosamente,",
      "Respeitosamente,",
      "Cordialmente,",
      "Com apreço,"
    ],
    "correctIndex": 0,
    "explanation": "'Atenciosamente' é usado para autoridades de mesma hierarquia ou de hierarquia inferior. 'Respeitosamente' é usado para autoridades de hierarquia superior. Conforme o Manual de Redação da Presidência da República, são os únicos dois fechos recomendados.",
    "example": "Mesmo nível ou inferior ao remetente → Atenciosamente. Superior ao remetente → Respeitosamente. Esses são os únicos dois fechos oficiais aceitos."
  },
  {
    "id": "portugues__Redação Oficial__Fácil__2",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Fácil",
    "question": "O que é um 'Ofício' na redação oficial?",
    "options": [
      "Comunicação oficial entre autoridades de órgãos diferentes",
      "Carta pessoal formal",
      "Ata de reunião",
      "Publicação no Diário Oficial"
    ],
    "correctIndex": 0,
    "explanation": "Ofício é um tipo de comunicação oficial utilizada entre autoridades e órgãos públicos para tratar de assuntos administrativos. Após o Decreto 9.758/2019, o padrão ofício unificou ofício, memorando e aviso em um único formato.",
    "example": "Ofício: entre órgãos ou autoridades diferentes. Memorando (antigo): comunicação interna. Aviso (antigo): entre ministros. Hoje todos são 'Ofício' com destinatário específico."
  },
  {
    "id": "portugues__Redação Oficial__Fácil__3",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Fácil",
    "question": "O que significa o princípio da impessoalidade na redação oficial?",
    "options": [
      "O texto não expressa opiniões pessoais, representando a instituição",
      "O texto não tem autor",
      "O texto não menciona nomes",
      "O texto é escrito em outro idioma"
    ],
    "correctIndex": 0,
    "explanation": "Impessoalidade: o autor não fala em nome próprio, mas em nome do órgão/instituição. Evita-se linguagem subjetiva, impressões pessoais e tratamento privilegiado. O texto deve ser objetivo e uniforme para qualquer destinatário.",
    "example": "ERRADO: 'Eu acho que devemos melhorar...' CORRETO: 'Esta Secretaria entende que medidas devem ser adotadas...' A voz é institucional, não pessoal."
  },
  {
    "id": "portugues__Redação Oficial__Fácil__4",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Fácil",
    "question": "Qual é o pronome de tratamento adequado para o Presidente da República?",
    "options": [
      "Vossa Excelência",
      "Vossa Senhoria",
      "Vossa Magnificência",
      "Vossa Santidade"
    ],
    "correctIndex": 0,
    "explanation": "O Presidente da República é tratado por 'Vossa Excelência' (abreviatura: V. Exa.). É o tratamento para as mais altas autoridades: Presidente, Vice-Presidente, Ministros, Governadores, Prefeitos, Parlamentares, Juízes, entre outros.",
    "example": "Vossa Excelência: Presidente, Ministros, Governadores, Juízes. Vossa Senhoria: diretores e funcionários. Vossa Magnificência: reitores. Vossa Santidade: Papa."
  },
  {
    "id": "portugues__Redação Oficial__Fácil__5",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Fácil",
    "question": "Na redação oficial, pode-se usar abreviações como 'vc', 'tb' e 'pq'?",
    "options": [
      "Não — são informais e inadequadas",
      "Sim — tornam o texto mais ágil",
      "Apenas em e-mails internos",
      "Apenas em notas de rodapé"
    ],
    "correctIndex": 0,
    "explanation": "Abreviações informais (vc, tb, pq, qdo) são proibidas na redação oficial. Só são aceitas abreviaturas padronizadas: Sr. (Senhor), V. Exa. (Vossa Excelência), nº (número), etc.",
    "example": "Proibidas: vc, tb, pq, q, cmg, hj. Aceitas: Sr., Sra., V. Exa., Dr., Prof., nº, pág. A redação oficial exige formalidade e clareza."
  },
  {
    "id": "portugues__Redação Oficial__Fácil__6",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Fácil",
    "question": "O que é o princípio da clareza na redação oficial?",
    "options": [
      "O texto deve ser compreensível na primeira leitura, sem ambiguidade",
      "O texto deve ser curto",
      "O texto deve usar linguagem rebuscada",
      "O texto deve ter muitos sinônimos"
    ],
    "correctIndex": 0,
    "explanation": "Clareza: o texto deve transmitir a mensagem de forma inequívoca, compreensível na primeira leitura. Evita-se ambiguidade, jargões desnecessários e construções que gerem dúvida.",
    "example": "Ambíguo: 'O diretor disse ao secretário que ele deveria sair.' (quem deveria sair?). Claro: 'O diretor informou ao secretário que este deveria se retirar.' Clareza elimina múltiplas interpretações."
  },
  {
    "id": "portugues__Redação Oficial__Fácil__7",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Fácil",
    "question": "Na redação oficial, qual vocativo é adequado para um governador?",
    "options": [
      "Senhor Governador,",
      "Caro Governador,",
      "Exmo. Governador,",
      "Prezado Governador,"
    ],
    "correctIndex": 0,
    "explanation": "O vocativo adequado é 'Senhor Governador,' (seguido de vírgula). Após o Manual de Redação (2018), eliminou-se 'Excelentíssimo' e 'Ilustríssimo'. Usa-se apenas 'Senhor(a)' + cargo.",
    "example": "Vocativos corretos: 'Senhor Presidente,', 'Senhor Ministro,', 'Senhor Governador,', 'Senhora Deputada,'. Abolidos: 'Excelentíssimo', 'Digno', 'Ilustríssimo'."
  },
  {
    "id": "portugues__Redação Oficial__Fácil__8",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Fácil",
    "question": "O que é o Manual de Redação da Presidência da República (MRPR) e qual seu papel na comunicação oficial?",
    "options": [
      "Guia normativo que padroniza a linguagem, formato e tratamento das comunicações oficiais do poder público federal",
      "Livro de gramática escolar adotado nas repartições públicas",
      "Coletânea de modelos de contratos adotados pelo governo federal",
      "Lei que define as penas por má redação oficial"
    ],
    "correctIndex": 0,
    "explanation": "MRPR (3ª edição, 2018): normatiza comunicação oficial federal. Características: clareza, concisão, impessoalidade, uso do padrão culto, formalidade. Define: ofício, exposição de motivos, mensagem presidencial.",
    "example": "Principal mudança 2018: extingiu o 'memo', unificando em 'ofício' a maioria das comunicações. Tratamentos: 'Vossa Excelência' (Pres. Rep., Congresso, STF), 'Vossa Senhoria' (demais). Impessoalidade: não usar 1ª pessoa do singular."
  },
  {
    "id": "portugues__Redação Oficial__Médio__1",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Médio",
    "question": "Qual dos princípios NÃO é uma característica da redação oficial?",
    "options": [
      "Subjetividade",
      "Impessoalidade",
      "Clareza",
      "Concisão"
    ],
    "correctIndex": 0,
    "explanation": "A redação oficial deve ser impessoal, clara, concisa, formal e padronizada. Subjetividade (opiniões pessoais, expressões emocionais) vai contra o princípio da impessoalidade, que exige tratamento objetivo e uniforme.",
    "example": "Princípios da redação oficial: Impessoalidade, Clareza, Concisão, Formalidade, Uniformidade/Padronização. Proíbe-se: linguagem coloquial, subjetividade, prolixidade."
  },
  {
    "id": "portugues__Redação Oficial__Médio__2",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Médio",
    "question": "Qual é a diferença entre 'Vossa Excelência' e 'Sua Excelência'?",
    "options": [
      "'Vossa' = falando COM a pessoa. 'Sua' = falando SOBRE a pessoa",
      "São sinônimos",
      "'Vossa' é mais formal",
      "'Sua' é para mulheres"
    ],
    "correctIndex": 0,
    "explanation": "'Vossa Excelência' é usado quando se fala diretamente COM a autoridade (2ª pessoa). 'Sua Excelência' é usado quando se fala SOBRE a autoridade para terceiros (3ª pessoa). A distinção é fundamental na redação oficial.",
    "example": "'Vossa Excelência sabe...' (falando COM o governador). 'Sua Excelência, o Governador, decidiu...' (falando SOBRE o governador para outra pessoa)."
  },
  {
    "id": "portugues__Redação Oficial__Médio__3",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Médio",
    "question": "Qual é a estrutura básica de um ofício?",
    "options": [
      "Cabeçalho, vocativo, corpo do texto, fecho e identificação do signatário",
      "Título, introdução, desenvolvimento e conclusão",
      "Saudação informal e corpo",
      "Apenas o corpo do texto"
    ],
    "correctIndex": 0,
    "explanation": "Estrutura do ofício: 1) Cabeçalho (identificação do expediente). 2) Vocativo (Ex: Senhor Ministro). 3) Corpo do texto (assunto). 4) Fecho (Atenciosamente/Respeitosamente). 5) Identificação do signatário (nome e cargo).",
    "example": "Cabeçalho: Ofício nº X/Ano/Órgão. Vocativo: Senhor(a) + cargo. Texto: parágrafos objetivos. Fecho: Atenciosamente ou Respeitosamente. Assinatura: nome completo e cargo."
  },
  {
    "id": "portugues__Redação Oficial__Médio__4",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Médio",
    "question": "Na redação oficial, qual forma pronominal deve-se preferir: 'eu' ou 'nós'?",
    "options": [
      "'Nós' ou formas impessoais — represença-se a instituição",
      "'Eu' — identifica claramente o autor",
      "Ambas são igualmente adequadas",
      "Nenhuma — omite-se o sujeito"
    ],
    "correctIndex": 0,
    "explanation": "Prefere-se 'nós' (plural majestático/de modestia) ou formas impessoais ('solicita-se', 'informa-se') para manter a impessoalidade. 'Eu' individualiza e quebra o caráter institucional do texto.",
    "example": "ERRADO: 'Eu solicito providências.' CORRETO: 'Solicitamos providências.' ou 'Solicita-se providências.' O pronome 'nós' representa a instituição, não o indivíduo."
  },
  {
    "id": "portugues__Redação Oficial__Médio__5",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Médio",
    "question": "O que era um 'Memorando' na antiga nomenclatura da redação oficial?",
    "options": [
      "Comunicação interna entre setores do mesmo órgão",
      "Comunicação entre órgãos diferentes",
      "Convite formal para eventos",
      "Publicação no Diário Oficial"
    ],
    "correctIndex": 0,
    "explanation": "Memorando era a comunicação interna entre setores do MESMO órgão. Após o Decreto 9.758/2019, foi unificado com ofício e aviso no formato padrão 'Óficio'. Hoje, usa-se apenas 'Ofício' para todas as comunicações.",
    "example": "Antes: Memorando (interno), Ofício (externo), Aviso (entre ministros). Depois de 2019: tudo é 'Ofício'. Simplificação e padronização conforme o Manual de Redação da Presidência."
  },
  {
    "id": "portugues__Redação Oficial__Médio__6",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Médio",
    "question": "O que é o 'padrão ofício' na redação oficial?",
    "options": [
      "Formato unificado para todas as comunicações oficiais desde 2019",
      "Modelo exclusivo para ofícios",
      "Padrão de letra e espaçamento",
      "Formato para documentos sigilosos"
    ],
    "correctIndex": 0,
    "explanation": "O padrão ofício, instituído pelo Decreto 9.758/2019, unificou ofício, memorando e aviso em um único formato de comunicação oficial. Simplifica a redação eliminando tipos redundantes.",
    "example": "Padrão ofício: formato único → identificação do expediente + vocativo + texto + fecho + assinatura. Antes: 3 tipos diferentes (ofício, memoraíndo, aviso). Depois: tudo é 'Ofício'."
  },
  {
    "id": "portugues__Redação Oficial__Médio__7",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Médio",
    "question": "Na redação oficial, quando se usa 'Respeitosamente' como fecho?",
    "options": [
      "Quando o destinatário é de hierarquia superior ao remetente",
      "Em qualquer comunicação oficial",
      "Quando o remetente é superior ao destinatário",
      "Apenas em memorandos"
    ],
    "correctIndex": 0,
    "explanation": "'Respeitosamente' é reservado para destinatários de hierarquia SUPERIOR. Exemplo: funcionário escrevendo ao ministro. 'Atenciosamente': para mesma hierarquia ou inferior.",
    "example": "Respeitosamente: para superiores. Atenciosamente: para iguais ou inferiores. São os únicos dois fechos aceitos. Proibidos: 'Cordialmente', 'Subscrevo-me', 'À disposição'."
  },
  {
    "id": "portugues__Redação Oficial__Médio__8",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Médio",
    "question": "Qual tratamento é correto para um documento dirigido a um deputado federal?",
    "options": [
      "Vossa Excelência (V. Exa.): deputados e senadores recebem esse tratamento por serem membros do Poder Legislativo",
      "Vossa Senhoria (V. S.): tratamento para cargos de alto escalão",
      "Ilustríssimo Senhor: tratamento adequado para todos os parlamentares",
      "Doutor: se ele tiver diploma universitário"
    ],
    "correctIndex": 0,
    "explanation": "MRPR: Vossa Excelência (V. Exa.) para: Presidente e Vice da República, Ministros, Governadores, Prefeitos, Senadores, Deputados Federais e Estaduais, Presidente e membros do STF, Embaixadores. Vossa Senhoria: demais autoridades.",
    "example": "V. Exa. vs V. S.ª: não há graduação por grau acadêmico. 'Doutor' não é tratamento oficial no MRPR exceto em contextos médicos. 'Ilustríssimo': era usado antes do MRPR atual; hoje não recomendado."
  },
  {
    "id": "portugues__Redação Oficial__Difícil__1",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Difícil",
    "question": "Conforme o Manual de Redação da Presidência, qual pronome de tratamento é correto para um JUIZ?",
    "options": [
      "Vossa Excelência",
      "Vossa Senhoria",
      "Vossa Magnificência",
      "Meritíssimo"
    ],
    "correctIndex": 0,
    "explanation": "Juízes são tratados por 'Vossa Excelência', conforme o Manual de Redação. 'Meritíssimo' é uma forma de tratamento usada nos tribunais na fala oral, mas não é pronome de tratamento oficial nas comunicações escritas. 'Vossa Magnificência' é para reitores. 'Vossa Senhoria' é para funcionários em geral.",
    "example": "Vossa Excelência: Presidente, Ministros, Governadores, Deputados, Senadores, Juízes, Desembargadores. Vossa Senhoria: diretores de órgãos públicos e demais autoridades. Vossa Magnificência: Reitores."
  },
  {
    "id": "portugues__Redação Oficial__Difícil__2",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Difícil",
    "question": "Na redação oficial, o que significa 'concisão'?",
    "options": [
      "Transmitir a informação com o mínimo de palavras necessárias",
      "Usar linguagem rebuscada",
      "Escrever textos longos e detalhados",
      "Usar gírias para simplificar"
    ],
    "correctIndex": 0,
    "explanation": "Concisão é dizer o máximo com o mínimo de palavras, sem prolixidade nem redundância. Cada palavra deve ser necessária. Textos concisos são diretos e objetivos, eliminando expressões desnecessárias.",
    "example": "Prolixo: 'Venho por meio deste solicitar a Vossa Excelência que se digne a providenciar...' Conciso: 'Solicito providências para...' Menos palavras, mesma informação."
  },
  {
    "id": "portugues__Redação Oficial__Difícil__3",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Difícil",
    "question": "Qual tipo de linguagem é PROIBIDO na redação oficial?",
    "options": [
      "Linguagem coloquial, gírias e expressões regionais",
      "Linguagem formal",
      "Uso de pronomes de tratamento",
      "Parágrafos curtos"
    ],
    "correctIndex": 0,
    "explanation": "A redação oficial exige linguagem formal e culta. São proibidos: gírias, coloquialismos, regionalismos, abreviaturas não oficiais, expressões emocionais e linguagem figurada. O texto deve ser acessível a todos, sem ambiguidade.",
    "example": "ERRADO: 'A gente precisa resolver esse rolo.' CORRETO: 'Nós/Esta Secretaria necessita solucionar a questão.' Formalidade não é rebuscamento — é adequação ao contexto oficial."
  },
  {
    "id": "portugues__Redação Oficial__Difícil__4",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Difícil",
    "question": "O que é uma 'Exposição de Motivos' na redação oficial?",
    "options": [
      "Documento de ministro ao Presidente propondo medida ou explicando razões",
      "Carta de demissão",
      "Ata de reunião ministerial",
      "Parecer jurídico"
    ],
    "correctIndex": 0,
    "explanation": "A Exposição de Motivos é um documento dirigido por Ministro de Estado ao Presidente da República, propondo medida administrativa ou expondo razões para determinada decisão. Pode ser individual ou interministerial.",
    "example": "Exposição de Motivos: Ministro → Presidente. Mensagem: Presidente → Congresso. Ofício: entre órgãos ou autoridades. Cada tipo tem remetente e destinatário específicos."
  },
  {
    "id": "portugues__Redação Oficial__Difícil__5",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre linguagem rebuscada e linguagem formal?",
    "options": [
      "Formal é clara e adequada; rebuscada é excessivamente ornamentada",
      "São a mesma coisa",
      "Rebuscada é mais adequada para textos oficiais",
      "Formal é sinônimo de informal"
    ],
    "correctIndex": 0,
    "explanation": "Linguagem formal segue a norma culta com clareza e objetividade. Linguagem rebuscada usa vocabulário arcaico, construções complexas desnecessárias e ornamentos que dificultam a compreensão. A redação oficial exige formalidade, NÃO rebuscamento.",
    "example": "Rebuscado: 'Outrossim, cumpre-nos asseverar que as providências demandam...' Formal e claro: 'Informamos que as providências serão tomadas.' Formalidade = norma culta + clareza."
  },
  {
    "id": "portugues__Redação Oficial__Difícil__6",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Difícil",
    "question": "O que é uma 'Mensagem' na redação oficial?",
    "options": [
      "Comunicação do Presidente da República ao Congresso Nacional",
      "E-mail interno entre funcionários",
      "Carta pessoal de autoridade",
      "Aviso entre ministros"
    ],
    "correctIndex": 0,
    "explanation": "A Mensagem é instrumento de comunicação oficial do Presidente da República ao Congresso Nacional. É usada para encaminhar projetos de lei, vetar leis, comunicar nomeações, entre outros atos.",
    "example": "Mensagem: Presidente → Congresso. Exposição de Motivos: Ministro → Presidente. Ofício: entre órgãos/autoridades. Cada instrumento tem remitente e destinatário específicos."
  },
  {
    "id": "portugues__Redação Oficial__Difícil__7",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Difícil",
    "question": "Os fechos 'À disposição' e 'Sem mais para o momento' são adequados na redação oficial?",
    "options": [
      "Não — os únicos fechos corretos são 'Atenciosamente' e 'Respeitosamente'",
      "Sim — são formais e adequados",
      "Apenas 'À disposição' é aceito",
      "Ambos são aceitos em memorandos"
    ],
    "correctIndex": 0,
    "explanation": "O Manual de Redação da Presidência estabelece apenas dois fechos: 'Atenciosamente' e 'Respeitosamente'. Formulas como 'À disposição', 'Sem mais', 'Subscrevo-me' estão abolidas.",
    "example": "Abolidos: 'À disposição', 'Sem mais para o momento', 'Cordialmente', 'Subscrevo-me'. Válidos: 'Atenciosamente,' (iguais/inferiores) e 'Respeitosamente,' (superiores). Apenas esses dois."
  },
  {
    "id": "portugues__Redação Oficial__Difícil__8",
    "track": "portugues",
    "category": "Redação Oficial",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre ofício, memorando e circular segundo a redação oficial atual?",
    "options": [
      "Após o MRPR 2018, o memorando foi extinto e o ofício unifica a comunicação inter e extra-órgãos; circular é ofício dirigido a múltiplos destinatários",
      "Memorando: externo; ofício: interno; circular: confidencial",
      "Todos são sinônimos; a denominação varia por área",
      "Memorando persiste para comunicação informal interna"
    ],
    "correctIndex": 0,
    "explanation": "MRPR 3ª ed. (2018): unificou 'memo' e 'ofício' em 'ofício'. Ofício: comunicação oficial entre órgãos ou com particulares. Circular: ofício com mesmo teor enviado a vários destinatários. Exposição de motivos: Ministro → Presidente. Mensagem: Pres. → Congresso.",
    "example": "Elementos do ofício atual: Identificação da unidade, número, data, destinatário, assunto, texto (intro, desenvolvimento, conclusão), fecho ('Atenciosamente' para autoridades de mesma ou menor patente; 'Respeitosamente' para superiores)."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Fácil__1",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual é a regência correta do verbo 'assistir' no sentido de VER?",
    "options": [
      "Assisti ao filme. (transitivo indireto)",
      "Assisti o filme. (transitivo direto)",
      "Assisti no filme. (transitivo indireto)",
      "Assisti pelo filme. (transitivo indireto)"
    ],
    "correctIndex": 0,
    "explanation": "Na norma culta, 'assistir' no sentido de 'ver, presenciar' é transitivo indireto com preposição 'a': assistir ao filme, assistir ao jogo. No sentido de 'prestar assistência', é transitivo direto: 'O médico assistiu o paciente.'",
    "example": "Assistir (ver): TI → assistir AO jogo. Assistir (ajudar): TD → assistir O paciente. Outros verbos com regência com 'a': obedecer a, visar a, aspirar a."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Fácil__2",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual é a regência correta de 'obedecer'?",
    "options": [
      "Obedecer ao professor (transitivo indireto)",
      "Obedecer o professor (transitivo direto)",
      "Obedecer pelo professor",
      "Obedecer com o professor"
    ],
    "correctIndex": 0,
    "explanation": "'Obedecer' é transitivo indireto com preposição 'a': obedecer ao professor, obedecer às regras, obedecer ao regulamento. Da mesma forma, 'desobedecer a'.",
    "example": "Obedecer A: 'Obedecer ao professor', 'Obedecer às leis', 'Obedecer ao sinal.' Na linguagem coloquial é comum sem preposição, mas a norma culta exige 'a'."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Fácil__3",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual é a regência do verbo 'ir'?",
    "options": [
      "Ir A (destino): 'Fui ao cinema'",
      "Ir EM: 'Fui no cinema'",
      "Ir DE: 'Fui do cinema'",
      "Ir COM: 'Fui com o cinema'"
    ],
    "correctIndex": 0,
    "explanation": "Na norma culta, 'ir' pede preposição 'a' (destino): 'Fui ao cinema', 'Foram à escola.' No uso coloquial, é comum 'ir em' ('Fui no cinema'), mas não é aceito na norma padrão escrita.",
    "example": "Ir A (norma culta): 'Fui ao médico', 'Vá à escola.' Ir EM (coloquial, evitar na escrita formal): 'Fui no médico.' Ir PARA (permanência): 'Fui para o exterior' (para ficar)."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Fácil__4",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual a regência do verbo 'namorar' na norma culta?",
    "options": [
      "Transitivo direto: namorar alguém",
      "Transitivo indireto: namorar com alguém",
      "Intransitivo",
      "Bitransitivo"
    ],
    "correctIndex": 0,
    "explanation": "'Namorar' é transitivo direto na norma culta: 'Ela namora João.' (sem preposição). 'Namorar com' é uso coloquial, não aceito na norma padrão escrita.",
    "example": "CORRETO: 'Ela namora João.' COLOQUIAL: 'Ela namora com João.' Dica: se substituir por 'amar' (VTD), funciona sem preposição: 'Ela ama João.'"
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Fácil__5",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Complete: 'Ela gosta ___ chocolate.'",
    "options": [
      "de",
      "a",
      "em",
      "com"
    ],
    "correctIndex": 0,
    "explanation": "'Gostar' é verbo transitivo indireto com preposição 'de': gostar DE algo/alguém. 'Ela gosta de chocolate.' A preposição 'de' é obrigatória na norma culta.",
    "example": "Gostar DE: 'Gosto de música', 'Gosta de viajar.' Precisar DE: 'Preciso de ajuda.' Necessitar DE: 'Necessito de tempo.' São VTIs com preposição 'de'."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Fácil__6",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Complete: 'O professor informou ___ alunos ___ resultado.'",
    "options": [
      "aos / o (VTDI: informar algo A alguém)",
      "os / do (informar alguém DE algo)",
      "para os / o",
      "nos / sobre o"
    ],
    "correctIndex": 0,
    "explanation": "'Informar' admite duas construções: 1) informar algo A alguém: 'Informou o resultado aos alunos.' 2) informar alguém DE algo: 'Informou os alunos do resultado.' Ambas são aceitas na norma culta.",
    "example": "Informar algo A alguém: 'Informou o fato ao diretor.' Informar alguém DE algo: 'Informou o diretor do fato.' Ambas corretas. ERRADO: 'Informou aos alunos do resultado' (mistura as duas construções)."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Fácil__7",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual é a regência do verbo 'chegar' na norma culta?",
    "options": [
      "Chegar A: 'Cheguei à escola'",
      "Chegar EM: 'Cheguei na escola'",
      "Chegar DE: 'Cheguei da escola'",
      "Chegar PARA: 'Cheguei para a escola'"
    ],
    "correctIndex": 0,
    "explanation": "Na norma culta, 'chegar' exige preposição 'a': 'Cheguei à escola', 'Cheguei ao trabalho.' 'Chegar em' é uso coloquial, muito comum na fala, mas inadequado na escrita formal.",
    "example": "Norma culta: 'Cheguei A casa.' 'Cheguei AO escritório.' Coloquial: 'Cheguei NA escola.' 'Cheguei NO trabalho.' Mesma lógica de 'ir A' (não 'ir EM')."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Fácil__8",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Fácil",
    "question": "Qual a regência correta do verbo 'assistir' no sentido de 'ver'?",
    "options": [
      "Assistir a algo: exige preposição 'a' (verbo transitivo indireto)",
      "Assistir algo: transitivo direto sem preposição",
      "Ambas corretas; a preposição é facultativa",
      "Assistir com: preposição 'com' no sentido de observar"
    ],
    "correctIndex": 0,
    "explanation": "'Assistir a' (sentido de ver/presenciar): transitivo indireto. 'Assisti ao jogo / Assisti ao filme.' No sentido de 'prestar assistência': também transitivo indireto. No sentido de 'caber direito': 'Assiste-lhe esse direito.'",
    "example": "'Assisti ao espetáculo.' (correto). '*Assisti o espetáculo.' (errado na norma). Popularmente: 'assisti o filme' é comum; na norma culta requer 'a'. Outros regidos com 'a': obedecer a, responder a, resistir a, aspirar a."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Médio__1",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Qual alternativa apresenta regência verbal CORRETA?",
    "options": [
      "Prefiro cinema a teatro.",
      "Prefiro cinema do que teatro.",
      "Prefiro mais cinema que teatro.",
      "Prefiro cinema ao invés de teatro."
    ],
    "correctIndex": 0,
    "explanation": "O verbo 'preferir' exige a construção: preferir X a Y (sem 'do que', sem 'mais', sem 'ao invés de'). 'Prefiro cinema a teatro' é a única forma correta na norma culta. 'Do que' e 'mais' são influências coloquiais.",
    "example": "Preferir: X a Y. 'Prefiro estudar a trabalhar.' ERRADO: 'Prefiro mais X do que Y.' O verbo já tem sentido de preferência, dispensando 'mais'."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Médio__2",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Qual é a diferença de regência entre 'visar' (objetivo) e 'visar' (assinar)?",
    "options": [
      "Visar A (objetivo, TI). Visar o documento (assinar, TD)",
      "Ambos são transitivos diretos",
      "Ambos são transitivos indiretos",
      "Não há diferença"
    ],
    "correctIndex": 0,
    "explanation": "'Visar' no sentido de 'ter como objetivo' é transitivo indireto: 'Ele visa ao cargo.' No sentido de 'dar visto/assinar' é transitivo direto: 'O gerente visou o cheque.' A mudança de sentido altera a regência.",
    "example": "Visar AO cargo (=almejar, TI). Visar O documento (=assinar, TD). Visar AO sucesso (=ter como meta). Visar O passaporte (=carimbar/assinar)."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Médio__3",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Na frase 'O filme ___ me refiro é antigo', qual pronome relativo preenche corretamente?",
    "options": [
      "a que",
      "que",
      "o qual",
      "cujo"
    ],
    "correctIndex": 0,
    "explanation": "'Referir-se A' → a preposição 'a' deve acompanhar o pronome relativo: 'O filme a que me refiro.' Sem a preposição, a regência fica incorreta. A mesma lógica vale para 'ao qual': 'O filme ao qual me refiro.'",
    "example": "Referir-se A → 'o filme A QUE me refiro.' Gostar DE → 'o livro DE QUE gosto.' Pensar EM → 'a pessoa EM QUE penso.' A preposição sempre precede o pronome relativo."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Médio__4",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Qual a regência do verbo 'implicar' no sentido de 'acarretar'?",
    "options": [
      "Transitivo direto: implicar algo (sem preposição)",
      "Transitivo indireto: implicar em algo",
      "Intransitivo",
      "Bitransitivo"
    ],
    "correctIndex": 0,
    "explanation": "'Implicar' no sentido de 'acarretar/provocar' é transitivo direto: 'A mudança implica riscos.' (sem 'em'). 'Implicar em' é uso coloquial, não aceito na norma culta. Já 'implicar com' (antipatizar) é TI aceito.",
    "example": "Implicar algo (= acarretar, TD): 'O erro implica prejuízo.' Implicar COM alguém (= antipatizar, TI): 'Ela implica com o irmão.' ERRADO: 'Implica em riscos.'"
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Médio__5",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Complete: 'Ele mora ___ São Paulo.'",
    "options": [
      "em",
      "a",
      "de",
      "para"
    ],
    "correctIndex": 0,
    "explanation": "'Morar' exige preposição 'em': 'Ele mora em São Paulo.' Da mesma forma: 'Reside em Brasília.' Verbos que indicam localização estática geralmente pedem 'em'.",
    "example": "Morar EM: 'Moro em São Paulo.' Ir A: 'Fui a São Paulo.' (destino temporário). Ir PARA: 'Fui para São Paulo.' (destino permanente). A preposição muda conforme o verbo."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Médio__6",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Qual é a regência do verbo 'agradar' no sentido de 'satisfazer'?",
    "options": [
      "Transitivo indireto: agradar A alguém",
      "Transitivo direto: agradar alguém",
      "Intransitivo",
      "Transitivo direto e indireto"
    ],
    "correctIndex": 0,
    "explanation": "'Agradar' no sentido de 'satisfazer, contentar' é TI: 'O resultado agradou aos alunos.' No sentido de 'fazer carinho', é TD: 'A mãe agradou o filho.' A mudança de sentido altera a regência.",
    "example": "Agradar A (satisfazer, TI): 'A palestra agradou ao público.' Agradar (fazer carinho, TD): 'Agradou a criança.' Compare: assistir A (ver) vs assistir (ajudar). Sentido diferente = regência diferente."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Médio__7",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Complete: 'O diretor procedeu ___ análise dos documentos.'",
    "options": [
      "à",
      "a",
      "na",
      "com a"
    ],
    "correctIndex": 0,
    "explanation": "'Proceder A' no sentido de 'dar início a, realizar' é transitivo indireto: 'Procedeu à análise' (com crase: a + a = à). No sentido de 'comportar-se', é intransitivo: 'Procedeu mal.'",
    "example": "Proceder A (= realizar, TI): 'Procedeu à votação.' 'Procedeu ao exame.' Proceder (= comportar-se, intransitivo): 'Procedeu bem.' Proceder DE (= originar-se): 'O produto procede da Alemanha.'"
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Médio__8",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Médio",
    "question": "Em 'Ele informou os funcionários sobre as mudanças', 'informou' está correto?",
    "options": [
      "Sim; 'informar alguém sobre algo' é regência padrão aceita (bitransitivo: OD de pessoa + complemento com 'sobre')",
      "Não; deveria ser 'informou aos funcionários'",
      "Não; 'sobre' deve ser substituído por 'a respeito de'",
      "Sim; qualquer preposição é válida após 'informar'"
    ],
    "correctIndex": 0,
    "explanation": "'Informar' admite duas construções: (1) 'informar alguém de/sobre algo' — OD de pessoa + adj adv; (2) 'informar algo a alguém' — OD de coisa + OI de pessoa. Ambas são gramaticalmente corretas.",
    "example": "Bitransitividade: 'Informou a diretoria das decisões' (OI + de). 'Informou as decisões à diretoria' (OD + OI). Regência nominal: 'consciente de', 'capaz de', 'compatível com', 'análogo a'. Regência nominal exige a preposição correta."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Difícil__1",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Em 'O cargo ___ ele aspira exige dedicação', qual pronome relativo completa corretamente?",
    "options": [
      "a que",
      "que",
      "o qual",
      "onde"
    ],
    "correctIndex": 0,
    "explanation": "'Aspirar' no sentido de 'desejar, almejar' é transitivo indireto com preposição 'a': aspirar ao cargo. Na oração relativa, a preposição deve preceder o pronome: 'O cargo a que ele aspira'. Sem a preposição, a regência fica incorreta.",
    "example": "Aspirar A algo → O cargo A QUE aspira. Comparar: 'O filme a que assisti' (assistir AO filme). 'A empresa em que trabalho' (trabalhar NA empresa). A preposição acompanha o pronome relativo."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Difícil__2",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Qual a diferença de regência entre 'esquecer' e 'esquecer-se de'?",
    "options": [
      "'Esquecer' (TD): esqueci o nome. 'Esquecer-se de' (TI): esqueci-me do nome",
      "São idênticos",
      "Apenas 'esquecer' existe",
      "'Esquecer-se' não precisa de preposição"
    ],
    "correctIndex": 0,
    "explanation": "'Esquecer' sem pronome é transitivo direto: 'Esqueci o nome.' 'Esquecer-se' (com pronome reflexivo) é transitivo indireto com 'de': 'Esqueci-me do nome.' A mesma lógica vale para lembrar/lembrar-se de.",
    "example": "Esquecer o livro (TD, sem pronome). Esquecer-se do livro (TI, com pronome + de). Lembrar o fato (TD). Lembrar-se do fato (TI). Com pronome = com preposição."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Difícil__3",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Qual a regência nominal de 'compatível'?",
    "options": [
      "Compatível COM (preposição 'com')",
      "Compatível A",
      "Compatível DE",
      "Compatível EM"
    ],
    "correctIndex": 0,
    "explanation": "Regência nominal: 'compatível COM'. Outros exemplos de regência nominal: acessível a, favorável a, ansioso por, compatível com, passível de, apto a/para, ávido por, imune a.",
    "example": "Compatível COM. Favorável A. Ansioso POR. Passível DE. Apto A/PARA. Acessível A. A regência nominal define qual preposição acompanha nomes (substantivos, adjetivos, advérbios)."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Difícil__4",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Qual a regência nominal do adjetivo 'ávido'?",
    "options": [
      "Ávido POR ou DE",
      "Ávido A",
      "Ávido EM",
      "Ávido COM"
    ],
    "correctIndex": 0,
    "explanation": "'Ávido' aceita as preposições 'por' ou 'de': 'Ávido por conhecimento' ou 'Ávido de novidades'. Ambas são aceitas pela norma culta. Significa 'ansioso, desejoso'.",
    "example": "Ávido POR/DE. Outros: ansioso POR, ávido POR/DE, ávida DE. Compare: favorável A, compatível COM, acessível A, passível DE."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Difícil__5",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Em 'O aluno ___ pai faleceu pediu dispensa', qual pronome relativo completa corretamente?",
    "options": [
      "cujo",
      "que o",
      "do qual o",
      "quem"
    ],
    "correctIndex": 0,
    "explanation": "'Cujo' é pronome relativo que indica POSSE — liga o antecedente (aluno) ao substantivo que vem depois (pai): 'O aluno cujo pai faleceu.' 'Cujo' concorda com o possuído (pai) e nunca é seguido de artigo.",
    "example": "Cujo = de quem. 'O aluno cujo pai = o aluno DE QUEM o pai.' Cujo concorda com o possuído: cujo pai, cuja mãe, cujos irmãos, cujas notas. NUNCA: 'cujo o', 'cuja a' (sem artigo após cujo)."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Difícil__6",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Qual a regência do verbo 'custar' no sentido de 'ser difícil'?",
    "options": [
      "Sujeito = coisa difícil + pronome oblíquo: 'Custou-me entender'",
      "Sujeito = pessoa: 'Eu custei a entender'",
      "Transitivo direto: 'Custei o estudo'",
      "Intransitivo: 'Custei muito'"
    ],
    "correctIndex": 0,
    "explanation": "'Custar' (= ser difícil) tem como sujeito a coisa difícil, não a pessoa: 'Custou-me entender' (entender custou a mim). A pessoa vira objeto indireto (me, lhe). ERRADO: 'Eu custei a entender' (a pessoa como sujeito).",
    "example": "CORRETO: 'Custou-me aceitar.' (sujeito = aceitar). ERRADO: 'Eu custei a aceitar.' (pessoa como sujeito). Custar (= ter preço, TD): 'O livro custou R$ 50.' Custar (= ser difícil, TI): 'Custou-lhe acreditar.'"
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Difícil__7",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "Na frase 'São atitudes ___ eu me orgulho', qual preposição falta?",
    "options": [
      "de que",
      "que",
      "com que",
      "a que"
    ],
    "correctIndex": 0,
    "explanation": "'Orgulhar-se DE' → a preposição 'de' deve acompanhar o pronome relativo: 'São atitudes de que eu me orgulho.' A regência do verbo determina a preposição que precede o pronome relativo.",
    "example": "Orgulhar-se DE → 'atitudes DE QUE me orgulho.' Gostar DE → 'música DE QUE gosto.' Referir-se A → 'assunto A QUE me refiro.' Lembrar-se DE → 'fato DE QUE me lembro.' Verbo + preposição + pronome relativo."
  },
  {
    "id": "portugues__Regência Nominal e Verbal__Difícil__8",
    "track": "portugues",
    "category": "Regência Nominal e Verbal",
    "difficulty": "Difícil",
    "question": "'Aonde você vai?' vs 'Onde você estava?': qual a regra para uso de 'aonde' vs 'onde'?",
    "options": [
      "'Aonde' = a+onde, usado com verbos que indicam movimento/destino (ir, chegar, voltar); 'onde' para verbos de posição/estado (estar, ficar, morar)",
      "São sinônimos; a escolha é apenas estilística",
      "'Aonde' para lugares fechados; 'onde' para exteriores",
      "'Onde' = lugar concreto; 'aonde' = lugar abstrato"
    ],
    "correctIndex": 0,
    "explanation": "'Aonde' = a + onde: indica destino, movimento. Verbos de movimento pedem preposição 'a' = funde com 'onde'. 'Aonde você vai?'. 'Onde': sem preposição embutida. 'Onde você está?'. Teste: substituir por 'a que lugar' (aonde) vs 'em que lugar' (onde).",
    "example": "'Onde' com verbo de estado: 'Onde está a chave?' = Em que lugar. 'Aonde' com verbo de movimento: 'Aonde você foi?' = A que lugar. Na fala coloquial: 'onde' substitui 'aonde'; na escrita formal, distinguir."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Fácil__1",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Fácil",
    "question": "Em 'Estudei bastante, mas não passei', as orações são ligadas por coordenação ou subordinação?",
    "options": [
      "Coordenação (adversativa)",
      "Subordinação (concessiva)",
      "Coordenação (aditiva)",
      "Subordinação (causal)"
    ],
    "correctIndex": 0,
    "explanation": "As duas orações são independentes sintaticamente (cada uma faz sentido sozinha). São ligadas pela conjunção 'mas', que é adversativa (indica oposição). Na coordenação, as orações são autônomas; na subordinação, uma depende da outra.",
    "example": "Coordenadas: orações independentes. 'Estudei (independente) + mas não passei (independente)'. Adversativas: mas, porém, contudo, todavia. Indicam contraste."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Fácil__2",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Fácil",
    "question": "O que é uma oração coordenada aditiva?",
    "options": [
      "Oração que soma/adiciona uma ideia a outra (conjunção: e, nem)",
      "Oração que expressa oposição",
      "Oração que expressa conclusão",
      "Oração que expressa condição"
    ],
    "correctIndex": 0,
    "explanation": "Coordenada aditiva soma ideias. Conjunções: e, nem, não só...mas também, tanto...quanto. 'Estudei e passei.' (adição). 'Não come nem bebe.' (adição negativa).",
    "example": "Aditivas (soma): e, nem. 'Ele leu e escreveu.' Adversativas (oposição): mas, porém. 'Leu, mas não entendeu.' Conclusivas: logo, portanto. 'Estudou, logo passou.'"
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Fácil__3",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre oração coordenada e subordinada?",
    "options": [
      "Coordenada: independente sintaticamente. Subordinada: depende da principal",
      "São a mesma coisa",
      "Coordenada sempre vem primeiro",
      "Subordinada não tem verbo"
    ],
    "correctIndex": 0,
    "explanation": "Orações coordenadas são sintaticamente independentes — cada uma faz sentido sozinha. Orações subordinadas dependem da oração principal para ter sentido completo. A subordinada funciona como sujeito, objeto, adjetivo ou advérbio da principal.",
    "example": "Coordenada: 'Choveu, MAS fui.' (duas independentes). Subordinada: 'Quero QUE você va.' ('que você vá' = objeto, depende da principal)."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Fácil__4",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Fácil",
    "question": "Em 'Ele correu, portanto chegou cedo', qual tipo de coordenada é a segunda oração?",
    "options": [
      "Conclusiva",
      "Adversativa",
      "Aditiva",
      "Alternativa"
    ],
    "correctIndex": 0,
    "explanation": "'Portanto' é conjunção coordenativa conclusiva — expressa a conclusão lógica da primeira oração. Ele correu (premissa) → portanto chegou cedo (conclusão).",
    "example": "Conclusivas: portanto, logo, então, assim, por isso, por conseguinte. 'Estudou, logo passou.' 'Choveu, portanto ficou em casa.'"
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Fácil__5",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Fácil",
    "question": "Quais são as conjunções coordenativas alternativas?",
    "options": [
      "Ou, ora...ora, já...já, quer...quer",
      "E, nem, também",
      "Mas, porém, contudo",
      "Logo, portanto, então"
    ],
    "correctIndex": 0,
    "explanation": "Conjunções alternativas expressam alternância ou exclusão: ou, ou...ou, ora...ora, já...já, quer...quer, seja...seja. 'Ou estuda ou trabalha.' 'Ora ri, ora chora.'",
    "example": "Alternativas: ou, ora...ora, já...já. 'Ou você vem, ou eu vou.' 'Ora chove, ora faz sol.' Expressam possibilidades que se alternam ou se excluem."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Fácil__6",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Fácil",
    "question": "Em 'Cheguei e sentei', que tipo de período é esse?",
    "options": [
      "Composto por coordenação",
      "Composto por subordinação",
      "Simples",
      "Misto"
    ],
    "correctIndex": 0,
    "explanation": "'Cheguei e sentei' contém duas orações independentes ligadas pela conjunção 'e' (aditiva). As orações são autônomas sintaticamente: 'Cheguei' e 'Sentei' fazem sentido sozinhas. Isso é coordenação.",
    "example": "Coordenação: orações independentes. 'Cheguei e sentei.' (cada uma faz sentido sozinha). Subordinação: uma depende da outra. 'Quando cheguei, sentei.' ('quando cheguei' depende da principal)."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Fácil__7",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Fácil",
    "question": "O que é uma oração coordenada assindética?",
    "options": [
      "Oração coordenada sem conjunção, separada por vírgula",
      "Oração coordenada com conjunção",
      "Oração subordinada sem conjunção",
      "Oração principal"
    ],
    "correctIndex": 0,
    "explanation": "Assindética: sem síndeto (conjunção). As orações são separadas por vírgula, e não por conjunção. 'Cheguei, sentei, estudei.' São três coordenadas assindéticas. Sindética: com conjunção. 'Cheguei e sentei.'",
    "example": "Assindética (sem conjunção): 'Vim, vi, venci.' Sindética (com conjunção): 'Vim e vi.' Aditiva: 'Estudou e passou.' Adversativa: 'Estudou, mas reprovou.' A conjunção classifica a sindética."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Fácil__8",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Fácil",
    "question": "O que são orações coordenadas e como se classificam?",
    "options": [
      "Orações independentes entre si (sem hierarquia); classificadas em: assindéticas (sem conjunção) e sindéticas (com conjunção: aditiva, adversativa, alternativa, conclusiva, explicativa)",
      "Orações dependentes de uma principal, classificadas em substantivas e adjetivas",
      "Orações introduzidas sempre por 'que' ou 'se'",
      "Juntas formam só um sujeito e um predicado compartilhados"
    ],
    "correctIndex": 0,
    "explanation": "Coordenadas: mesma hierarquia, podem existir independentemente. Assindética: 'Chegou, sentou, calou.' Sindéticas aditiva: 'e', 'nem'; adversativa: 'mas', 'porém'; alternativa: 'ou...ou'; conclusiva: 'logo', 'portanto'; explicativa: 'pois', 'porque'.",
    "example": "'Estudei muito, porém não passei.' (adversativa). 'Estudei e dormi.' (aditiva). 'Não comeu, logo estava cheio.' (conclusiva). 'Não chore, pois tudo passa.' (explicativa). Subordinadas: dependentes de outra."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Médio__1",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Médio",
    "question": "Classifique a oração subordinada em 'É importante que você estude':",
    "options": [
      "Subordinada substantiva subjetiva",
      "Subordinada substantiva objetiva direta",
      "Subordinada adjetiva restritiva",
      "Subordinada adverbial causal"
    ],
    "correctIndex": 0,
    "explanation": "A oração 'que você estude' funciona como sujeito da oração principal 'É importante'. Teste: 'Isso é importante' (sujeito = isso = a oração). Quando a subordinada exerce função de sujeito, é chamada substantiva subjetiva.",
    "example": "Substitua por 'isso': 'Isso é importante.' → o 'isso' é sujeito → oração subordinada substantiva subjetiva. Compare: 'Eu quero que você estude' → 'Eu quero isso' → OD → objetiva direta."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Médio__2",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Médio",
    "question": "Em 'Quando chegar, me avise', a oração 'quando chegar' é:",
    "options": [
      "Subordinada adverbial temporal",
      "Subordinada substantiva subjetiva",
      "Coordenada aditiva",
      "Subordinada adjetiva"
    ],
    "correctIndex": 0,
    "explanation": "'Quando chegar' indica circunstância de TEMPO em que a ação principal acontecerá. Orações subordinadas adverbiais exercem função de advérbio para a oração principal. Outras adverbiais: causal, condicional, concessiva, final, consecutiva.",
    "example": "Temporais: quando, enquanto, assim que, logo que. 'Quando chegar, avise.' Causais: porque, já que. 'Faltou porque estava doente.' Condicionais: se, caso. 'Se chover, fico em casa.'"
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Médio__3",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Médio",
    "question": "O que é uma oração subordinada adverbial concessiva?",
    "options": [
      "Expressa contraste/oposição com a principal, sem impedi-la (embora, mesmo que)",
      "Indica causa",
      "Indica tempo",
      "Indica condição"
    ],
    "correctIndex": 0,
    "explanation": "Concessiva expressa uma circunstância que poderia impedir a ação principal, mas não impede. Conjunções: embora, mesmo que, ainda que, apesar de que. 'Embora chovesse, fomos ao parque.' (a chuva não impediu).",
    "example": "'Embora estivesse cansado, estudou.' (concessiva: o cansaço não impediu o estudo). Compare com adversativa: 'Estava cansado, mas estudou.' (mesmo sentido, mas coordenada)."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Médio__4",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Médio",
    "question": "O que é uma oração subordinada adverbial final?",
    "options": [
      "Expressa finalidade/objetivo (para que, a fim de que)",
      "Expressa causa (porque, já que)",
      "Expressa tempo (quando, enquanto)",
      "Expressa condição (se, caso)"
    ],
    "correctIndex": 0,
    "explanation": "A adverbial final expressa a finalidade ou o objetivo da ação principal. Conjunções finais: para que, a fim de que, porque (ant. = para que). 'Estudou para que passasse.' (objetivo de estudar = passar).",
    "example": "Finais: para que, a fim de que. 'Falo baixo para que ninguém ouça.' (finalidade). Compare: 'Falo baixo porque estou rouco.' (causa). A conjunção muda a classificação."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Médio__5",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Médio",
    "question": "Em 'O livro que comprei é bom', a oração 'que comprei' é:",
    "options": [
      "Subordinada adjetiva restritiva",
      "Subordinada adjetiva explicativa",
      "Subordinada substantiva objetiva",
      "Coordenada assindética"
    ],
    "correctIndex": 0,
    "explanation": "'Que comprei' modifica o substantivo 'livro' (funciona como adjetivo) e não está entre vírgulas → é adjetiva restritiva. Restringe: não é qualquer livro, mas o que eu comprei especificamente.",
    "example": "Restritiva (sem vírgula): 'O livro que comprei.' (especifica qual livro). Explicativa (com vírgula): 'O livro, que é caro, está na estante.' (informação extra, qualquer livro). Vírgula = explicativa."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Médio__6",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Médio",
    "question": "Classifique a oração subordinada em 'Eu sei que você mentiu':",
    "options": [
      "Subordinada substantiva objetiva direta",
      "Subordinada substantiva subjetiva",
      "Subordinada adjetiva restritiva",
      "Subordinada adverbial causal"
    ],
    "correctIndex": 0,
    "explanation": "'Que você mentiu' funciona como objeto direto do verbo 'sei'. Teste: 'Eu sei isso' → 'isso' é OD → a oração é subordinada substantiva objetiva direta. A oração substitui o objeto direto.",
    "example": "Substitua por 'isso': 'Eu sei isso.' → 'isso' = OD → objetiva direta. Compare: 'É certo que ele vem' → 'Isso é certo' → sujeito → subjetiva. O teste do 'isso' revela a função."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Médio__7",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Médio",
    "question": "O que é uma oração subordinada adverbial causal?",
    "options": [
      "Expressa causa/motivo: porque, já que, visto que",
      "Expressa consequência: tão...que",
      "Expressa tempo: quando, enquanto",
      "Expressa condição: se, caso"
    ],
    "correctIndex": 0,
    "explanation": "A adverbial causal expressa a causa/motivo da ação principal. Conjunções: porque, pois, já que, visto que, uma vez que, como. 'Faltou porque estava doente.' (causa = doença → resultado = falta).",
    "example": "Causais: porque, já que, como, visto que. 'Como choveu, fiquei em casa.' 'Já que você insiste, aceito.' Compare com consecutiva: 'Choveu tanto que alagou.' (consequência, não causa)."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Médio__8",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Médio",
    "question": "Classifique a oração subordinada em 'Não sei quando ele vai chegar'.",
    "options": [
      "Substantiva objetiva direta: objeto direto de 'sei'",
      "Adverbial temporal: indica tempo",
      "Adjetiva restritiva: restringe 'ele'",
      "Substantiva subjetiva: sujeito de 'sei'"
    ],
    "correctIndex": 0,
    "explanation": "'Quando ele vai chegar' = OD de 'sei' (sei o quê? = quando ele vai chegar). Substantiva objetiva direta. Não é adverbial temporal pois responde 'o quê' (OD), não 'quando'. 'Quando' aqui é conjunção integrante.",
    "example": "'Não sei quando/onde/por quê/se': substantivas OD. 'Vou quando ele chegar': adverbial temporal ('quando chegar' = circunstância de tempo). Teste: 'Não sei isso' → 'isso' = OD → substantiva obj. direta."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Difícil__1",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Difícil",
    "question": "Em 'Os alunos cujas notas foram altas passaram', a oração 'cujas notas foram altas' é:",
    "options": [
      "Subordinada adjetiva restritiva",
      "Subordinada adjetiva explicativa",
      "Subordinada substantiva subjetiva",
      "Coordenada assindética"
    ],
    "correctIndex": 0,
    "explanation": "A oração 'cujas notas foram altas' restringe o antecedente 'alunos': não são TODOS, mas apenas os que tiveram notas altas. Oração adjetiva restritiva: sem vírgula, restringe o sentido. Se fosse 'Os alunos, cujas notas foram altas, passaram' (com vírgulas), seria explicativa.",
    "example": "Restritiva (sem vírgula): limita. 'Alunos que estudam passam' (só os que estudam). Explicativa (com vírgula): acrescenta info. 'Deus, que é bom, nos protege' (Deus = bom por natureza, info extra)."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Difícil__2",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Difícil",
    "question": "O que é uma oração subordinada substantiva completiva nominal?",
    "options": [
      "Funciona como complemento de um nome (substantivo, adjetivo)",
      "Funciona como sujeito",
      "Funciona como objeto direto",
      "Funciona como advérbio"
    ],
    "correctIndex": 0,
    "explanation": "A completiva nominal completa o sentido de um nome (substantivo, adjetivo ou advérbio) da oração principal. 'Tenho certeza DE QUE ele virá.' ('de que ele virá' completa o substantivo 'certeza'). Teste: 'Tenho certeza disso.'",
    "example": "'Tenho certeza DE QUE virá' (completiva nominal = complemento do nome 'certeza'). 'Sei QUE virá' (objetiva direta = complemento do verbo 'sei'). A diferença: completa nome vs completa verbo."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Difícil__3",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Difícil",
    "question": "Classifique a oração destacada: 'Ele saiu SEM QUE NINGUÉM percebesse'.",
    "options": [
      "Subordinada adverbial modal",
      "Subordinada substantiva objetiva",
      "Coordenada adversativa",
      "Subordinada adjetiva restritiva"
    ],
    "correctIndex": 0,
    "explanation": "'Sem que ninguém percebesse' indica o MODO como a ação foi realizada — é uma subordinada adverbial modal. Expressa a circunstância/maneira em que o sujeito saiu. Conjunções modais: sem que, conforme, como.",
    "example": "'Saiu sem que percebessem' (como saiu? → de forma despercebida = modal). 'Saiu quando escureceu' (temporal). 'Saiu porque queria' (causal). O tipo de circunstância define a classificação."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Difícil__4",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Difícil",
    "question": "O que é uma oração subordinada adverbial consecutiva?",
    "options": [
      "Expressa consequência (tão...que, tanto...que, tal...que)",
      "Expressa causa",
      "Expressa condição",
      "Expressa concessão"
    ],
    "correctIndex": 0,
    "explanation": "A consecutiva expressa a consequência de um fato na principal. Estrutura: intensificador (tão, tanto, tal, tamanho) + QUE. 'Estudou TANTO QUE passou.' 'Estava TÃO cansado QUE dormiu.'",
    "example": "Tão...que: 'Tão triste que chorou.' Tanto...que: 'Comeu tanto que passou mal.' Tal...que: 'Tal era o barulho que saí.' O intensificador na principal + 'que' na subordinada."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Difícil__5",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Difícil",
    "question": "Classifique a oração: 'Se ele vier, avise-me.'",
    "options": [
      "Subordinada adverbial condicional",
      "Subordinada adverbial temporal",
      "Subordinada substantiva subjetiva",
      "Coordenada aditiva"
    ],
    "correctIndex": 0,
    "explanation": "'Se ele vier' estabelece uma CONDIÇÃO para que a ação principal aconteça. Orações condicionais expressam hipótese: a ação principal só ocorre se a condição for cumprida.",
    "example": "Condicionais: se, caso, desde que, contanto que. 'Se chover, fico em casa.' 'Caso ele venha, avise.' A condição deve ser satisfeita para a principal acontecer."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Difícil__6",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Difícil",
    "question": "O que é uma oração subordinada adverbial proporcional?",
    "options": [
      "Expressa proporção: à medida que, quanto mais...mais",
      "Expressa causa",
      "Expressa condição",
      "Expressa finalidade"
    ],
    "correctIndex": 0,
    "explanation": "A proporcional expressa fatos simultâneos e proporcionais. Conjunções: à medida que, à proporção que, quanto mais...mais, quanto menos...menos. 'Quanto mais estudo, mais aprendo.' Dois processos que crescem juntos.",
    "example": "À medida que: 'À medida que estudava, melhorava.' Quanto mais...mais: 'Quanto mais leio, mais sei.' ERRADO: 'Na medida em que' (= porque, causal, não proporcional). Cuidado com essa troca!"
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Difícil__7",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Difícil",
    "question": "Em 'Quem estuda passa', classifique 'quem estuda':",
    "options": [
      "Subordinada substantiva subjetiva",
      "Subordinada adjetiva restritiva",
      "Coordenada assindética",
      "Subordinada adverbial condicional"
    ],
    "correctIndex": 0,
    "explanation": "'Quem estuda' funciona como sujeito do verbo 'passa': Quem estuda (= sujeito) passa. Teste: 'Ele/Isso passa.' → sujeito → oração subordinada substantiva subjetiva. 'Quem' é pronome relativo indefinido.",
    "example": "'Quem estuda passa.' → 'Ele passa.' → sujeito → subjetiva. 'Quem' sem antecedente = pronome relativo indefinido (= aquele que). Compare: 'O aluno que estuda passa' → adjetiva (modifica 'aluno')."
  },
  {
    "id": "portugues__Sintaxe do Período Composto__Difícil__8",
    "track": "portugues",
    "category": "Sintaxe do Período Composto",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre oração subordinada adjetiva restritiva e explicativa?",
    "options": [
      "Restritiva: delimita (restringe) o antecedente, sem vírgulas; explicativa: acrescenta informação acessória sobre o referente já determinado, entre vírgulas",
      "Restritiva vem entre vírgulas; explicativa sem vírgulas",
      "São nomenclaturas diferentes para o mesmo fenômeno",
      "Restritiva só aparece após pronomes; explicativa após substantivos"
    ],
    "correctIndex": 0,
    "explanation": "Restritiva: 'Os alunos que estudaram passaram.' (só os que estudaram = delimita o universo). Sem vírgulas. Explicativa: 'Os alunos, que estudaram, passaram.' (todos os alunos estudaram — acréscimo). Com vírgulas. A mudança de vírgula altera radicalmente o sentido.",
    "example": "'Os políticos que são corruptos devem ser afastados.' (restritiva — somente os corruptos). 'Os políticos, que são corruptos, devem ser afastados.' (explicativa — todos são corruptos). Em provas: presença/ausência de vírgulas antes de 'que' = pista da classificação."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Fácil",
    "question": "Qual é o comprimento máximo de um segmento de cabo UTP Cat5e em redes Ethernet?",
    "options": [
      "100 metros",
      "50 metros",
      "200 metros",
      "150 metros"
    ],
    "correctIndex": 0,
    "explanation": "O padrão TIA/EIA-568 define que cabos UTP (categorias 5e, 6, 6A) podem ter no máximo 100 metros por segmento em redes Ethernet. Isso inclui 90m de cabeamento fixo + 10m de patch cords (cabos de ligação).",
    "example": "Horizontal cabling: 90m (da sala de telecomunicações até a tomada). Patch cords: 5m de cada lado (5+5=10). Total: 90 + 10 = 100m. Acima disso, é necessário usar um switch/repetidor."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Fácil",
    "question": "Qual tipo de cabo era necessário para conectar dois computadores diretamente sem switch em redes Fast Ethernet?",
    "options": [
      "Cabo crossover (cruzado)",
      "Cabo coaxial",
      "Cabo de fibra óptica",
      "Cabo direto (straight-through)"
    ],
    "correctIndex": 0,
    "explanation": "O cabo crossover cruza os pares de transmissão e recepção (TX↔RX), permitindo comunicação direta entre dois dispositivos iguais (PC-PC, switch-switch). Dispositivos modernos com Auto-MDI/MDIX detectam e corrigem automaticamente, tornando o crossover desnecessário.",
    "example": "Crossover: pinos 1,2 trocam com 3,6. Usa 568A em uma ponta e 568B na outra. Auto-MDI/MDIX (presente em switches e NICs modernos) detecta o tipo de cabo e ajusta automaticamente."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Fácil",
    "question": "O que é um patch panel em cabeamento estruturado?",
    "options": [
      "Painel que organiza e termina os cabos fixos da rede em um rack",
      "Equipamento que amplifica o sinal de rede",
      "Dispositivo que converte fibra óptica em cabo UTP",
      "Software de gerenciamento de cabos"
    ],
    "correctIndex": 0,
    "explanation": "O patch panel é um painel passivo instalado no rack que organiza a terminação dos cabos fixos (horizontal cabling). Cada porta corresponde a uma tomada de rede. Patch cords conectam o patch panel ao switch.",
    "example": "Vantagem: facilita manutenção e mudanças — basta trocar o patch cord, sem alterar o cabeamento fixo na parede. Norma TIA-568: o patch panel fica na sala de telecomunicações (TR)."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Fácil",
    "question": "Qual o comprimento máximo de um segmento de cabo UTP Ethernet (horizontal cabling)?",
    "options": [
      "100 metros",
      "50 metros",
      "200 metros",
      "500 metros"
    ],
    "correctIndex": 0,
    "explanation": "O padrão TIA-568 define 100 metros como comprimento máximo total do canal (channel): 90m de cabeamento fixo + até 10m de patch cords. Acima de 100m, a atenuação do sinal degrada a comunicação.",
    "example": "90m de cabeamento horizontal (fixo na parede) + 5m de patch cord no rack + 5m de patch cord na área de trabalho = 100m total (channel). Fibra permite distâncias muito maiores."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Fácil",
    "question": "Qual tipo de cabo é usado para conectar dispositivos diferentes (PC ↔ switch)?",
    "options": [
      "Cabo direto (straight-through)",
      "Cabo crossover",
      "Cabo rollover/console",
      "Cabo coaxial"
    ],
    "correctIndex": 0,
    "explanation": "Cabo direto (straight-through) conecta dispositivos diferentes: PC↔switch, switch↔roteador. Usa o mesmo padrão (568B) em ambas as pontas. Cabo crossover conecta dispositivos iguais (PC↔PC, switch↔switch).",
    "example": "Direto: mesmo padrão nas duas pontas (568B-568B). Crossover: padrões diferentes (568A-568B). Aujourd'hui: switches modernos com Auto-MDI/MDIX detectam automaticamente."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Fácil",
    "question": "O que é um rack de telecomunicações em cabeamento estruturado?",
    "options": [
      "Armário metálico que organiza equipamentos de rede como switches e patch panels",
      "Software de gerenciamento de cabos",
      "Tipo de conector para fibra óptica",
      "Dispositivo que amplifica o sinal Wi-Fi"
    ],
    "correctIndex": 0,
    "explanation": "O rack é uma estrutura metálica padronizada (19 polegadas de largura) que acomoda switches, patch panels, servidores e organizadores de cabos. A altura é medida em U (unidades de rack, 1U = 44.45mm).",
    "example": "Rack 19\": padrão da indústria. Tamanhos comuns: 42U (piso), 12U (parede). Componentes: patch panel, switch, organizador de cabos, régua de energia (PDU). Norma TIA-569 define o espaço."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Fácil",
    "question": "Para que serve a fibra óptica em redes de computadores?",
    "options": [
      "Transmitir dados como pulsos de luz, alcançando longas distâncias com alta velocidade",
      "Substituir cabos de energia elétrica",
      "Conectar teclados e mouses ao computador",
      "Transmitir sinal de rádio para redes Wi-Fi"
    ],
    "correctIndex": 0,
    "explanation": "A fibra óptica transmite dados usando luz (laser ou LED) em vez de sinais elétricos. Vantagens: imunidade a interferência eletromagnética, distâncias muito maiores e velocidades mais altas que o cobre.",
    "example": "Vantagens da fibra: distância (km vs 100m do UTP), velocidade (100+ Gbps), imunidade a EMI, segurança (difícil interceptar). Desvantagens: custo maior, fragilidade, mão-de-obra especializada."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre catária Cat 5e e Cat 6 em cabeamento estético?",
    "options": [
      "Cat 5e: até 1 Gbps em 100m; Cat 6: até 10 Gbps em 55m / 1 Gbps em 100m com menor interferência (spline interno)",
      "Cat 5e: até 10 Gbps; Cat 6: somente Fast Ethernet (100 Mbps)",
      "São equivalentes; a diferença é apenas no conector RJ45",
      "Cat 6 usa fibra óptica; Cat 5e usa par trançado de cobre"
    ],
    "correctIndex": 0,
    "explanation": "Cat 5e (Enhanced Category 5): 1 Gbps em 100m, 350 MHz. Cat 6: 10 Gbps em até 55m (10GBase-T), 1 Gbps em 100m, 250 MHz (algumas 550 MHz). Cat 6A: 10 Gbps em 100m, 500 MHz. Spline no Cat 6 separa os 4 pares reduzindo NEXT (Near-End CrossTalk). Janélas de fixação e bending radius também diferem.",
    "example": "Data center 10GBase-T: Cat 6A ou Cat 7 (até 100m). Cat 5e: adequado para 1 GbE corporativo. Cat 7: blindagem individual por par (S/FTP), 10 GbE em 100m, 600 MHz. Conector Cat 7: GG45 ou TERA (não RJ45). Planejamento: testar com certificador Fluke LinkIQ após instalação."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Médio__1",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Médio",
    "question": "Qual a principal diferença entre cabo UTP Cat6 e Cat6A?",
    "options": [
      "Cat6A suporta 10 Gbps a 100m; Cat6 suporta 10 Gbps apenas a 55m",
      "Cat6A é blindado e Cat6 não",
      "Cat6A suporta apenas 1 Gbps",
      "Não há diferença prática"
    ],
    "correctIndex": 0,
    "explanation": "Cat6 suporta 10 Gigabit Ethernet (10GBASE-T) apenas até 55 metros; para 1 Gbps vai até 100m normalmente. Cat6A (Augmented) foi projetado para suportar 10 Gbps em toda a distância de 100m, com melhor isolamento contra crosstalk (alien crosstalk).",
    "example": "Cat5e: 1 Gbps/100m. Cat6: 1 Gbps/100m ou 10 Gbps/55m. Cat6A: 10 Gbps/100m. Cat7: 10 Gbps/100m (blindado, conector GG45). Cat8: 25-40 Gbps/30m."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Médio__2",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Médio",
    "question": "Qual tipo de fibra óptica é ideal para longas distâncias acima de 10 km?",
    "options": [
      "Fibra monomodo (single-mode)",
      "Fibra multimodo (multi-mode)",
      "Cabo UTP Cat6A",
      "Cabo coaxial RG-59"
    ],
    "correctIndex": 0,
    "explanation": "Fibra monomodo (SMF) usa um núcleo muito fino (~9 µm) que permite apenas um modo de propagação da luz, reduzindo a dispersão. Alcança 10 km a 100+ km. Fibra multimodo (MMF, núcleo 50/62.5 µm) é para curtas distâncias (até ~550m em 10G).",
    "example": "Monomodo: núcleo 9 µm, laser, longa distância (10-100+ km), mais cara. Multimodo: núcleo 50/62.5 µm, LED/VCSEL, curta distância (até 2 km em 1G, 550m em 10G), mais barata. Conector LC é o mais comum."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Médio__3",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Médio",
    "question": "O que é crosstalk (diafonia) em cabos de rede e qual tipo é medido na ponta transmissora?",
    "options": [
      "NEXT (Near-End Crosstalk) — interferência entre pares adjacentes dentro do mesmo cabo",
      "Atenuação do sinal ao longo do cabo",
      "Reflexão do sinal causada por impedância incorreta",
      "Perda de pacotes na camada de transporte"
    ],
    "correctIndex": 0,
    "explanation": "Crosstalk é a interferência eletromagnética entre pares de fios. NEXT mede a interferência na mesma ponta onde o sinal é transmitido. FEXT mede na ponta oposta. A trançagem dos pares e blindagem (STP/FTP) reduzem o crosstalk.",
    "example": "NEXT: Near-End Crosstalk (ponta transmissora). FEXT: Far-End Crosstalk (ponta receptora). PS-NEXT: Power Sum NEXT (todos os pares). Quanto maior o valor em dB, melhor o isolamento."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Médio__4",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Médio",
    "question": "O que é PoE (Power over Ethernet)?",
    "options": [
      "Tecnologia que fornece energia elétrica e dados pelo mesmo cabo de rede",
      "Protocolo de roteamento para redes ópticas",
      "Método de criptografia para Ethernet",
      "Padrão de conector para fibra óptica"
    ],
    "correctIndex": 0,
    "explanation": "PoE (IEEE 802.3af/at/bt) permite alimentar dispositivos como access points, câmeras IP e telefones VoIP pelo próprio cabo Ethernet, eliminando a necessidade de fonte de energia separada. Requer switch PoE ou injetor PoE.",
    "example": "802.3af (PoE): até 15.4W. 802.3at (PoE+): até 30W. 802.3bt (PoE++): até 60-100W. Usa pares sobressalentes do cabo ou sobreposição nos pares de dados."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Médio__5",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Médio",
    "question": "Qual a diferença entre cabos UTP, STP e FTP?",
    "options": [
      "UTP: sem blindagem. STP: blindagem por par. FTP: blindagem geral (folha)",
      "São todos iguais, apenas marcas diferentes",
      "UTP é para 1 Gbps, STP para 10 Gbps, FTP para 100 Gbps",
      "UTP é cobre, STP é fibra, FTP é coaxial"
    ],
    "correctIndex": 0,
    "explanation": "UTP (Unshielded Twisted Pair): sem blindagem, mais flexível e barato. FTP (Foiled TP) / F/UTP: uma folha metálica envolvendo todos os pares. STP (Shielded TP) / S/FTP: blindagem individual por par + geral. Blindagem reduz EMI.",
    "example": "Notação ISO: X/Y TP. X = blindagem geral (U=nenhuma, F=folha, S=malha). Y = blindagem por par (U=nenhuma, F=folha). Ex: S/FTP = malha geral + folha por par."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Médio__6",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Médio",
    "question": "O que é o backbone (cabeamento vertical) em cabeamento estruturado?",
    "options": [
      "Cabeamento que interconecta salas de telecomunicações entre andares diferentes",
      "O cabo que liga o computador ao switch",
      "O servidor central da rede",
      "O roteador principal do edifício"
    ],
    "correctIndex": 0,
    "explanation": "O backbone (ou cabeamento vertical) conecta as salas de telecomunicações (TR) dos diversos andares à sala de equipamentos principal (ER). Geralmente usa fibra óptica para suportar maiores distâncias e largura de banda.",
    "example": "Backbone vertical: entre andares (TR↔ER). Cabeamento horizontal: do TR até a estação de trabalho (máx 90m). Norma TIA-568: backbone usa fibra (multimodo até 2000m, monomodo até 3000m) ou cobre (até 800m)."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Médio__7",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Médio",
    "question": "Qual ferramenta é usada para testar continuidade e mapeamento de pinos em cabos UTP?",
    "options": [
      "Testador de cabos (cable tester)",
      "Alicate de crimpagem",
      "Decapador de cabos",
      "Multímetro digital"
    ],
    "correctIndex": 0,
    "explanation": "O testador de cabos (cable tester) verifica se os 8 fios estão corretamente conectados pino a pino, identificando cabos rompidos, curtos, pares trocados ou abertos. Modelos avançados (certificadores) medem atenuação, NEXT, return loss.",
    "example": "Tester básico: apenas continuidade e mapeamento. Qualificador: testa para velocidades específicas (1G, 10G). Certificador (Fluke, etc.): mede todos os parâmetros para certificação Cat5e/6/6A."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Médio__8",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Médio",
    "question": "O que é o DMБББ (IDF/MDF) e como se organiza a hierarquia de cabeamento estruturado?",
    "options": [
      "MDF (Main Distribution Frame): sala principal de telecomunicações; IDF (Intermediate): distribuição por andar/ala; hierarquia: MDF → IDF → TO (tomada de trabalho)",
      "MDF é o rack de servidores; IDF é o switch de acesso",
      "IDF é principal; MDF é secundário; hierarquia é invertida",
      "MDF e IDF são sinonímos para a mesma sala de equipamentos"
    ],
    "correctIndex": 0,
    "explanation": "Cableamento estruturado (EIA/TIA 568): subsistemas. MDF (ou TR Principal): conexão com operadora, equipamentos core. IDF (TR Intermediário): distribuição por andar (backbone vertical até MDF). TO: Tomada de Telecomunicações até 90m do IDF. Backbone horizontal: IDF → TO (até 100m total incluindo patchcords).",
    "example": "EIA/TIA 568C: define tipos de cabo, comprimentos, métodos de teste. Área de trabalho: até 10m (patchcord de equipamento + TO). Horizontal: 90m máximo (cobre). Backbone vertical: fibra multimodo (MDF-IDF) ou monomodo (entre edifícios). Certificação: Fluke DSX-8000."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Difícil",
    "question": "No padrão TIA-568B, qual é a sequência correta dos pares de fios no conector RJ-45?",
    "options": [
      "Branco-Laranja, Laranja, Branco-Verde, Azul, Branco-Azul, Verde, Branco-Marrom, Marrom",
      "Branco-Verde, Verde, Branco-Laranja, Azul, Branco-Azul, Laranja, Branco-Marrom, Marrom",
      "Branco-Laranja, Laranja, Branco-Azul, Verde, Branco-Verde, Azul, Branco-Marrom, Marrom",
      "Laranja, Branco-Laranja, Verde, Branco-Verde, Azul, Branco-Azul, Marrom, Branco-Marrom"
    ],
    "correctIndex": 0,
    "explanation": "TIA-568B (mais comum): pinos 1-8 = BL, L, BV, Az, BAz, V, BM, M. TIA-568A troca os pares laranja e verde: BV, V, BL, Az, BAz, L, BM, M. Cabo crossover usa 568A numa ponta e 568B na outra; cabo direto (straight) usa o mesmo padrão em ambas.",
    "example": "568B: 1-BL 2-L 3-BV 4-Az 5-BAz 6-V 7-BM 8-M. Mnemônico: 'OoGbBgBbB' (Orange, green, blue em pares). Pinos de dados Ethernet (10/100): 1,2 (TX) e 3,6 (RX)."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Difícil",
    "question": "Em cabeamento estruturado, qual é a diferença entre os testes de certificação 'channel' e 'permanent link'?",
    "options": [
      "Channel inclui os patch cords (até 100m); permanent link testa apenas o cabeamento fixo (até 90m)",
      "Channel testa apenas fibra; permanent link testa cobre",
      "Não há diferença — são sinônimos",
      "Channel é usado em Cat5e; permanent link em Cat6"
    ],
    "correctIndex": 0,
    "explanation": "Permanent link testa o cabeamento fixo entre o patch panel e a tomada (até 90m), excluindo patch cords. Channel testa o caminho completo ponta a ponta incluindo patch cords (até 100m). Channel é mais realista pois inclui mais conexões.",
    "example": "Permanent link: patch panel → cabeamento horizontal → tomada (90m). Channel: equipment cord + patch panel → cabeamento → tomada → work area cord (100m). Mais conexões = mais atenuação."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Difícil",
    "question": "O que é alien crosstalk (AXT) e a partir de qual categoria de cabeamento ele se tornou requisito de teste?",
    "options": [
      "Interferência entre cabos adjacentes no mesmo feixe; Cat6A foi a primeira a exigir esse teste",
      "Interferência entre pares do mesmo cabo; Cat5e já exigia",
      "Atenuação causada por temperatura; Cat7 introduziu",
      "Reflexão de sinal em conectores; todas as categorias exigem"
    ],
    "correctIndex": 0,
    "explanation": "Alien crosstalk (AXT) é a interferência eletromagnética entre cabos diferentes (não entre pares do mesmo cabo). Com frequências mais altas (500 MHz em Cat6A), a proximidade entre cabos causa interferência significativa. Cat6A introduziu testes obrigatórios de AXT.",
    "example": "Cat6: até 250 MHz, AXT não exigido. Cat6A: até 500 MHz, AXT obrigatório. Mitigação: blindagem (F/UTP ou S/FTP), maior espaçamento entre cabos. ANEXT: Alien NEXT. AFEXT: Alien FEXT."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Difícil",
    "question": "O que é um OTDR e para que é utilizado?",
    "options": [
      "Reflectometro óptico que testa e localiza falhas em fibra óptica",
      "Analisador de protocolo para redes Ethernet",
      "Ferramenta de crimpagem de conectores RJ-45",
      "Software de projeção de cabeamento estruturado"
    ],
    "correctIndex": 0,
    "explanation": "OTDR (Optical Time Domain Reflectometer) envia pulsos de luz na fibra e analisa as reflexões. Permite medir atenuação, localizar emendas, conectores e pontos de ruptura com precisão de metros. Essencial para certificação de fibra.",
    "example": "OTDR gera um traço (trace) mostrando distância × potência. Eventos reflexivos (conectores) aparecem como picos; eventos não-reflexivos (emendas por fusão) aparecem como degraus. Alternativa: power meter + light source."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Difícil",
    "question": "Qual padrão Ethernet opera a 10 Gbps sobre par trançado (cobre)?",
    "options": [
      "10GBASE-T (IEEE 802.3an)",
      "1000BASE-T (IEEE 802.3ab)",
      "100BASE-TX (IEEE 802.3u)",
      "10GBASE-SR (IEEE 802.3ae)"
    ],
    "correctIndex": 0,
    "explanation": "10GBASE-T (IEEE 802.3an) opera a 10 Gbps sobre cabo de par trançado. Requer Cat6A para 100m ou Cat6 para ~55m. Usa todos os 4 pares do cabo e modulação PAM-16. 10GBASE-SR é fibra multimodo.",
    "example": "100BASE-TX: 100 Mbps, Cat5, 100m. 1000BASE-T: 1 Gbps, Cat5e, 100m. 10GBASE-T: 10 Gbps, Cat6A, 100m. O 'T' indica par trançado; 'SR/LR' indicam fibra curta/longa."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre emenda por fusão e emenda mecânica em fibra óptica?",
    "options": [
      "Fusão: permanente, baixa perda (~0.02 dB). Mecânica: temporária, maior perda (~0.3 dB)",
      "São a mesma técnica com nomes diferentes",
      "Fusão é para multimodo; mecânica para monomodo",
      "Mecânica requer equipamento mais caro"
    ],
    "correctIndex": 0,
    "explanation": "Emenda por fusão: usa máquina fusora que derrete e une as extremidades da fibra. Perda típica: 0.02 dB. Permanente e robusta. Emenda mecânica: alinha as fibras mecanicamente com gel de índice. Perda: ~0.3 dB. Mais rápida, mas menos confiável.",
    "example": "Fusão: máquina fusora (~R$ 15-80k), perda ≤0.05 dB, permanente. Mecânica: conector mecânico (~R$ 30-50/emenda), perda ~0.3 dB, provisória. Para certificação, fusão é preferida."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Difícil",
    "question": "O que é delay skew em cabeamento de rede e por que é importante em Gigabit Ethernet?",
    "options": [
      "Diferença no tempo de propagação entre os 4 pares do cabo; Gigabit usa todos os pares simultaneamente",
      "Atraso causado pela distância do cabo",
      "Tempo de resposta do servidor DNS",
      "Latência adicionada pela criptografia"
    ],
    "correctIndex": 0,
    "explanation": "Delay skew é a diferença de tempo de propagação entre os pares de um cabo UTP. Gigabit e 10G Ethernet usam os 4 pares simultaneamente — se os sinais chegarem em tempos muito diferentes, ocorrem erros. Limite: ≤45 ns em 100m.",
    "example": "Fast Ethernet (100 Mbps): usa 2 pares → delay skew menos crítico. Gigabit (1000BASE-T): usa 4 pares em transmissão simultânea → delay skew ≤45 ns exigido. Causa: diferenças físicas de trançagem entre pares."
  },
  {
    "id": "rede-de-computadores__Cabeamento Estruturado__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Cabeamento Estruturado",
    "difficulty": "Difícil",
    "question": "Quais os parâmetros medidos numa certificção de par trançado Cat 6A e o que cada um representa?",
    "options": [
      "Comprimento, atraso de propagação, NEXT, FEXT, attenuation, return loss, PS-ANEXT; medem capacidade de transmissão e amplitude de crosstalk em todos os pares",
      "Somente comprimento e continuidade elétrica",
      "Apenas NEXT e atenuação; os demais são opcionais",
      "Potência de sinal óptico e birrefringência (apenas para fibra)"
    ],
    "correctIndex": 0,
    "explanation": "Parâmetros Cat 6A (TIA-1096-A): attenuation (perda por m), NEXT (cross-talk na origem), FEXT (na extremidade distante), return loss (reflexão), insertion loss, prop. delay, delay skew entre pares, PS-ANEXT (alien crosstalk dos cabos adjacentes). Todos medidos em MHz até 500 MHz.",
    "example": "PS-ANEXT (Power Sum Alien NEXT): crosstalk de cabos nas proximidades nas bandejas. Impacto em 10GBase-T: requer blindagem S/FTP ou distanciamento adequado. Fluke DTX/DSX: certifica automaticamente todos os parâmetros com resultado PASS/FAIL por parâmetro e frequência."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Fácil__1",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Fácil",
    "question": "Qual é a principal função do DNS (Domain Name System)?",
    "options": [
      "Traduzir nomes de domínio em endereços IP",
      "Atribuir IPs automaticamente",
      "Criptografar dados na rede",
      "Filtrar pacotes maliciosos"
    ],
    "correctIndex": 0,
    "explanation": "O DNS funciona como uma 'lista telefônica' da internet: converte nomes legíveis (ex: google.com) em endereços IP numéricos (ex: 142.250.80.46) que os computadores usam para se comunicar.",
    "example": "Sem DNS, você precisaria digitar 142.250.80.46 em vez de google.com. O DNS resolve queries recursivas e iterativas através de uma hierarquia: Root → TLD (.com) → Autoritativo (google.com)."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Fácil__2",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Fácil",
    "question": "O que o DHCP faz automaticamente para os dispositivos em uma rede?",
    "options": [
      "Atribui endereços IP, máscara, gateway e DNS automaticamente",
      "Traduz nomes de domínio para IPs",
      "Filtra pacotes maliciosos na rede",
      "Criptografa a comunicação entre dispositivos"
    ],
    "correctIndex": 0,
    "explanation": "DHCP (Dynamic Host Configuration Protocol) configura automaticamente os parâmetros de rede: endereço IP, máscara de sub-rede, gateway padrão e servidores DNS. Elimina a necessidade de configuração manual em cada dispositivo.",
    "example": "Sem DHCP: cada dispositivo precisa de IP, máscara, gateway e DNS configurados manualmente. Com DHCP: o dispositivo recebe tudo ao se conectar. Portas UDP 67 (servidor) e 68 (cliente)."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Fácil__3",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Fácil",
    "question": "O que é NAT (Network Address Translation)?",
    "options": [
      "Técnica que traduz endereços IP privados para públicos ao acessar a internet",
      "Protocolo que atribui IPs automaticamente",
      "Serviço que resolve nomes de domínio",
      "Mecanismo de criptografia de pacotes"
    ],
    "correctIndex": 0,
    "explanation": "NAT traduz endereços IP privados (ex: 192.168.1.x) em endereços IP públicos para que dispositivos internos acessem a internet. O roteador mantém uma tabela de tradução para encaminhar respostas ao dispositivo correto.",
    "example": "Sem NAT: cada dispositivo precisaria de um IP público. Com NAT: toda a rede interna compartilha um ou poucos IPs públicos. Tipos: Static NAT (1:1), Dynamic NAT (pool), PAT/overload (muitos:1)."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Fácil__4",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Fácil",
    "question": "Qual porta o DNS utiliza por padrão?",
    "options": [
      "Porta 53",
      "Porta 80",
      "Porta 443",
      "Porta 25"
    ],
    "correctIndex": 0,
    "explanation": "O DNS usa a porta 53. Consultas normais usam UDP/53 (rápido, resposta curta). Transferências de zona (AXFR) e respostas grandes usam TCP/53. DNS sobre HTTPS (DoH) usa 443; DNS sobre TLS (DoT) usa 853.",
    "example": "UDP/53: consultas DNS normais (<512 bytes, ou com EDNS0 até ~4096 bytes). TCP/53: transferência de zona, respostas truncadas. DoH: 443. DoT: 853."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Fácil__5",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Fácil",
    "question": "O que acontece quando o lease DHCP de um dispositivo expira?",
    "options": [
      "O dispositivo precisa renovar ou obter um novo endereço IP",
      "O IP se torna permanente",
      "O dispositivo é bloqueado da rede",
      "Nada acontece"
    ],
    "correctIndex": 0,
    "explanation": "Quando o lease expira, o IP volta ao pool do servidor DHCP. O cliente tenta renovar em 50% do lease (T1) e 87.5% (T2). Se não conseguir renovar, perde o IP e reinicia o processo DORA para obter um novo.",
    "example": "Renovação: T1 (50% do lease, unicast ao servidor). T2 (87.5%, broadcast). Expiração: perde o IP. Em Windows, recebe APIPA (169.254.x.x) se não houver servidor DHCP."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Fácil__6",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Fácil",
    "question": "O que acontece se o servidor DNS ficar indisponível?",
    "options": [
      "O dispositivo não consegue traduzir nomes em IPs, impedindo acesso por nome de domínio",
      "A internet para completamente",
      "Os IPs de todos os dispositivos mudam",
      "Os dados enviados são perdidos"
    ],
    "correctIndex": 0,
    "explanation": "Sem DNS, o dispositivo não resolve nomes como google.com para IPs. O acesso por IP direto (ex: 142.250.80.46) ainda funciona. Por isso, configuram-se dois servidores DNS (primário e secundário) para redundância.",
    "example": "Teste sem DNS: `ping 8.8.8.8` funciona (IP direto), mas `ping google.com` falha (precisa de DNS). Cache DNS local pode manter resoluções recentes. Servidores DNS secundários garantem redundância."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Fácil__7",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre IP estático e IP dinâmico (via DHCP)?",
    "options": [
      "Estático: configurado manualmente, fixo. Dinâmico: atribuído pelo DHCP, pode mudar",
      "São a mesma coisa",
      "Estático é mais rápido",
      "Dinâmico é mais seguro"
    ],
    "correctIndex": 0,
    "explanation": "IP estático é configurado manualmente e não muda — ideal para servidores, impressoras de rede e roteadores. IP dinâmico é atribuído automaticamente pelo DHCP e pode mudar a cada renovação de lease.",
    "example": "Estático: servidores (DNS, web, e-mail), impressoras, roteadores — precisam de IP fixo para serem encontrados. Dinâmico: estações de trabalho, celulares — facilita a administração em redes grandes."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Médio__1",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Médio",
    "question": "No processo DHCP, qual é a sequência correta das mensagens trocadas (DORA)?",
    "options": [
      "Discover → Offer → Request → Acknowledge",
      "Demand → Offer → Reply → Accept",
      "Discover → Open → Request → Assign",
      "Detect → Offer → Register → Acknowledge"
    ],
    "correctIndex": 0,
    "explanation": "DORA: 1) Discover (cliente broadcast: 'preciso de IP'). 2) Offer (servidor: 'ofereço esse IP'). 3) Request (cliente: 'aceito esse IP'). 4) Acknowledge (servidor: 'IP confirmado, é seu por X tempo'). Todas as mensagens usam UDP nas portas 67 (servidor) e 68 (cliente).",
    "example": "Discover: broadcast 255.255.255.255, src 0.0.0.0. Offer: servidor responde com IP proposto + máscara + gateway + DNS + lease time. Request: cliente confirma escolha. ACK: servidor finaliza."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Médio__2",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Médio",
    "question": "Qual tipo de registro DNS é usado para apontar um domínio para um endereço IPv4?",
    "options": [
      "Registro A",
      "Registro MX",
      "Registro CNAME",
      "Registro PTR"
    ],
    "correctIndex": 0,
    "explanation": "Registro A (Address): mapeia nome de domínio → endereço IPv4. AAAA: IPv6. MX: servidor de email. CNAME: alias para outro domínio. PTR: resolução reversa (IP → nome). NS: servidor DNS autoritativo.",
    "example": "Exemplo: google.com → A → 142.250.80.46. CNAME: mail.google.com → googlemail.l.google.com. Comando: `nslookup -type=A google.com` ou `dig A google.com`."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Médio__3",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Médio",
    "question": "O que é DHCP Relay e quando ele é necessário?",
    "options": [
      "Encaminha mensagens DHCP entre sub-redes diferentes quando o servidor está em outra rede",
      "Replica o servidor DHCP para redundância",
      "Renova os leases automaticamente",
      "Bloqueia requisições DHCP suspeitas"
    ],
    "correctIndex": 0,
    "explanation": "DHCP Relay é necessário quando cliente e servidor DHCP estão em sub-redes diferentes. Como o Discover é broadcast (não atravessa roteadores), o relay agent captura o broadcast e encaminha como unicast ao servidor DHCP remoto.",
    "example": "Cisco: `ip helper-address 10.0.0.100`. O relay converte broadcast → unicast e adiciona o campo giaddr (endereço da interface) para o servidor saber de qual sub-rede veio o pedido."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Médio__4",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Médio",
    "question": "Qual registro DNS é usado para indicar o servidor de e-mail de um domínio?",
    "options": [
      "Registro MX",
      "Registro A",
      "Registro CNAME",
      "Registro NS"
    ],
    "correctIndex": 0,
    "explanation": "MX (Mail Exchanger) indica o servidor responsável por receber e-mails para aquele domínio. Cada registro MX tem um valor de prioridade (preferência) — menor número = maior prioridade.",
    "example": "Exemplo: gmail.com MX 5 gmail-smtp-in.l.google.com. Prioridade 5 = preferêncial. Se o servidor principal falhar, tenta o MX de prioridade 10, 20 etc. (fallback)."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Médio__5",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Médio",
    "question": "Qual a diferença entre DNS recursivo e DNS autoritativo?",
    "options": [
      "Recursivo consulta outros servidores em nome do cliente; autoritativo responde com dados próprios",
      "São a mesma coisa",
      "Recursivo é mais rápido que autoritativo",
      "Autoritativo faz cache; recursivo não"
    ],
    "correctIndex": 0,
    "explanation": "Recursivo (resolver): recebe a consulta do cliente e busca a resposta percorrendo a hierarquia DNS (root → TLD → autoritativo). Faz cache. Autoritativo: é a fonte oficial dos registros de um domínio, responde com dados definitivos.",
    "example": "Recursivo: 8.8.8.8 (Google), 1.1.1.1 (Cloudflare) — fazem a busca para o cliente. Autoritativo: ns1.exemplo.com — tem os registros reais do domínio. O recursivo consulta o autoritativo."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Médio__6",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Médio",
    "question": "O que é um registro CNAME no DNS?",
    "options": [
      "Alias que aponta um domínio para outro domínio (não diretamente para um IP)",
      "Registro que mapeia nome para IPv4",
      "Registro de servidor de e-mail",
      "Registro de resolução reversa"
    ],
    "correctIndex": 0,
    "explanation": "CNAME (Canonical Name) cria um alias: um domínio aponta para outro. Ex: www.site.com CNAME site.com. O navegador resolve o CNAME até encontrar um registro A (IPv4) ou AAAA (IPv6). CNAME não pode coexistir com outros registros no mesmo nome.",
    "example": "www.google.com CNAME www.google.com.cdn.cloudflare.net → depois resolve o A desse destino. CNAME não pode ser usado na raiz do domínio (ex: google.com) — use ALIAS/ANAME (extensão não-padrão)."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Médio__7",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Médio",
    "question": "O que é DHCP Snooping e qual seu objetivo?",
    "options": [
      "Recurso de segurança no switch que filtra mensagens DHCP não autorizadas",
      "Monitor de tráfego DNS",
      "Ferramenta de atribuição de IPs estáticos",
      "Protocolo de roteamento dinâmico"
    ],
    "correctIndex": 0,
    "explanation": "DHCP Snooping é um recurso de segurança L2 que classifica portas como confiáveis (trusted) ou não confiáveis (untrusted). Apenas portas trusted podem enviar DHCP Offer/ACK, prevenindo servidores DHCP falsos (rogue DHCP).",
    "example": "Porta trusted: conectada ao servidor DHCP legítimo. Untrusted: todas as outras. Se um atacante ligar um DHCP falso em porta untrusted, os Offers são descartados. Também cria binding table (MAC↔IP↔porta)."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Difícil__1",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Difícil",
    "question": "No NAT tipo PAT (Port Address Translation), como múltiplos dispositivos compartilham um único IP público?",
    "options": [
      "Cada conexão interna recebe uma porta de origem diferente no IP público",
      "Cada dispositivo recebe um IP público temporário",
      "As conexões são multiplexadas por MAC address",
      "O roteador alterna o IP público entre os dispositivos"
    ],
    "correctIndex": 0,
    "explanation": "PAT (também chamado NAT overload) mapeia múltiplos IPs privados para UM IP público usando portas diferentes. O roteador mantém uma tabela de tradução: (IP_privado:porta_interna) ↔ (IP_público:porta_externa). Isso permite milhares de conexões simultâneas com um único IP público.",
    "example": "Exemplo: PC1 (192.168.1.10:5000) → NAT → (200.1.1.1:40001). PC2 (192.168.1.11:5000) → NAT → (200.1.1.1:40002). Ambos usam o mesmo IP público, diferenciados pela porta."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Difícil__2",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Difícil",
    "question": "O que são ataques de DNS Cache Poisoning e como o DNSSEC protege contra eles?",
    "options": [
      "Injeção de registros DNS falsos no cache; DNSSEC usa assinaturas digitais para validar respostas",
      "Sobrecarga do servidor DNS; DNSSEC limita conexões",
      "Interceptação de queries DNS; DNSSEC criptografa o tráfego",
      "Sequestro do domínio no registrar; DNSSEC bloqueia transferências"
    ],
    "correctIndex": 0,
    "explanation": "DNS Cache Poisoning: atacante injeta respostas DNS falsas no cache de um resolver, redirecionando usuários para IPs maliciosos. DNSSEC adiciona assinaturas digitais (RRSIG) aos registros, permitindo validar autenticidade e integridade das respostas.",
    "example": "DNSSEC usa cadeia de confiança: Root → TLD → Domínio, com chaves KSK e ZSK. Registros: DNSKEY, RRSIG, DS, NSEC/NSEC3. Nota: DNSSEC não criptografa — apenas autentica."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Difícil__3",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre NAT estático, NAT dinâmico e PAT (Port Address Translation)?",
    "options": [
      "Estático: 1:1 fixo. Dinâmico: pool de IPs públicos. PAT: múltiplos privados compartilham 1 público via portas",
      "Todos são sinônimos para a mesma técnica",
      "Estático usa IPv6, dinâmico usa IPv4 e PAT usa ambos",
      "A diferença é apenas na velocidade de tradução"
    ],
    "correctIndex": 0,
    "explanation": "NAT Estático: mapeamento fixo 1:1 (ideal para servidores). NAT Dinâmico: usa pool de IPs públicos sob demanda. PAT (overload): múltiplos IPs privados compartilham um único IP público, diferenciados por portas de origem. PAT é o mais usado.",
    "example": "Estático: 10.0.0.5 ↔ 200.1.1.5 (sempre). Dinâmico: 10.0.0.x → próximo IP do pool 200.1.1.10-20. PAT: 10.0.0.x:porta → 200.1.1.1:porta_aleatória. PAT é padrão em roteadores domésticos."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Difícil__4",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Difícil",
    "question": "O que é NAT64 e para que serve?",
    "options": [
      "Traduz IPv6 ↔ IPv4, permitindo hosts IPv6-only acessarem serviços IPv4",
      "Traduz endereços MAC em endereços IPv6",
      "Comprime cabeçalhos NAT para economizar banda",
      "Duplica o número de portas disponíveis no PAT"
    ],
    "correctIndex": 0,
    "explanation": "NAT64 permite que redes exclusivamente IPv6 se comuniquem com serviços IPv4, traduzindo cabeçalhos entre os dois protocolos. É uma solução de transição para a coexistência IPv4/IPv6 durante a migração.",
    "example": "NAT64 geralmente opera com DNS64, que sintetiza registros AAAA para domínios que só têm registros A (IPv4). O prefixo 64:ff9b::/96 é usado para mapear endereços IPv4 dentro de IPv6."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Difícil__5",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre DNS sobre HTTPS (DoH) e DNS sobre TLS (DoT)?",
    "options": [
      "DoH usa porta 443 (misturado com HTTPS); DoT usa porta 853 (canal TLS dedicado)",
      "São a mesma coisa com nomes diferentes",
      "DoH é mais antigo que DoT",
      "DoT não é criptografado"
    ],
    "correctIndex": 0,
    "explanation": "DoH (RFC 8484): encapsula queries DNS em HTTPS na porta 443, tornando o tráfego DNS indistinguível de navegação web. DoT (RFC 7858): usa TLS na porta dedicada 853, permitindo que administradores identifiquem e controlem o tráfego DNS.",
    "example": "DoH: porta 443, difícil de bloquear/filtrar (confunde com HTTPS). DoT: porta 853, fácil de identificar/bloquear. Ambos criptografam queries DNS. DoH preferido por navegadores; DoT preferido por administradores de rede."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Difícil__6",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Difícil",
    "question": "O que é CGNAT (Carrier-Grade NAT) e por que foi necessário?",
    "options": [
      "NAT em larga escala feito pelo ISP, compartilhando IPs públicos entre múltiplos clientes devido à exaustão de IPv4",
      "NAT exclusivo para redes domésticas",
      "Tradução de endereços MAC para IP",
      "Protocolo de roteamento para ISPs"
    ],
    "correctIndex": 0,
    "explanation": "CGNAT (RFC 6888) é NAT feito pelo provedor de internet, não pelo roteador do cliente. Múltiplos clientes compartilham o mesmo IP público. Foi necessário pela exaustão de endereços IPv4. Bloco reservado: 100.64.0.0/10.",
    "example": "Problema: 4.3 bilhões de IPs IPv4 esgotados. CGNAT: ISP dá IP privado (100.64.x.x) ao cliente, que já faz NAT internamente → duplo NAT. Desvantagens: dificulta P2P, port forwarding e rastreamento."
  },
  {
    "id": "rede-de-computadores__DNS, DHCP e NAT__Difícil__7",
    "track": "rede-de-computadores",
    "category": "DNS, DHCP e NAT",
    "difficulty": "Difícil",
    "question": "O que são registros NSEC e NSEC3 no DNSSEC?",
    "options": [
      "Provam autenticamente que um domínio NÃO existe (prova de inexistência)",
      "Criptografam as queries DNS",
      "Armazenam chaves públicas do domínio",
      "Indicam servidores DNS autoritativos"
    ],
    "correctIndex": 0,
    "explanation": "NSEC e NSEC3 permitem que o resolver verifique que um nome de domínio realmente não existe (authenticated denial of existence). NSEC lista o próximo nome existente na zona; NSEC3 usa hashes para evitar enumeração de zona (zone walking).",
    "example": "NSEC: 'Entre aaa.com e bbb.com não há nada' — permite zone walking (listar todos os nomes). NSEC3: usa hash dos nomes → impede enumeração. NSEC3 é preferido por segurança."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Fácil",
    "question": "Qual das seguintes é uma faixa de endereços IP privados (classe C)?",
    "options": [
      "192.168.0.0 a 192.168.255.255",
      "200.0.0.0 a 200.255.255.255",
      "172.0.0.0 a 172.255.255.255",
      "10.0.0.0 a 10.0.0.255"
    ],
    "correctIndex": 0,
    "explanation": "A RFC 1918 define três faixas de IPs privados: Classe A: 10.0.0.0/8 (10.0.0.0 a 10.255.255.255). Classe B: 172.16.0.0/12 (172.16.0.0 a 172.31.255.255). Classe C: 192.168.0.0/16 (192.168.0.0 a 192.168.255.255).",
    "example": "IPs privados não são roteados na internet. Uso: redes internas/domésticas. Para acessar a internet, precisam de NAT. Note: 172.0.0.0 não é toda privada — apenas 172.16.0.0 a 172.31.255.255."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Fácil",
    "question": "Qual é a máscara de sub-rede padrão de uma rede classe C?",
    "options": [
      "255.255.255.0 (/24)",
      "255.0.0.0 (/8)",
      "255.255.0.0 (/16)",
      "255.255.255.128 (/25)"
    ],
    "correctIndex": 0,
    "explanation": "Classes de IP e máscaras padrão: Classe A (1.0–126.x) → /8 = 255.0.0.0. Classe B (128.0–191.x) → /16 = 255.255.0.0. Classe C (192.0–223.x) → /24 = 255.255.255.0. Sistema classful é obsoleto mas cobrado em provas.",
    "example": "Classe A: /8 (16M hosts). Classe B: /16 (65K hosts). Classe C: /24 (254 hosts). CIDR (Classless) substituiu: permite qualquer máscara (/1 a /32), independente da 'classe'."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Fácil",
    "question": "O endereço 127.0.0.1 é utilizado para qual finalidade?",
    "options": [
      "Loopback — referência ao próprio dispositivo (localhost)",
      "Gateway padrão da rede",
      "Endereço de broadcast",
      "Primeiro IP utilizável em qualquer rede"
    ],
    "correctIndex": 0,
    "explanation": "O endereço 127.0.0.1 (faixa 127.0.0.0/8) é reservado para loopback: o tráfego nunca sai da máquina. Usado para testes locais e comunicação entre processos. 'localhost' é o nome associado.",
    "example": "127.0.0.0/8: 16M endereços para loopback (só 127.0.0.1 é comumente usado). `ping 127.0.0.1` testa a pilha TCP/IP local. Em IPv6, o loopback é ::1."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Fácil",
    "question": "Quais são os três intervalos de endereços IP privados definidos pela RFC 1918?",
    "options": [
      "10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16",
      "10.0.0.0/16, 172.16.0.0/8, 192.168.0.0/24",
      "127.0.0.0/8, 169.254.0.0/16, 10.0.0.0/8",
      "192.0.0.0/8, 172.0.0.0/8, 10.0.0.0/8"
    ],
    "correctIndex": 0,
    "explanation": "RFC 1918 define 3 faixas privadas: 10.0.0.0/8 (16M hosts), 172.16.0.0/12 (1M hosts), 192.168.0.0/16 (65K hosts). Esses IPs não são roteáveis na internet — precisam de NAT para sair.",
    "example": "Classe A privada: 10.0.0.0–10.255.255.255. Classe B privada: 172.16.0.0–172.31.255.255. Classe C privada: 192.168.0.0–192.168.255.255. Redes domésticas usam 192.168.x.x."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Fácil",
    "question": "O que é um endereço de broadcast em uma rede IP?",
    "options": [
      "Endereço que envia pacote para todos os hosts da rede",
      "Endereço do roteador padrão",
      "Primeiro IP utilizável da sub-rede",
      "Endereço reservado para DNS"
    ],
    "correctIndex": 0,
    "explanation": "O endereço de broadcast é o último da sub-rede (todos os bits de host = 1). Pacotes enviados para este endereço são entregues a TODOS os hosts da rede. Ex: na rede 192.168.1.0/24, o broadcast é 192.168.1.255.",
    "example": "Broadcast: todos os bits de host = 1. Endereço de rede: todos = 0. Nenhum dos dois pode ser atribuído a hosts. Broadcast limitado: 255.255.255.255 (não cruza roteadores)."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Fácil",
    "question": "O que é uma máscara de sub-rede?",
    "options": [
      "Número que define quais bits do IP identificam a rede e quais identificam o host",
      "Endereço IP do roteador principal",
      "Senha de acesso à rede",
      "Identificador do fabricante do equipamento"
    ],
    "correctIndex": 0,
    "explanation": "A máscara de sub-rede separa a parte de rede da parte de host em um endereço IP. Bits 1 = rede, bits 0 = host. Ex: 255.255.255.0 = /24 (24 bits de rede, 8 de host). Dispositivos na mesma rede compartilham a mesma parte de rede.",
    "example": "255.255.255.0 = 11111111.11111111.11111111.00000000 = /24. Os '1s' identificam a rede; os '0s' identificam o host. IP 192.168.1.10 com /24: rede = 192.168.1, host = .10."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Fácil",
    "question": "O endereço 192.168.1.0 em uma rede /24 pode ser atribuído a um host?",
    "options": [
      "Não — é o endereço de rede, reservado",
      "Sim — é um endereço normal",
      "Apenas para servidores",
      "Apenas para roteadores"
    ],
    "correctIndex": 0,
    "explanation": "O primeiro endereço de uma sub-rede (todos os bits de host = 0) é o endereço de rede e não pode ser atribuído a nenhum dispositivo. O último (todos os bits = 1) é o broadcast. Ambos são reservados.",
    "example": "Rede 192.168.1.0/24: .0 = endereço de rede (reservado). .255 = broadcast (reservado). Hosts válidos: .1 a .254 (254 hosts). Todo cálculo de sub-rede desconta esses 2 endereços."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Fácil",
    "question": "Qual o número de hosts úteis em uma sub-rede /28?",
    "options": [
      "14 hosts",
      "16 hosts",
      "30 hosts",
      "254 hosts"
    ],
    "correctIndex": 0,
    "explanation": "/28 = 32-28 = 4 bits para hosts. 2^4 = 16 endereços totais. Hosts úteis = 16 - 2 = 14 (subtrai endereço de rede e broadcast).",
    "example": "Máscara /28 = 255.255.255.240. Bloco de 16. Rede: .0, Broadcast: .15, Hosts: .1 a .14 (14 úteis). VLSM: /28 em ambiente com 10 hosts (pede /28); /26 para 60 hosts (2^6-2=62). /30: 2 hosts (links ponto-a-ponto)."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Médio__1",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Médio",
    "question": "Quantos hosts válidos podem existir em uma rede /26?",
    "options": [
      "62",
      "64",
      "30",
      "126"
    ],
    "correctIndex": 0,
    "explanation": "Uma rede /26 tem 32 - 26 = 6 bits para hosts. 2⁶ = 64 endereços totais. Subtraímos 2 (endereço de rede e broadcast): 64 - 2 = 62 hosts válidos. Máscara /26 = 255.255.255.192.",
    "example": "/26 → 6 bits host → 2⁶ = 64. Hosts utilizáveis: 64 - 2 = 62. Primeiro IP: rede. Último IP: broadcast. Exemplo: 192.168.1.0/26 → rede .0, hosts .1 a .62, broadcast .63."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Médio__2",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Médio",
    "question": "Qual é o endereço de broadcast da rede 192.168.10.0/24?",
    "options": [
      "192.168.10.255",
      "192.168.10.0",
      "192.168.10.1",
      "192.168.11.0"
    ],
    "correctIndex": 0,
    "explanation": "O broadcast é o último endereço da sub-rede — todos os bits de host são 1. Em /24, os últimos 8 bits: 11111111 = 255. Broadcast = 192.168.10.255. O endereço de rede é 192.168.10.0.",
    "example": "Rede: .0 (bits host = 0). Broadcast: .255 (bits host = 1). Hosts válidos: .1 a .254 (254 hosts). Gateway geralmente é .1 ou .254. Broadcast entrega pacotes a todos os hosts."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Médio__3",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Médio",
    "question": "Qual a diferença entre IPv4 e IPv6 em termos de tamanho de endereço?",
    "options": [
      "IPv4 usa 32 bits; IPv6 usa 128 bits",
      "IPv4 usa 64 bits; IPv6 usa 128 bits",
      "IPv4 usa 32 bits; IPv6 usa 64 bits",
      "Ambos usam 32 bits"
    ],
    "correctIndex": 0,
    "explanation": "IPv4: 32 bits = 4 octetos (ex: 192.168.1.1) → ~4,3 bilhões de endereços. IPv6: 128 bits = 8 grupos hexadecimais (ex: 2001:0db8::1) → 3,4 × 10³⁸ endereços. IPv6 resolve a escassez de IPv4.",
    "example": "IPv4: 2³² ≈ 4,3 × 10⁹. IPv6: 2¹²⁸ ≈ 3,4 × 10³⁸. IPv6 elimina NAT, tem IPsec nativo e autoconfiguração (SLAAC). Formato: 2001:0db8:85a3::8a2e:0370:7334."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Médio__4",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Médio",
    "question": "Qual a máscara de sub-rede para /28 em notação decimal?",
    "options": [
      "255.255.255.240",
      "255.255.255.224",
      "255.255.255.248",
      "255.255.255.192"
    ],
    "correctIndex": 0,
    "explanation": "/28 significa 28 bits de rede e 4 bits de host. Último octeto: 11110000 = 240. Máscara: 255.255.255.240. Hosts: 2⁴ - 2 = 14 hosts válidos por sub-rede.",
    "example": "/28 = 255.255.255.240 (14 hosts). /29 = .248 (6 hosts). /30 = .252 (2 hosts, links ponto-a-ponto). /27 = .224 (30 hosts). /26 = .192 (62 hosts)."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Médio__5",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Médio",
    "question": "O que é CIDR (Classless Inter-Domain Routing)?",
    "options": [
      "Sistema flexível de endereçamento IP que substitui classes fixas",
      "Protocolo de roteamento dinâmico",
      "Método de criptografia de pacotes",
      "Protocolo de transferência de arquivos"
    ],
    "correctIndex": 0,
    "explanation": "CIDR permite usar qualquer máscara de sub-rede (/1 a /32), sem depender das classes A, B e C tradicionais. Notação: IP/prefixo (ex: 192.168.1.0/24). Permite agregação de rotas (supernetting) e uso eficiente de endereços.",
    "example": "Antes (classful): Classe A (/8), B (/16), C (/24) fixos. Com CIDR: qualquer máscara. Exemplo: 200.10.0.0/22 agrega 4 redes /24. CIDR foi definido na RFC 4632."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Médio__6",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Médio",
    "question": "Quantas sub-redes /28 podem ser criadas a partir de uma rede /24?",
    "options": [
      "16",
      "8",
      "32",
      "4"
    ],
    "correctIndex": 0,
    "explanation": "De /24 para /28: 28 - 24 = 4 bits emprestados para sub-rede. 2⁴ = 16 sub-redes. Cada sub-rede /28 tem 2⁴ - 2 = 14 hosts válidos. Total: 16 sub-redes × 14 hosts = 224 hosts (vs 254 em /24).",
    "example": "/24 → /28 = 4 bits extra = 16 sub-redes de 14 hosts. /24 → /26 = 2 bits = 4 sub-redes de 62 hosts. /24 → /25 = 1 bit = 2 sub-redes de 126 hosts. Fórmula: 2^(novo-antigo) sub-redes."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Médio__7",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Médio",
    "question": "Qual a faixa de hosts válidos na sub-rede 10.0.0.64/26?",
    "options": [
      "10.0.0.65 a 10.0.0.126",
      "10.0.0.64 a 10.0.0.127",
      "10.0.0.65 a 10.0.0.127",
      "10.0.0.64 a 10.0.0.126"
    ],
    "correctIndex": 0,
    "explanation": "/26 → 6 bits de host → 64 endereços por sub-rede. Rede: 10.0.0.64. Broadcast: 10.0.0.127 (64 + 63). Hosts válidos: primeiro +1 (10.0.0.65) até broadcast -1 (10.0.0.126) = 62 hosts.",
    "example": "Sub-redes /26 em 10.0.0.0/24: .0-.63, .64-.127, .128-.191, .192-.255. Cada bloco: 64 endereços, 62 hosts. Rede 10.0.0.64/26: rede .64, hosts .65-.126, broadcast .127."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Médio__8",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Médio",
    "question": "O que é o IPv6 EUI-64 e como ele gera o identificador de interface a partir do MAC address?",
    "options": [
      "EUI-64: expande MAC de 48 bits para 64 bits inserindo FFFE no meio e invertendo o bit U/L (bit 7); composto com prefixo /64 forma o IPv6 completo",
      "EUI-64 é um algoritmo de hash SHA64 aplicado ao MAC address",
      "O router gera o identificador aleatoriamente sem relação com o MAC",
      "EUI-64 usa os últimos 64 bits do MAC truncando os primeiros"
    ],
    "correctIndex": 0,
    "explanation": "MAC: AA:BB:CC:DD:EE:FF (48 bits). EUI-64: AA:BB:CC:FF:FE:DD:EE:FF (64 bits). Processo: divide MAC em duas metades (3B cada), insere FF:FE no meio, inverte bit 7 do primeiro byte (bit U/L: 0=universal, 1=local administrado). Prefixo /64 + EUI-64 ID = endereço IPv6 SLAAC.",
    "example": "MAC AA:BB:CC:DD:EE:FF → bit7 de AA (=10101010): bit7=1→0 → A8. EUI-64: A8:BB:CC:FF:FE:DD:EE:FF. Endereço: 2001:db8::/64 → 2001:db8::a8bb:ccff:fedd:eeff. Privacidade: RFC 4941 gera identificadores temporários aleatórios (privacy extensions). DHCPv6 stateful: servidor atribui manualmente."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Difícil",
    "question": "Você precisa dividir a rede 10.0.0.0/8 em sub-redes que comportem exatamente 500 hosts cada. Qual máscara usar?",
    "options": [
      "/23 (255.255.254.0)",
      "/22 (255.255.252.0)",
      "/24 (255.255.255.0)",
      "/25 (255.255.255.128)"
    ],
    "correctIndex": 0,
    "explanation": "Para 500 hosts: precisamos de n bits tal que 2ⁿ - 2 ≥ 500. 2⁹ = 512 (512-2 = 510 ≥ 500 ✓). 2⁸ = 256 (256-2 = 254 < 500 ✗). Com 9 bits de host: máscara = 32 - 9 = /23 = 255.255.254.0. Cada sub-rede tem 510 hosts utilizáveis.",
    "example": "500 hosts → 2⁹ = 512 → /23. Sub-redes: 10.0.0.0/23 (hosts .0.1-.1.254), 10.0.2.0/23 (hosts .2.1-.3.254), etc. Total de sub-redes possíveis: 2^(23-8) = 2¹⁵ = 32.768 sub-redes."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Difícil",
    "question": "O que é VLSM (Variable Length Subnet Masking) e qual sua vantagem?",
    "options": [
      "Permite usar máscaras de tamanho diferente em cada sub-rede, otimizando o uso de IPs",
      "Usa uma máscara única para toda a rede",
      "Funciona apenas com IPv6",
      "É um protocolo de roteamento dinâmico"
    ],
    "correctIndex": 0,
    "explanation": "VLSM permite que diferentes sub-redes tenham máscaras distintas. Em vez de /24 para todas (desperdício se uma sub-rede tem 3 hosts), usa-se /30 para links ponto-a-ponto e /24 para sub-redes maiores.",
    "example": "Sem VLSM: todas /24 = 254 hosts (link WAN: 2 hosts, desperdício de 252). Com VLSM: WAN usa /30 (2 hosts), LAN usa /24 (254). Requer protocolos classless (OSPF, EIGRP, RIPv2)."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Difícil",
    "question": "Dado o endereço 172.16.45.123/20, qual é o endereço de rede e o broadcast desta sub-rede?",
    "options": [
      "Rede: 172.16.32.0 — Broadcast: 172.16.47.255",
      "Rede: 172.16.45.0 — Broadcast: 172.16.45.255",
      "Rede: 172.16.44.0 — Broadcast: 172.16.47.255",
      "Rede: 172.16.40.0 — Broadcast: 172.16.43.255"
    ],
    "correctIndex": 0,
    "explanation": "/20 = 255.255.240.0. Terceiro octeto 45 em binário: 00101101. Máscara 3º octeto: 11110000. Parte de rede: 00100000 = 32. Rede = 172.16.32.0. Broadcast: 32 + 15 = 47 → 172.16.47.255.",
    "example": "Cálculo: /20 → 12 bits host. 45 AND 240 = 32 (rede). 32 OR 15 = 47 (broadcast). Faixa: 172.16.32.0 a 172.16.47.255 = 4096 endereços (4094 hosts)."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Difícil",
    "question": "O que é supernetting (superrede) e quando é utilizado?",
    "options": [
      "Agregação de múltiplas sub-redes em uma rota única para reduzir tabelas de roteamento",
      "Divisão de uma rede grande em sub-redes menores",
      "Criação de VLANs dentro de uma sub-rede",
      "Duplicação de IPs para redundância"
    ],
    "correctIndex": 0,
    "explanation": "Supernetting (agregação de rotas / route summarization) combina várias sub-redes contíguas em uma única rota com máscara menor. Exemplo: 4 redes /24 (192.168.0.0–3.0) viram 1 rota /22. Reduz o tamanho da tabela de roteamento.",
    "example": "192.168.0.0/24 + .1.0/24 + .2.0/24 + .3.0/24 = 192.168.0.0/22 (1 rota). Requisito: as redes devem ser contíguas e a quantidade deve ser potência de 2."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Difícil",
    "question": "Em IPv6, o que é SLAAC (Stateless Address Autoconfiguration)?",
    "options": [
      "Método que permite hosts gerarem IPs automaticamente sem servidor DHCP",
      "Protocolo de roteamento exclusivo para IPv6",
      "Mecanismo de tradução IPv4 para IPv6",
      "Firewall nativo do IPv6"
    ],
    "correctIndex": 0,
    "explanation": "SLAAC permite que um host IPv6 configure seu próprio endereço combinando o prefixo da rede (obtido via Router Advertisement/NDP) com o identificador da interface (geralmente derivado do MAC via EUI-64 ou aleatório).",
    "example": "SLAAC: host recebe prefixo /64 via RA do roteador + gera sufixo. Sem estado no servidor (stateless). DHCPv6: stateful (servidor controla IPs). Ambos usam NDP (Neighbor Discovery Protocol) na base."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Difícil",
    "question": "O que é um endereço link-local em IPv6 e qual seu prefixo?",
    "options": [
      "fe80::/10 — autoconfigurado, não roteável, comunicação no mesmo link",
      "2001::/16 — endereço público global",
      "ff00::/8 — multicast",
      "::1/128 — loopback"
    ],
    "correctIndex": 0,
    "explanation": "Endereços link-local (fe80::/10) são autoconfigurados em TODA interface IPv6 e são válidos apenas no segmento local (não são roteados). São essenciais para NDP (Neighbor Discovery), SLAAC e roteamento local.",
    "example": "fe80:: link-local: sempre presente, não roteável. 2001:: global unicast: roteável na internet. ff02:: multicast link-local. ::1 loopback. fc00::/7 unique local (equivalente ao IP privado)."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Difícil",
    "question": "Qual é o endereço de rede e broadcast de 192.168.5.130/25?",
    "options": [
      "Rede: 192.168.5.128 — Broadcast: 192.168.5.255",
      "Rede: 192.168.5.0 — Broadcast: 192.168.5.255",
      "Rede: 192.168.5.128 — Broadcast: 192.168.5.191",
      "Rede: 192.168.5.129 — Broadcast: 192.168.5.254"
    ],
    "correctIndex": 0,
    "explanation": "/25 divide em 2 sub-redes de 128 endereços. 130 é > 128 → segunda sub-rede: 192.168.5.128 a 192.168.5.255. Rede: .128 (bits host = 0). Broadcast: .255 (bits host = 1). Hosts: .129 a .254 (126 hosts).",
    "example": "/25: 7 bits host = 128 endereços. Sub-rede 1: .0-.127 (hosts .1-.126). Sub-rede 2: .128-.255 (hosts .129-.254). 130 está na sub-rede 2. Cálculo: 130 AND 128 = 128 (rede)."
  },
  {
    "id": "rede-de-computadores__Endereçamento IP e Sub-redes__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Endereçamento IP e Sub-redes",
    "difficulty": "Difícil",
    "question": "Como funciona o VLSM (Variable Length Subnet Masking) e por que é mais eficiente que classful routing?",
    "options": [
      "VLSM: cada sub-rede pode ter máscara diferente; permite alocar exatamente o espaço necessário evitando desperdício; classful usa máscaras fixas por classe (A/B/C)",
      "VLSM divide a rede apenas em blocos iguais de 2^n",
      "Classless routing e VLSM são sinônimos; não há diferença prática",
      "VLSM exige roteamento classful como RIP v1 que carrega a máscara nos updates"
    ],
    "correctIndex": 0,
    "explanation": "Classful: Classe C = /24 fixo (254 hosts). Se precisar de 2 links WAN e 50 hosts: 2+50 = 52 + desperdiça 202. VLSM: 50 hosts → /26 (62 hosts), link WAN → /30 (2 hosts). Protocolos classless (OSPF, EIGRP, RIPv2, BGP): enviam a máscara junto com o prefixo nas atualizações. RIPv1: classful (não envia máscara).",
    "example": "Projeto VLSM: bloco 192.168.1.0/24. Sub-rede 1 (60 hosts): /26 = 192.168.1.0/26. Sub-rede 2 (30 hosts): /27 = 192.168.1.64/27. Link WAN: /30 = 192.168.1.96/30. Sub-rede 3 (12 hosts): /28 = 192.168.1.100/28. Alocar do maior ao menor para não fragmentar."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Fácil",
    "question": "Qual equipamento opera na Camada 2 (Enlace) do modelo OSI e encaminha quadros com base em endereços MAC?",
    "options": [
      "Switch",
      "Roteador",
      "Hub",
      "Modem"
    ],
    "correctIndex": 0,
    "explanation": "O switch opera na Camada 2 (Enlace de Dados) e utiliza endereços MAC para encaminhar quadros (frames) apenas para a porta de destino. Diferente do hub (Camada 1), que replica para todas as portas. Roteador opera na Camada 3 (Rede).",
    "example": "Hub: Camada 1 (repete sinal em todas as portas). Switch: Camada 2 (encaminha por MAC). Roteador: Camada 3 (encaminha por IP). Switch L3: opera nas camadas 2 e 3."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Fácil",
    "question": "Qual é a função de um roteador em uma rede?",
    "options": [
      "Encaminhar pacotes entre redes diferentes com base em endereços IP",
      "Amplificar o sinal elétrico nas portas",
      "Conectar dispositivos na mesma rede local por MAC",
      "Converter sinais digitais em analógicos"
    ],
    "correctIndex": 0,
    "explanation": "O roteador opera na Camada 3 (Rede) do modelo OSI e encaminha pacotes entre redes diferentes usando endereços IP e tabelas de roteamento. É essencial para conectar LAN à internet (WAN) e segmentar redes.",
    "example": "Switch: mesma rede (intra-VLAN). Roteador: redes diferentes (inter-rede). O roteador é o 'gateway padrão'. Funções adicionais comuns: NAT, firewall, DHCP, VPN."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Fácil",
    "question": "O que é um access point (AP) wireless?",
    "options": [
      "Dispositivo que permite conexão sem fio (Wi-Fi) à rede cabeada",
      "Roteador com fio para redes grandes",
      "Firewall para redes wireless",
      "Amplificador de sinal de internet via cabo"
    ],
    "correctIndex": 0,
    "explanation": "O access point cria uma rede sem fio (Wi-Fi) e conecta clientes wireless à rede cabeada. Diferente de um roteador Wi-Fi doméstico, um AP dedicado não faz NAT nem roteamento — apenas bridge entre wireless e wired.",
    "example": "Roteador Wi-Fi doméstico = roteador + switch + AP + NAT em um só. AP corporativo: gerenciado por controladora (WLC), múltiplos SSIDs, VLANs, 802.1X."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Fácil",
    "question": "O que é um repetidor (repeater) em redes?",
    "options": [
      "Dispositivo que amplifica/regenera o sinal para aumentar o alcance",
      "Equipamento que traduz endereços IP",
      "Filtro de pacotes por regras",
      "Servidor que distribui endereços IP"
    ],
    "correctIndex": 0,
    "explanation": "O repetidor opera na Camada 1 (Física) e regenera o sinal degradado, estendendo o alcance da rede. Não interpreta dados — simplesmente amplifica. Em redes modernas, foi substituído por switches e APs.",
    "example": "Repetidor: Camada 1, regenera sinal. Hub: Camada 1, repetidor multiporta. Switch: Camada 2, encaminha por MAC. Roteador: Camada 3, roteia por IP. Camada mais alta = mais inteligência."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Fácil",
    "question": "Qual equipamento é o 'gateway padrão' de uma rede local?",
    "options": [
      "Roteador",
      "Switch",
      "Hub",
      "Access Point"
    ],
    "correctIndex": 0,
    "explanation": "O roteador é o gateway padrão — o ponto de saída da rede local para outras redes (internet). Quando um host quer acessar um IP fora de sua sub-rede, envia o pacote para o gateway (IP do roteador na rede local).",
    "example": "Gateway padrão: geralmente o primeiro ou último IP da sub-rede (ex: 192.168.1.1 ou .254). Configurado no host ou via DHCP. Sem gateway, o host só se comunica dentro da própria sub-rede."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Fácil",
    "question": "O que é um switch PoE?",
    "options": [
      "Switch que fornece energia elétrica e dados pelo mesmo cabo de rede",
      "Switch que opera apenas com fibra óptica",
      "Switch com fonte de energia mais potente",
      "Switch exclusivo para redes sem fio"
    ],
    "correctIndex": 0,
    "explanation": "Um switch PoE (Power over Ethernet) fornece energia elétrica e dados simultaneamente pelo cabo UTP. Ideal para alimentar access points, câmeras IP e telefones VoIP sem necessidade de tomada elétrica próxima ao dispositivo.",
    "example": "PoE (802.3af): 15.4W. PoE+ (802.3at): 30W. PoE++ (802.3bt): 60-100W. Orçamento PoE do switch: soma da potência disponível para todas as portas. Exemplo: switch 24 portas com 370W PoE budget."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Fácil",
    "question": "Qual dispositivo conecta uma rede local (LAN) à internet (WAN)?",
    "options": [
      "Roteador",
      "Hub",
      "Repetidor",
      "Patch panel"
    ],
    "correctIndex": 0,
    "explanation": "O roteador conecta redes diferentes, como a LAN interna e a internet (WAN). Ele encaminha pacotes entre essas redes usando endereços IP e tabelas de roteamento. O roteador é o gateway padrão da LAN.",
    "example": "LAN (rede local) ↔ Roteador ↔ WAN (internet). O roteador faz NAT, DHCP, firewall básico e roteamento. Em empresas: roteador dedicado + switch + AP. Em casa: tudo integrado no 'roteador Wi-Fi'."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Fácil",
    "question": "Qual a diferença funcional entre Hub, Switch e Roteador?",
    "options": [
      "Hub: broadcast físico (camada 1) para todas as portas; Switch: comuta por MAC (camada 2) para a porta correta; Roteador: encaminha por IP (camada 3) entre redes diferentes",
      "Hub e Switch são idênticos; só o roteador difere",
      "Switch opera na camada 3; roteador na camada 2",
      "Hub verifica colisões; Switch e Roteador não têm domínio de colisão"
    ],
    "correctIndex": 0,
    "explanation": "Hub (camada 1): repassa o sinal elétrico para todas as portas — domínio de colisão único (CSMA/CD), half-duplex. Switch (camada 2): aprende tabela MAC, encaminha somente para porta de destino — cada porta = domínio de colisão isolado, full-duplex. Roteador (camada 3): encaminha pacotes IP, separa domínios de broadcast (uma tabela de roteamento por interface).",
    "example": "Switch Camada 3 (multilayer): faz roteamento IP internamente ao hardware (linha rate). Router-on-a-stick: roteador com subinterfaces para inter-VLAN routing. Hub: desapareceu do mercado (domínio de colisão elimina performance). Microsegmentação: switch dedica banda por porta."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Médio__1",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Médio",
    "question": "O que é um switch gerenciável (managed switch) e qual sua vantagem sobre um switch não gerenciável?",
    "options": [
      "Permite configuração de VLANs, QoS, espelhamento e monitoramento via interface de gestão",
      "É mais rápido que o não gerenciável",
      "Funciona como roteador automaticamente",
      "Tem mais portas que um switch comum"
    ],
    "correctIndex": 0,
    "explanation": "Switches gerenciáveis permitem configuração avançada: VLANs (segmentação lógica), QoS (priorização de tráfego), port mirroring (espelhamento), SNMP (monitoramento), spanning tree (prevenção de loops), segurança por porta. São acessados via CLI, web ou SNMP.",
    "example": "Não gerenciável: plug-and-play, sem configuração. Gerenciável: CLI/Web para VLANs, ACLs, QoS, LLDP, STP, SNMP, port security. Custo maior, mas essencial em redes corporativas."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Médio__2",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Médio",
    "question": "Qual a principal diferença entre um hub e um switch?",
    "options": [
      "O hub envia dados para todas as portas; o switch envia apenas para a porta de destino",
      "O hub é mais rápido que o switch",
      "O switch funciona apenas com fibra óptica",
      "O hub opera na Camada 3 e o switch na Camada 1"
    ],
    "correctIndex": 0,
    "explanation": "Hub (Camada 1): repete o sinal para TODAS as portas, criando um domínio de colisão. Switch (Camada 2): aprende endereços MAC e encaminha quadros APENAS para a porta correta, um domínio de colisão por porta.",
    "example": "Hub: banda compartilhada (10 dispositivos × 100Mbps = ~10Mbps cada). Switch: banda dedicada por porta. Hub gera mais colisões. Switch usa tabela MAC (CAM table)."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Médio__3",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Médio",
    "question": "O que é um modem e em qual camada do modelo OSI ele atua?",
    "options": [
      "Modula/demodula sinais para transmissão; atua na Camada 1 (Física)",
      "Equipamento da Camada 3 que roteia pacotes",
      "Dispositivo da Camada 2 que filtra quadros",
      "Software da Camada 7 que processa dados"
    ],
    "correctIndex": 0,
    "explanation": "Modem (MOdulador/DEModulador) converte sinais digitais em analógicos para transmissão pelo meio (linha telefônica, cabo, fibra) e vice-versa. Opera na Camada 1 (Física) do modelo OSI.",
    "example": "Tipos: ADSL (linha telefônica), cable modem (coaxial/HFC), fibra (ONT/ONU), 4G/5G. O modem da operadora geralmente inclui roteador e Wi-Fi integrados (CPE)."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Médio__4",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Médio",
    "question": "O que é a tabela MAC (CAM table) de um switch?",
    "options": [
      "Tabela que associa endereços MAC às portas físicas do switch",
      "Tabela de roteamento IP",
      "Lista de VLANs configuradas",
      "Registro de logs de segurança"
    ],
    "correctIndex": 0,
    "explanation": "A tabela MAC (CAM — Content Addressable Memory) mapeia endereços MAC para portas do switch. Quando o switch recebe um quadro, ele aprende o MAC de origem na porta de entrada e encaminha para a porta associada ao MAC de destino.",
    "example": "Aprendizagem: quadro entra na porta 1 com MAC-A → switch grava 'MAC-A = porta 1'. Encaminhamento: destino MAC-B → busca na tabela → porta 3. Se não conhece: flooding (envia para todas)."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Médio__5",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Médio",
    "question": "O que é VLAN e qual sua principal vantagem?",
    "options": [
      "Rede virtual que segmenta logicamente a rede, mesmo no mesmo switch físico",
      "Rede que só funciona com cabos virtuais",
      "Protocolo de criptografia para switches",
      "Software de gerenciamento de roteadores"
    ],
    "correctIndex": 0,
    "explanation": "VLAN (Virtual LAN) permite segmentar uma rede física em múltiplas redes lógicas. Portas do mesmo switch podem pertencer a VLANs diferentes (domínios de broadcast separados). Comunicação entre VLANs requer roteamento (roteador ou switch L3).",
    "example": "VLAN 10 (vendas) e VLAN 20 (TI) no mesmo switch: isoladas. Trunk (802.1Q): link que transporta múltiplas VLANs entre switches usando tags. Access port: pertence a uma única VLAN."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Médio__6",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Médio",
    "question": "O que é EtherChannel (Link Aggregation) em switches?",
    "options": [
      "Agrupamento de múltiplos links físicos em um único link lógico",
      "Protocolo de roteamento dinâmico",
      "Método de criptografia para VLANs",
      "Tipo de cabo para conexões de alta velocidade"
    ],
    "correctIndex": 0,
    "explanation": "EtherChannel (ou Link Aggregation / LAG) combina 2-8 links físicos em um único link lógico, aumentando a largura de banda e fornecendo redundância. Se um link falhar, o tráfego é redistribuído pelos demais.",
    "example": "4 links de 1 Gbps = 1 link lógico de 4 Gbps. Protocolos: LACP (IEEE 802.3ad, negociação automática) e PAgP (Cisco proprietário). STP vê o EtherChannel como uma única porta."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Médio__7",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Médio",
    "question": "O que é um switch Layer 3?",
    "options": [
      "Switch que também roteia pacotes usando endereços IP, combinando funções de L2 e L3",
      "Switch com 3 portas de uplink",
      "Switch que opera apenas na Camada 1",
      "Switch exclusivo para fibra óptica"
    ],
    "correctIndex": 0,
    "explanation": "Um switch L3 combina switching (Camada 2, por MAC) com roteamento (Camada 3, por IP). Faz roteamento inter-VLAN em hardware (ASICs), com desempenho muito superior a um roteador para tráfego interno.",
    "example": "Switch L2: encaminha por MAC, não roteia. Switch L3: encaminha por MAC + roteia por IP. Roteador: foco em WAN, NAT, VPN. Switch L3 é ideal para core/distribuição em redes corporativas."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Médio__8",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Médio",
    "question": "O que é Spanning Tree Protocol (STP) e por que é necessário em redes comutadas?",
    "options": [
      "STP (802.1D): previne loops em redes com caminhos redundantes bloqueando portas redundantes; elege root bridge e determina portas Designated/Root/Blocked",
      "STP balanceia carga entre todos os links redundantes simultaneamente",
      "STP é usado somente em WAN; LAN com switches não tem risco de loop",
      "STP opera na camada 3; roteadores também participam da eleição do root"
    ],
    "correctIndex": 0,
    "explanation": "Loop de camada 2: broadcast storm (frame se propaga infinitamente), instabilidade de tabela MAC, duplicação de frames. STP: root bridge (menor Bridge ID = prioridade+MAC). Root Port: porta mais próxima do root em switches não-root. Designated Port: melhor caminho por segmento. Blocked Port: descarta frames de dados. Estados: Blocking/Listening/Learning/Forwarding (Disabled).",
    "example": "RSTP (802.1w): convergencia < 1s. MSTP (802.1s): múltiplas STP per VLAN-group. PVST+ (Cisco): STP por VLAN. PortFast: pula estados no acesso (hosts). BPDU Guard: desabilita porta se receber BPDU (previne rouge switch). Loop Guard: previne root port de transicionar por falta de BPDU."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Difícil",
    "question": "Em qual cenário é mais apropriado usar um switch Layer 3 em vez de um roteador tradicional?",
    "options": [
      "Roteamento entre VLANs em alta velocidade dentro do campus",
      "Conexão WAN com a internet",
      "VPN site-to-site",
      "Filtragem de pacotes no perímetro da rede"
    ],
    "correctIndex": 0,
    "explanation": "Switches L3 fazem roteamento inter-VLAN em hardware (ASICs), com latência muito menor e throughput muito maior que roteadores tradicionais. São ideais para roteamento interno (campus/LAN). Roteadores são preferidos para WAN, VPN e funções de perímetro com recursos como NAT e firewall avançado.",
    "example": "Switch L3: roteamento LAN/campus inter-VLAN, hardware-based, wire-speed. Roteador: WAN, NAT, VPN, firewall, links seriais/DSL. Em redes grandes, combinam-se ambos: switches L3 internamente e roteadores na borda."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Difícil",
    "question": "Qual é a função do Spanning Tree Protocol (STP) em redes com switches?",
    "options": [
      "Prevenir loops de camada 2 bloqueando portas redundantes",
      "Balancear carga de tráfego entre switches",
      "Criptografar o tráfego entre switches",
      "Atribuir VLANs automaticamente às portas"
    ],
    "correctIndex": 0,
    "explanation": "STP (IEEE 802.1D) previne loops de Camada 2 em redes com links redundantes. Elege um Root Bridge e calcula caminhos livres de loop, bloqueando portas redundantes. RSTP (802.1w) oferece convergência mais rápida.",
    "example": "Sem STP: loop → broadcast storm → rede cai. Com STP: Root Bridge eleito (menor Bridge ID). Portas: Root, Designated, Blocked. STP converge em 30-50s. RSTP: < 6s."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Difícil",
    "question": "O que é empilhamento (stacking) de switches e quais benefícios oferece?",
    "options": [
      "Conectar múltiplos switches para operarem como uma única unidade lógica",
      "Empilhar switches fisicamente no rack sem conexão",
      "Usar switches de marcas diferentes na mesma rede",
      "Configurar VLANs em switches diferentes automaticamente"
    ],
    "correctIndex": 0,
    "explanation": "Stacking conecta switches por cabos dedicados de alta velocidade formando um único switch lógico. Um switch master gerencia todo o stack. Benefícios: gerenciamento unificado, tabela MAC única, alta disponibilidade.",
    "example": "Exemplos: Cisco StackWise, Juniper Virtual Chassis. Stack link: até 480 Gbps. Stack de 8 switches = 1 switch lógico com N × portas. Diferente de chassis modular."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Difícil",
    "question": "O que é port mirroring (SPAN) e para que é usado?",
    "options": [
      "Copia tráfego de uma porta para outra para análise e monitoramento",
      "Bloqueia portas não utilizadas do switch",
      "Duplica a largura de banda de uma porta",
      "Espelha a configuração entre switches"
    ],
    "correctIndex": 0,
    "explanation": "Port mirroring (SPAN — Switched Port Analyzer) copia todo o tráfego de uma ou mais portas (source) para uma porta de destino (monitor), onde um analisador (Wireshark, IDS) captura os pacotes. Não afeta o tráfego original.",
    "example": "SPAN: local (mesmo switch). RSPAN: entre switches (via VLAN). ERSPAN: encapsula em GRE para análise remota via IP. Usado para troubleshooting, IDS/IPS e compliance."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Difícil",
    "question": "O que é um chassis modular de switch e como difere de stacking?",
    "options": [
      "Switch com slots para módulos intercambiáveis; stacking une switches separados",
      "São a mesma coisa com nomes diferentes",
      "Chassis modular é mais barato que stacking",
      "Stacking usa fibra e chassis usa cobre"
    ],
    "correctIndex": 0,
    "explanation": "Chassis modular: um único equipamento com backplane de alta velocidade e slots para line cards, supervisores e fontes redundâncias (ex: Cisco Catalyst 9400). Stacking: múltiplos switches independentes conectados por cabos stack formando uma unidade lógica.",
    "example": "Chassis: Cisco 9400/9600, Juniper EX9200. Alto custo, alta resiliência, backplane dedicado. Stacking: Cisco 9200/9300 StackWise. Menor custo, flexibilidade, mas depende de cabos stack."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Difícil",
    "question": "O que é SDN (Software Defined Networking)?",
    "options": [
      "Arquitetura que separa o plano de controle do plano de dados, centralizando a inteligência em um controlador",
      "Rede exclusivamente por software, sem hardware",
      "Protocolo de roteamento para data centers",
      "VPN baseada em nuvem"
    ],
    "correctIndex": 0,
    "explanation": "SDN desacopla o plano de controle (decisões de encaminhamento) do plano de dados (encaminhamento físico). Um controlador central programa os switches via protocolos como OpenFlow. Permite automação, agilidade e visão global da rede.",
    "example": "Tradicional: cada switch decide localmente. SDN: controlador central decide, switches só encaminham. Protocolos: OpenFlow, NETCONF, gRPC. Controladores: OpenDaylight, ONOS, VMware NSX."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Difícil",
    "question": "O que é LACP (Link Aggregation Control Protocol) e como funciona?",
    "options": [
      "Protocolo IEEE 802.3ad que negocia automaticamente a criação de links agregados entre switches",
      "Protocolo de roteamento dinâmico",
      "Método de autenticação 802.1X",
      "Protocolo de transferência de arquivos"
    ],
    "correctIndex": 0,
    "explanation": "LACP (IEEE 802.3ad) negocia automaticamente a agregação de links entre switches. Cada lado envia LACPDUs para identificar links compatíveis e formar o port-channel. Modos: active (inicia negociação) e passive (aguarda).",
    "example": "LACP modos: active-active ou active-passive (um lado deve ser active). PAgP (Cisco): desirable-desirable ou desirable-auto. LACP é padrão IEEE (interoperável); PAgP é Cisco proprietário."
  },
  {
    "id": "rede-de-computadores__Equipamentos de Rede__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Equipamentos de Rede",
    "difficulty": "Difícil",
    "question": "Como funciona o mecanismo de ECMP (Equal-Cost Multi-Path) e quais algoritmos de balanceamento são usados?",
    "options": [
      "ECMP instala múltiplas rotas de mesmo custo na tabela de roteamento; balanceamento por per-packet, per-flow (5-tuple hash) ou per-destination; per-flow é o default para manter ordering TCP",
      "ECMP ativo somente com OSPF; BGP não suporta multi-path por padrão",
      "ECMP usa STP para bloquear caminhos redundantes em IPv6",
      "Somente 2 caminhos simultâneos; não há limite de sub três"
    ],
    "correctIndex": 0,
    "explanation": "ECMP: roteadores com OSPF/EIGRP/BGP multi-path instalam N rotas de custo idêntico. Algoritmos: per-packet (round-robin, pode reordenar — problema TCP), per-destination (hash IP src/dst — simple), per-flow (hash 5-tuple: src/dst IP+port+proto — evita reordenamento, default Linux/Cisco). Cisco EIGRP: variancea permite ECMP e desbalancedo (unequal-cost).",
    "example": "Linux ECMP: ip route add via + routing table com nexthops. BGP multipath: 'maximum-paths 4'. Hashing assimetria: flows concentrados num caminho (elephant flows). ECMP com LAG (Link Aggregation): nível de enlace, ECMP em nível de rede. SD-WAN: ECMP por políticas de aplicação (latency, jitter)."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Fácil",
    "question": "Qual é a função principal de um firewall em uma rede?",
    "options": [
      "Filtrar tráfego de rede com base em regras de segurança",
      "Acelerar a conexão com a internet",
      "Atribuir endereços IP",
      "Converter nomes de domínio em IPs"
    ],
    "correctIndex": 0,
    "explanation": "O firewall atua como barreira entre redes (ex: interna e internet), permitindo ou bloqueando tráfego com base em regras de segurança. Pode filtrar por IP, porta, protocolo, estado da conexão ou conteúdo, dependendo do tipo.",
    "example": "Analogia: porteiro de prédio que verifica credenciais. Pode ser: hardware (appliance dedicado), software (Windows Firewall, iptables) ou cloud-based (WAF). Sem firewall, todos os serviços ficam expostos."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Fácil",
    "question": "O que é uma DMZ (Zona Desmilitarizada) em segurança de redes?",
    "options": [
      "Rede intermediária entre a rede interna e a internet onde ficam servidores públicos",
      "Área física onde ficam os servidores",
      "Tipo de firewall mais seguro",
      "Protocolo de criptografia"
    ],
    "correctIndex": 0,
    "explanation": "A DMZ é uma sub-rede isolada entre a rede interna e a internet. Servidores acessíveis externamente (web, email, DNS) ficam na DMZ. Se comprometidos, o atacante não acessa a rede interna diretamente.",
    "example": "Topologia: Internet → Firewall → DMZ (servidores públicos) → Firewall → Rede interna. Com duas zonas de firewall, a DMZ tem acesso controlado de ambos os lados."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Fácil",
    "question": "O que é um proxy server (servidor proxy)?",
    "options": [
      "Intermediário entre clientes e a internet que filtra e armazena conteúdo em cache",
      "Servidor que atribui endereços IP",
      "Equipamento que interliga redes diferentes",
      "Software que criptografa todo o tráfego"
    ],
    "correctIndex": 0,
    "explanation": "O proxy atua como intermediário: clientes enviam requisições ao proxy, que as encaminha à internet. Vantagens: cache (acelera acessos repetidos), filtragem de conteúdo, anonimato (esconde IP do cliente) e log de acessos.",
    "example": "Exemplo: empresa usa Squid Proxy para bloquear redes sociais e cachear atualizações. Proxy pode ser configurado no navegador ou ser transparente (intercepta na rede). Porta padrão Squid: 3128."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Fácil",
    "question": "Qual a política padrão de firewall considerada mais segura?",
    "options": [
      "Negar tudo (deny all) e liberar apenas o necessário",
      "Permitir tudo (allow all) e bloquear o perigoso",
      "Bloquear somente portas conhecidas",
      "Permitir tráfego interno e bloquear externo"
    ],
    "correctIndex": 0,
    "explanation": "A política 'deny all' (whitelist) bloqueia TUDO por padrão e permite apenas tráfego autorizado explicitamente. É mais segura que 'allow all' (blacklist), que permite tudo e tenta bloquear ameaças conhecidas — deixando brechas.",
    "example": "Deny all: regra DENY ALL no final. Administrador cria regras ALLOW específicas (ex: permitir porta 443 para HTTPS). Princípio do menor privilégio aplicado a redes."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Fácil",
    "question": "Em que camadas do modelo OSI opera um firewall de filtragem de pacotes básico?",
    "options": [
      "Camada 3 (Rede) e Camada 4 (Transporte)",
      "Apenas Camada 7 (Aplicação)",
      "Camada 1 (Física) e Camada 2 (Enlace)",
      "Todas as 7 camadas"
    ],
    "correctIndex": 0,
    "explanation": "Firewall de filtragem de pacotes analisa cabeçalhos das Camadas 3 e 4: endereços IP origem/destino (L3), portas e protocolo TCP/UDP (L4). Não inspeciona o conteúdo dos dados (payload). Exemplo clássico: ACLs em roteadores.",
    "example": "Packet filter (L3/L4) → Stateful (L3/L4 + estado) → Application Gateway/Proxy (L7) → NGFW (L3-L7 + DPI + IPS). Quanto mais alto na camada, mais contexto e mais overhead."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Fácil",
    "question": "O que é uma regra de firewall?",
    "options": [
      "Instrução que define se o tráfego deve ser permitido ou bloqueado com base em critérios",
      "Programa que detecta vírus",
      "Configuração de velocidade da rede",
      "Protocolo de criptografia"
    ],
    "correctIndex": 0,
    "explanation": "Uma regra de firewall define critérios (IP origem/destino, porta, protocolo) e uma ação (permitir/bloquear/registrar). São avaliadas em ordem (top-down): a primeira regra que combinar é aplicada. A última regra geralmente é 'deny all'.",
    "example": "Exemplo: ALLOW TCP src=192.168.1.0/24 dst=ANY port=443 (permite HTTPS da LAN). Regras são avaliadas na ordem: primeira que combina ganha. Regra final: DENY ALL (bloqueia o restante)."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre firewall de hardware e firewall de software?",
    "options": [
      "Hardware: appliance dedicado. Software: programa instalado no sistema operacional",
      "São a mesma coisa",
      "Hardware só funciona com Linux",
      "Software é sempre mais seguro"
    ],
    "correctIndex": 0,
    "explanation": "Firewall de hardware: appliance dedicado (ex: Fortinet, Palo Alto, Cisco ASA) com SO próprio otimizado. Firewall de software: programa instalado no OS (ex: iptables/nftables no Linux, Windows Firewall). Ambos podem coexistir em defesa em profundidade.",
    "example": "Hardware: alto desempenho, dedicado, custo elevado. Software: flexível, custo menor, compartilha recursos do host. Empresas usam ambos: appliance na borda + host firewall nos servidores."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre firewall stateless e stateful?",
    "options": [
      "Stateless: filtra pacote a pacote por regras (src/dst IP+porta) sem rastrear conexões; Stateful: rastreia o estado da conexão (SYN/SYN-ACK/established) permitindo retorno automático",
      "Stateful bloqueia mais tráfego; stateless é mais permissivo por padrão",
      "São idênticos; 'stateful' é apenas o nome comercial de firewalls de nova geração",
      "Stateless examina conteúdo do payload; stateful apenas cabeçalhos IP"
    ],
    "correctIndex": 0,
    "explanation": "Stateless (ACL simples): regra srcIP/dstIP/dstPort/protocol. Retorno: precisa de regra explícita para established. Stateful: Connection Tracking Table (CTT) guarda estado (NEW, ESTABLISHED, RELATED, INVALID). Retorno automático: conexões established são permitidas sem regra explícita. NGFW: adiciona inspeção Layer 7 (DPI).",
    "example": "iptables Linux: stateful com conntrack. 'iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT' permite retorno. ACL Cisco: sem estado. ASA, Palo Alto: stateful. Stateful inspection: Checkpoint (1993). UDP, ICMP: stateful ainda rastreia 'pseudo-conexoes' por timeout."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Médio__1",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Médio",
    "question": "Qual a diferença entre um firewall stateless e um stateful?",
    "options": [
      "Stateful rastreia o estado da conexão; stateless analisa pacotes individualmente",
      "Stateless é mais seguro que stateful",
      "Stateful só funciona na Camada 7",
      "Não há diferença prática"
    ],
    "correctIndex": 0,
    "explanation": "Stateless: analisa cada pacote isoladamente (IP/porta origem/destino). Stateful: mantém uma tabela de estados de conexão, sabendo se um pacote faz parte de uma sessão já estabelecida. Stateful é mais seguro pois impede pacotes forjados que não pertencem a conexões legítimas.",
    "example": "Stateless: regra 'permitir porta 80' permite QUALQUER pacote na porta 80. Stateful: só permite respostas de conexões que VOCÊ iniciou. Exemplo: iptables com módulo conntrack (state ESTABLISHED,RELATED)."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Médio__2",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Médio",
    "question": "O que é um firewall de próxima geração (NGFW — Next-Generation Firewall)?",
    "options": [
      "Firewall que integra inspeção profunda de pacotes, IPS e controle de aplicações",
      "Firewall com mais portas de rede",
      "Versão atualizada do iptables",
      "Firewall exclusivo para redes IPv6"
    ],
    "correctIndex": 0,
    "explanation": "NGFW combina firewall stateful com funcionalidades avançadas: DPI (Deep Packet Inspection), IPS, controle de aplicações (identifica apps independente da porta), filtragem de URL e integração com threat intelligence.",
    "example": "Firewall tradicional: filtra por IP/porta. NGFW: identifica a aplicação (ex: bloqueia WhatsApp na porta 443), inspeciona conteúdo, detecta malware. Exemplos: Palo Alto, Fortinet FortiGate, Cisco Firepower."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Médio__3",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Médio",
    "question": "Qual a diferença entre um IDS e um IPS?",
    "options": [
      "IDS detecta e alerta sobre ataques; IPS detecta e bloqueia automaticamente",
      "IDS bloqueia e IPS apenas detecta",
      "Ambos são sinônimos",
      "IDS é hardware e IPS é software"
    ],
    "correctIndex": 0,
    "explanation": "IDS (Intrusion Detection System): monitora o tráfego e gera alertas quando detecta atividades suspeitas, mas não bloqueia. IPS (Intrusion Prevention System): monitora E bloqueia automaticamente tráfego malicioso em tempo real, posicionado inline.",
    "example": "IDS: passivo (cópia do tráfego via SPAN/TAP), apenas alerta. IPS: inline (tráfego passa por ele), bloqueia em tempo real. Tipos: NIDS/NIPS (rede) e HIDS/HIPS (host). Exemplos: Snort, Suricata."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Médio__4",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Médio",
    "question": "O que é um WAF (Web Application Firewall)?",
    "options": [
      "Firewall de camada 7 que protege aplicações web contra ataques como SQL Injection e XSS",
      "Firewall de rede que bloqueia IPs maliciosos",
      "Antivírus para servidores web",
      "Software que criptografa páginas web"
    ],
    "correctIndex": 0,
    "explanation": "WAF opera na Camada 7 (Aplicação), analisando requisições HTTP/HTTPS. Protege contra OWASP Top 10: SQL Injection, XSS, CSRF, etc. Pode ser appliance (hardware), software (ModSecurity) ou cloud (AWS WAF, Cloudflare).",
    "example": "WAF vs Firewall de rede: firewall de rede filtra L3/L4 (IP/porta). WAF filtra L7 (parâmetros HTTP, cookies, headers). Ambos são complementares. WAF cloud: protege sem alteração de infra."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Médio__5",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Médio",
    "question": "O que é o conceito de 'security zones' em firewalls modernos?",
    "options": [
      "Segmentação lógica da rede em zonas com diferentes níveis de confiança",
      "Criptografia diferenciada por segmento de rede",
      "Backup automático de regras de firewall",
      "Virtualização do hardware do firewall"
    ],
    "correctIndex": 0,
    "explanation": "Security zones agrupam interfaces/sub-redes com o mesmo nível de confiança. Exemplos clássicos: Trust (interna), Untrust (internet), DMZ (servidores públicos). Políticas são definidas entre zonas (inter-zone), não apenas por IP/porta.",
    "example": "Cisco ASA: security levels (0-100). Palo Alto: zone-based policies. Tráfego Trust→Untrust: geralmente permitido. Untrust→Trust: bloqueado por padrão. Intra-zone: mesmo nível, geralmente livre."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Médio__6",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Médio",
    "question": "O que é DPI (Deep Packet Inspection)?",
    "options": [
      "Técnica que analisa o conteúdo (payload) dos pacotes, não apenas os cabeçalhos",
      "Método que verifica apenas endereços IP",
      "Protocolo de roteamento avançado",
      "Criptografia de pacotes em trânsito"
    ],
    "correctIndex": 0,
    "explanation": "DPI examina o conteúdo (payload) dos pacotes além dos cabeçalhos L3/L4. Permite identificar aplicações (YouTube, BitTorrent), detectar malware, filtrar conteúdo e aplicar políticas granulares. É a base dos NGFWs.",
    "example": "Sem DPI: vê apenas IP + porta (ex: porta 443 = HTTPS). Com DPI: identifica QUE aplicação usa a porta 443 (Netflix? VPN? WhatsApp?). Trade-off: mais segurança vs mais processamento e questões de privacidade."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Médio__7",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Médio",
    "question": "O que é filtragem de URL em firewalls e proxies?",
    "options": [
      "Bloqueio ou liberação de acesso a sites com base em categorias ou URLs específicas",
      "Criptografia de endereços web",
      "Redirect automático de URLs",
      "Cache de páginas web"
    ],
    "correctIndex": 0,
    "explanation": "A filtragem de URL permite bloquear ou permitir acesso a sites baseando-se em categorias (redes sociais, jogos, adulto) ou URLs específicas. Bancos de dados de URLs categorizam milhões de sites. Pode ser feita no proxy, NGFW ou DNS.",
    "example": "Categorias: 'Redes Sociais' (bloquear), 'Bancário' (permitir), 'Malware' (bloquear). Implementação: proxy (Squid + SquidGuard), NGFW (Fortinet, Palo Alto), DNS (OpenDNS, Pi-hole)."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Médio__8",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Médio",
    "question": "O que é Web Application Firewall (WAF) e como difere de NGFW?",
    "options": [
      "WAF: inspeção de camada 7 HTTP/HTTPS focada em ataques de aplicação web (SQLi, XSS, OWASP Top 10); NGFW: inspeção multicamada (L3-L7) de qualquer aplicação, IDS/IPS, URL filtering",
      "WAF e NGFW são sinônimos; diferem apenas no fabricante",
      "WAF opera na camada 4; NGFW na camada 7",
      "NGFW substitui completamente o WAF; não há razão para usar ambos"
    ],
    "correctIndex": 0,
    "explanation": "WAF: especialista em HTTP. Inspeção de body, headers HTTP, regex contra SQL injection, XSS, path traversal, CSRF. Regras OWASP Core Rule Set (CRS). Modo: proxy reverso, inline, sniffing passivo. NGFW: Palo Alto, Fortinet — app-ID, user-ID, content-ID. WAF: Cloudflare WAF, AWS WAF, ModSecurity, F5 BIG-IP ASM. Deploy conjunto: NGFW no perímetro, WAF na DMZ para cada aplicação web.",
    "example": "ModSecurity + OWASP CRS: WAF open-source. Rate limiting: WAF pode bloquear DDoS HTTP (flood). False positives: WAF em modo log antes de blocking. NGFW: não inspeciona payload HTTP com profundidade de WAF. PCI-DSS: exige WAF para ambientes card data (ou code review). Bot management: CAPTCHA, fingerprinting."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Difícil",
    "question": "O que é um proxy reverso e como ele difere de um proxy direto (forward proxy)?",
    "options": [
      "Proxy reverso fica na frente dos servidores; proxy direto fica na frente dos clientes",
      "São termos sinônimos",
      "Proxy reverso funciona apenas com HTTPS",
      "Proxy direto é mais seguro que o reverso"
    ],
    "correctIndex": 0,
    "explanation": "Forward proxy: intermediário entre clientes internos e a internet (ex: Squid). Clientes sabem que usam proxy. Proxy reverso: intermediário entre a internet e servidores internos (ex: Nginx, HAProxy). Clientes não sabem que existe proxy — pensam estar acessando o servidor diretamente. Oferece load balancing, cache, SSL termination e proteção dos servidores.",
    "example": "Forward: Cliente → Proxy → Internet (esconde o cliente). Reverse: Internet → Proxy Reverso → Servidores (esconde os servidores). Nginx como reverse proxy: balanceia carga entre vários servidores backend."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Difícil",
    "question": "O que é SSL/TLS Inspection em firewalls e quais suas implicações?",
    "options": [
      "Firewall decifra, inspeciona e recifra tráfego HTTPS; requer certificado CA nos clientes",
      "Bloqueio total de tráfego HTTPS",
      "Monitoramento apenas de cabeçalhos sem decifrar conteúdo",
      "Técnica para acelerar conexões HTTPS"
    ],
    "correctIndex": 0,
    "explanation": "SSL Inspection: o firewall atua como MitM legítimo — decifra o tráfego HTTPS, inspeciona o conteúdo (malware, DLP) e recifra antes de enviar ao destino. Requer que a CA interna seja confiável nos clientes. Levanta questões de privacidade.",
    "example": "Fluxo: Cliente ↔ Firewall (CA interna) ↔ Servidor (certificado real). Sem SSL Inspection: vê apenas IP/SNI. Com: vê todo o conteúdo. Exceções comuns: sites bancários, saúde (compliance)."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Difícil",
    "question": "Em um proxy transparente, como o tráfego é interceptado sem configuração nos clientes?",
    "options": [
      "O roteador/switch redireciona automaticamente o tráfego para o proxy via WCCP ou iptables",
      "O proxy envia broadcast pedindo para ser usado",
      "Os clientes detectam o proxy via DNS",
      "O proxy altera a tabela MAC do switch"
    ],
    "correctIndex": 0,
    "explanation": "Proxy transparente intercepta tráfego sem configuração no cliente. O roteador/switch redireciona tráfego HTTP (porta 80) para o proxy usando WCCP, policy-based routing ou iptables/REDIRECT. HTTPS requer SSL bump.",
    "example": "Linux: iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 3128 (Squid). Cisco WCCP: redirecionamento automático. Proxy transparente + HTTPS = precisa SSL Inspection."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Difícil",
    "question": "O que é micro-segmentação de rede e como se relaciona com firewalls?",
    "options": [
      "Aplicar regras granulares de firewall por workload/aplicação, não apenas por segmento de rede",
      "Dividir a rede em VLANs menores",
      "Usar múltiplos firewalls físicos em série",
      "Segmentar apenas o tráfego de saída"
    ],
    "correctIndex": 0,
    "explanation": "Micro-segmentação aplica políticas de segurança por carga de trabalho individual (VM, container), não apenas por sub-rede. Cada workload tem regras específicas. Pilar do Zero Trust: nunca confie, sempre verifique — mesmo tráfego leste-oeste (interno).",
    "example": "Tradicional: firewall no perímetro (norte-sul). Micro-seg: firewall distribuído internamente (leste-oeste). Ferramentas: VMware NSX, Cisco ACI, Illumio. Impede movimentação lateral do atacante."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Difícil",
    "question": "O que é um UTM (Unified Threat Management)?",
    "options": [
      "Dispositivo que integra firewall, antivírus, IDS/IPS, VPN e filtro de conteúdo em um só",
      "Software exclusivo para gestão de logs",
      "Tipo avançado de switch gerenciável",
      "Protocolo unificado de monitoramento"
    ],
    "correctIndex": 0,
    "explanation": "UTM consolida múltiplas funções de segurança em um único appliance: firewall stateful, antivírus/antimalware, IDS/IPS, VPN, filtragem de URL/conteúdo, antispam. Ideal para PMEs. Desvantagem: ponto único de falha, menor performance que soluções dedicadas.",
    "example": "UTM vs NGFW: UTM foca em PMEs (tudo-em-um). NGFW foca em empresas grandes (firewall + DPI + app control). Na prática, a linha entre eles está borrada. Exemplos UTM: Fortinet, Sophos, pfSense."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Difícil",
    "question": "O que é Zero Trust Architecture e como se relaciona com firewalls?",
    "options": [
      "Modelo que nunca confia em nenhum tráfego por padrão, verificando continuamente cada acesso",
      "Firewall que bloqueia todo o tráfego",
      "Rede sem firewall",
      "Tipo de VPN sem autenticação"
    ],
    "correctIndex": 0,
    "explanation": "Zero Trust: 'nunca confie, sempre verifique'. Nenhum usuário, dispositivo ou rede é automaticamente confiável — nem tráfego interno. Requer autenticação contínua, micro-segmentação e menor privilégio. Firewalls evoluem para suportar este modelo.",
    "example": "Tradicional: 'confie na LAN, desconfie da internet' (castelo e fosso). Zero Trust: desconfie de TUDO. Pilares: identidade forte, micro-segmentação, least privilege, MFA, monitoramento contínuo. NIST SP 800-207."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Difícil",
    "question": "O que é um Application Layer Gateway (ALG) em firewalls?",
    "options": [
      "Firewall L7 que entende protocolos de aplicação específicos e inspeciona seu conteúdo",
      "Firewall básico que filtra por IP",
      "Proxy transparente para DNS",
      "Protocolo de agregação de links"
    ],
    "correctIndex": 0,
    "explanation": "ALG (Application Layer Gateway) opera na Camada 7 e compreende protocolos específicos (FTP, SIP, H.323). Pode modificar o payload para permitir que protocolos problemáticos com NAT funcionem (ex: FTP ativo através de NAT).",
    "example": "FTP ativo: servidor abre conexão de volta ao cliente (problema com NAT/firewall). ALG para FTP: firewall entende o comando PORT e abre a porta dinâmica automaticamente. ALG SIP: ajusta endereços SDP em VoIP."
  },
  {
    "id": "rede-de-computadores__Firewall e Proxy__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Firewall e Proxy",
    "difficulty": "Difícil",
    "question": "Como funciona o Transparent Proxy e quando usar SSL Inspection (MITM) corporativo?",
    "options": [
      "Transparent Proxy intercepta TCP 80/443 sem configurar cliente; SSL Inspection re-assina certificados com CA corporativa instalado nos clientes; permite inspeção de conteúdo criptografado",
      "Transparent Proxy só funciona para HTTP; HTTPS exige proxy explícito com autenticação",
      "SSL Inspection quebra certificate pinning sem impacto em aplicações móveis",
      "Transparent Proxy requer configuração manual em cada cliente"
    ],
    "correctIndex": 0,
    "explanation": "Transparent Proxy: redirecionamento por política no firewall (iptables REDIRECT ou policy route). Cliente não sabe do proxy. SSL/TLS Inspection (MITM): proxy termina TLS com cliente (CA corporativa), re-estabelece TLS com servidor original. Inspeção de conteúdo (DLP, AV) em tráfego criptografado. Compliance: LGPD, regras de privacidade.",
    "example": "Bypass por Certificate Pinning: apps móveis com pinning rejeitam CA corp. Solução: exemption list (banking apps). CA corp instalada via MDM/GPO nos endpoints gerenciados. Squid+SSL_bump: proxy open-source com SSL inspection. Categorização de URL: Brightcloud, Webroot. DLP: identifica uploads de dados sensíveis."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Fácil",
    "question": "Quantas camadas tem o modelo OSI?",
    "options": [
      "7",
      "4",
      "5",
      "6"
    ],
    "correctIndex": 0,
    "explanation": "O modelo OSI (Open Systems Interconnection) tem 7 camadas: 1-Física, 2-Enlace de Dados, 3-Rede, 4-Transporte, 5-Sessão, 6-Apresentação, 7-Aplicação. É um modelo de referência teórico criado pela ISO para padronizar a comunicação em rede.",
    "example": "Mnemônico de baixo para cima: 'Filhos Educados Raramente Trazem Sensações Pouco Agradáveis' → Física, Enlace, Rede, Transporte, Sessão, Apresentação, Aplicação."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Fácil",
    "question": "No modelo TCP/IP, quantas camadas existem e quais são?",
    "options": [
      "4 camadas: Acesso à Rede, Internet, Transporte e Aplicação",
      "7 camadas, iguais ao modelo OSI",
      "5 camadas: Física, Enlace, Rede, Transporte e Aplicação",
      "3 camadas: Rede, Transporte e Aplicação"
    ],
    "correctIndex": 0,
    "explanation": "O modelo TCP/IP tem 4 camadas: 1) Acesso à Rede (Link) = Física+Enlace do OSI. 2) Internet = Rede (IP). 3) Transporte = TCP, UDP. 4) Aplicação = Sessão+Apresentação+Aplicação do OSI.",
    "example": "OSI (7 camadas, teórico) vs TCP/IP (4 camadas, prático). OSI 1-2 → Acesso. OSI 3 → Internet. OSI 4 → Transporte. OSI 5-7 → Aplicação. Na prática, TCP/IP é o modelo implementado."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Fácil",
    "question": "Qual camada do modelo OSI é responsável pelo endereçamento IP?",
    "options": [
      "Camada 3 — Rede",
      "Camada 2 — Enlace",
      "Camada 4 — Transporte",
      "Camada 7 — Aplicação"
    ],
    "correctIndex": 0,
    "explanation": "A Camada 3 (Rede) é responsável pelo endereçamento lógico (IP), roteamento de pacotes entre redes e determinação do melhor caminho. Protocolos: IP, ICMP, OSPF, BGP.",
    "example": "Camada 3: endereço IP (lógico, mutável). Camada 2: endereço MAC (físico, fixo). Roteadores operam na Camada 3. Switches operam na Camada 2. Switch L3 opera em ambas."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Fácil",
    "question": "Como é chamado o PDU (unidade de dados) da Camada 2 do modelo OSI?",
    "options": [
      "Frame (quadro)",
      "Pacote",
      "Segmento",
      "Datagrama"
    ],
    "correctIndex": 0,
    "explanation": "Cada camada tem seu PDU: Camada 4 = Segmento (TCP) ou Datagrama (UDP). Camada 3 = Pacote. Camada 2 = Frame (quadro). Camada 1 = Bits. O frame encapsula o pacote adicionando cabeçalho MAC e trailer (FCS).",
    "example": "Frame Ethernet: Preâmbulo (8B) + MAC destino (6B) + MAC origem (6B) + Tipo/Len (2B) + Payload (46–1500B) + FCS (4B). Tamanho total: 64–1518 bytes."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Fácil",
    "question": "Em qual camada do modelo OSI opera o protocolo HTTP?",
    "options": [
      "Camada 7 — Aplicação",
      "Camada 4 — Transporte",
      "Camada 3 — Rede",
      "Camada 6 — Apresentação"
    ],
    "correctIndex": 0,
    "explanation": "HTTP opera na Camada 7 (Aplicação), que interage diretamente com o usuário/software. Outros protocolos L7: HTTPS, FTP, SMTP, DNS, SSH, Telnet, SNMP. No TCP/IP, corresponde à camada de Aplicação (que engloba L5-L7 do OSI).",
    "example": "Protocolos por camada OSI: L7: HTTP, FTP, DNS, SMTP. L6: SSL/TLS (debate), JPEG, MPEG. L5: NetBIOS, RPC. L4: TCP, UDP. L3: IP, ICMP, OSPF. L2: Ethernet, Wi-Fi. L1: RS-232, DSL."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Fácil",
    "question": "Qual camada do modelo OSI é responsável por endereços MAC?",
    "options": [
      "Camada 2 — Enlace de Dados",
      "Camada 3 — Rede",
      "Camada 1 — Física",
      "Camada 4 — Transporte"
    ],
    "correctIndex": 0,
    "explanation": "A Camada 2 (Enlace de Dados) usa endereços MAC (Media Access Control) para encaminhar quadros dentro da rede local. O MAC é um endereço físico de 48 bits gravado na placa de rede (NIC), ex: AA:BB:CC:DD:EE:FF.",
    "example": "Camada 2: MAC (físico, 48 bits, fixo na NIC). Camada 3: IP (lógico, 32/128 bits, atribuído). Switch usa MAC. Roteador usa IP. Para enviar dados, o host precisa de ambos (MAC local + IP destino)."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Fácil",
    "question": "Qual protocolo de transporte é orientado a conexão?",
    "options": [
      "TCP",
      "UDP",
      "ICMP",
      "ARP"
    ],
    "correctIndex": 0,
    "explanation": "TCP (Transmission Control Protocol) é orientado a conexão: estabelece uma conexão (three-way handshake) antes de transmitir dados, garantindo entrega confiável, ordem correta e retransmissão em caso de perda.",
    "example": "TCP: confiável, orientado a conexão, controle de fluxo e congestionamento. UDP: não confiável, sem conexão, mais rápido, sem retransmissão. TCP: HTTP, FTP, SSH. UDP: DNS, VoIP, streaming."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Fácil",
    "question": "Qual a função da camada de Transporte no modelo OSI?",
    "options": [
      "Prover comunicação fim-a-fim entre processos, controle de fluxo, controle de erros e multiplexacao por portas (TCP e UDP)",
      "Definir o endereçamento físico (MAC) e acesso ao meio",
      "Roteamento de pacotes entre redes diferentes por endereço IP",
      "Estabelecer sessões e controle de diálogo entre aplicações"
    ],
    "correctIndex": 0,
    "explanation": "Camada 4 (Transporte): TCP (confiável, orientado a conexão, controle de congestionamento) e UDP (não confiável, sem conexão, mais rápido). Portas: multiplexam aplicações no mesmo host. Segmentos TCP: número de seq, ACK, janelas, flags (SYN, FIN, RST, ACK). Cama 3: IP (roteamento). Camada 2: Ethernet/MAC.",
    "example": "TCP three-way handshake: SYN, SYN-ACK, ACK. Four-way termination: FIN, ACK, FIN, ACK. Portas well-known: HTTP 80, HTTPS 443, SSH 22, DNS 53. Half-open connections: SYN flood ataque (mitigation: SYN cookies). UDP: DNS, DHCP, TFTP, VoIP (RTP), streaming."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Médio__1",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Médio",
    "question": "No modelo TCP/IP, a camada de Transporte trabalha com quais dois protocolos principais?",
    "options": [
      "TCP e UDP",
      "HTTP e FTP",
      "IP e ICMP",
      "ARP e RARP"
    ],
    "correctIndex": 0,
    "explanation": "TCP (Transmission Control Protocol): orientado a conexão, confiável, com controle de fluxo e retransmissão. UDP (User Datagram Protocol): sem conexão, não confiável, mais rápido. Ambos operam na camada de Transporte do modelo TCP/IP.",
    "example": "TCP: usado em HTTP, FTP, SSH, email — quando confiabilidade importa. UDP: usado em DNS, VoIP, streaming, games — quando velocidade importa. TCP usa three-way handshake (SYN → SYN-ACK → ACK)."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Médio__2",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Médio",
    "question": "Qual protocolo da camada de rede envia mensagens de erro e diagnóstico?",
    "options": [
      "ICMP (Internet Control Message Protocol)",
      "TCP (Transmission Control Protocol)",
      "ARP (Address Resolution Protocol)",
      "HTTP (HyperText Transfer Protocol)"
    ],
    "correctIndex": 0,
    "explanation": "ICMP é usado para mensagens de controle e erro: 'Destination Unreachable' (inacessível), 'Time Exceeded' (TTL expirou, usado pelo traceroute), 'Echo Request/Reply' (usado pelo ping).",
    "example": "Ping: ICMP Echo Request (tipo 8) → Echo Reply (tipo 0). Traceroute: TTL incrementando → ICMP Time Exceeded (tipo 11). Tipos comuns: 0, 3, 5, 8, 11."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Médio__3",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Médio",
    "question": "Qual é a função do three-way handshake do TCP?",
    "options": [
      "Estabelecer uma conexão confiável entre dois hosts antes da transmissão de dados",
      "Encerrar uma conexão TCP",
      "Verificar a identidade dos hosts via certificados",
      "Dividir os dados em segmentos"
    ],
    "correctIndex": 0,
    "explanation": "Three-way handshake estabelece conexão TCP: 1) SYN: cliente envia SYN. 2) SYN-ACK: servidor responde. 3) ACK: cliente confirma. Após isso, dados podem fluir. Encerramento usa four-way handshake (FIN).",
    "example": "SYN (seq=100) → SYN-ACK (seq=300, ack=101) → ACK (seq=101, ack=301). SYN flood attack: enviar milhares de SYN sem completar o handshake, esgotando recursos do servidor."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Médio__4",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Médio",
    "question": "O que é ARP (Address Resolution Protocol) e para que serve?",
    "options": [
      "Protocolo que resolve endereço IP para endereço MAC na rede local",
      "Protocolo que resolve nomes de domínio para IPs",
      "Protocolo de roteamento dinâmico",
      "Protocolo de criptografia de tráfego"
    ],
    "correctIndex": 0,
    "explanation": "ARP mapeia IP → MAC na rede local. Quando um host quer enviar dados a outro IP na mesma sub-rede, envia ARP Request (broadcast) perguntando 'quem tem esse IP?'. O dono responde com ARP Reply (unicast) informando seu MAC.",
    "example": "ARP Request: broadcast (FF:FF:FF:FF:FF:FF) → 'Quem tem 192.168.1.5?' ARP Reply: unicast → '192.168.1.5 está em AA:BB:CC:DD:EE:FF'. Cache ARP: armazena mapeamentos. ARP spoofing: ataque MitM."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Médio__5",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Médio",
    "question": "Qual é a função da Camada 5 (Sessão) do modelo OSI?",
    "options": [
      "Estabelecer, gerenciar e encerrar sessões de comunicação entre aplicações",
      "Criptografar os dados transmitidos",
      "Definir o endereçamento lógico dos hosts",
      "Converter dados entre formatos diferentes"
    ],
    "correctIndex": 0,
    "explanation": "A Camada 5 (Sessão) gerencia diálogos entre aplicações: estabelece, mantém e encerra sessões. Controla modos de comunicação (simplex, half-duplex, full-duplex) e sincronização com checkpoints. Exemplos: NetBIOS, RPC, sessões SIP.",
    "example": "Na prática, muitas funções de L5/L6 são absorvidas por protocolos de L7 no TCP/IP. Por isso o TCP/IP funde L5+L6+L7 em uma camada só (Aplicação). L5 é mais conceitual que implementado separadamente."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Médio__6",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Médio",
    "question": "O que é o TTL (Time to Live) em um pacote IP?",
    "options": [
      "Contador que limita o número de roteadores (hops) por onde o pacote pode passar",
      "Tempo máximo de conexão TCP",
      "Tamanho máximo do pacote",
      "Tempo de validade do cache DNS"
    ],
    "correctIndex": 0,
    "explanation": "TTL é decrementado a cada roteador (hop). Se chegar a 0, o pacote é descartado e um ICMP Time Exceeded é enviado. Previne loops infinitos. Valor inicial comum: 64 (Linux), 128 (Windows), 255 (roteadores).",
    "example": "TTL inicial: 64 (Linux), 128 (Windows). A cada hop: TTL−1. TTL = 0 → descartado + ICMP Time Exceeded. Traceroute usa TTL incremental (1, 2, 3...) para descobrir cada roteador no caminho."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Médio__7",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Médio",
    "question": "Qual número de porta TCP é padrão do HTTPS?",
    "options": [
      "443",
      "80",
      "8080",
      "22"
    ],
    "correctIndex": 0,
    "explanation": "HTTPS (HTTP Secure) usa a porta TCP 443 por padrão. HTTP usa porta 80. Outras portas comuns: SSH=22, FTP=21, SMTP=25, DNS=53, Telnet=23, POP3=110, IMAP=143.",
    "example": "Well-known ports (0-1023): HTTP=80, HTTPS=443, SSH=22, DNS=53, FTP=21, SMTP=25. Registered (1024-49151): 3306=MySQL, 5432=PostgreSQL. Dynamic (49152-65535): portas efêmeras."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Médio__8",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Médio",
    "question": "No modelo TCP/IP moderno, quais são as quatro camadas e como se mapeiam ao modelo OSI de 7 camadas?",
    "options": [
      "Network Access (OSI 1+2), Internet (OSI 3), Transport (OSI 4), Application (OSI 5+6+7)",
      "Physical (1), DataLink (2), Network (3), Application (5+6+7)",
      "Link (1), Network (2+3), Transport (4), Application (5+6+7)",
      "As quatro camadas TCP/IP correspondem diretamente às quatro primeiras do OSI"
    ],
    "correctIndex": 0,
    "explanation": "Modelo TCP/IP (RFC 1122): Network Access/Link (OSI 1-2), Internet/Network (OSI 3), Transport (OSI 4), Application (OSI 5-6-7). OSI tem 7 camadas por questões didáticas. Na prática: implementações seguem TCP/IP. Camada de sessão (5) e apresentação (6) do OSI: mapeadas para a camada Application.",
    "example": "Encapsulamento: App (dados) → Transport (segmento TCP) → Internet (pacote IP) → Link (frame Ethernet). PDUs: stream (L5-7), segmento (L4), pacote (L3), frame (L2), bit (L1). MTU: 1500 bytes Ethernet. Fragmentação IP: quando pacote > MTU. Path MTU Discovery: evita fragmentação."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Difícil",
    "question": "Em qual camada do modelo OSI ocorre o encapsulamento de dados em 'segmentos'?",
    "options": [
      "Camada 4 — Transporte",
      "Camada 3 — Rede",
      "Camada 2 — Enlace",
      "Camada 5 — Sessão"
    ],
    "correctIndex": 0,
    "explanation": "O encapsulamento segue: Camada 7/6/5 → Dados. Camada 4 (Transporte) → Segmentos (TCP) ou Datagramas (UDP). Camada 3 (Rede) → Pacotes. Camada 2 (Enlace) → Quadros/Frames. Camada 1 (Física) → Bits. Cada camada adiciona seu cabeçalho.",
    "example": "PDU (Protocol Data Unit) por camada: L7-L5: Data. L4: Segment (TCP) / Datagram (UDP). L3: Packet. L2: Frame. L1: Bits. Processo inverso = desencapsulamento."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Difícil",
    "question": "O que é o MTU (Maximum Transmission Unit) e o que acontece quando um pacote excede o MTU?",
    "options": [
      "Tamanho máximo do pacote que o enlace suporta; pacotes maiores são fragmentados ou descartados",
      "Velocidade máxima da conexão; pacotes são enfileirados",
      "Número máximo de hops; pacotes são roteados por caminho alternativo",
      "Tempo máximo de vida do pacote; descartados silenciosamente"
    ],
    "correctIndex": 0,
    "explanation": "MTU é o tamanho máximo de pacote que um enlace transporta. Ethernet padrão: 1500 bytes. Se excede o MTU: IPv4 fragmenta; IPv6 descarta com ICMP 'Packet Too Big' (proíbe fragmentação em trânsito).",
    "example": "Ethernet MTU: 1500 bytes. Jumbo frames: até 9000 bytes. IPv4: roteador fragmenta (flag DF → ICMP Type 3 Code 4). IPv6: NUNCA fragmenta em trânsito. Path MTU Discovery descobre o menor MTU do caminho."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Difícil",
    "question": "Como funciona o mecanismo de janela deslizante (sliding window) do TCP?",
    "options": [
      "Permite enviar múltiplos segmentos antes de receber confirmação, ajustando o tamanho conforme a rede",
      "Envia um segmento por vez e espera confirmação",
      "Descarta pacotes duplicados automaticamente",
      "Prioriza pacotes conforme tipo de tráfego"
    ],
    "correctIndex": 0,
    "explanation": "Sliding window: o transmissor envia até N segmentos (tamanho da janela) sem esperar ACK. A janela desliza conforme ACKs chegam. O receptor anuncia rwnd (receive window). Congestion window (cwnd) limita baseado na rede.",
    "example": "Window=3: envia seg 1,2,3 → ACK 1 → desliza → envia seg 4. Congestion control: slow start → congestion avoidance → fast retransmit/recovery. rwnd × cwnd determinam a taxa efetiva."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Difícil",
    "question": "O que é o MSS (Maximum Segment Size) e como se relaciona com o MTU?",
    "options": [
      "Tamanho máximo de dados TCP em um segmento; MSS = MTU − cabeçalhos IP e TCP",
      "Tamanho máximo de um pacote na Camada 2",
      "Número máximo de segmentos enviados sem ACK",
      "Velocidade máxima de transferência do enlace"
    ],
    "correctIndex": 0,
    "explanation": "MSS = MTU − cabeçalho IP (20B) − cabeçalho TCP (20B). Com MTU Ethernet de 1500 bytes, MSS = 1460 bytes. O MSS é negociado durante o three-way handshake (opção no campo TCP Options do SYN).",
    "example": "MTU 1500 → MSS 1460 (sem opções). Com timestamps TCP: MSS 1448. VPN (overhead do túnel): MTU menor → MSS menor. MSS clamping: roteador ajusta o MSS para evitar fragmentação em túneis."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Difícil",
    "question": "Quais são as fases do controle de congestionamento do TCP?",
    "options": [
      "Slow Start, Congestion Avoidance, Fast Retransmit e Fast Recovery",
      "Handshake, Transfer e Teardown",
      "SYN, DATA e FIN",
      "Connect, Transmit, Disconnect e Retry"
    ],
    "correctIndex": 0,
    "explanation": "1) Slow Start: cwnd dobra a cada RTT (crescimento exponencial). 2) Congestion Avoidance: após ssthresh, cwnd cresce linearmente (+1 MSS/RTT). 3) Fast Retransmit: 3 ACKs duplicados → retransmite sem esperar timeout. 4) Fast Recovery: reduz cwnd pela metade ao invés de reiniciar.",
    "example": "Algoritmos: Tahoe (slow start após perda), Reno (fast recovery), CUBIC (Linux padrão, baseado em função cúbica), BBR (Google, baseado em bandwidth/RTT). cwnd inicial: tipicamente 10 MSS (RFC 6928)."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Difícil",
    "question": "O que é Path MTU Discovery (PMTUD) e por que é importante?",
    "options": [
      "Mecanismo que descobre o menor MTU do caminho para evitar fragmentação",
      "Protocolo que descobre a rota mais rápida",
      "Método de compressão de pacotes",
      "Ferramenta de diagnóstico de rede"
    ],
    "correctIndex": 0,
    "explanation": "PMTUD envia pacotes com flag DF (Don't Fragment) e descobre o menor MTU do caminho através de ICMP 'Packet Too Big' (tipo 3, código 4 em IPv4; tipo 2 em ICMPv6). Ajusta o tamanho dos pacotes para evitar fragmentação.",
    "example": "Host envia pacote com DF=1. Se excede MTU de um link, roteador descarta e envia ICMP 'Fragmentation Needed' com MTU do link. Host reduz tamanho e retenta. Problema: firewalls que bloqueiam ICMP quebram PMTUD."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Difícil",
    "question": "O que diferencia TCP CUBIC de TCP Reno no controle de congestionamento?",
    "options": [
      "CUBIC usa função cúbica baseada no tempo; Reno usa crescimento linear baseado em RTT",
      "São idênticos",
      "Reno é mais moderno que CUBIC",
      "CUBIC só funciona com IPv6"
    ],
    "correctIndex": 0,
    "explanation": "TCP Reno: cresce cwnd linearmente (+1 MSS/RTT) em Congestion Avoidance — depende do RTT. TCP CUBIC (Linux padrão desde 2.6.19): usa função cúbica do tempo desde a última redução, independente do RTT. CUBIC é mais justo em links de alta largura de banda.",
    "example": "Reno: AIMD (Additive Increase, Multiplicative Decrease) — janela depende do RTT. CUBIC: baseado no tempo (RTT-independent) — melhor para links fat (alta banda, alto delay). BBR (Google): baseado em bandwidth estimada + RTT mínimo."
  },
  {
    "id": "rede-de-computadores__Modelo OSI e TCP/IP__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Modelo OSI e TCP/IP",
    "difficulty": "Difícil",
    "question": "Como funciona o TCP Slow Start, Congestion Avoidance e Fast Retransmit?",
    "options": [
      "Slow Start: cresce cwnd exponencialmente até ssthresh; Congestion Avoidance: crescimento linear após ssthresh; Fast Retransmit: retransmite ao receber 3 ACKs duplicados sem esperar timeout",
      "Slow Start: espera 1 RTT antes de cada segmento; Congestion Avoidance: para o envio temporariamente",
      "Fast Retransmit reinicia conexao TCP após perda; Slow Start é somente para UDP",
      "cwnd cresce linearmente em Slow Start; exponencialmente em Congestion Avoidance"
    ],
    "correctIndex": 0,
    "explanation": "Slow Start: cwnd=1 MSS; por ACK, cwnd++; por RTT, cwnd*2 (exponencial). Ao atingir ssthresh, entra em Congestion Avoidance (cwnd++ por RTT, linear). Perda detectada por timeout: ssthresh=cwnd/2, cwnd=1, volta Slow Start. 3 ACKdups (Fast Retransmit): ssthresh=cwnd/2, cwnd=ssthresh (RFC 5681 CUBIC). Fast Recovery: não chega a cwnd=1.",
    "example": "TCP Reno: slow start + cong. avoidance + fast retransmit + fast recovery. TCP CUBIC (Linux default): janela cresce como função cúbica do tempo, melhor em redes de alta largura de banda e latencia. BBR (Google): modelo de rede baseado em BDP. iperf3: mede throughput TCP e visualiza cwnd."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Fácil",
    "question": "Qual é a diferença entre roteamento estático e dinâmico?",
    "options": [
      "Estático: rotas configuradas manualmente. Dinâmico: rotas aprendidas automaticamente por protocolos",
      "Estático é mais lento que dinâmico",
      "Dinâmico não usa tabela de roteamento",
      "Estático só funciona em redes locais"
    ],
    "correctIndex": 0,
    "explanation": "Roteamento estático: o administrador configura manualmente cada rota. Simples, sem overhead, mas não se adapta a mudanças. Roteamento dinâmico: protocolos (OSPF, BGP, EIGRP) trocam informações entre roteadores e atualizam rotas automaticamente.",
    "example": "Estático: `ip route 10.0.0.0 255.255.255.0 192.168.1.1` (manual). Dinâmico: roteadores OSPF descobrem vizinhos e calculam melhores rotas automaticamente. Usado em redes grandes e complexas."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Fácil",
    "question": "O que é uma tabela de roteamento?",
    "options": [
      "Lista com os caminhos disponíveis para alcançar diferentes redes",
      "Tabela com endereços MAC dos dispositivos",
      "Lista de portas abertas no firewall",
      "Registro de todos os pacotes que passaram pelo roteador"
    ],
    "correctIndex": 0,
    "explanation": "A tabela de roteamento contém: rede de destino, máscara, próximo salto (next hop), interface de saída e métrica. O roteador consulta essa tabela para decidir o encaminhamento de cada pacote.",
    "example": "Comando: `ip route` (Linux). Fontes: C (connected), S (static), O (OSPF), R (RIP), B (BGP). O roteador escolhe a rota mais específica (longest prefix match)."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Fácil",
    "question": "O que é o gateway padrão (default gateway) em uma rede?",
    "options": [
      "Endereço IP do roteador que encaminha tráfego para redes externas",
      "Endereço do servidor DNS",
      "Endereço IP do switch principal",
      "Endereço de broadcast da rede"
    ],
    "correctIndex": 0,
    "explanation": "O gateway padrão é o IP do roteador que o dispositivo usa para enviar pacotes a redes fora da sub-rede local. Quando não há rota específica, o pacote vai ao default gateway. Geralmente é .1 ou .254.",
    "example": "PC 192.168.1.10/24, gateway 192.168.1.1. Pacote para 10.0.0.5 → não está na sub-rede → envia para 192.168.1.1 (roteador) → roteador encaminha para a próxima rede."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Fácil",
    "question": "O que é o 'next hop' (próximo salto) em uma tabela de roteamento?",
    "options": [
      "IP do roteador vizinho para onde o pacote deve ser encaminhado",
      "Endereço MAC do destino final",
      "Número da porta TCP do serviço",
      "Velocidade do link de saída"
    ],
    "correctIndex": 0,
    "explanation": "Next hop é o endereço IP do próximo roteador no caminho até o destino. O pacote é encaminhado salto a salto (hop by hop) até chegar à rede de destino. Se o destino está diretamente conectado, o next hop é a própria interface.",
    "example": "Tabela: Rede 10.0.0.0/8 → Next Hop 192.168.1.2 → Interface eth0. 'Directly connected' = sem next hop. Default route (0.0.0.0/0) → next hop = gateway padrão."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Fácil",
    "question": "O que significa uma rede estar 'convergida' em roteamento dinâmico?",
    "options": [
      "Todos os roteadores têm visão consistente e atualizada da topologia da rede",
      "Todos os links estão na velocidade máxima",
      "O firewall está sincronizado com o roteador",
      "O DNS resolveu todos os nomes corretamente"
    ],
    "correctIndex": 0,
    "explanation": "Convergência é o estado em que todos os roteadores concordam sobre as rotas disponíveis após uma mudança na topologia. OSPF converge rapidamente (segundos); RIP converge lentamente (minutos). Durante a convergência, can haver loops temporários.",
    "example": "Tempo de convergência: RIP = até minutos (count-to-infinity). OSPF = segundos (SPF rápido). EIGRP = subsegundos (Feasible Successor). Rede não convergida = risco de loops e black holes."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Fácil",
    "question": "O que é o protocolo RIP e qual sua principal limitação?",
    "options": [
      "Protocolo distance-vector que usa contagem de hops como métrica, limitado a 15 hops",
      "Protocolo link-state limitado a 30 roteadores",
      "Protocolo de transporte limitado a redes locais",
      "Protocolo de aplicação limitado a 100 Mbps"
    ],
    "correctIndex": 0,
    "explanation": "RIP (Routing Information Protocol) é um protocolo distance-vector que usa hop count como métrica (máximo 15 hops — 16 = inalcançável). Simples de configurar, mas converge lentamente e sofre com count-to-infinity.",
    "example": "RIPv1: classful, broadcast. RIPv2: classless, multicast (224.0.0.9), suporta VLSM e autenticação. RIPng: versão para IPv6. Atualiza tabela a cada 30 segundos. Quase obsoleto — substituído por OSPF/EIGRP."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Fácil",
    "question": "O que é uma rota padrão (default route)?",
    "options": [
      "Rota 0.0.0.0/0 usada quando não há rota específica na tabela para o destino",
      "Primeira rota inserida na tabela de roteamento",
      "Rota com maior número de hops",
      "Rota exclusiva para tráfego local"
    ],
    "correctIndex": 0,
    "explanation": "A default route (0.0.0.0/0) é a rota 'coringa' — usada quando nenhuma rota mais específica combina com o destino. Aponta para o gateway de último recurso. Todo host tem uma (apontando para o default gateway).",
    "example": "Cisco: `ip route 0.0.0.0 0.0.0.0 192.168.1.1`. Linux: `ip route add default via 192.168.1.1`. Longest prefix match: default route (/0) é a menos específica, usada apenas como fallback."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre roteamento estático e dinâmico?",
    "options": [
      "Estático: rotas configuradas manualmente; dinâmico: protocolos (OSPF, BGP) trocam informações e atualizam tabelas automaticamente",
      "Dinâmico é mais seguro; estático é somente para redes grandes",
      "São equivalentes; a diferença é apenas na nomenclatura do fabricante",
      "Estático usa tabelas ARP; dinâmico usa tabelas MAC"
    ],
    "correctIndex": 0,
    "explanation": "Estático: 'ip route 10.0.2.0/24 via 192.168.1.1'. Vantagens: simples, determinístico, sem overhead de protocolo. Desvantagens: não se adapta a falhas. Dinâmico: protocolos IGP (OSPF, EIGRP, RIP) e EGP (BGP) calculam melhor caminho. Adaptação automática a failover.",
    "example": "Default route: 0.0.0.0/0 via ISP. Administrative distance: estática=1, OSPF=110, RIP=120, BGP externo=20. OSPF SPF (Dijkstra): calcula menor custo. BGP path vector: melhor caminho baseado em atributos. Floating static: estática com AD alto como backup."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Médio__1",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Médio",
    "question": "O protocolo OSPF é classificado como qual tipo de protocolo de roteamento?",
    "options": [
      "Link-state (estado de enlace)",
      "Distance-vector (vetor de distância)",
      "Path-vector (vetor de caminho)",
      "Hybrid (híbrido)"
    ],
    "correctIndex": 0,
    "explanation": "OSPF (Open Shortest Path First) é um protocolo link-state: cada roteador conhece a topologia completa da rede e calcula o melhor caminho usando o algoritmo de Dijkstra. Diferente de distance-vector (RIP), onde roteadores conhecem apenas vizinhos diretos.",
    "example": "Link-state: OSPF, IS-IS — cada roteador tem mapa completo, usa SPF/Dijkstra. Distance-vector: RIP — conhece apenas distância (hops) até destinos via vizinhos. Path-vector: BGP — usado entre sistemas autônomos (internet)."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Médio__2",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Médio",
    "question": "Qual é a principal diferença entre OSPF e RIP como protocolos de roteamento?",
    "options": [
      "OSPF usa estado de enlace e Dijkstra; RIP usa vetor de distância com máximo 15 hops",
      "OSPF é mais simples que RIP",
      "RIP suporta mais roteadores que OSPF",
      "Ambos usam o mesmo algoritmo"
    ],
    "correctIndex": 0,
    "explanation": "OSPF (link-state): cada roteador conhece a topologia completa e calcula o melhor caminho com Dijkstra. Converge rápido. RIP (distance-vector): conhece apenas vizinhos, métrica = hops (máximo 15). Converge lento. OSPF é preferido em redes grandes.",
    "example": "RIP: máx 15 hops, atualização a cada 30s, count-to-infinity. OSPF: sem limite de hops, convergência rápida, áreas hierárquicas, métrica baseada em bandwidth. RIPv1: classful. RIPv2: classless."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Médio__3",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Médio",
    "question": "O que é métrica em roteamento e como diferentes protocolos a calculam?",
    "options": [
      "Valor numérico do custo de um caminho; RIP usa hops, OSPF usa largura de banda",
      "É a velocidade da interface de rede",
      "É o número de VLANs no caminho",
      "É o tempo de resposta do ping"
    ],
    "correctIndex": 0,
    "explanation": "Métrica é o critério para comparar rotas. RIP = hop count. OSPF = custo baseado em bandwidth (10⁸/BW). EIGRP = composto (bandwidth, delay, reliability, load). Se duas rotas existem, escolhe-se a de menor métrica.",
    "example": "RIP: link 100 Mbps ou 10 Gbps = 1 hop (não diferencia). OSPF: 100 Mbps = custo 1, 10 Mbps = custo 10 (ajustável). EIGRP: fórmula composta permite ajuste fino."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Médio__4",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Médio",
    "question": "O que é distância administrativa (AD) em roteamento?",
    "options": [
      "Valor de confiabilidade de uma fonte de rota; menor AD = mais confiável",
      "Distância física entre roteadores",
      "Número de hops até o destino",
      "Largura de banda do link"
    ],
    "correctIndex": 0,
    "explanation": "Distância administrativa prioriza fontes de rota. Valores padrão (Cisco): Connected = 0, Static = 1, EIGRP = 90, OSPF = 110, RIP = 120, BGP externo = 20. Se há duas rotas de protocolos diferentes, vence a de menor AD.",
    "example": "Exemplo: rota para 10.0.0.0/8 via OSPF (AD 110) e RIP (AD 120) → OSPF vence. Se OSPF cai, RIP assume. AD não é métrica — métrica compara rotas DENTRO do mesmo protocolo."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Médio__5",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Médio",
    "question": "O que significa 'longest prefix match' no roteamento IP?",
    "options": [
      "O roteador escolhe a rota com máscara mais longa (mais específica) para o destino",
      "Escolhe a rota com menor número de hops",
      "Seleciona a rota mais antiga na tabela",
      "Prefere rotas estáticas sobre dinâmicas"
    ],
    "correctIndex": 0,
    "explanation": "Longest prefix match: se existem rotas 10.0.0.0/8 e 10.1.0.0/16 e o destino é 10.1.2.3, o roteador escolhe /16 (mais específica). Quanto maior o prefixo, mais específica a rota. /32 = host route (mais específica possível).",
    "example": "Pacote para 10.1.2.3: /8 (match), /16 (match), /24 (match se existir) → escolhe a mais específica. Default route 0.0.0.0/0 = menor prefixo, usada quando nada mais combina."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Médio__6",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Médio",
    "question": "O que são áreas no OSPF e qual a função da Área 0?",
    "options": [
      "Divisões lógicas da rede que reduzem overhead; Área 0 (backbone) interconecta todas as outras",
      "Grupos de VLANs; Área 0 é a VLAN padrão",
      "Segmentos físicos; Área 0 é o datacenter",
      "Zonas de firewall; Área 0 é a DMZ"
    ],
    "correctIndex": 0,
    "explanation": "OSPF divide a rede em áreas para limitar a propagação de LSAs e reduzir o processamento. A Área 0 (backbone) é obrigatória e todas as outras áreas devem se conectar a ela (diretamente ou via virtual link).",
    "example": "Benefícios de áreas: menos LSAs por área → tabelas menores → SPF mais rápido. Tipos de área: Stub (sem LSA 5), NSSA (permite LSA 7), Totally Stubby (só rota padrão)."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Médio__7",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Médio",
    "question": "O que é o algoritmo de Dijkstra utilizado pelo OSPF?",
    "options": [
      "Algoritmo que calcula o caminho mais curto de um nó a todos os outros em um grafo ponderado",
      "Algoritmo de criptografia de rotas",
      "Método de compressão de tabelas de roteamento",
      "Protocolo de autenticação entre roteadores"
    ],
    "correctIndex": 0,
    "explanation": "O algoritmo SPF (Shortest Path First) de Dijkstra constrói uma árvore de caminhos mínimos a partir do roteador local. Cada roteador OSPF executa Dijkstra sobre seu LSDB (Link-State Database) para calcular as melhores rotas.",
    "example": "Complexidade: O(n² + m) ou O(n log n + m) com heap. OSPF executa SPF a cada mudança de topologia. Para evitar cálculos frequentes, há SPF delay timers e incremental SPF (iSPF)."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Médio__8",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Médio",
    "question": "O que é o protocolo OSPF Area e como as áreas reduzem a utilização da CPU e da largura de banda?",
    "options": [
      "OSPF Area segmenta o domínio OSPF; cada área mantm LSDB local; LSA propagados só dentro da área; Area 0 (backbone) obrigatória; inter-area routing via ABR",
      "OSPF áreas são sinonímos de VLANs; cada VLAN é uma área OSPF",
      "Area 0 é opcional; qualquer roteador pode ser o backbone",
      "Todas as áreas têm a mesma LSDB global; áreas são apenas organização administrativa"
    ],
    "correctIndex": 0,
    "explanation": "OSPF hierarquia: Area 0 (backbone) obrigatória. Outras áreas conectam via ABR (Area Border Router). LSA intrá-área (tipo 1, 2) ficam dentro da área. LSA inter-área (tipo 3) resumidos pelo ABR. LSDB reduzida = menor SPF. Stub Area: bloqueia LSA externos. Totally Stubby: bloqueia inter-área e externos (default route injected).",
    "example": "10k routers single area: LSDB enorme, SPF custoso. Partição em 100 áreas de 100 roteadores: SPF local menor. ASBR: injeta rotas externas (redistribução). NSSA (Not-So-Stubby Area): permite ASBRs mas com LSA tipo 7. Virtual Link: conecta área descontínua ao backbone. OSPF v3: IPv6."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Difícil",
    "question": "Em uma rede OSPF multi-área, qual é a função do ABR (Area Border Router)?",
    "options": [
      "Conectar diferentes áreas OSPF e sumarizar rotas entre elas",
      "Redistribuir rotas de outros protocolos para o OSPF",
      "Eleger o DR e BDR da rede",
      "Gerar a rota padrão para a área 0"
    ],
    "correctIndex": 0,
    "explanation": "O ABR (Area Border Router) é um roteador que pertence a pelo menos duas áreas OSPF (uma delas é a área 0 — backbone). Ele injeta LSAs tipo 3 (Summary LSAs) na outra área, permitindo que roteadores conheçam rotas de áreas diferentes. Também pode sumarizar rotas, reduzindo o tamanho das tabelas.",
    "example": "ASBR (Autonomous System Boundary Router): redistribui rotas externas → LSA tipo 5. ABR: conecta áreas → LSA tipo 3. DR/BDR: eleitos por prioridade/Router ID em redes multi-acesso, reduzindo adjacências."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Difícil",
    "question": "O que é redistribuição de rotas e quando ela é necessária?",
    "options": [
      "Compartilhar rotas entre protocolos diferentes; necessária quando a rede usa múltiplos protocolos",
      "Balancear tráfego entre rotas iguais",
      "Replicar a tabela de roteamento para backup",
      "Comprimir rotas para economizar memória"
    ],
    "correctIndex": 0,
    "explanation": "Redistribuição injeta rotas de um protocolo em outro (ex: OSPF no EIGRP). Necessária quando partes da rede usam protocolos diferentes (fusão de empresas, migração). Cuidados: loops, métricas incompatíveis.",
    "example": "Cisco: `router ospf 1` → `redistribute eigrp 100 subnets`. Riscos: routing loops, suboptimal routing. Soluções: route maps, distribute-lists, métricas seed configuradas."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Difícil",
    "question": "No BGP, o que são os atributos AS_PATH e NEXT_HOP?",
    "options": [
      "AS_PATH lista os ASes atravessados (menor = preferido); NEXT_HOP indica o próximo roteador",
      "AS_PATH é a velocidade do link; NEXT_HOP é o DNS",
      "Ambos são opcionais e não influenciam a seleção",
      "AS_PATH é usado apenas em iBGP; NEXT_HOP apenas em eBGP"
    ],
    "correctIndex": 0,
    "explanation": "AS_PATH: lista ordenada dos Autonomous Systems que a rota atravessou. Menor AS_PATH = rota preferida. Também previne loops (se o AS local já está no path, descarta). NEXT_HOP: IP do próximo roteador BGP para alcançar o destino.",
    "example": "Rota 8.8.8.0/24: AS_PATH 64500 64501 15169 (3 saltos) vs 64500 15169 (2 saltos) → segunda preferida. Seleção BGP: Weight → Local Pref → AS_PATH → MED."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre iBGP e eBGP?",
    "options": [
      "iBGP é entre roteadores do mesmo AS; eBGP é entre ASes diferentes",
      "iBGP usa TCP e eBGP usa UDP",
      "eBGP só funciona em IPv6",
      "iBGP não usa atributos de caminho"
    ],
    "correctIndex": 0,
    "explanation": "eBGP (external): peering entre roteadores de ASes diferentes (ex: ISPs). TTL=1 por padrão. iBGP (internal): peering dentro do mesmo AS. Propaga rotas aprendidas externamente internamente. iBGP não altera o NEXT_HOP por padrão e requer full-mesh ou route reflectors.",
    "example": "iBGP full-mesh: n(n-1)/2 sessões. Soluções: Route Reflectors (RR) ou Confederações. eBGP: altera AS_PATH a cada salto. iBGP: não altera AS_PATH (regra split-horizon do BGP)."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Difícil",
    "question": "O que é ECMP (Equal-Cost Multi-Path) em roteamento?",
    "options": [
      "Balanceamento de carga entre múltiplas rotas de custo igual para o mesmo destino",
      "Protocolo de redundância de gateway",
      "Método de criptografia de rotas",
      "Técnica de compressão de tabela de roteamento"
    ],
    "correctIndex": 0,
    "explanation": "ECMP permite usar várias rotas com o mesmo custo simultaneamente, distribuindo o tráfego entre elas. Aumenta a largura de banda efetiva e provê redundância. OSPF, IS-IS e BGP (com configuração) suportam ECMP.",
    "example": "OSPF permite até 4 rotas ECMP por padrão (ajustável). Balanceamento: per-packet (risco de reordenamento) ou per-flow (hash 5-tupla). ECMP é base do roteamento em data centers (Clos/Fat-Tree)."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Difícil",
    "question": "O que são Route Reflectors no iBGP e por que são necessários?",
    "options": [
      "Roteadores que refletem rotas iBGP para evitar full-mesh entre todos os peers do AS",
      "Servidores que armazenam backup das rotas BGP",
      "Dispositivos que criptografam sessões BGP",
      "Switches que redistribuem rotas entre VLANs"
    ],
    "correctIndex": 0,
    "explanation": "No iBGP, rotas recebidas de um peer não são repassadas a outros peers (split-horizon). Isso exige full-mesh (n(n-1)/2 sessões). Route Reflectors quebram essa regra: recebem rotas de clientes e as refletem para outros clientes e non-clients.",
    "example": "RR cluster: RR + seus clientes. Atributos: ORIGINATOR_ID (evita loops), CLUSTER_LIST (rastreio de clusters). Hierarquia de RRs possível. Alternativa: Confederações BGP (dividem AS em sub-ASes)."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Difícil",
    "question": "O que é o protocolo IS-IS e como ele difere do OSPF?",
    "options": [
      "Protocolo link-state baseado em OSI que encapsula diretamente em L2, sem depender de IP",
      "Protocolo distance-vector mais rápido que o RIP",
      "Versão do OSPF para redes sem fio",
      "Protocolo de roteamento exclusivo para IPv6"
    ],
    "correctIndex": 0,
    "explanation": "IS-IS (Intermediate System to Intermediate System) é um protocolo link-state que roda diretamente sobre L2 (não precisa de IP). Usa TLVs extensíveis, suporta IPv4 e IPv6 nativamente. Preferido por grandes ISPs pela escalabilidade.",
    "example": "IS-IS vs OSPF: IS-IS roda sobre L2 (OSPF sobre IP). IS-IS usa TLVs (fácil extensão). IS-IS: 2 níveis (L1 intra-área, L2 inter-área). OSPF: área backbone + áreas stub/NSSA. ISPs preferem IS-IS; empresas preferem OSPF."
  },
  {
    "id": "rede-de-computadores__Protocolos de Roteamento__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Protocolos de Roteamento",
    "difficulty": "Difícil",
    "question": "Como funciona o BGP route selection process e quais são os principais atributos em ordem de preferência?",
    "options": [
      "BGP seleciona rota com: maior Weight (Cisco), maior Local Preference, Locally Originated, menor AS-Path, menor Origin, menor MED, eBGP sobre iBGP, menor IGP metric, menor Router-ID",
      "BGP escolhe apenas pelo menor AS-Path; os demais atributos são opcionais",
      "Local Preference só se aplica a rotas iBGP; AS-Path somente a eBGP",
      "Weight e Local Preference têm a mesma prioridade; MED é o tiebreaker final"
    ],
    "correctIndex": 0,
    "explanation": "BGP decision process (Cisco): 1. Peso (Weight, local Cisco); 2. LP (Local Preference, maior melhor, propagado iBGP); 3. Originated locally; 4. AS-Path comprimento (menor melhor); 5. Origin (IGP>EGP>Incomplete); 6. MED (menor melhor); 7. eBGP > iBGP; 8. IGP metric ao next-hop; 9. ECMP/multipath; 10. Menor Router-ID.",
    "example": "Políticas BGP: community, route-map, prefix-list. LP alto=preferência de saída. MED=preferência de entrada (informativo). AS-Path prepend: engana parceiros a não preferir pelo caminho mais longo. BGP communities: 65001:100 (sinalizador de rota). RPKI: validação de origem de prefixos contra hijacking."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Fácil",
    "question": "Qual padrão Wi-Fi opera exclusivamente na frequência de 5 GHz?",
    "options": [
      "802.11a",
      "802.11b",
      "802.11g",
      "802.11n"
    ],
    "correctIndex": 0,
    "explanation": "802.11a: 5 GHz (até 54 Mbps). 802.11b: 2,4 GHz (até 11 Mbps). 802.11g: 2,4 GHz (até 54 Mbps). 802.11n (Wi-Fi 4): dual-band 2,4/5 GHz (até 600 Mbps). 802.11a foi um dos primeiros a usar 5 GHz, mas teve menor alcance.",
    "example": "2,4 GHz: maior alcance, mais interferência (micro-ondas, Bluetooth). 5 GHz: menor alcance, mais canais, menos interferência. 802.11ac (Wi-Fi 5) = apenas 5 GHz. 802.11ax (Wi-Fi 6) = dual-band."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Fácil",
    "question": "O que é o SSID de uma rede Wi-Fi?",
    "options": [
      "Nome da rede sem fio que aparece na lista de redes disponíveis",
      "Senha da rede Wi-Fi",
      "Endereço MAC do roteador",
      "Frequência do canal Wi-Fi"
    ],
    "correctIndex": 0,
    "explanation": "SSID (Service Set Identifier) é o nome que identifica uma rede Wi-Fi. É o que aparece quando você procura redes disponíveis. Cada access point pode ter um ou múltiplos SSIDs.",
    "example": "SSID pode ser ocultado (hidden), mas não é segurança real — ferramentas capturam facilmente. Boas práticas: WPA3, senha forte, nome não revelador."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre as frequências 2,4 GHz e 5 GHz em redes Wi-Fi?",
    "options": [
      "2,4 GHz tem maior alcance mas mais interferência; 5 GHz tem menor alcance mas mais velocidade",
      "2,4 GHz é mais rápido que 5 GHz",
      "5 GHz tem maior alcance que 2,4 GHz",
      "Não há diferença prática"
    ],
    "correctIndex": 0,
    "explanation": "2,4 GHz: maior alcance, melhor penetração em paredes, mas apenas 3 canais não sobrepostos (1, 6, 11) e mais interferência. 5 GHz: menor alcance, mais canais (23+), menos interferência e maiores velocidades.",
    "example": "2,4 GHz: canais 1-14 (3 não sobrepostos). 5 GHz: canais 36-165 (23+). Wi-Fi 6: dual-band. Wi-Fi 6E: adiciona 6 GHz. Dual-band: AP opera em ambas simultaneamente."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Fácil",
    "question": "O que significa Wi-Fi 6 em termos de padrão IEEE?",
    "options": [
      "802.11ax",
      "802.11ac",
      "802.11n",
      "802.11ad"
    ],
    "correctIndex": 0,
    "explanation": "Wi-Fi 6 = 802.11ax: dual-band (2,4/5 GHz), até 9,6 Gbps teóricos, OFDMA, MU-MIMO 8×8, BSS Coloring e TWT. Wi-Fi 5 = 802.11ac. Wi-Fi 4 = 802.11n. A Wi-Fi Alliance simplificou os nomes.",
    "example": "Wi-Fi 4 (11n): 600 Mbps. Wi-Fi 5 (11ac): 6,9 Gbps, só 5 GHz. Wi-Fi 6 (11ax): 9,6 Gbps, dual-band. Wi-Fi 6E: adiciona 6 GHz. Wi-Fi 7 (11be): 46 Gbps, tri-band, MLO."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Fácil",
    "question": "O que é um canal em redes Wi-Fi?",
    "options": [
      "Faixa de frequência específica dentro da banda usada para transmissão de dados",
      "Cabo físico que conecta o AP ao switch",
      "Tipo de criptografia usada na rede",
      "Número máximo de dispositivos conectados"
    ],
    "correctIndex": 0,
    "explanation": "Um canal Wi-Fi é uma faixa de frequência dentro da banda (2,4 ou 5 GHz). Na banda 2,4 GHz existem 14 canais, mas só 3 não se sobrepõem (1, 6, 11). Na 5 GHz há mais canais sem sobreposição.",
    "example": "2,4 GHz: cada canal tem 20 MHz de largura, espaçados 5 MHz → sobreposição. Canais 1, 6 e 11 não se sobrepõem. 5 GHz: canais de 20, 40, 80 ou 160 MHz. Mais largo = mais velocidade, menos canais."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Fácil",
    "question": "O que é um access point (AP) em redes Wi-Fi?",
    "options": [
      "Dispositivo que conecta clientes sem fio à rede cabeada, atuando como ponte",
      "Servidor que distribui endereços IP",
      "Equipamento que filtra tráfego malicioso",
      "Software de gerenciamento de rede"
    ],
    "correctIndex": 0,
    "explanation": "O access point (AP) é o dispositivo central em redes Wi-Fi infrastructure mode. Ele recebe conexões dos clientes wireless e as encaminha para a rede cabeada (e vice-versa). APs corporativos suportam múltiplos SSIDs e VLANs.",
    "example": "AP doméstico: geralmente integrado ao roteador (roteador wireless). AP corporativo: dispositivo separado, gerenciado por WLC. Modos: AP autônomo (standalone) ou Lightweight (controlado por WLC via CAPWAP)."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Fácil",
    "question": "O que significa a sigla WPA em redes Wi-Fi?",
    "options": [
      "Wi-Fi Protected Access, protocolo de segurança que criptografa a comunicação wireless",
      "Wireless Public Authentication, método de login em redes abertas",
      "Wide Protocol Adapter, interface de rede",
      "Web Privacy Algorithm, criptografia de navegação"
    ],
    "correctIndex": 0,
    "explanation": "WPA (Wi-Fi Protected Access) é o padrão de segurança para redes Wi-Fi. Substituiu o WEP (vulnerável). WPA usa TKIP, WPA2 usa AES-CCMP e WPA3 usa SAE + AES-GCMP. Cada versão melhorou a segurança.",
    "example": "Evolução: WEP (1997, quebrado) → WPA (2003, TKIP) → WPA2 (2004, AES-CCMP, padrão atual) → WPA3 (2018, SAE, forward secrecy). PSK = Personal (senha compartilhada). Enterprise = 802.1X/RADIUS."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre os padrões Wi-Fi 802.11n (Wi-Fi 4) e 802.11ac (Wi-Fi 5)?",
    "options": [
      "802.11n: 2,4/5 GHz, MIMO 4×4, até 600 Mbps; 802.11ac: somente 5 GHz, MU-MIMO, canais de 80/160 MHz, beamforming, até 3,5 Gbps",
      "802.11n opera só em 5 GHz; 802.11ac em 2,4 e 5 GHz",
      "São equivalentes; a diferença é apenas o nome de marketing",
      "802.11ac tem alcance maior em 2,4 GHz por usar menor frequência"
    ],
    "correctIndex": 0,
    "explanation": "802.11n (Wi-Fi 4): MIMO espacial (SU-MIMO) até 4 streams, canais 20/40 MHz, 2,4 ou 5 GHz, agregação de frames (A-MPDU). 802.11ac (Wi-Fi 5): somente 5 GHz, canais até 160 MHz, MU-MIMO (até 4 clientes simultâneos), beamforming explícito, modulation 256-QAM, 8 streams.",
    "example": "Wi-Fi 6 (802.11ax): OFDMA, BSS Coloring, TWT, 2,4+5 GHz, 1024-QAM. Wi-Fi 6E: adiciona 6 GHz. Canal 40 MHz: 'bonding' de dois canais de 20 MHz. 5 GHz: menos interferência, mais canais não sobrepostos (1,6,11 em 2,4 GHz). Seleção de banda: steering por RSSI e load."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Médio__1",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Médio",
    "question": "Qual protocolo de segurança Wi-Fi é considerado seguro atualmente?",
    "options": [
      "WPA3",
      "WEP",
      "WPA (TKIP)",
      "WPA2-PSK sem AES"
    ],
    "correctIndex": 0,
    "explanation": "WPA3 é o protocolo mais seguro, usando SAE (Simultaneous Authentication of Equals) em vez de PSK, protegendo contra ataques de dicionário offline. WEP é trivial de quebrar. WPA (TKIP) tem vulnerabilidades conhecidas. WPA2-AES ainda é aceitável, mas WPA3 é preferido.",
    "example": "Evolução: WEP (quebrado em minutos) → WPA/TKIP (vulnerável) → WPA2/AES (seguro, mas suscetível a KRACK) → WPA3/SAE (proteção forward secrecy e anti-dicionário offline)."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Médio__2",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Médio",
    "question": "O que é roaming em redes Wi-Fi corporativas?",
    "options": [
      "Transição automática do cliente entre access points sem perder a conexão",
      "Conectar-se a redes Wi-Fi públicas automaticamente",
      "Usar dados móveis quando o Wi-Fi cai",
      "Compartilhar a senha entre dispositivos"
    ],
    "correctIndex": 0,
    "explanation": "Roaming é a migração entre access points da mesma rede sem perda de conexão. Protocolos 802.11r (Fast BSS Transition) e 802.11k (neighbor reports) aceleram o processo. O controlador wireless (WLC) coordena os APs.",
    "example": "Sem roaming otimizado: desconecta do AP1, reconecta no AP2. Com 802.11r: pré-autenticação no AP2 antes de sair do AP1 (handoff < 50ms). Essencial para VoIP em movimento."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Médio__3",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Médio",
    "question": "Qual a diferença entre os modos Infrastructure e Ad-hoc em redes Wi-Fi?",
    "options": [
      "Infrastructure usa access point central; Ad-hoc conecta dispositivos diretamente entre si",
      "Infrastructure é mais lento que Ad-hoc",
      "Ad-hoc requer um servidor central",
      "Não há diferença prática"
    ],
    "correctIndex": 0,
    "explanation": "Infrastructure (BSS): dispositivos se conectam a um AP que coordena a comunicação e conecta à rede cabeada. Ad-hoc (IBSS): comunicação direta peer-to-peer sem AP. Infrastructure é o modo padrão.",
    "example": "Infrastructure: celular → AP → internet (modo normal). Ad-hoc: notebook ↔ notebook (sem AP). WDS: APs comunicam-se entre si para estender a rede sem cabeamento adicional."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Médio__4",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Médio",
    "question": "O que é band steering em redes Wi-Fi dual-band?",
    "options": [
      "Técnica que direciona dispositivos compatíveis para a banda 5 GHz automaticamente",
      "Ajuste automático da potência do sinal",
      "Balanceamento de carga entre APs",
      "Criptografia diferenciada por banda"
    ],
    "correctIndex": 0,
    "explanation": "Band steering detecta dispositivos dual-band e os 'empurra' para 5 GHz (menos congestionada, mais rápida). O AP reduz resposta aos probes do cliente em 2,4 GHz, forçando-o a conectar em 5 GHz. Dispositivos só 2,4 GHz não são afetados.",
    "example": "Técnica: AP ignora Probe Request em 2,4 GHz de clientes dual-band → cliente tenta 5 GHz e conecta lá. Configurável no AP. Melhora a experiência geral ao desafogar 2,4 GHz."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Médio__5",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Médio",
    "question": "O que são beamforming e MU-MIMO em redes Wi-Fi?",
    "options": [
      "Beamforming direciona o sinal ao cliente; MU-MIMO atende múltiplos clientes simultaneamente",
      "Ambos são protocolos de criptografia",
      "Beamforming é para 2,4 GHz e MU-MIMO para 5 GHz",
      "São técnicas de compressão de dados"
    ],
    "correctIndex": 0,
    "explanation": "Beamforming: o AP ajusta a fase das antenas para concentrar o sinal na direção do cliente (em vez de irradiar igualmente). MU-MIMO (Multi-User MIMO): permite que o AP transmita para vários clientes ao mesmo tempo usando streams espaciais independentes.",
    "example": "SU-MIMO (11n/ac wave1): 1 cliente por vez. MU-MIMO (11ac wave2): até 4 clientes DL. Wi-Fi 6 (11ax): MU-MIMO 8×8 DL+UL. Beamforming explícito: AP usa feedback do cliente para otimizar."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Médio__6",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Médio",
    "question": "O que é um controlador wireless (WLC) em redes corporativas?",
    "options": [
      "Equipamento centralizado que gerencia múltiplos APs, configurações e políticas de roaming",
      "Software antivírus para redes sem fio",
      "Roteador dedicado para tráfego wireless",
      "Protocolo de criptografia WPA3"
    ],
    "correctIndex": 0,
    "explanation": "O WLC (Wireless LAN Controller) centraliza a gestão de APs Lightweight. Controla configuração, canais, potência, segurança, roaming e load balancing. APs se conectam ao WLC via protocolo CAPWAP (porta UDP 5246/5247).",
    "example": "Arquiteturas: Autônoma (cada AP independente) → Centralizada (WLC + Lightweight APs) → Cloud-managed (Meraki, Aruba Central). Split-MAC: AP lida com L1 (RF), WLC lida com L2+ (autenticação, roaming)."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Médio__7",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Médio",
    "question": "O que é 802.11r (Fast BSS Transition) em redes Wi-Fi?",
    "options": [
      "Padrão que acelera roaming entre APs com pré-autenticação antes da transição",
      "Protocolo de criptografia avançada para Wi-Fi",
      "Técnica de aumento de alcance do sinal",
      "Método de compressão de dados wireless"
    ],
    "correctIndex": 0,
    "explanation": "802.11r (FT — Fast BSS Transition) reduz o tempo de roaming ao realizar pré-autenticação e pré-associação com o AP de destino antes do handoff. O cliente negocia chaves antecipadamente, permitindo transição em menos de 50ms.",
    "example": "Sem 802.11r: desconecta → reassocia → reaute (200-500ms). Com 802.11r: FT over-the-air ou over-the-DS (<50ms). Complemento: 802.11k (neighbor reports), 802.11v (BSS transition management). Essencial para VoIP wireless."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Médio__8",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Médio",
    "question": "O que é WPA3 e como ele melhora a segurança em relação ao WPA2?",
    "options": [
      "WPA3: SAE (Dragonfly) substitui PSK/4-way handshake, resistente a offline dictionary attack; PMF obrigatório; WPA3-Enterprise: 192-bit security suite",
      "WPA3 é apenas WPA2 com senha mínima de 12 caracteres",
      "WPA3 remove criptografia para acelerar conexões em ambientes públicos",
      "WPA2 e WPA3 usam o mesmo handshake; WPA3 apenas aumenta o tamanho da chave CCMP"
    ],
    "correctIndex": 0,
    "explanation": "WPA2-PSK: 4-way handshake vulnerável a offline dictionary attack (captura handshake, força bruta offline). WPA3-Personal: SAE (Simultaneous Authentication of Equals) = handshake Dragonfly com PFS (forward secrecy). WPA3-Enterprise: suites de 192 bits (GCMP-256, HMAC-SHA384). PMF (Protected Management Frames, 802.11w): obrigatório no WPA3.",
    "example": "KRACK (2017): ataque a WPA2 via reinstalação de chave no handshake. SAE: mesmo com senha fraca, captura não permite brute force offline. PMF protege deauth/disassoc frames (previne deauth flood). OWE (Opportunistic Wireless Encryption): criptografia sem senha para redes abertas (Wi-Fi Enhanced Open). Transição mode: WPA2/WPA3 misto."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Difícil",
    "question": "Em redes Wi-Fi corporativas, o que caracteriza o modo WPA2/WPA3-Enterprise em relação ao Personal?",
    "options": [
      "Usa servidor RADIUS para autenticação 802.1X individual por usuário",
      "Usa uma senha compartilhada mais longa",
      "É apenas para redes 5 GHz",
      "Não precisa de access point"
    ],
    "correctIndex": 0,
    "explanation": "WPA-Enterprise usa 802.1X com servidor RADIUS para autenticar cada usuário individualmente (credenciais únicas). WPA-Personal (PSK) usa uma senha compartilhada por todos. Enterprise permite auditoria, revogação individual e políticas por usuário. Usa EAP (PEAP, EAP-TLS) como framework de autenticação.",
    "example": "Personal: todos compartilham a mesma PSK. Enterprise: User→AP→RADIUS→AD/LDAP. Protocolos EAP: PEAP (user/pass), EAP-TLS (certificados). Se um funcionário sai, revoga-se apenas suas credenciais."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Difícil",
    "question": "O que é um rogue access point e como o WIDS/WIPS ajuda a detectá-lo?",
    "options": [
      "AP não autorizado na rede; WIDS/WIPS monitora o espectro e detecta APs desconhecidos",
      "AP com firmware atualizado; WIDS verifica versões",
      "AP configurado com WPA3; WIPS força atualização",
      "AP com múltiplos SSIDs; WIDS limita a quantidade"
    ],
    "correctIndex": 0,
    "explanation": "Rogue AP é um access point não autorizado na rede corporativa. WIDS (Wireless Intrusion Detection) monitora o espectro RF e detecta APs desconhecidos. WIPS (Prevention) pode desautenticar clientes conectados ao rogue AP.",
    "example": "Detecção: WIDS compara APs detectados com lista de autorizados. Contenção: WIPS envia deauth frames. Prevenção: 802.1X + NAC impede dispositivos não autorizados."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Difícil",
    "question": "O que é o problema da estação oculta (hidden node) e como o RTS/CTS resolve?",
    "options": [
      "Duas estações não se veem mas transmitem ao AP causando colisão; RTS/CTS reserva o canal",
      "Estação que esconde seu SSID; RTS/CTS força exibição",
      "Estação com sinal fraco; RTS/CTS amplifica o sinal",
      "Estação conectada a AP errado; RTS/CTS força roaming"
    ],
    "correctIndex": 0,
    "explanation": "Hidden node: A e C alcançam o AP (B) mas não se alcançam. Transmissões simultâneas causam colisão no AP. RTS/CTS: A envia RTS → AP responde CTS (ouvido por todos) → C espera → A transmite sem colisão.",
    "example": "CSMA/CA sem RTS/CTS: A não ouve C e transmite → colisão. Com RTS/CTS: CTS indica NAV timer (período de silêncio). Overhead: útil apenas com frames grandes ou hidden nodes."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Difícil",
    "question": "O que é DFS (Dynamic Frequency Selection) na banda de 5 GHz?",
    "options": [
      "Mecanismo que detecta sinais de radar e muda automaticamente de canal para evitá-los",
      "Seleção automática da melhor criptografia",
      "Ajuste dinâmico da potência de transmissão",
      "Protocolo de roaming entre APs"
    ],
    "correctIndex": 0,
    "explanation": "DFS é obrigatório em certos canais de 5 GHz (compartilhados com radares meteorológicos e militares). O AP monitora o canal; se detecta radar, deve mudar de canal em segundos. Canais DFS ficam indisponíveis por 30 minutos após detecção.",
    "example": "Canais DFS (5 GHz): 52–64, 100–144 (depende do país). Canais não-DFS: 36–48, 149–165. DFS amplia os canais disponíveis, mas com risco de mudança repentina. Outdoor: DFS é mais crítico."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Difícil",
    "question": "O que é OFDMA no Wi-Fi 6 e como melhora a eficiência?",
    "options": [
      "Divide o canal em sub-canais (Resource Units) para atender múltiplos clientes simultaneamente",
      "Aumenta a potência de transmissão do AP",
      "Criptografa cada pacote individualmente",
      "Reduz o número de antenas necessárias"
    ],
    "correctIndex": 0,
    "explanation": "OFDMA (Orthogonal Frequency-Division Multiple Access) divide o canal em Resource Units (RUs) menores, permitindo que o AP envie dados para vários clientes ao mesmo tempo no mesmo slot de tempo. Ideal para tráfego de baixa latência (IoT, VoIP).",
    "example": "OFDM (Wi-Fi 5): canal inteiro para 1 cliente por vez. OFDMA (Wi-Fi 6): canal dividido em RUs (ex: 20 MHz → 9 RUs de 2 MHz). Cada RU atende 1 cliente. Similar ao LTE/5G. Melhora eficiência em ambientes densos."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Difícil",
    "question": "O que é BSS Coloring no Wi-Fi 6 e como melhora o desempenho?",
    "options": [
      "Técnica que identifica BSSs vizinhos por 'cor', permitindo reúso espacial ao transmitir simultaneamente",
      "Método de colorir pacotes para priorização QoS",
      "Sistema de LEDs para indicar estado do AP",
      "Protocolo de balanceamento de carga entre APs"
    ],
    "correctIndex": 0,
    "explanation": "BSS Coloring atribui um identificador (cor, 1-63) a cada BSS. Ao detectar sinais com cor diferente abaixo de um limiar, o dispositivo pode transmitir simultaneamente (spatial reuse) em vez de esperar (CCA). Reduz latência em ambientes densos.",
    "example": "Sem BSS Coloring: CCA detecta qualquer sinal → espera (defer). Com BSS Coloring: identifica OBSS (cor diferente) → se sinal fraco, transmite (SR). Parte do 802.11ax. Complementa OFDMA e MU-MIMO."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Difícil",
    "question": "O que é TWT (Target Wake Time) no Wi-Fi 6?",
    "options": [
      "Mecanismo que agenda horários de comunicação entre AP e clientes para economizar energia",
      "Protocolo de sincronização de relógio entre APs",
      "Técnica de aumento de throughput em 5 GHz",
      "Método de detecção de interferência radar"
    ],
    "correctIndex": 0,
    "explanation": "TWT (Target Wake Time) permite que AP e cliente negociem janelas de tempo para comunicação. Fora dessas janelas, o cliente entra em modo sleep. Ideal para dispositivos IoT e sensores que transmitem dados esporadicamente.",
    "example": "TWT individual: AP negocia com cada cliente. TWT broadcast: AP define janela para grupo. Economia: até 7x mais bateria em IoT. Wi-Fi 5: PS-Poll/DTIM (menos eficiente). TWT é similar ao DRX do LTE/5G."
  },
  {
    "id": "rede-de-computadores__Redes Sem Fio__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Redes Sem Fio",
    "difficulty": "Difícil",
    "question": "Como funciona o OFDMA no Wi-Fi 6 e como ele melhora o desempenho em ambientes densos?",
    "options": [
      "OFDMA divide o canal em Resource Units (RUs) permitindo transmitir para múltiplos clientes simultaneamente no mesmo canal; reduz latência e overhead em ambientes com muitos dispositivos IoT/móveis",
      "OFDMA é apenas uma nova versão do MIMO com mais antenas por AP",
      "OFDMA funciona somente em downlink; uplink continua CSMA/CA individual",
      "OFDMA usa múltiplos canais de rádio de forma exclusiva; não compartilha o espectro"
    ],
    "correctIndex": 0,
    "explanation": "OFDM (Wi-Fi 5): canal inteiro alocado para um cliente por vez. OFDMA (Wi-Fi 6): subdivide canal em RUs (Resource Units, grupos de subcarriers). Downlink MU-OFDMA: AP envia para vários clientes no mesmo TXOP em RUs diferentes. Uplink MU-OFDMA: clientes respondem simultaneamente (UL MU). BSS Coloring: diminui CCA desnecessário entre BSSs. TWT (Target Wake Time): agenda wake-up de IoT.",
    "example": "26-tone RU: menor unidade (2 MHz equiv). 242-tone RU: canal 20 MHz completo. AP agenda quais clientes usam quais RUs no próximo TXOP. Ganho: reduz contention (CSMA overhead) de 30–40 clientes. Spatial Reuse: BSS Color permite reutilizar espectro quando RSSI do BSS vizinho < threshold. Analisador Wi-Fi: Wireshark + 802.11 radiotap headers."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Fácil",
    "question": "O que é um ataque de phishing?",
    "options": [
      "Tentativa de obter dados sensíveis se passando por entidade confiável",
      "Invadir redes Wi-Fi",
      "Atacar servidores com excesso de requisições",
      "Adivinhar senhas por tentativa e erro"
    ],
    "correctIndex": 0,
    "explanation": "Phishing é engenharia social: o atacante se disfarça de entidade confiável (banco, empresa) via email, SMS ou site falso para enganar a vítima e obter credenciais, dados bancários ou instalar malware. É o ataque mais comum na internet.",
    "example": "Exemplo: email falso do 'seu banco' pedindo para atualizar dados em um link que leva a um site clone. Variantes: spear phishing (alvo específico), whaling (executivos), smishing (SMS), vishing (voz)."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Fácil",
    "question": "O que é um ataque DDoS (Distributed Denial of Service)?",
    "options": [
      "Ataque que sobrecarrega um servidor com tráfego de múltiplas fontes simultaneamente",
      "Ataque que rouba senhas de usuários",
      "Vírus que se espalha por email",
      "Interceptação de dados criptografados"
    ],
    "correctIndex": 0,
    "explanation": "DDoS usa milhares de máquinas comprometidas (botnet) para enviar tráfego massivo ao alvo, esgotando recursos e tornando o serviço indisponível. Diferente de DoS (uma máquina), DDoS é distribuído.",
    "example": "DoS: uma máquina → alvo. DDoS: botnet (milhares) → alvo. Tipos: volumétrico (UDP flood), protocolo (SYN flood), aplicação (HTTP flood). Mitigação: CDN, rate limiting, Cloudflare, AWS Shield."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Fácil",
    "question": "O que é engenharia social em segurança da informação?",
    "options": [
      "Técnica de manipulação psicológica para obter informações confidenciais",
      "Software que protege contra vírus",
      "Método de criptografia de dados",
      "Análise de logs de rede"
    ],
    "correctIndex": 0,
    "explanation": "Engenharia social explora o fator humano — persuade pessoas a revelar informações ou realizar ações inseguras. Inclui phishing, pretexting, tailgating, baiting. É a ameaça mais difícil de mitigar com tecnologia.",
    "example": "Exemplos: ligar para HelpDesk fingindo ser diretor e pedir reset de senha. Deixar pen drive infectado no estacionamento. Seguir funcionário pela porta. Defesa: treinamento de security awareness."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Fácil",
    "question": "O que é malware?",
    "options": [
      "Software malicioso que inclui vírus, trojans, worms e ransomware",
      "Hardware defeituoso que danifica a rede",
      "Técnica de engenharia social",
      "Protocolo de segurança desatualizado"
    ],
    "correctIndex": 0,
    "explanation": "Malware (malicious software) é qualquer software projetado para causar dano. Tipos: vírus (precisa de hospedeiro), worm (se espalha sozinho), trojan (disfarce), ransomware (sequestra dados), spyware (espiona), adware (propaganda).",
    "example": "Vírus: infecta arquivos. Worm: replica pela rede (ex: WannaCry). Trojan: parece legítimo. Ransomware: criptografa + pede resgate. Rootkit: esconde presença no SO. Keylogger: captura digitação."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Fácil",
    "question": "O que é autenticação de dois fatores (2FA)?",
    "options": [
      "Método que exige dois fatores diferentes para confirmar a identidade",
      "Usar duas senhas diferentes",
      "Autenticar em dois servidores ao mesmo tempo",
      "Login com usuário e email"
    ],
    "correctIndex": 0,
    "explanation": "2FA requer dois de três fatores: algo que você sabe (senha), algo que você tem (celular/token) ou algo que você é (biometria). Mesmo que a senha vaze, o atacante não acessa sem o segundo fator.",
    "example": "Fatores: 1) Conhecimento (senha, PIN). 2) Posse (token, celular, smart card). 3) Inerência (digital, face, íris). MFA (Multi-Factor): 2+ fatores. Duas senhas = ainda só 1 fator (conhecimento)."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Fácil",
    "question": "O que é um IDS (Sistema de Detecção de Intrusão)?",
    "options": [
      "Sistema que monitora o tráfego da rede e detecta atividades suspeitas ou maliciosas",
      "Software que bloqueia todos os acessos externos",
      "Protocolo de criptografia de dados",
      "Ferramenta de backup automático"
    ],
    "correctIndex": 0,
    "explanation": "IDS (Intrusion Detection System) analisa o tráfego de rede ou logs de host em busca de padrões de ataque. Tipos: NIDS (baseado em rede) e HIDS (baseado em host). Ele DETECTA e alerta, mas não bloqueia automaticamente.",
    "example": "NIDS: monitora tráfego na rede (Snort, Suricata). HIDS: monitora arquivos e logs no host (OSSEC, Wazuh). Detecção: por assinatura (known attacks) ou anomalia (desvio do normal). IDS é passivo; IPS é ativo."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Fácil",
    "question": "O que é criptografia e por que é importante em redes?",
    "options": [
      "Técnica que transforma dados legíveis em código ilegível para proteger a confidencialidade",
      "Método de compressão de dados para economizar banda",
      "Protocolo de roteamento seguro",
      "Software que acelera a transferência de arquivos"
    ],
    "correctIndex": 0,
    "explanation": "Criptografia converte dados em formato ilegível (cifrado) para quem não possui a chave de decifração. Tipos: simétrica (mesma chave, AES) e assimétrica (par de chaves, RSA). Essencial para HTTPS, VPN, email seguro e armazenamento.",
    "example": "Simétrica: AES-256, ChaCha20 — rápida, usada para dados em trânsito. Assimétrica: RSA, ECDSA — lenta, usada para troca de chaves e assinaturas digitais. Híbrido (TLS): assimétrica troca chave simétrica."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Fácil",
    "question": "O que é uma VLAN e como ela contribui para a segurança em redes locais?",
    "options": [
      "VLAN segmenta logicamente a rede em domínios de broadcast isolados; impede comunicação direta entre segmentos sem passar pelo firewall/roteador",
      "VLAN criptografa o tráfego entre switches para proteção interna",
      "VLAN é uma tecnologia de roteamento para separar redes WAN",
      "VLANs permitem que qualquer host da rede acesse outros hosts diretamente"
    ],
    "correctIndex": 0,
    "explanation": "VLAN (IEEE 802.1Q): tag de 12 bits no frame Ethernet identifica a VLAN (4094 VLANs possíveis). Isolamento de broadcast: dispositivos em VLANs diferentes não recebem broadcasts uns dos outros. Segurança: hosts de diferentes departamentos (RH, TI, Finanças) em VLANs separadas; comunicação inter-VLAN exige L3 (roteador ou switch L3) + ACL/firewall.",
    "example": "Port-based VLAN: porta 1-10 VLAN10 (RH), portas 11-20 VLAN20 (TI). Trunk (802.1Q): carrega múltiplas VLANs entre switches. Native VLAN: tráfego sem tag (risco: VLAN hopping via double-tagging se native VLAN = VLAN de dados). Mitigação: native VLAN dedicada e não utilizada (ex: VLAN 999). Private VLAN: isolamento dentro da mesma VLAN."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Médio__1",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Médio",
    "question": "O que é um ataque Man-in-the-Middle (MitM)?",
    "options": [
      "Interceptar e possivelmente alterar comunicação entre duas partes sem que elas saibam",
      "Sobrecarregar um servidor com requisições",
      "Capturar senhas de Wi-Fi",
      "Injetar código malicioso em websites"
    ],
    "correctIndex": 0,
    "explanation": "No MitM, o atacante se posiciona entre dois comunicantes, capturando e potencialmente modificando dados em trânsito. As vítimas acreditam estar se comunicando diretamente. Pode ocorrer via ARP spoofing, DNS spoofing, rogue access point ou SSL stripping.",
    "example": "Alice↔Mallory↔Bob. Alice pensa que fala com Bob, mas Mallory intercepta. Proteções: HTTPS/TLS, certificate pinning, HSTS, DNSSEC. Em redes locais: ARP spoofing é o vetor mais comum."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Médio__2",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Médio",
    "question": "O que é um ataque de força bruta (brute force) e como se proteger?",
    "options": [
      "Tentativa sistemática de todas as combinações de senha; proteção com lockout, 2FA e senhas longas",
      "Ataque que explora vulnerabilidades de software",
      "Interceptação de tráfego de rede",
      "Injeção de código malicioso em formulários"
    ],
    "correctIndex": 0,
    "explanation": "Brute force: atacante testa todas as combinações possíveis até encontrar a senha. Variante: dictionary attack (palavras comuns). Proteções: lockout após N tentativas, CAPTCHAs, 2FA/MFA, senhas longas e complexas.",
    "example": "Senha de 4 dígitos = 10.000 combinações (segundos). 8 chars alfanuméricos = ~2,8 trilhões. Rate limiting: max 5 tentativas/min. Ferramentas: Hydra, John the Ripper, Hashcat."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Médio__3",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Médio",
    "question": "O que são os protocolos SSL e TLS e qual a diferença?",
    "options": [
      "Protocolos de criptografia para comunicação segura; TLS é o sucessor mais seguro do SSL",
      "SSL é mais seguro que TLS",
      "Ambos são protocolos de roteamento",
      "SSL é usado em email e TLS apenas em web"
    ],
    "correctIndex": 0,
    "explanation": "SSL (Secure Sockets Layer) foi substituído pelo TLS (Transport Layer Security). SSL 3.0 teve vulnerabilidades graves (POODLE). TLS 1.2 e 1.3 são os padrões atuais, criptografando comunicação entre cliente e servidor.",
    "example": "SSL 2.0/3.0: obsoletos. TLS 1.0/1.1: deprecated. TLS 1.2: amplamente usado. TLS 1.3: mais rápido (1-RTT handshake), mais seguro. 'HTTPS = HTTP + TLS'."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Médio__4",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Médio",
    "question": "O que é um ataque de SQL Injection?",
    "options": [
      "Inserção de código SQL malicioso em campos de entrada para manipular o banco de dados",
      "Interceptação de consultas SQL na rede",
      "Quebra de criptografia de bancos de dados",
      "Sobrecarga do servidor de banco de dados com requisições"
    ],
    "correctIndex": 0,
    "explanation": "SQL Injection: o atacante insere comandos SQL em campos de formulário (login, busca). Se a aplicação não sanitiza inputs, o SQL malicioso executa no banco. Pode ler, alterar ou apagar dados, e até executar comandos no SO.",
    "example": "Exemplo: campo login: ' OR '1'='1' -- → bypass de autenticação. Proteção: prepared statements (parameterized queries), ORM, WAF, validação de input, princípio do menor privilégio no DB."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Médio__5",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Médio",
    "question": "O que é 802.1X (controle de acesso baseado em porta)?",
    "options": [
      "Protocolo que exige autenticação antes de conceder acesso à rede via porta de switch ou Wi-Fi",
      "Padrão de cabeamento estruturado",
      "Protocolo de roteamento seguro",
      "Método de criptografia de frames Ethernet"
    ],
    "correctIndex": 0,
    "explanation": "802.1X é o padrão IEEE para NAC (Network Access Control) baseado em porta. Componentes: Suplicante (cliente), Authenticator (switch/AP) e Authentication Server (RADIUS). Antes de autenticar, só permitido tráfego EAP.",
    "example": "Fluxo: PC (suplicante) → Switch (authenticator) → RADIUS (auth server) → AD/LDAP. Se autenticado: porta do switch abre. Se não: porta bloqueada ou VLAN de quarentena."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Médio__6",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Médio",
    "question": "O que é um ataque de XSS (Cross-Site Scripting)?",
    "options": [
      "Injeção de código JavaScript malicioso em páginas web para executar no navegador da vítima",
      "Sobrecarga de servidor com requisições simultâneas",
      "Interceptação de tráfego criptografado",
      "Quebra de senhas por força bruta"
    ],
    "correctIndex": 0,
    "explanation": "XSS permite que o atacante injete scripts maliciosos em páginas vistas por outros usuários. O navegador executa o script confiando na origem. Pode roubar cookies, credenciais ou redirecionar. Tipos: Reflected, Stored e DOM-based.",
    "example": "Reflected: script na URL, executa ao clicar. Stored: script salvo no banco (comentários). DOM-based: manipulação do DOM no cliente. Proteção: output encoding, CSP (Content-Security-Policy), HttpOnly cookies, sanitização de input."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Médio__7",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Médio",
    "question": "O que é um IPS e como difere do IDS?",
    "options": [
      "IPS bloqueia ameaças automaticamente (inline); IDS apenas detecta e alerta (passivo)",
      "IPS é mais lento que IDS",
      "IDS bloqueia e IPS apenas detecta",
      "Ambos são idênticos em funcionalidade"
    ],
    "correctIndex": 0,
    "explanation": "IDS (Detection) monitora tráfego e ALERTA sobre ameaças. IPS (Prevention) monitora E BLOQUEIA automaticamente. IPS fica inline (no caminho do tráfego); IDS fica em modo promiscuous/mirror. IPS pode causar latência mas reage em tempo real.",
    "example": "IDS: modo mirror/span port → alerta → admin investiga. IPS: inline → drop packet automaticamente. Risco IPS: falso positivo bloqueia tráfego legítimo. Ferramentas: Snort, Suricata (ambos podem ser IDS ou IPS). NGFW integra IPS."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Médio__8",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Médio",
    "question": "O que é um ataque de ARP Spoofing e como o Dynamic ARP Inspection (DAI) previne esse ataque?",
    "options": [
      "ARP Spoofing: atacante envia ARP Reply falso associando seu MAC ao IP do gateway (MitM); DAI: switch valida ARP contra binding table do DHCP Snooping, descartando ARPs inválidos",
      "ARP Spoofing exige acesso físico ao switch; DAI não substitui criptografia",
      "DAI bloqueia todo tráfego ARP na rede; hosts precisam usar ARP estático",
      "ARP Spoofing só funciona em redes sem fio; DAI é desnecessário em redes cabeadas"
    ],
    "correctIndex": 0,
    "explanation": "ARP: sem autenticação (stateless). Atacante na mesma VLAN: envia GARP (Gratuitous ARP) ou ARP Reply com MAC=próprio para IP do gateway. Vítimas atualizam ARP cache → tráfego flui pelo atacante (MitM, sniffing, modificação). DAI: compara ARP (sender IP, sender MAC) com binding table do DHCP Snooping (IP+MAC+port). ARP estático em tabela do switch ignora DAI.",
    "example": "Cisco: 'ip arp inspection vlan 10; interface gi0/1; ip arp inspection trust' (uplinks/servers). Limite de rate: 'ip arp inspection limit rate 100'. Ferramentas de ataque: Ettercap, Bettercap, arpspoof. Detecção: XAR (arpwatch), monitoramento de duplicata MAC. Solução complementar: 802.1X + isolamento por porta."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Difícil",
    "question": "Em uma rede corporativa, qual técnica previne ataques de ARP Spoofing?",
    "options": [
      "Dynamic ARP Inspection (DAI) no switch",
      "Usar cabos Cat6A",
      "Aumentar o TTL dos pacotes",
      "Configurar DNS reverso"
    ],
    "correctIndex": 0,
    "explanation": "DAI (Dynamic ARP Inspection) intercepta respostas ARP no switch e as valida contra a tabela do DHCP Snooping. Pacotes ARP com mapeamentos IP-MAC inválidos são descartados. Requer DHCP Snooping habilitado para construir a binding table confiável.",
    "example": "Defesa em camadas: 1) DHCP Snooping (tabela IP↔MAC confiável). 2) DAI (valida ARPs contra essa tabela). 3) IP Source Guard (valida IPs de origem). Configuração Cisco: `ip arp inspection vlan 10`."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Difícil",
    "question": "O que são honeypots e honeynets em segurança de redes?",
    "options": [
      "Sistemas intencionalmente vulneráveis para atrair atacantes e estudar suas técnicas",
      "Firewalls que bloqueiam tráfego malicioso",
      "Redes Wi-Fi seguras para testes",
      "Servidores de backup redundantes"
    ],
    "correctIndex": 0,
    "explanation": "Honeypot é um sistema propositalmente vulnerável para atrair atacantes, estudar técnicas e detectar invasões. Honeynet é uma rede de honeypots. Qualquer acesso é suspeito, pois não há razão legítima para acessá-lo.",
    "example": "Tipos: low-interaction (emula serviços, ex: Honeyd), high-interaction (sistema real). Honeynet = rede completa. Uso: pesquisa de ameaças, early warning, deception defense."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Difícil",
    "question": "O que é o princípio de defesa em profundidade (defense in depth)?",
    "options": [
      "Múltiplas camadas de segurança sobrepostas para que a falha de uma não comprometa o sistema",
      "Instalar o firewall mais caro disponível",
      "Usar apenas um mecanismo de segurança muito forte",
      "Concentrar toda a segurança no perímetro da rede"
    ],
    "correctIndex": 0,
    "explanation": "Defense in depth: múltiplas camadas de proteção. Se uma falha, as outras continuam protegendo. Camadas: perímetro (firewall), rede (IDS/IPS, segmentação), host (antivírus), aplicação (WAF), dados (criptografia, backup).",
    "example": "Analogia: castelo medieval — fosso, muralha, torre, portão. Na rede: firewall → IDS/IPS → VLAN → ACLs → antivírus → criptografia → backup. Zero Trust: 'nunca confie, sempre verifique'."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Difícil",
    "question": "O que é DNS Spoofing (DNS Cache Poisoning)?",
    "options": [
      "Inserção de registros DNS falsos no cache para redirecionar tráfego a sites maliciosos",
      "Bloqueio de todas as consultas DNS",
      "Criptografia forçada de respostas DNS",
      "Sobrecarga do servidor DNS com requisições"
    ],
    "correctIndex": 0,
    "explanation": "DNS Cache Poisoning: o atacante insere registros falsos no cache de um resolver DNS, fazendo um domínio legítimo (ex: banco.com) apontar para um IP malicioso. Vítimas acessam o site falso sem perceber. Proteção: DNSSEC, DoH, DoT.",
    "example": "Ataque Kaminsky (2008): explorou fraqueza do DNS para envenenar caches. DNSSEC: assinaturas digitais validam respostas DNS. DoH/DoT: criptografam consultas DNS. Ferramentas de detecção: Passive DNS monitoring."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Difícil",
    "question": "O que é SIEM e como auxilia a segurança de redes?",
    "options": [
      "Sistema que centraliza, correlaciona e analisa logs de segurança em tempo real",
      "Firewall de última geração",
      "Software antivírus corporativo",
      "Protocolo de autenticação multifator"
    ],
    "correctIndex": 0,
    "explanation": "SIEM (Security Information and Event Management) coleta logs de múltiplas fontes (firewalls, IDS, servidores, endpoints), correlaciona eventos em tempo real e gera alertas de segurança. Essencial para SOC (Security Operations Center).",
    "example": "Ferramentas: Splunk, IBM QRadar, Microsoft Sentinel, Elastic SIEM. Funções: coleta de logs, correlação de eventos, alertas, dashboard, compliance, forense. Regra SIEM: '5 falhas de login em 1 min do mesmo IP → alerta'."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Difícil",
    "question": "O que é Zero Trust Network Access (ZTNA)?",
    "options": [
      "Modelo que verifica continuamente identidade e contexto antes de conceder acesso, sem confiar na rede",
      "VPN corporativa com criptografia dupla",
      "Firewall que bloqueia todo tráfego externo",
      "Protocolo de autenticação biométrica"
    ],
    "correctIndex": 0,
    "explanation": "ZTNA segue o princípio 'nunca confie, sempre verifique'. Cada acesso é autenticado e autorizado individualmente, independente da localização do usuário (interno ou externo). Substitui VPN tradicional em muitos cenários.",
    "example": "VPN: acesso à rede inteira após autenticação. ZTNA: acesso granular por aplicação (micro-segmentação). Soluções: Zscaler Private Access, Cloudflare Access, Google BeyondCorp. SASE = ZTNA + CASB + FWaaS + SD-WAN."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Difícil",
    "question": "O que é um ataque de supply chain em software?",
    "options": [
      "Comprometimento de componentes, bibliotecas ou atualizações de software para atingir usuários finais",
      "Roubo físico de equipamentos de rede",
      "Sobrecarga de servidores de download",
      "Engenharia social contra fornecedores de hardware"
    ],
    "correctIndex": 0,
    "explanation": "Supply chain attack compromete o software na cadeia de distribuição: bibliotecas (npm, PyPI), atualizações (SolarWinds Orion, 2020) ou ferramentas de build. O código malicioso é distribuído como atualização legítima para milhares de vítimas.",
    "example": "SolarWinds (2020): backdoor em atualização → 18.000 organizações afetadas. Codecov (2021): script de CI comprometido. NPM typosquatting: pacotes maliciosos com nomes similares. Defesa: SBOM, assinatura de artefatos, Sigstore."
  },
  {
    "id": "rede-de-computadores__Segurança de Redes__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Segurança de Redes",
    "difficulty": "Difícil",
    "question": "O que é 802.1X (Port-Based Network Access Control) e como funciona o processo de autenticação EAP-TLS?",
    "options": [
      "802.1X: supplicant (cliente), authenticator (switch), authentication server (RADIUS); EAP-TLS: autenticação mútua via certificados X.509 client+server, mais seguro que PEAP/MSCHAPv2",
      "802.1X usa somente senha, sem certificados; EAP-TLS é somente para Wi-Fi",
      "Authenticator e Authentication Server são o próprio switch; não há servidor externo",
      "EAP-TLS só valida o certificado do servidor; o cliente não precisa de certificado"
    ],
    "correctIndex": 0,
    "explanation": "802.1X (IEEE): Supplicant (NIC do cliente), Authenticator (switch/AP), Authentication Server (RADIUS). Fluxo: supplicant envia EAP-Identity → RADIUS desafia → EAP method. EAP-TLS: supplicant apresenta certificado cliente; server apresenta certificado servidor; TLS handshake mútuo; deriva chave de sessão (PMK para Wi-Fi, MAK para wired). Porta bloqueada (uncontrolled) até autenticação.",
    "example": "PKI necessária: CA emite certificados para cada dispositivo (MDM). PEAP-MSCHAPv2: server autentica com cert; cliente com senha AD/LDAP (não recomendado sem validação de cert server). Cisco ISE / FreeRADIUS: RADIUS servers. MAB (MAC Authentication Bypass): fallback para dispositivos sem 802.1X (IoT). CoA (Change of Authorization): RADIUS pode reautenticar ou mover VLAN dinâmica."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Fácil__1",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Fácil",
    "question": "Qual porta padrão é utilizada pelo protocolo HTTP?",
    "options": [
      "80",
      "443",
      "21",
      "25"
    ],
    "correctIndex": 0,
    "explanation": "HTTP usa a porta 80 (não criptografado). HTTPS usa a porta 443 (criptografado com TLS/SSL). Portas bem conhecidas (well-known ports) vão de 0 a 1023 e são reservadas para serviços padrão.",
    "example": "Portas comuns: HTTP=80, HTTPS=443, FTP=21, SSH=22, Telnet=23, SMTP=25, DNS=53, DHCP=67/68, POP3=110, IMAP=143, RDP=3389."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Fácil__2",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Fácil",
    "question": "Qual protocolo é usado para enviar emails?",
    "options": [
      "SMTP (Simple Mail Transfer Protocol)",
      "POP3 (Post Office Protocol)",
      "FTP (File Transfer Protocol)",
      "HTTP (HyperText Transfer Protocol)"
    ],
    "correctIndex": 0,
    "explanation": "SMTP (porta 25 ou 587 com TLS) é usado para ENVIAR emails. POP3 (porta 110) e IMAP (porta 143) são usados para RECEBER/ler. SMTP funciona entre servidores de email e do cliente para o servidor.",
    "example": "Enviar: SMTP (25/587). Receber: POP3 (110) baixa e apaga. IMAP (143) mantém no servidor. Versões seguras: SMTPS (465/587+STARTTLS), POP3S (995), IMAPS (993)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Fácil__3",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Fácil",
    "question": "O que é o protocolo SSH e para que ele é utilizado?",
    "options": [
      "Protocolo de acesso remoto seguro com criptografia, porta 22",
      "Protocolo de transferência de arquivos, porta 21",
      "Protocolo de email, porta 25",
      "Protocolo de navegação web, porta 80"
    ],
    "correctIndex": 0,
    "explanation": "SSH (Secure Shell, porta 22) permite acesso remoto com criptografia forte. Substitui o Telnet (porta 23) que transmite em texto claro. SSH também faz tunneling e transferência de arquivos (SCP, SFTP).",
    "example": "Telnet (23): texto claro = inseguro. SSH (22): criptografado. Usos: terminal remoto, SCP/SFTP, port forwarding. Autenticação: senha ou chave pública (mais seguro)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Fácil__4",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Fácil",
    "question": "O que é o protocolo FTP e quais portas ele utiliza?",
    "options": [
      "Protocolo de transferência de arquivos; porta 21 (controle) e porta 20 (dados)",
      "Protocolo de email; porta 25",
      "Protocolo de acesso remoto; porta 22",
      "Protocolo de resolução DNS; porta 53"
    ],
    "correctIndex": 0,
    "explanation": "FTP (File Transfer Protocol) transfere arquivos entre cliente e servidor. Usa porta 21 para comandos (controle) e porta 20 para transferência de dados (modo ativo). No modo passivo, o servidor indica uma porta alta aleatória para dados.",
    "example": "Modo ativo: cliente abre porta alta → servidor conecta de volta na porta 20. Modo passivo (PASV): servidor indica porta alta → cliente conecta. Passivo funciona melhor com firewalls/NAT."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Fácil__5",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Fácil",
    "question": "Por que o Telnet é considerado inseguro e qual protocolo o substitui?",
    "options": [
      "Transmite tudo em texto claro (inclusive senha); substituído pelo SSH",
      "Não suporta IPv6; substituído pelo HTTP",
      "É muito lento; substituído pelo FTP",
      "Não funciona em Linux; substituído pelo RDP"
    ],
    "correctIndex": 0,
    "explanation": "Telnet (porta 23) transmite TUDO em texto claro, incluindo usuário e senha — qualquer sniffer na rede captura as credenciais. SSH (porta 22) criptografa toda a sessão. Telnet só deve ser usado em redes isoladas de lab.",
    "example": "Demonstração: `tcpdump -A port 23` captura login/senha em texto. Com SSH: dados criptografados, ilegíveis. Telnet ainda usado para testar portas: `telnet servidor 80` (verifica conectividade)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Fácil__6",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Fácil",
    "question": "O que é o protocolo ICMP e para que serve o comando ping?",
    "options": [
      "Protocolo de controle que envia mensagens de diagnóstico; ping usa ICMP para testar conectividade",
      "Protocolo de transferência de arquivos; ping envia arquivos",
      "Protocolo de criptografia; ping verifica certificados",
      "Protocolo de roteamento; ping calcula melhores rotas"
    ],
    "correctIndex": 0,
    "explanation": "ICMP (Internet Control Message Protocol) envia mensagens de erro e diagnóstico. Ping envia Echo Request e recebe Echo Reply para testar se um host está acessível e medir latência. Traceroute/tracert também usa ICMP.",
    "example": "Ping: ICMP tipo 8 (Echo Request) → tipo 0 (Echo Reply). Traceroute: envia pacotes com TTL incremental; cada roteador retorna ICMP Time Exceeded (tipo 11). Outros: Destination Unreachable (tipo 3), Redirect (tipo 5)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Fácil__7",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Fácil",
    "question": "O que é o protocolo ARP e qual sua função?",
    "options": [
      "Protocolo que resolve endereços IP em endereços MAC na rede local",
      "Protocolo que converte nomes de domínio em IPs",
      "Protocolo de roteamento entre sub-redes",
      "Protocolo de criptografia de tráfego local"
    ],
    "correctIndex": 0,
    "explanation": "ARP (Address Resolution Protocol) descobre o endereço MAC correspondente a um IP na mesma sub-rede. O dispositivo envia um ARP Request em broadcast ('quem tem o IP X?') e recebe ARP Reply com o MAC correspondente.",
    "example": "ARP Request: broadcast (ff:ff:ff:ff:ff:ff). ARP Reply: unicast. Tabela ARP: cache local IP↔MAC. Comando: `arp -a`. Problema: ARP Spoofing — atacante envia ARP Reply falso. Proteção: DAI no switch."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Fácil__8",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Fácil",
    "question": "O que é NTP (Network Time Protocol) e por que sincronização de tempo é crítica em redes corporativas?",
    "options": [
      "NTP sincroniza relógios de dispositivos via hierarquia stratum; sincronização correta é essencial para logs correlativos, Kerberos (±5min), certificados TLS, DNSSEC e forense",
      "NTP é usado para transferência de arquivos de configuração entre roteadores",
      "Sincronização de tempo não afeta autenticação; apenas logs precisam de NTP",
      "NTP opera sobre TCP 123; requer conexão estabelecida com o servidor"
    ],
    "correctIndex": 0,
    "explanation": "NTP (RFC 5905): UDP porta 123. Stratum 0: relógio de referência (GPS, atomic). Stratum 1: servidor diretamente conectado. Stratum 2: client de stratum 1. Kerberos: tickets inválidos se skew > 5 minutos. DNSSEC: validação de assinatura depende de tempo correto. Logs: correlação de eventos em SIEMs. Certificados TLS: expired por relógio errado.",
    "example": "NTP pool: pool.ntp.org. Cisco: 'ntp server pool.ntp.org'. Linux: chrony ou systemd-timesyncd. NTPsec: versão segura. Ataques NTP: amplification DDoS (monlist), time-shifting (KSK rollover 2018). PTP (IEEE 1588): precisão nanossegundos para telecom/financeiro. GPS disciplined oscillator: stratum 1 interno."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Médio__1",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Médio",
    "question": "Qual é a diferença principal entre FTP e SFTP?",
    "options": [
      "SFTP usa SSH para criptografia; FTP transmite dados em texto claro",
      "SFTP é mais rápido que FTP",
      "FTP usa porta 22 e SFTP usa porta 21",
      "Não há diferença prática"
    ],
    "correctIndex": 0,
    "explanation": "FTP (porta 21) transmite dados e credenciais em texto claro — vulnerável a interceptação. SFTP (porta 22) opera sobre SSH, criptografando toda a comunicação. Há também FTPS (FTP sobre TLS, portas 990/989), que é diferente de SFTP.",
    "example": "FTP: porta 21 (controle) + porta 20 (dados/ativo). SFTP: porta 22 (via SSH, um único canal). FTPS: FTP + TLS, portas 990/989 (implícito) ou 21 (explícito/STARTTLS)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Médio__2",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Médio",
    "question": "Qual a diferença entre POP3 e IMAP para recebimento de emails?",
    "options": [
      "POP3 baixa emails e remove do servidor; IMAP sincroniza e mantém no servidor",
      "POP3 é mais seguro que IMAP",
      "Ambos são protocolos de envio de email",
      "IMAP usa porta 25 e POP3 usa porta 80"
    ],
    "correctIndex": 0,
    "explanation": "POP3 (porta 110): baixa emails para o dispositivo e remove do servidor. Ideal para um único dispositivo. IMAP (porta 143): mantém no servidor e sincroniza em múltiplos dispositivos (celular + notebook + web).",
    "example": "POP3: offline, local, sem sync multi-device. IMAP: online, servidor, sincronização completa. Gmail/Outlook usam IMAP por padrão. Portas seguras: POP3S=995, IMAPS=993."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Médio__3",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Médio",
    "question": "O que é o protocolo NTP e por que a sincronização de horário é importante?",
    "options": [
      "Protocolo de sincronização de relógio; essencial para logs, certificados e autenticação",
      "Protocolo de transferência de arquivos",
      "Protocolo de backup automático",
      "Protocolo de compressão de dados"
    ],
    "correctIndex": 0,
    "explanation": "NTP (Network Time Protocol, porta 123/UDP) sincroniza os relógios de dispositivos com servidores de tempo. Horário preciso é essencial para: logs (forense), certificados SSL/TLS, Kerberos (tolerância 5 min) e protocolos de roteamento.",
    "example": "Stratum: 0 (relógio atômico), 1 (servidor direto), 2, 3... Precisão: ms em LAN, dezenas ms em WAN. Cisco: `ntp server 200.160.0.8`. Linux: chrony ou ntpd."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Médio__4",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Médio",
    "question": "O que é HTTPS e como difere do HTTP?",
    "options": [
      "HTTP com criptografia TLS; protege dados em trânsito na porta 443",
      "Versão mais rápida do HTTP sem criptografia",
      "Protocolo exclusivo para transferência de arquivos",
      "HTTP com compressão de dados na porta 8080"
    ],
    "correctIndex": 0,
    "explanation": "HTTPS = HTTP + TLS (Transport Layer Security). Criptografa a comunicação entre navegador e servidor (porta 443). Protege contra interceptação (MitM), garante integridade e autentica o servidor via certificado digital.",
    "example": "HTTP (80): texto claro, vulnerável. HTTPS (443): criptografado, certificado SSL/TLS. Chrome marca HTTP como 'Não seguro'. Let's Encrypt: certificados gratuitos. HSTS: força HTTPS no navegador."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Médio__5",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Médio",
    "question": "O que é LDAP e para que é usado em redes corporativas?",
    "options": [
      "Protocolo de acesso a diretórios para gerenciar usuários e recursos (ex: Active Directory)",
      "Protocolo de transferência de arquivos entre servidores",
      "Protocolo de monitoramento de rede",
      "Protocolo de backup automatizado"
    ],
    "correctIndex": 0,
    "explanation": "LDAP (Lightweight Directory Access Protocol, porta 389) acessa e mantém serviços de diretório distribuídos. O Active Directory da Microsoft usa LDAP. Armazena usuários, grupos, políticas e recursos. LDAPS (porta 636) = LDAP com TLS.",
    "example": "Estrutura LDAP: DC=empresa,DC=com → OU=TI → CN=joao. Operações: Bind (login), Search, Add, Modify, Delete. Alternativa moderna: Azure AD (Entra ID) com protocolos web (OAuth/OIDC)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Médio__6",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Médio",
    "question": "O que é um reverse proxy e como difere de um forward proxy?",
    "options": [
      "Reverse proxy fica na frente dos servidores protegendo-os; forward proxy fica na frente dos clientes",
      "Ambos são idênticos em funcionalidade",
      "Reverse proxy acelera downloads; forward proxy bloqueia vírus",
      "Forward proxy é para servidores; reverse proxy é para clientes"
    ],
    "correctIndex": 0,
    "explanation": "Forward proxy: intermediário entre clientes e internet (controle de acesso, cache, anonimato). Reverse proxy: intermediário entre internet e servidores internos (load balancing, SSL termination, cache, proteção).",
    "example": "Forward: Cliente → Proxy → Internet (ex: Squid). Reverse: Internet → Reverse Proxy → Servidores (ex: Nginx, HAProxy, Cloudflare). CDN é um tipo de reverse proxy distribuído globalmente."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Médio__7",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Médio",
    "question": "O que é o protocolo RDP e para que é utilizado?",
    "options": [
      "Protocolo de acesso remoto gráfico da Microsoft, porta 3389, para controlar desktops Windows",
      "Protocolo de transferência de arquivos criptografados",
      "Protocolo de monitoramento de rede",
      "Protocolo de backup remoto de servidores"
    ],
    "correctIndex": 0,
    "explanation": "RDP (Remote Desktop Protocol, porta 3389/TCP) permite acesso remoto com interface gráfica a computadores Windows. Transmite tela, teclado, mouse, áudio e até redirecionamento de dispositivos USB.",
    "example": "RDP: porta 3389. Alternativas: VNC (multi-plataforma, porta 5900), SSH com X11 forwarding (Linux), TeamViewer/AnyDesk. Segurança: NLA (Network Level Authentication), não expor 3389 na internet, usar VPN."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Médio__8",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Médio",
    "question": "Como funciona o protocolo LDAP e qual o fluxo de autenticação com Active Directory?",
    "options": [
      "LDAP (protocolo de diretório TCP 389/636): bind (autenticação), search (consulta de objetos); AD usa LDAP para consultar usuários/grupos; autenticação: client bind com credenciais, AD verifica no DIT",
      "LDAP é um protocolo de transferência de arquivos entre servidores AD",
      "LDAP usa UDP 53; é o mesmo protocolo base do DNS",
      "Active Directory não utiliza LDAP; usa protocolo proprietário SMB"
    ],
    "correctIndex": 0,
    "explanation": "LDAP (Lightweight Directory Access Protocol): RFC 4511. Porta 389 (plain/StartTLS), 636 (LDAPS). Bind: simples (user/pass em texto) ou SASL (GSSAPI/Kerberos). Search: base DN, scope (base/one/sub), filter (objectClass=user)(cn=joao). Active Directory: DIT hierárquico (DC=empresa, DC=com → OU=TI → CN=joao). NTLM vs Kerberos: Kerberos é padrão AD moderno.",
    "example": "ldapsearch: 'ldapsearch -H ldap://dc01 -b dc=empresa,dc=com (sAMAccountName=joao) -W'. LDAPS: TLS sobre 636 (recomendado). StartTLS: negocia TLS no 389. SASL/GSSAPI: usa ticket Kerberos (SSO). LDAP injection: filter manipulation (semelhante SQLi). Mitigação: validação de entrada. Service account: bind read-only. Azure AD: LDAP via Azure AD DS."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Difícil__1",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Difícil",
    "question": "O que é o protocolo SNMP e para que serve o conceito de 'community string'?",
    "options": [
      "Protocolo de gerenciamento de rede; community string é a senha de acesso aos dados do dispositivo",
      "Protocolo de roteamento; community string define a área OSPF",
      "Protocolo de email; community string é o domínio de envio",
      "Protocolo de DNS; community string identifica a zona"
    ],
    "correctIndex": 0,
    "explanation": "SNMP (Simple Network Management Protocol) monitora e gerencia dispositivos de rede (switches, roteadores, servidores). A community string funciona como senha: 'public' (leitura — padrão perigoso) e 'private' (leitura/escrita). SNMPv3 adicionou autenticação real e criptografia.",
    "example": "SNMPv1/v2c: community string em texto claro (inseguro). SNMPv3: autenticação (SHA/MD5) + criptografia (AES/DES). Componentes: Manager (NMS), Agent (no dispositivo), MIB (banco de dados de objetos gerenciáveis)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Difícil__2",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Difícil",
    "question": "O que é QoS (Quality of Service) e como o DSCP prioriza tráfego?",
    "options": [
      "Mecanismo que prioriza tipos de tráfego; DSCP marca pacotes com valores de prioridade",
      "QoS aumenta a banda total disponível; DSCP é protocolo de roteamento",
      "QoS funciona apenas em Wi-Fi; DSCP apenas em cabo",
      "QoS e DSCP são a mesma coisa"
    ],
    "correctIndex": 0,
    "explanation": "QoS prioriza tráfego crítico (VoIP, vídeo) sobre menos prioritário. DSCP (Differentiated Services Code Point) usa 6 bits do cabeçalho IP para marcar prioridade. Switches e roteadores leem o DSCP e enfileiram conforme a prioridade.",
    "example": "DSCP EF (46): VoIP (máxima prioridade). AF: 4 classes × 3 drop probabilities. CS: compatível com IP Precedence. Sem QoS: best-effort (todos iguais, VoIP sofre)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Difícil__3",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre Syslog e SNMP para monitoramento de rede?",
    "options": [
      "Syslog envia logs unidirecionais; SNMP permite consultas bidirecionais e coleta métricas",
      "Ambos são idênticos",
      "Syslog usa SNMP internamente",
      "SNMP é apenas para Windows e Syslog para Linux"
    ],
    "correctIndex": 0,
    "explanation": "Syslog (porta 514/UDP): dispositivos enviam mensagens de log a um servidor centralizado, unidirecional. SNMP (porta 161/162): manager consulta agents (polling) e agents enviam traps, bidirecional, coleta métricas (CPU, memória, tráfego).",
    "example": "Syslog: severidades 0-7 (Emergency→Debug). SNMP: GetRequest, GetNext, Set, Trap. Juntos: SNMP monitora métricas + Syslog registra eventos. Ferramentas: Zabbix/PRTG (SNMP), ELK/Graylog (Syslog)."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Difícil__4",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Difícil",
    "question": "O que é o protocolo RADIUS e como é usado em controle de acesso?",
    "options": [
      "Protocolo AAA centralizado: autenticação, autorização e contabilização de acesso à rede",
      "Protocolo de roteamento dinâmico",
      "Protocolo de transferência criptografada de arquivos",
      "Protocolo de sincronização de relógio"
    ],
    "correctIndex": 0,
    "explanation": "RADIUS (Remote Authentication Dial-In User Service) centraliza AAA: Autenticação (quem é?), Autorização (o que pode fazer?) e Contabilização (o que fez?). Usado com 802.1X para controle de acesso em switches e Wi-Fi empresarial.",
    "example": "RADIUS: porta 1812/1813 (UDP). TACACS+ (Cisco): porta 49 (TCP), criptografa todo o payload. RADIUS criptografa só a senha. 802.1X + RADIUS + AD = NAC completo. FreeRADIUS: implementação open-source."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Difícil__5",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Difícil",
    "question": "O que é NetFlow/sFlow e como difere do SNMP para análise de tráfego?",
    "options": [
      "Capturam metadados de fluxos de tráfego (quem fala com quem); SNMP coleta métricas de dispositivos",
      "São versões diferentes do SNMP",
      "NetFlow substitui o Syslog",
      "sFlow é exclusivo para redes Wi-Fi"
    ],
    "correctIndex": 0,
    "explanation": "NetFlow (Cisco) e sFlow (padrão multi-vendor) exportam informações de fluxos: IP origem/destino, portas, protocolo, bytes, pacotes. Permitem análise detalha de 'quem fala com quem'. SNMP foca em métricas de dispositivos (CPU, interfaces).",
    "example": "NetFlow: amostra todos os pacotes (ou amostrado). sFlow: amostragem estatística (1:N). IPFIX: evolução padronizada do NetFlow v9. Ferramentas: ntopng, ElastiFlow, SolarWinds NTA. Uso: detecção de anomalias, planejamento de capacidade."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Difícil__6",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Difícil",
    "question": "O que é o protocolo TFTP e como difere do FTP?",
    "options": [
      "Protocolo simples via UDP (porta 69), sem autenticação; usado para boot de rede e firmware",
      "Versão criptografada do FTP",
      "Protocolo de email simplificado",
      "FTP com compressão automática"
    ],
    "correctIndex": 0,
    "explanation": "TFTP (Trivial FTP, porta 69/UDP) é extremamente simples: sem autenticação, sem listagem de diretórios, apenas leitura/escrita de arquivos. Usado para PXE boot (boot pela rede), atualização de firmware de switches e transferências em ambientes controlados.",
    "example": "FTP: TCP, portas 20/21, autenticação, diretórios, modos ativo/passivo. TFTP: UDP, porta 69, sem auth, só get/put. TFTP + PXE: switch boots firmware via TFTP. Inseguro — usar apenas em redes isoladas."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Difícil__7",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Difícil",
    "question": "O que é o protocolo MQTT e onde é utilizado?",
    "options": [
      "Protocolo leve de mensageria publish/subscribe usado em IoT e ambientes com banda limitada",
      "Protocolo de transferência de vídeo em tempo real",
      "Protocolo de roteamento para redes móveis",
      "Protocolo de autenticação multifator"
    ],
    "correctIndex": 0,
    "explanation": "MQTT (Message Queuing Telemetry Transport, porta 1883/8883) é um protocolo pub/sub leve, ideal para IoT. Clientes publicam em tópicos e assinam tópicos via broker central. Consome pouca banda e energia.",
    "example": "Modelo: Publisher → Broker (Mosquitto, HiveMQ) → Subscriber. QoS: 0 (at most once), 1 (at least once), 2 (exactly once). Alternativas: AMQP (mais robusto), CoAP (RESTful para IoT). AWS IoT Core usa MQTT."
  },
  {
    "id": "rede-de-computadores__Serviços de Rede__Difícil__8",
    "track": "rede-de-computadores",
    "category": "Serviços de Rede",
    "difficulty": "Difícil",
    "question": "Como funciona o Kerberos v5 e quais os componentes KDC, TGT, TGS e ST no fluxo de autenticação?",
    "options": [
      "KDC contém AS+TGS; cliente autentica no AS recebendo TGT criptografado com chave do usuário; usa TGT no TGS para obter ST (service ticket) para o serviço; serviço valida ST sem precisar do KDC",
      "Kerberos usa canal direto entre cliente e serviço; KDC não participa após o login inicial",
      "TGT e ST são o mesmo ticket; usados de forma intercambiável",
      "Kerberos v5 usa criptografia assimétrica RSA; TGT é assinado com chave pública do KDC"
    ],
    "correctIndex": 0,
    "explanation": "Kerberos v5 (RFC 4120): KDC = AS (Authentication Service) + TGS (Ticket-Granting Service). Fluxo: (1) AS-REQ: client envia user+timestamp cifrado com hash senha. (2) AS-REP: KDC retorna TGT (cifrado com chave do krbtgt) + session key cifrada com hash da senha do usuário. (3) TGS-REQ: client envia TGT ao TGS pedindo ST para serviço. (4) TGS-REP: ST cifrado com chave do serviço. (5) AP-REQ: client apresenta ST ao serviço.",
    "example": "Pass-the-ticket: atacante rouba TGT (mimikatz sekurlsa::tickets). Golden Ticket: forge TGT com hash do krbtgt (persistência). Silver Ticket: forge ST com hash do serviço (sem KDC). Kerberoasting: solicita ST para serviços com SPN, crackeia offline. Mitigação: AES256 (não RC4), LAPS, senha longa do krbtgt rotacionada, Protected Users group, Credential Guard."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Fácil__1",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Fácil",
    "question": "Qual é a principal finalidade de uma VPN?",
    "options": [
      "Criar um túnel criptografado entre dois pontos através de uma rede pública",
      "Acelerar a velocidade da internet",
      "Substituir o uso de roteadores",
      "Bloquear anúncios em sites"
    ],
    "correctIndex": 0,
    "explanation": "VPN (Virtual Private Network) cria um 'túnel' criptografado sobre a internet pública, permitindo comunicação segura como se os dispositivos estivessem na mesma rede privada. Protege confidencialidade e integridade dos dados em trânsito.",
    "example": "Exemplo: funcionário em home office usa VPN para acessar servidores da empresa como se estivesse no escritório. Tráfego é criptografado e encapsulado, invisível a terceiros na internet."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Fácil__2",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Fácil",
    "question": "O que é um túnel VPN?",
    "options": [
      "Canal criptografado dentro de uma rede pública que protege os dados em trânsito",
      "Cabo físico subterrâneo entre dois sites",
      "Tipo de firewall para redes remotas",
      "Protocolo de roteamento dinâmico"
    ],
    "correctIndex": 0,
    "explanation": "Um túnel VPN encapsula dados em um protocolo de tunelamento (IPsec, OpenVPN, WireGuard), criptografando todo o conteúdo. O pacote original fica dentro de um novo pacote, como carta em envelope lacrado.",
    "example": "Protocolos: IPsec, OpenVPN (SSL/TLS), WireGuard, L2TP, PPTP (obsoleto). O tráfego encapsulado parece normal para observadores externos na rede pública."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Fácil__3",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Fácil",
    "question": "Cite dois usos comuns de VPN no dia a dia.",
    "options": [
      "Acesso remoto ao trabalho e proteção em redes Wi-Fi públicas",
      "Acelerar downloads e aumentar velocidade da internet",
      "Bloquear vírus e substituir o antivírus",
      "Aumentar o alcance do Wi-Fi e melhorar o sinal"
    ],
    "correctIndex": 0,
    "explanation": "Usos comuns: 1) Home office — acessar rede corporativa com segurança. 2) Wi-Fi público — proteção contra interceptação. 3) Acesso a conteúdo geo-restrito. 4) Privacidade de navegação.",
    "example": "Corporativo: site-to-site (escritórios) e remote access (funcionários). Pessoal: NordVPN, ExpressVPN para privacidade. VPN não torna anônimo — o provedor de VPN vê o tráfego."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Fácil__4",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Fácil",
    "question": "O que acontece com seus dados quando você se conecta a uma VPN?",
    "options": [
      "São criptografados antes de sair do dispositivo e viajam por um túnel seguro",
      "São comprimidos para economizar banda",
      "Ficam armazenados no servidor VPN para sempre",
      "São duplicados para redundância"
    ],
    "correctIndex": 0,
    "explanation": "Com VPN ativa, todos os dados (ou parte, no split tunnel) são criptografados no dispositivo ANTES de saírem pela rede. Viajam pelo túnel VPN até o servidor VPN, que decifra e encaminha ao destino. Na volta, o processo é inverso.",
    "example": "Fluxo: App → Criptografia (VPN client) → Internet (túnel criptografado) → VPN Server → Decifra → Destino. Observadores na rede local ou ISP veem apenas dados cifrados."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Fácil__5",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Fácil",
    "question": "O que é um concentrador VPN?",
    "options": [
      "Dispositivo que gerencia múltiplas conexões VPN simultâneas",
      "Cabo especial para VPN",
      "Software antivírus com VPN integrada",
      "Roteador que bloqueia VPNs"
    ],
    "correctIndex": 0,
    "explanation": "O concentrador VPN (VPN gateway/headend) é o servidor ou appliance que aceita e gerencia múltiplas conexões VPN simultaneamente. Em empresas: Cisco ASA, FortiGate, pfSense. Gerencia autenticação, criptografia e roteamento dos túneis.",
    "example": "Concentrador é o ponto central (hub). Funcionários remotos (spokes) conectam-se ao concentrador. Capacidade: centenas ou milhares de túneis simultâneos. Redundância: HA (high availability) com failover."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Fácil__6",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Fácil",
    "question": "O que é PPTP e por que não é recomendado atualmente?",
    "options": [
      "Protocolo VPN antigo com vulnerabilidades de criptografia conhecidas; substituído por IPsec/WireGuard",
      "Protocolo VPN mais seguro disponível",
      "Protocolo de roteamento dinâmico",
      "Método de compressão de dados"
    ],
    "correctIndex": 0,
    "explanation": "PPTP (Point-to-Point Tunneling Protocol, porta TCP 1723) foi um dos primeiros protocolos VPN. Sua criptografia (MS-CHAPv2) tem vulnerabilidades graves e pode ser quebrada. Não deve ser usado em ambientes que exigem segurança.",
    "example": "PPTP: rápido de configurar, mas inseguro. MS-CHAPv2 quebrável com ferramentas como chapcrack. Alternativas seguras: IPsec, OpenVPN, WireGuard, L2TP/IPsec. PPTP ainda presente em equipamentos legados."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Fácil__7",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Fácil",
    "question": "O que é L2TP e como é combinado com IPsec?",
    "options": [
      "Protocolo de tunelamento L2 sem criptografia própria; combinado com IPsec (L2TP/IPsec) para segurança",
      "Protocolo de criptografia que substitui o IPsec",
      "Protocolo de roteamento para VPNs",
      "Software de gerenciamento de túneis"
    ],
    "correctIndex": 0,
    "explanation": "L2TP (Layer 2 Tunneling Protocol) encapsula dados na camada 2 mas NÃO criptografa. Por isso é combinado com IPsec: L2TP cria o túnel e IPsec fornece criptografia e autenticação. L2TP/IPsec usa porta UDP 1701.",
    "example": "L2TP sozinho: tunelamento sem segurança. L2TP/IPsec: encapsula L2TP dentro de ESP (IPsec). Duplo encapsulamento = mais overhead vs OpenVPN/WireGuard. Suporte nativo: Windows, macOS, iOS, Android."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Fácil__8",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre VPN Site-to-Site e VPN de Acesso Remoto (Client VPN)?",
    "options": [
      "Site-to-Site: conecta duas redes permanentemente via gateways VPN; Client VPN: usuário instala software VPN para acessar a rede corporativa de local remoto",
      "Site-to-Site requer certificados; Client VPN usa apenas senha",
      "Site-to-Site é mais lenta; Client VPN usa hardware dedicado dos dois lados",
      "São equivalentes; a diferença é apenas o número de usuários conectados"
    ],
    "correctIndex": 0,
    "explanation": "Site-to-Site (LAN-to-LAN): gateway A negocia IPSec/IKE com gateway B; subredes atrás de cada gateway são alcançáveis mutuamente. Gerenciado pela TI, permanente. Client VPN (Remote Access): usuário instala cliente (OpenVPN, Cisco AnyConnect, WireGuard). Split tunneling: só corporativo passa pelo túnel. Full tunnel: todo tráfego passa pelo VPN.",
    "example": "IPSec Site-to-Site: IKEv2 (recomendado) ou IKEv1. Cisco ASA, Fortinet, pfSense. GRE: encapsula multicast/roteamento dinâmico (não criptografado → encapsular em IPSec). SD-WAN: VPN automatizada com policies de QoS. WireGuard: mais simples e rápido que OpenVPN. SSL VPN: HTTP-based (porta 443), atravessa firewall corporativo."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Médio__1",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Médio",
    "question": "Qual a diferença entre VPN site-to-site e VPN de acesso remoto?",
    "options": [
      "Site-to-site conecta redes inteiras; acesso remoto conecta um usuário individual à rede",
      "Ambas são idênticas",
      "Site-to-site não usa criptografia",
      "Acesso remoto é mais seguro"
    ],
    "correctIndex": 0,
    "explanation": "Site-to-site: conecta duas redes inteiras (ex: escritórios de uma empresa em cidades diferentes) de forma permanente. Usa roteadores/firewalls nas pontas. Acesso remoto: um usuário individual se conecta à rede corporativa (ex: home office) via software cliente VPN. Conexão sob demanda.",
    "example": "Site-to-site: Escritório SP ↔ Escritório RJ (sempre ligado, roteador-a-roteador). Acesso remoto: Notebook de José → Internet → VPN Server da empresa (sob demanda, cliente VPN no notebook)."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Médio__2",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Médio",
    "question": "Quais são as principais diferenças entre IPsec e OpenVPN?",
    "options": [
      "IPsec opera na camada 3 (kernel); OpenVPN opera na camada 7 (SSL/TLS, user-space)",
      "Ambos são idênticos em funcionamento",
      "IPsec é open-source e OpenVPN é proprietário",
      "OpenVPN é mais rápido em todos os cenários"
    ],
    "correctIndex": 0,
    "explanation": "IPsec: camada 3, integrado ao kernel, usa IKE para negociação. Complexo mas rápido. OpenVPN: camada 7, SSL/TLS, user-space, mais fácil de configurar e atravessar firewalls (porta 443). WireGuard é alternativa mais nova e rápida.",
    "example": "IPsec: kernel-space, UDP 500/4500, suporte nativo em roteadores. OpenVPN: user-space, TCP/UDP 1194 ou 443. WireGuard: kernel, UDP, mais simples que ambos."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Médio__3",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Médio",
    "question": "O que é split tunneling em VPN e quais os riscos?",
    "options": [
      "Parte do tráfego vai pela VPN e parte direto pela internet; risco de vazamento de dados",
      "Usar duas VPNs simultaneamente",
      "Dividir a banda entre upload e download",
      "Conectar a duas redes corporativas ao mesmo tempo"
    ],
    "correctIndex": 0,
    "explanation": "Split tunneling: apenas tráfego corporativo passa pela VPN; o restante vai direto pela internet. Reduz carga no concentrador VPN, mas cria risco: malware na internet pode acessar a rede corporativa via dispositivo dual-homed.",
    "example": "Full tunnel: TODO tráfego → VPN (mais seguro, mais lento). Split tunnel: só corporativo → VPN, resto → internet (menos seguro, mais rápido). Risco: PC infectado vira ponte."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Médio__4",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Médio",
    "question": "O que é WireGuard e quais suas vantagens?",
    "options": [
      "Protocolo VPN moderno, simples (~4000 linhas de código), rápido e com criptografia moderna",
      "Versão atualizada do IPsec",
      "Protocolo VPN exclusivo para Windows",
      "Firewall que inclui VPN integrada"
    ],
    "correctIndex": 0,
    "explanation": "WireGuard é um protocolo VPN moderno com apenas ~4000 linhas de código (vs 600K do OpenVPN). Usa criptografia de última geração (ChaCha20, Curve25519, BLAKE2s). Integrado ao kernel Linux. Mais rápido e simples de auditar.",
    "example": "IPsec: complexo, muitas opções. OpenVPN: modular, user-space. WireGuard: minimalista, kernel-space, UDP. Throughput: WireGuard > IPsec > OpenVPN. Adotado: Cloudflare WARP, Mullvad, Tailscale."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Médio__5",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Médio",
    "question": "O que é NAT-T (NAT Traversal) em VPN IPsec?",
    "options": [
      "Encapsula pacotes IPsec em UDP porta 4500 para atravessar dispositivos NAT",
      "Protocolo de roteamento para VPNs",
      "Técnica de compressão de pacotes VPN",
      "Método de autenticação multifator para VPN"
    ],
    "correctIndex": 0,
    "explanation": "IPsec usa protocolo ESP (IP 50) que não tem portas — incompatível com NAT. NAT-T detecta NAT no caminho e encapsula ESP dentro de UDP porta 4500, permitindo que o tráfego passe por roteadores NAT normalmente.",
    "example": "Sem NAT-T: ESP (prot 50) → NAT altera IP → checksum inválido → falha. Com NAT-T: [IP][UDP 4500][ESP][Dados] → NAT traduz normalmente. IKE negocia NAT-T automaticamente (RFC 3947)."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Médio__6",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Médio",
    "question": "O que é Perfect Forward Secrecy (PFS) em VPN?",
    "options": [
      "Propriedade que garante que comprometimento de uma chave não compromete sessões anteriores",
      "Método de compressão de dados em VPN",
      "Protocolo de redundância de túneis",
      "Técnica de balanceamento de carga entre VPNs"
    ],
    "correctIndex": 0,
    "explanation": "PFS gera chaves de sessão efemeras via Diffie-Hellman a cada sessão. Se a chave privada de longo prazo for comprometida, sessões passadas permanecem seguras. IKEv2 suporta PFS nativamente.",
    "example": "Sem PFS: chave master comprometida → todas as sessões gravadas podem ser decifradas. Com PFS: cada sessão gera chave DH única → impossível decifrar sessões passadas. TLS 1.3 também exige PFS (ECDHE)."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Médio__7",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Médio",
    "question": "O que é SSL VPN e como difere do IPsec VPN?",
    "options": [
      "VPN baseada em SSL/TLS que funciona via navegador ou cliente leve; mais fácil de atravessar firewalls",
      "Versão mais antiga do IPsec",
      "VPN exclusiva para redes locais",
      "Protocolo de roteamento com criptografia"
    ],
    "correctIndex": 0,
    "explanation": "SSL VPN usa TLS (porta 443) e pode funcionar via navegador (clientless/portal) ou cliente leve. Atravessa firewalls facilmente (porta 443 geralmente aberta). IPsec requer cliente específico e portas UDP 500/4500.",
    "example": "SSL VPN clientless: acessa apps web via portal HTTPS (sem instalar nada). SSL VPN full-tunnel: cliente leve, acesso completo à rede. Cisco AnyConnect, FortiClient, Pulse Secure. IPsec: mais performance, SSL VPN: mais flexibilidade."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Médio__8",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Médio",
    "question": "Como funciona o protocolo IKEv2 e como ele estabelece uma SA (Security Association) IPSec?",
    "options": [
      "IKEv2: troca inicial IKE_SA_INIT (negotiates crypto, Diffie-Hellman) + IKE_AUTH (autentica identidades, cria CHILD_SA para dados); menos round trips que IKEv1",
      "IKEv2 usa 6 trocas de mensagens; IKEv1 usa apenas 2",
      "IKEv2 não suporta certificados; somente PSK (pre-shared key)",
      "IKE_AUTH é opcional em IKEv2; a autenticação é feita fora de banda"
    ],
    "correctIndex": 0,
    "explanation": "IKEv2 (RFC 7296): 2 messages IKE_SA_INIT (propõe algoritmos crypto, troca DH pubkeys, nonces) + 2 messages IKE_AUTH (autentica: cert/PSK/EAP, cria primeira CHILD_SA com ESP/AH). CHILD_SA = IPSec SA (SPI, algoritmo, chaves, seletores de tráfego). ESP (Encapsulating Security Payload): criptografia + autenticação. AH: somente autenticação. Modos: Tunnel (encapsula IP completo) ou Transport.",
    "example": "DH groups: 14 (2048-bit MODP, mínimo), 19-21 (ECDH). AEAD: AES-GCM (criptografia+integridade em um). Perfect Forward Secrecy: nova troca DH por CHILD_SA. MOBIKE (RFC 4555): suporte a roaming de IP (IKEv2). Diagnóstico: 'show crypto isakmp sa' (Cisco). strongSwan: IKEv2 Linux. Rekeying: renovação automática de SA antes do lifetime expirar."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Difícil__1",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre os modos Túnel e Transporte no IPsec?",
    "options": [
      "Modo Túnel encapsula o pacote IP inteiro com novo cabeçalho; Modo Transporte protege apenas o payload",
      "Não há diferença prática",
      "Modo Transporte é usado apenas em IPv6",
      "Modo Túnel não criptografa dados"
    ],
    "correctIndex": 0,
    "explanation": "Modo Transporte: protege apenas o payload (dados) do pacote IP original, mantendo o cabeçalho IP original. Usado em comunicação host-to-host. Modo Túnel: encapsula o pacote IP INTEIRO (cabeçalho + dados) dentro de um novo pacote com novo cabeçalho IP. Usado em VPN site-to-site e gateway-to-gateway.",
    "example": "Transporte: [IP_orig][ESP/AH][Payload_criptografado]. Túnel: [Novo_IP][ESP/AH][IP_orig_criptografado][Payload_criptografado]. Túnel esconde o IP original interno, essencial em VPNs site-to-site."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Difícil__2",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Difícil",
    "question": "O que é IKE (Internet Key Exchange) e qual seu papel no IPsec?",
    "options": [
      "Protocolo que negocia parâmetros de segurança e troca chaves criptográficas para IPsec",
      "Protocolo de roteamento para VPNs",
      "Algoritmo de criptografia simétrica",
      "Método de autenticação via RADIUS"
    ],
    "correctIndex": 0,
    "explanation": "IKE negocia os Security Associations (SAs) do IPsec: Fase 1 (IKE SA) autentica os peers e estabelece canal seguro. Fase 2 (IPsec SA) negocia parâmetros do túnel. IKEv2 simplifica e suporta MOBIKE (mobilidade).",
    "example": "IKEv1: Main Mode (6 msgs) ou Aggressive (3). IKEv2: 4 mensagens (IKE_SA_INIT + IKE_AUTH). Porta UDP 500, 4500 (NAT-T). Autenticação: PSK ou certificados."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Difícil__3",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre GRE e IPsec e por que são combinados?",
    "options": [
      "GRE encapsula mas não criptografa; IPsec criptografa mas não suporta multicast. GRE over IPsec combina ambos",
      "GRE é mais seguro que IPsec",
      "Ambos são protocolos de roteamento",
      "GRE substitui o IPsec em redes modernas"
    ],
    "correctIndex": 0,
    "explanation": "GRE (protocolo 47): tunela qualquer protocolo (multicast, IPv6 over IPv4) mas SEM criptografia. IPsec (ESP protocolo 50): criptografa e autentica mas não suporta multicast nativamente. GRE over IPsec: tunelamento GRE + criptografia IPsec.",
    "example": "GRE: encapsula, sem criptografia. IPsec: criptografa, sem multicast. GRE over IPsec: OSPF/EIGRP + criptografia. mGRE + IPsec = DMVPN (Dynamic Multipoint VPN)."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Difícil__4",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Difícil",
    "question": "O que é DMVPN (Dynamic Multipoint VPN) e qual sua vantagem?",
    "options": [
      "Permite túneis hub-and-spoke e spoke-to-spoke dinâmicos sem configuração ponto-a-ponto",
      "VPN que só funciona em redes locais",
      "Protocolo de roteamento para VPNs",
      "VPN que não requer criptografia"
    ],
    "correctIndex": 0,
    "explanation": "DMVPN (Cisco) usa mGRE + NHRP + IPsec. Spokes constroem túneis sob demanda diretamente entre si (spoke-to-spoke), sem passar pelo hub. Elimina configuração manual ponto-a-ponto em redes com muitas filiais.",
    "example": "Fases: Phase 1 (hub-spoke), Phase 2 (spoke-spoke via NHRP), Phase 3 (spoke-spoke com sumário/default). NHRP: Next-Hop Resolution Protocol — mapeia tunnel IP → NBMA address (IP real)."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Difícil__5",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre MPLS VPN e IPsec VPN?",
    "options": [
      "MPLS VPN usa rótulos na rede da operadora (sem criptografia nativa); IPsec criptografa sobre internet pública",
      "Ambas são idênticas",
      "MPLS é gratuito e IPsec é pago",
      "IPsec funciona apenas em redes locais"
    ],
    "correctIndex": 0,
    "explanation": "MPLS VPN (L3VPN): operadora cria VRFs isoladas na rede MPLS — tráfego privado sem criptografia (depende da confiança na operadora). IPsec VPN: criptografa sobre a internet pública (mais barato, menos SLA). Combinação: MPLS + IPsec = privacidade + criptografia.",
    "example": "MPLS L3VPN: PE (Provider Edge) + CE (Customer Edge) + VRF. QoS garantido, SLA da operadora, custo alto. IPsec: internet, custo baixo, sem SLA. SD-WAN: combina MPLS + internet + IPsec + políticas inteligentes."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Difícil__6",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Difícil",
    "question": "O que é SD-WAN e como se relaciona com VPNs?",
    "options": [
      "Tecnologia que virtualiza a WAN combinando múltiplos links com políticas inteligentes de roteamento",
      "Versão sem fio do IPsec",
      "Protocolo de roteamento exclusivo para VPNs",
      "Firewall dedicado para tráfego VPN"
    ],
    "correctIndex": 0,
    "explanation": "SD-WAN (Software-Defined WAN) abstrai o transporte (MPLS, internet, 4G/5G) e aplica políticas inteligentes: tráfego crítico via MPLS, bulk via internet. Inclui VPN IPsec automática entre sites, simplificando a gestão.",
    "example": "Sem SD-WAN: MPLS caro, configuração manual. Com SD-WAN: orquestração centralizada, failover automático. Vendors: Cisco Viptela, VMware VeloCloud, Fortinet, Silver Peak. SASE = SD-WAN + segurança (ZTNA, CASB, FWaaS)."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Difícil__7",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Difícil",
    "question": "O que é VXLAN e como estende redes L2 sobre L3?",
    "options": [
      "Protocolo overlay que encapsula frames Ethernet em UDP/IP, criando até 16 milhões de segmentos",
      "Protocolo de criptografia para VLANs",
      "Versão estendida do IPsec",
      "Técnica de compressão de tráfego de rede"
    ],
    "correctIndex": 0,
    "explanation": "VXLAN (Virtual Extensible LAN, RFC 7348) encapsula frames L2 em pacotes UDP/IP (porta 4789), permitindo estender domínios L2 sobre redes L3. Usa VNI (VXLAN Network Identifier) de 24 bits = ~16 milhões de segmentos (vs 4096 VLANs).",
    "example": "VLAN: 12 bits = 4094 IDs. VXLAN: 24 bits = ~16M VNIs. VTEP (VXLAN Tunnel Endpoint): encapsula/desencapsula frames. Usado em data centers e cloud (multi-tenant). Concorrentes: NVGRE, Geneve (preferêncial no Linux)."
  },
  {
    "id": "rede-de-computadores__VPN e Túneis__Difícil__8",
    "track": "rede-de-computadores",
    "category": "VPN e Túneis",
    "difficulty": "Difícil",
    "question": "Como o WireGuard se diferencia de IPSec e OpenVPN em design e segurança criptográfica?",
    "options": [
      "WireGuard: código minimal (~4000 linhas), crypto moderna fixa (ChaCha20-Poly1305, Curve25519, BLAKE2), sem negociação de cipher; IPSec e OpenVPN: flexíveis mas complexos (maior superfície de ataque), configurações fracas possíveis",
      "WireGuard usa RSA como IPSec; a única diferença é o tamanho do código",
      "OpenVPN é mais seguro por ter mais opções de cifra que WireGuard",
      "WireGuard não suporta autenticação de usuários; IPSec e OpenVPN suportam"
    ],
    "correctIndex": 0,
    "explanation": "WireGuard (RFC 2019+ , production-ready Linux 5.6): Noise Protocol Framework, ChaCha20-Poly1305 (AEAD), Curve25519 (DH), BLAKE2s (hash), HKDF (key derivation). Sem negociação: apenas um cipher suite. Handshake: 1-RTT. Roaming IP: nativo. Comparação: IPSec (IKEv2) ~100k linhas código, suporta algoritmos fracos (3DES, MD5 se configurado mal). OpenVPN: baseado em OpenSSL, TLS, flexível mas verboso.",
    "example": "WireGuard peers: chaves públicas (Curve25519) configuradas manualmente. AllowedIPs: seletores de tráfego por prefixo. Stealth: sem resposta a pacotes não autenticados (não expõe presença). Linux kernel module: performance nativa no caminho de dados. Mullvad, ProtonVPN: usam WireGuard. Comparação benchmark: WireGuard > 3× mais rápido que OpenVPN em throughput. Limitation: sem PKI nativa; soluções: Tailscale, Netbird."
  },
  {
    "id": "rede-de-computadores__VoIP__Fácil__1",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Fácil",
    "question": "O que significa VoIP?",
    "options": [
      "Voice over Internet Protocol — voz transmitida pela internet",
      "Video over IP — vídeo pela internet",
      "Virtual Office IP — escritório virtual",
      "Voice over Intranet Protocol — voz em intranet"
    ],
    "correctIndex": 0,
    "explanation": "VoIP (Voice over Internet Protocol) é a tecnologia que permite transmitir chamadas de voz pela internet ou redes IP, em vez de usar a rede telefônica tradicional (PSTN). Exemplos: Skype, WhatsApp, Zoom, Microsoft Teams.",
    "example": "A voz é digitalizada, comprimida em codecs (G.711, G.729), empacotada em RTP/UDP/IP e transmitida pela rede. Vantagens: custo menor, integração com dados, flexibilidade. Desafio: qualidade depende da rede."
  },
  {
    "id": "rede-de-computadores__VoIP__Fácil__2",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Fácil",
    "question": "Cite um exemplo popular de aplicativo que usa tecnologia VoIP.",
    "options": [
      "WhatsApp, Skype ou Zoom — chamadas de voz pela internet",
      "Microsoft Word — processador de texto",
      "Antivírus Kaspersky — proteção contra malware",
      "FileZilla — transferência de arquivos"
    ],
    "correctIndex": 0,
    "explanation": "WhatsApp, Skype, Zoom, Microsoft Teams, Google Meet e Discord usam VoIP para chamadas pela internet. Economizam custos em relação à telefonia tradicional (PSTN) e permitem chamadas internacionais gratuitas.",
    "example": "Pessoal: WhatsApp, Telegram, FaceTime. Empresarial: Teams, Cisco Webex, Zoom Phone. Tradicional: Asterisk (PBX open-source). Softphone: app que simula telefone (Zoiper, Linphone)."
  },
  {
    "id": "rede-de-computadores__VoIP__Fácil__3",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Fácil",
    "question": "Qual a principal vantagem do VoIP em relação à telefonia convencional (PSTN)?",
    "options": [
      "Custo menor e integração com dados — chamadas pela internet",
      "Qualidade de áudio sempre superior à PSTN",
      "Funciona sem internet",
      "Não requer nenhum equipamento especial"
    ],
    "correctIndex": 0,
    "explanation": "Vantagens: custo reduzido (especialmente internações), integração com sistemas (CRM, email), mobilidade, escalabilidade (ramais simples) e funcionalidades avançadas (gravação, URA, videoconferência).",
    "example": "VoIP: custo por ligação ≈ 0 (internet). PSTN: tarifação por minuto. Desvantagens VoIP: depende da internet, latência, jitter, perda de pacotes. PSTN: qualidade garantida mas cara."
  },
  {
    "id": "rede-de-computadores__VoIP__Fácil__4",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Fácil",
    "question": "Qual protocolo de transporte (TCP ou UDP) é usado nas chamadas VoIP e por quê?",
    "options": [
      "UDP — menor latência e retransmissão não faz sentido em áudio em tempo real",
      "TCP — porque garante entrega de todos os pacotes",
      "Ambos são usados igualmente",
      "Nem TCP nem UDP — usa protocolo próprio"
    ],
    "correctIndex": 0,
    "explanation": "VoIP usa UDP porque áudio em tempo real não tolera atrasos de retransmissão do TCP. Se um pacote se perde, retransmiti-lo chegaria tarde demais. Melhor ignorar e continuar. RTP (sobre UDP) é o protocolo que transporta a mídia.",
    "example": "TCP: confiável mas com retransmissões (atraso). UDP: sem garantia mas sem atraso. Para VoIP, pacote atrasado = inútil. Perda ≤ 1% é imperceptível. SIP (sinalização) pode usar TCP ou UDP."
  },
  {
    "id": "rede-de-computadores__VoIP__Fácil__5",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Fácil",
    "question": "O que é um softphone?",
    "options": [
      "Aplicativo que permite fazer chamadas VoIP usando computador ou celular",
      "Telefone com tela sensível ao toque",
      "Hardware especializado para VoIP",
      "Software de gravação de ligações"
    ],
    "correctIndex": 0,
    "explanation": "Softphone é um software que simula um telefone, permitindo fazer/receber chamadas VoIP pelo computador ou celular. Usa microfone e alto-falante do dispositivo. Exemplos: Zoiper, Linphone, Cisco Jabber, Microsoft Teams.",
    "example": "Softphone vs Hardphone (telefone IP físico): softphone é mais flexível e barato. Hardphone: melhor qualidade de áudio, dedicado. Webphone: softphone no navegador (WebRTC). Todos registram-se no PBX via SIP."
  },
  {
    "id": "rede-de-computadores__VoIP__Fácil__6",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Fácil",
    "question": "O que é latência em chamadas VoIP?",
    "options": [
      "Atraso entre falar e a outra pessoa ouvir; deve ser menor que 150ms para boa qualidade",
      "Volume do áudio durante a chamada",
      "Número de chamadas simultâneas suportadas",
      "Qualidade do codec utilizado"
    ],
    "correctIndex": 0,
    "explanation": "Latência (delay) é o tempo total para a voz sair do falante e chegar ao ouvinte. Inclui: codificação, empacotamento, propagação na rede e jitter buffer. Até 150ms: imperceptível. 150-300ms: perceptível. >300ms: conversação difícil.",
    "example": "Fontes de latência: codec (5-40ms), packetization (20ms), jitter buffer (20-80ms), propagação (5ms/1000km), serialization. Latência um sentido (one-way) < 150ms (ITU-T G.114). Satélite GEO: ~250ms só propagação."
  },
  {
    "id": "rede-de-computadores__VoIP__Fácil__7",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Fácil",
    "question": "O que é SIP (Session Initiation Protocol)?",
    "options": [
      "Protocolo de sinalização que inicia, modifica e encerra sessões de comunicação VoIP",
      "Protocolo que transporta o áudio da chamada",
      "Codec de compressão de voz",
      "Software de PBX para empresas"
    ],
    "correctIndex": 0,
    "explanation": "SIP (Session Initiation Protocol, porta 5060/5061) é o protocolo de sinalização dominante em VoIP. Ele estabelece, modifica e encerra chamadas. O áudio em si é transportado por RTP. SIP é baseado em texto, similar ao HTTP.",
    "example": "Mensagens SIP: INVITE (iniciar), 200 OK (aceitar), ACK (confirmar), BYE (encerrar), REGISTER (registrar no servidor). SIP Proxy: roteamento de chamadas. SIP Registrar: mantém localização dos usuários."
  },
  {
    "id": "rede-de-computadores__VoIP__Fácil__8",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Fácil",
    "question": "O que é o protocolo SIP e qual sua função em sistemas de telefonia VoIP?",
    "options": [
      "SIP (Session Initiation Protocol): protocolo de sinalização para estabelecer, modificar e encerrar sessões multimídia (chamadas VoIP); a mídia em si é transportada por RTP",
      "SIP transporta o áudio da chamada VoIP diretamente em seus pacotes",
      "SIP é um protocolo proprietário da Cisco; H.323 é o padrão aberto equivalente",
      "SIP opera sobre TCP somente; UDP não é suportado para chamadas de voz"
    ],
    "correctIndex": 0,
    "explanation": "SIP (RFC 3261): protocolo de sinalização application-layer (texto, similar HTTP). Funções: REGISTER (registra ramal), INVITE (inicia chamada), BYE (encerra), ACK (confirma), CANCEL, OPTIONS. Portas: UDP/TCP 5060, TLS 5061. Mídia: negociada via SDP (Session Description Protocol) no body do INVITE; transportada por RTP (UDP). Codecs: G.711, G.729, Opus.",
    "example": "Fluxo básico: INVITE → 100 Trying → 180 Ringing → 200 OK → ACK → RTP (mídia) → BYE → 200 OK. H.323: padrão mais antigo (binário, mais complexo). SBC (Session Border Controller): proxy SIP na borda, NAT traversal, segurança. Media gateway: converte PSTN/TDM para VoIP. QoS: DSCP EF (46) para RTP, AF31 para sinalização SIP."
  },
  {
    "id": "rede-de-computadores__VoIP__Médio__1",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Médio",
    "question": "Qual protocolo é responsável por transportar o áudio em tempo real nas chamadas VoIP?",
    "options": [
      "RTP (Real-time Transport Protocol)",
      "SIP (Session Initiation Protocol)",
      "HTTP",
      "SMTP"
    ],
    "correctIndex": 0,
    "explanation": "RTP transporta o fluxo de áudio/vídeo em tempo real. SIP é responsável por sinalização (iniciar, modificar, encerrar chamadas), mas não carrega o áudio. RTP usa UDP para baixa latência e inclui timestamps e números de sequência para reordenação.",
    "example": "SIP: sinalização (INVITE → 200 OK → ACK → BYE). RTP: transporte de mídia (áudio/vídeo em tempo real). RTCP: relatórios de qualidade (jitter, perda de pacotes). Porta RTP: dinâmica (tipicamente 16384-32767)."
  },
  {
    "id": "rede-de-computadores__VoIP__Médio__2",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Médio",
    "question": "Qual a diferença entre os protocolos SIP e H.323 em VoIP?",
    "options": [
      "SIP é baseado em texto e mais simples; H.323 é binário e mais complexo",
      "Ambos são idênticos",
      "SIP é mais antigo que H.323",
      "H.323 é usado apenas em redes Wi-Fi"
    ],
    "correctIndex": 0,
    "explanation": "SIP: baseado em texto (similar ao HTTP), leve e flexível, amplamente usado. H.323: padrão ITU-T, binário (ASN.1/BER), mais complexo, em sistemas legados. SIP dominou o mercado por simplicidade.",
    "example": "SIP: porta 5060 (UDP/TCP), 5061 (TLS). Mensagens: INVITE, ACK, BYE, REGISTER. H.323: Gateway, Gatekeeper, MCU. SIP domina o mercado atual."
  },
  {
    "id": "rede-de-computadores__VoIP__Médio__3",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Médio",
    "question": "O que é um codec de áudio em VoIP e quais os mais comuns?",
    "options": [
      "Algoritmo que comprime/descomprime áudio; G.711 (sem compressão) e G.729 (comprimido)",
      "Driver de placa de som para VoIP",
      "Tipo de microfone especial para chamadas",
      "Protocolo de rede para transmissão de áudio"
    ],
    "correctIndex": 0,
    "explanation": "Codec (COder/DECoder) comprime voz digitalizada. G.711: sem compressão, 64 kbps, melhor qualidade, mais banda. G.729: 8 kbps, boa qualidade, economiza banda. A escolha depende da banda disponível.",
    "example": "G.711: 64 kbps, MOS ~4.4. G.729: 8 kbps, MOS ~3.9. G.722: HD voice, 64 kbps. Opus: moderno, adaptativo (6-510 kbps), WebRTC. MOS: Mean Opinion Score (1-5)."
  },
  {
    "id": "rede-de-computadores__VoIP__Médio__4",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Médio",
    "question": "O que é um PBX IP e como difere de um PBX tradicional?",
    "options": [
      "PBX IP usa rede de dados (VoIP); PBX tradicional usa linhas telefônicas analógicas/digitais",
      "São a mesma coisa",
      "PBX IP é apenas para chamadas externas",
      "PBX tradicional é mais barato que IP"
    ],
    "correctIndex": 0,
    "explanation": "PBX (Private Branch Exchange) é a central telefônica privada. PBX IP usa rede de dados (Ethernet/Wi-Fi) e protocolo SIP. PBX tradicional usa fiação dedicada e troncos analógicos/ISDN. PBX IP é mais flexível, escalável e barato de manter.",
    "example": "PBX IP: Asterisk (open-source), 3CX, Cisco CUCM. Cloud PBX: hospedado na nuvem (RingCentral, Vonage). PBX híbrido: suporta ramais analógicos e IP. Vantagens IP: URA, gravação, integração CRM."
  },
  {
    "id": "rede-de-computadores__VoIP__Médio__5",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Médio",
    "question": "O que é NAT traversal em VoIP e por que é um desafio?",
    "options": [
      "Técnica para VoIP funcionar através de NAT; necessária porque SIP embute IPs privados no payload",
      "Criptografia de chamadas VoIP",
      "Backup de configurações de PBX",
      "Protocolo de qualidade de serviço"
    ],
    "correctIndex": 0,
    "explanation": "SIP inclui endereços IP nos headers e SDP (corpo da mensagem). Atrás de NAT, esses IPs são privados e inacessíveis externamente. Soluções: STUN (descobre IP público), TURN (relay), ICE (combina STUN+TURN), SBC.",
    "example": "STUN: cliente descobre seu IP público perguntando a servidor externo. TURN: relay quando STUN falha (NAT simétrico). ICE: framework que testa vários caminhos (host, srflx, relay). WebRTC usa ICE nativamente."
  },
  {
    "id": "rede-de-computadores__VoIP__Médio__6",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Médio",
    "question": "O que é uma URA (Unidade de Resposta Audível) em sistemas VoIP?",
    "options": [
      "Sistema automatizado que atende ligações e direciona o chamador por menus de voz",
      "Codec de áudio de alta qualidade",
      "Protocolo de criptografia de chamadas",
      "Hardware de amplificação de sinal"
    ],
    "correctIndex": 0,
    "explanation": "URA (IVR — Interactive Voice Response) é o sistema que atende automaticamente: 'Tecle 1 para vendas, 2 para suporte'. Pode integrar com bancos de dados, TTS (text-to-speech) e ASR (speech recognition). Reduz custo com atendentes.",
    "example": "URA simples: menu por DTMF (teclas). URA avançada: reconhecimento de voz, NLU, chatbot por voz. Plataformas: Asterisk (open-source), Genesys, Five9. Tendência: voicebot com IA (Dialogflow, Amazon Connect)."
  },
  {
    "id": "rede-de-computadores__VoIP__Médio__7",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Médio",
    "question": "O que é SRTP e por que é importante em VoIP?",
    "options": [
      "Versão segura do RTP que criptografa o áudio, protegendo contra interceptação de chamadas",
      "Protocolo de sinalização criptografada",
      "Codec de alta qualidade com baixa latência",
      "Método de compressão de áudio"
    ],
    "correctIndex": 0,
    "explanation": "SRTP (Secure RTP, RFC 3711) criptografa e autentica o fluxo de mídia (voz/vídeo). Sem SRTP, qualquer sniffer na rede pode gravar chamadas VoIP. SRTP usa AES para criptografia e HMAC-SHA1 para integridade.",
    "example": "RTP: mídia em texto claro (vulnerável). SRTP: mídia criptografada. Troca de chaves: SDES (simples, via SDP), DTLS-SRTP (WebRTC, mais seguro), ZRTP (DH no mídia path). SRTP + SRTP = chamada end-to-end encriptada."
  },
  {
    "id": "rede-de-computadores__VoIP__Médio__8",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Médio",
    "question": "O que é jitter em VoIP e como os buffers de jitter e QoS mitigam seus efeitos?",
    "options": [
      "Jitter: variação no atraso de pacotes RTP; jitter buffer absorve variações guardando pacotes antes de reproduzir; QoS (DSCP/WRED) prioriza RTP sobre outros tráfegos na fila",
      "Jitter ocorre apenas em redes sem fio; redes cabeadas não têm variação de atraso",
      "Jitter buffer aumenta o atraso total mas não afeta a qualidade percebida",
      "QoS reduz jitter apenas aumentando a largura de banda do link"
    ],
    "correctIndex": 0,
    "explanation": "Jitter: pacotes RTP chegam com intervalos irregulares (causas: enfileiramento, congestionamento, múltiplos caminhos). Impacto: descontinuidade no áudio. Jitter buffer: acumula alguns pacotes (10-50ms), reproduz em ritmo constante. Estático: tamanho fixo. Adaptativo: ajusta dinamicamente ao jitter medido. QoS: DSCP EF (Expedited Forwarding): classe priority queuing. LLQ (Low Latency Queuing): garante banda mínima/máxima para voz.",
    "example": "ITU G.114: latência máxima 150ms one-way, jitter < 30ms, perda < 1% para qualidade aceitável. Codec G.729: 8 kbps, tolerante a perdas. G.711: 64 kbps, alta qualidade. RTCP (RTP Control Protocol): reporta estatísticas de jitter/perda em tempo real. Wireshark: analisa streams RTP (Telephony > RTP > Stream Analysis). MOS (Mean Opinion Score): 4+ = excelente, < 3.5 = ruim."
  },
  {
    "id": "rede-de-computadores__VoIP__Difícil__1",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Difícil",
    "question": "Em VoIP, o que é jitter e como ele afeta a qualidade da chamada?",
    "options": [
      "Variação no tempo de chegada dos pacotes, causando áudio entrecortado",
      "Perda total de pacotes de áudio",
      "Atraso fixo na transmissão",
      "Eco na ligação"
    ],
    "correctIndex": 0,
    "explanation": "Jitter é a variação (inconsistência) no atraso entre pacotes. Se pacotes chegam com intervalos irregulares, o áudio fica entrecortado, robotizado ou com gaps. Buffer de jitter (jitter buffer) armazena pacotes temporariamente para regularizar a entrega, mas aumenta a latência.",
    "example": "Jitter ideal: < 30ms. Latência ideal: < 150ms. Perda de pacotes ideal: < 1%. QoS (DSCP EF — Expedited Forwarding) prioriza tráfego VoIP. Jitter buffer (fixo ou adaptativo) compensa variações."
  },
  {
    "id": "rede-de-computadores__VoIP__Difícil__2",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Difícil",
    "question": "O que é QoS para VoIP e quais métricas devem ser priorizadas?",
    "options": [
      "Priorização de tráfego de voz; latência < 150ms, jitter < 30ms, perda < 1%",
      "Apenas aumentar a largura de banda resolve",
      "QoS não tem efeito em VoIP",
      "Somente a latência importa para VoIP"
    ],
    "correctIndex": 0,
    "explanation": "QoS prioriza pacotes VoIP (RTP) sobre tráfego menos crítico. Métricas ideais: latência < 150ms, jitter < 30ms, perda < 1%. DSCP EF (valor 46) marca pacotes VoIP para tratamento prioritário em switches e roteadores.",
    "example": "Sem QoS: download congestiona link → VoIP pica. Com QoS: fila prioritária (LLQ). Configuração Cisco: policy-map com class VoIP → priority. DSCP EF = encaminhamento acelerado."
  },
  {
    "id": "rede-de-computadores__VoIP__Difícil__3",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Difícil",
    "question": "O que é um SBC (Session Border Controller) em redes VoIP?",
    "options": [
      "Dispositivo na borda que controla sessões, fazendo segurança, NAT traversal e transcodificação",
      "Servidor que armazena mensagens de voz",
      "Switch especializado para áudio",
      "Codec de alta qualidade para chamadas"
    ],
    "correctIndex": 0,
    "explanation": "SBC fica na borda da rede VoIP, controlando sessões SIP/RTP. Funções: segurança (proteção contra ataques SIP), NAT traversal, transcodificação entre codecs, interoperabilidade entre redes e controle de admissão.",
    "example": "SBC faz B2BUA (Back-to-Back User Agent): termina e re-origina sessões SIP. Funções: topology hiding, media anchoring, call admission control. Exemplos: Audiocodes, Oracle SBC, Ribbon."
  },
  {
    "id": "rede-de-computadores__VoIP__Difícil__4",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Difícil",
    "question": "O que é WebRTC e como se relaciona com VoIP?",
    "options": [
      "API que permite comunicação de voz/vídeo diretamente no navegador sem plugins",
      "Protocolo de roteamento para VoIP",
      "Codec de áudio de alta qualidade",
      "Software de PBX baseado em nuvem"
    ],
    "correctIndex": 0,
    "explanation": "WebRTC (Web Real-Time Communication) é um padrão aberto que permite áudio, vídeo e dados P2P diretamente no navegador, sem plugins. Usa SRTP (mídia criptografada), ICE/STUN/TURN (NAT traversal) e codec Opus/VP8/VP9.",
    "example": "WebRTC: JavaScript API (getUserMedia, RTCPeerConnection). Sinalização: não define (pode usar WebSocket, SIP, XMPP). Mídia: SRTP obrigatório. Navegadores: Chrome, Firefox, Safari, Edge. Usado: Google Meet, Discord."
  },
  {
    "id": "rede-de-computadores__VoIP__Difícil__5",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Difícil",
    "question": "O que é transcodificação em VoIP e quando é necessária?",
    "options": [
      "Conversão entre codecs diferentes durante a chamada; necessária quando endpoints usam codecs incompatíveis",
      "Criptografia do áudio da chamada",
      "Compressão de sinalização SIP",
      "Conversão de voz em texto"
    ],
    "correctIndex": 0,
    "explanation": "Transcodificação: converter áudio de um codec para outro em tempo real (ex: G.711 ↔ G.729). Necessária quando dois endpoints não suportam o mesmo codec. Feita pelo PBX ou SBC. Consome CPU e pode degradar qualidade.",
    "example": "Exemplo: Telefone IP (G.711) ↔ PBX (transcodifica) ↔ Celular SIP (G.729). Sem transcodificação: ambos usam mesmo codec (ideal). DSP (Digital Signal Processor): hardware dedicado para transcodificação em escala."
  },
  {
    "id": "rede-de-computadores__VoIP__Difícil__6",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Difícil",
    "question": "O que é toll fraud em VoIP e como preveni-lo?",
    "options": [
      "Uso não autorizado do sistema VoIP para fazer chamadas de longa distância; prevenção com senhas fortes e ACLs",
      "Interceptação de chamadas criptografadas",
      "Perda de pacotes durante a chamada",
      "Problema de eco em ligações"
    ],
    "correctIndex": 0,
    "explanation": "Toll fraud: atacante compromete PBX/SIP e faz chamadas internacionais caras (prejuízos de milhares a milhões). Vetores: senhas SIP fracas, ramais desprotegidos, troncos sem ACL. Detecção: monitoramento de CDRs e limites de gasto.",
    "example": "Prevenção: senhas SIP fortes, fail2ban (bloqueia IPs), ACLs por IP/sub-rede, limitar destinos internacionais, alertas de gasto anormal. Asterisk: security events + fail2ban. PBX na nuvem: provedor gerencia segurança."
  },
  {
    "id": "rede-de-computadores__VoIP__Difícil__7",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Difícil",
    "question": "Quais são os principais ataques contra infraestrutura SIP?",
    "options": [
      "Registration hijacking, INVITE flooding e SIP scanning; mitigados com SBC, TLS e fail2ban",
      "Apenas ataques DDoS genéricos",
      "Somente interceptação de áudio",
      "Ataques exclusivamente físicos ao hardware"
    ],
    "correctIndex": 0,
    "explanation": "Registration hijacking: atacante registra-se com URI da vítima. INVITE flooding: DoS com milhares de INVITEs. SIP scanning: varredura de ramais válidos (SIPVicious). Eavesdropping: interceptação de RTP sem SRTP.",
    "example": "Defesas: SBC (filtra, rate limit, topology hiding), SIP sobre TLS (SIPS, porta 5061), SRTP para mídia, fail2ban, ACLs, autenticação digest. SIPVicious: ferramenta de scanning/cracking SIP. Honey-SIP: honeypot para SIP."
  },
  {
    "id": "rede-de-computadores__VoIP__Difícil__8",
    "track": "rede-de-computadores",
    "category": "VoIP",
    "difficulty": "Difícil",
    "question": "Quais são os principais vetores de ataque em infraestruturas SIP/VoIP e como um SBC mitiga cada um?",
    "options": [
      "SIP scanning/enumeration, INVITE flooding (DoS), registration hijacking, eavesdropping de RTP sem SRTP, toll fraud; SBC mitiga via rate limiting, topology hiding, autenticação, SRTP/SIPS e ACLs geográficas",
      "Somente eavesdropping é possível em VoIP; os demais ataques são teóricos",
      "SBC é apenas um proxy de sinalização sem funções de segurança",
      "Firewall convencional stateful é suficiente para proteger infraestrutura SIP"
    ],
    "correctIndex": 0,
    "explanation": "Vetores VoIP: (1) SIP scanning: SIPVicious varre ramais (100-999) via OPTIONS/REGISTER. (2) Brute force REGISTER: força credenciais de ramais. (3) INVITE flood: DoS com INVITEs sem ACK. (4) Registration hijacking: substitui contato de ramal legítimo. (5) Eavesdropping RTP: sem SRTP, mídia em plaintext. (6) Toll fraud: faz chamadas internacionais via ramal comprometido. SBC: stateful SIP proxy com rate limiting, geoblocking, SRTP relay.",
    "example": "SIPVicious: svmap (scan), svwar (extensão enum), svcrack (brute force). Defesas: fail2ban para SIP (parse logs Asterisk/FreeSWITCH), whitelist IPs, SRTP obrigatório, SIPS (TLS), ACL de países. Asterisk: 'deny=0.0.0.0/0; permit=203.0.113.0/24' no sip.conf. CDR analysis: detecção de toll fraud por volume de chamadas internacionais fora do horário. STIR/SHAKEN: autenticação de caller ID."
  },
  {
    "id": "rede-de-computadores__DNS DHCP e NAT__Fácil__1",
    "track": "rede-de-computadores",
    "category": "DNS DHCP e NAT",
    "difficulty": "Fácil",
    "question": "O que é um registro MX no DNS e para que serve?",
    "options": [
      "Mail Exchanger: aponta para o servidor de e-mail responsável por receber mensagens do domínio; tem prioridade numérica (menor = preferido)",
      "Registro que mapeia IP para hostname (DNS reverso)",
      "Configura o roteamento interno do domínio",
      "Define o servidor DNS secundário do domínio"
    ],
    "correctIndex": 0,
    "explanation": "Tipos de registro DNS: A (IPv4), AAAA (IPv6), CNAME (alias), MX (mail), NS (name server), TXT (verificação/SPF/DKIM), SOA (start of authority), PTR (reverso), SRV (serviço). MX: 'empresa.com IN MX 10 mail.empresa.com'. Prioridade: menor valor = maior preferência. Múltiplos MX = redundância.",
    "example": "'empresa.com MX 10 mail1.empresa.com; empresa.com MX 20 mail2.empresa.com'. Se mail1 indisponível, tenta mail2. SPF em TXT: 'v=spf1 mx ~all' autoriza servidores MX a enviar e-mail. DKIM: assinatura criptográfica em TXT. DMARC: política de autenticação de e-mail em TXT."
  },
  {
    "id": "rede-de-computadores__DNS DHCP e NAT__Médio__1",
    "track": "rede-de-computadores",
    "category": "DNS DHCP e NAT",
    "difficulty": "Médio",
    "question": "O que é o DHCP Snooping e como protege contra ataques DHCP Starvation e Rogue DHCP?",
    "options": [
      "Switch filtra mensagens DHCP: só trusts portas trunk/uplink (servidor DHCP); portas de acesso só recebem OFFER/ACK; previne DHCP falso e esgotamento de pool",
      "Protocolo que replica o banco de dados DHCP entre servidores redundantes",
      "Função do servidor para registrar todos os leases em syslog",
      "Filtra endereços MAC para impedir clientes não autorizados de obter IP"
    ],
    "correctIndex": 0,
    "explanation": "DHCP Starvation: atacante envia milhares de DISCOVER com MAC spoofed esgotando o pool. Rogue DHCP: servidor falso responde OFFER com gateway/DNS do atacante (man-in-the-middle). DHCP Snooping: switch cria binding table (MAC, IP, porta, VLAN); descarta OFFER nas portas untrusted; rate-limits DISCOVERs.",
    "example": "Cisco IOS: 'ip dhcp snooping; ip dhcp snooping vlan 10; interface gi0/1; ip dhcp snooping trust'. Binding table: usado também por Dynamic ARP Inspection (DAI) e IP Source Guard. Combinação DHCP Snooping + DAI + IP Source Guard: proteção completa no nível de acesso."
  },
  {
    "id": "rede-de-computadores__DNS DHCP e NAT__Difícil__1",
    "track": "rede-de-computadores",
    "category": "DNS DHCP e NAT",
    "difficulty": "Difícil",
    "question": "O que é DNSSEC e como as assinaturas RRSIG protegem a integridade das respostas DNS?",
    "options": [
      "DNSSEC assina registros DNS com criptografia assímétrica (RSA/ECDSA); RRSIG: assinatura digital do ownser sobre cada resource record set; validadores verificam com DNSKEY; NSEC/NSEC3 garantem negação autenticada",
      "DNSSEC cifra o conteúdo das respostas DNS prevenindo escuta",
      "RRSIG é um tipo de registro para redundância de servidores DNS",
      "DNSSEC funciona apenas em zonas internas (split-DNS)"
    ],
    "correctIndex": 0,
    "explanation": "DNSSEC: não criptografa (confid.), garante integridade e autentia. DNSKEY: chave pública da zona. ZSK (Zone Signing Key) assina RRSets; KSK (Key Signing Key) assina ZSK. RRSIG: assinatura sobre o RRSet. DS (Delegation Signer): liga zona filha ao pai. Chain of trust: raiz (ICANN) → TLD → domínio. NSEC/NSEC3: nega existência autenticada.",
    "example": "Ataque DNS cache poisoning (Kaminsky, 2008): inserir registros falsos no cache. DNSSEC previne: validação de assinatura no recursive resolver. Alg: RSASHA256 (RSA+SHA256) ou ECDSAP256SHA256 (menor chave, mais eficiente). Ferramentas: dig +dnssec, delv, dnsviz.net. Deployment: ~30% dos domínios TLD assinados."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Fácil",
    "question": "Qual é a função principal de um certificado digital?",
    "options": [
      "Vincular uma identidade a uma chave pública de forma confiável",
      "Criptografar arquivos no disco",
      "Bloquear vírus",
      "Criar senhas fortes"
    ],
    "correctIndex": 0,
    "explanation": "O certificado digital é um documento eletrônico assinado por uma Autoridade Certificadora (CA) que vincula a identidade de uma pessoa/organização a uma chave pública. Permite verificar a autenticidade e estabelecer comunicações seguras (ex: HTTPS).",
    "example": "Analogia: como um RG digital. A CA (cartório) atesta que a chave pública pertence realmente àquela pessoa/site. Formato padrão: X.509. Exemplo: cadeado verde no navegador = certificado SSL/TLS válido."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Fácil",
    "question": "O que é HTTPS e qual a relação com certificados digitais?",
    "options": [
      "HTTP com criptografia TLS usando certificado digital para autenticar o servidor",
      "Versão mais rápida do HTTP",
      "Protocolo exclusivo para e-commerce",
      "HTTP com compressão de dados"
    ],
    "correctIndex": 0,
    "explanation": "HTTPS = HTTP + TLS/SSL. O certificado digital autentica o site e possibilita criptografia. O navegador verifica: CA confiável, não expirado, domínio correspondente. Cadeado = conexão segura.",
    "example": "HTTP: texto claro (porta 80). HTTPS: criptografado com TLS (porta 443). Let's Encrypt: CA gratuita que democratizou HTTPS. Sem certificado válido: navegador exibe 'Conexão não é particular'."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Fácil",
    "question": "O que é uma Autoridade Certificadora (CA)?",
    "options": [
      "Entidade confiável que emite e assina certificados digitais",
      "Software antivírus para websites",
      "Tipo de firewall para servidores",
      "Protocolo de criptografia"
    ],
    "correctIndex": 0,
    "explanation": "A CA verifica a identidade do solicitante e emite certificados assinados com sua chave privada. Navegadores confiam em CAs pré-instaladas (trust store). Exemplos: DigiCert, Let's Encrypt, GlobalSign.",
    "example": "Processo: gera par de chaves → envia CSR (Certificate Signing Request) → CA verifica identidade → emite certificado. Tipos: DV (domínio), OV (organização), EV (validação estendida)."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Fácil",
    "question": "O que acontece quando você acessa um site com certificado digital expirado?",
    "options": [
      "O navegador exibe um aviso de segurança 'Conexão não é particular'",
      "O site carrega normalmente sem diferença",
      "O certificado é renovado automaticamente",
      "O firewall bloqueia o acesso"
    ],
    "correctIndex": 0,
    "explanation": "Certificado expirado significa que a CA não garante mais a identidade do site. O navegador mostra alerta de segurança e impede o acesso direto (usuário pode forçar, por sua conta e risco). A criptografia ainda funciona, mas a confiança na identidade está comprometida.",
    "example": "Chrome: ERR_CERT_DATE_INVALID. Causa: admins esqueceram de renovar. Let's Encrypt: validade 90 dias (auto-renovação com certbot). DigiCert/Comodo: 1-2 anos. Monitorar expiração: ferramentas como Nagios, UptimeRobot."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Fácil",
    "question": "O que é a cadeia de confiança (chain of trust) em certificados digitais?",
    "options": [
      "Hierarquia onde a CA Raiz assina a Intermediária, que assina o certificado do site",
      "Sequência de firewalls que protegem o certificado",
      "Lista de todos os sites que usam HTTPS",
      "Backup de certificados em múltiplos servidores"
    ],
    "correctIndex": 0,
    "explanation": "A cadeia de confiança vai do certificado do site até a CA Raiz (pre-instalada no navegador): Certificado do site → assinado pela CA Intermediária → assinada pela CA Raiz. Se qualquer elo é inválido, a conexão é rejeitada.",
    "example": "Verificação: navegador recebe cert do site + intermediário. Busca CA Raiz no trust store local. Se confere: cadeado verde. Se falta intermediário: erro de chain incompleta. Comando: `openssl s_client -showcerts`."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Fácil",
    "question": "O que é uma assinatura digital?",
    "options": [
      "Técnica que usa criptografia assimétrica para garantir autenticidade e integridade de um documento",
      "Imagem digitalizada de uma assinatura manuscrita",
      "Senha especial para documentos eletrônicos",
      "Software de edição de PDFs"
    ],
    "correctIndex": 0,
    "explanation": "Assinatura digital: o remetente calcula o hash do documento e cifra com sua chave privada. O destinatário decifra com a chave pública do remetente e compara o hash. Se confere: documento autêntico e íntegro.",
    "example": "Processo: Hash(documento) → cifra com chave privada → assinatura. Verificação: decifra com chave pública → compara hash. Garante: autenticidade (quem assinou), integridade (não alterado), não-repúdio (não pode negar)."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Fácil",
    "question": "O que é o protocolo TLS e onde é usado?",
    "options": [
      "Protocolo que criptografa a comunicação entre cliente e servidor, usado em HTTPS, email e VPN",
      "Software de backup de dados",
      "Protocolo de roteamento seguro",
      "Firewall para aplicações web"
    ],
    "correctIndex": 0,
    "explanation": "TLS (Transport Layer Security) é o protocolo que fornece criptografia, integridade e autenticação entre aplicações. Substitui o SSL (inseguro). Versão atual: TLS 1.3 (mais rápido e seguro). Usado em HTTPS, SMTPS, IMAPS, VPNs.",
    "example": "TLS handshake: ClientHello → ServerHello + certificado → troca de chaves (ECDHE) → chave simétrica → comunicação cifrada. TLS 1.3: 1-RTT handshake (vs 2-RTT no 1.2). 0-RTT resumption possível."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Fácil",
    "question": "O que é uma CA (Certificate Authority) e qual seu papel na PKI?",
    "options": [
      "CA é a entidade que emite, assina e revoga certificados digitais X.509; sua chave privada garante a cadeia de confiança da PKI",
      "CA é o servidor que armazena as chaves privadas dos usuários",
      "CA é um protocolo de troca de chaves como TLS",
      "CA é sinônimo de servidor LDAP usado para autenticação"
    ],
    "correctIndex": 0,
    "explanation": "PKI (Public Key Infrastructure): hierarquia de CAs. Root CA: autoassinada, offline (air-gap). Intermediate CA: emite certificados de entidade final. Certificado X.509: Subject, Issuer, Serial, Validity, Public Key, Extensions (SAN, EKU), Signature. Chain of trust: navegador valida até Root CA no trust store.",
    "example": "Root CA offline: chave privada nunca exposta à rede. Intermediate CA online: HSM protege chave. CRL (Certificate Revocation List): lista de certificados revogados. OCSP: verificação online em tempo real. Certificate Transparency (CT logs): lista pública de certificados emitidos. Let's Encrypt: CA pública gratuita com ACME protocol."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Médio",
    "question": "No modelo PKI (Public Key Infrastructure), qual é o papel da AC Raiz (Root CA)?",
    "options": [
      "É a entidade de confiança máxima que assina certificados das ACs intermediárias",
      "É o servidor que armazena todas as senhas",
      "É o firewall principal da organização",
      "É o backup dos certificados expirados"
    ],
    "correctIndex": 0,
    "explanation": "A AC Raiz é o topo da cadeia de confiança. Ela auto-assina seu próprio certificado e assina certificados das ACs Intermediárias, que por sua vez assinam certificados de entidades finais. A AC Raiz geralmente fica offline para proteção máxima.",
    "example": "Cadeia: AC Raiz → AC Intermediária → Certificado do site. Navegadores têm AC Raiz pré-instaladas (trust store). Se a AC Raiz for comprometida, toda a cadeia perde confiança. Ex no Brasil: ICP-Brasil → AC Raiz + ACs como Serasa, Certisign."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Médio",
    "question": "O que é uma CRL (Certificate Revocation List) e para que serve?",
    "options": [
      "Lista da CA contendo certificados revogados antes da expiração",
      "Lista de CAs confiáveis no navegador",
      "Log de todos os certificados emitidos",
      "Backup de chaves privadas"
    ],
    "correctIndex": 0,
    "explanation": "Quando um certificado é comprometido, a CA o revoga e publica na CRL. O cliente pode verificar se o certificado está revogado. Problema: CRLs podem ser grandes e a verificação adiciona latência.",
    "example": "Motivos de revogação: chave privada comprometida, mudança de dados. CRL: lista completa. OCSP: consulta individual (mais eficiente). OCSP Stapling: servidor web busca e anexa resposta OCSP."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Médio",
    "question": "Qual a diferença entre certificados DV, OV e EV?",
    "options": [
      "DV valida só domínio; OV valida organização; EV faz validação estendida rigorosa",
      "São versões diferentes do mesmo certificado",
      "Apenas EV fornece criptografia",
      "DV é gratuito, OV e EV são pagos e mais seguros na criptografia"
    ],
    "correctIndex": 0,
    "explanation": "DV (Domain Validation): prova controle do domínio (automático, minutos). OV (Organization): verifica identidade da organização (dias). EV (Extended): verificação rigorosa (semanas). Todos criptografam igualmente — a diferença é no nível de confiança na identidade.",
    "example": "DV: Let's Encrypt, gratuito. OV: exibe nome da empresa. EV: validação completa (menos visualmente distinto nos browsers modernos). Todos usam o mesmo TLS."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Médio",
    "question": "O que é um CSR (Certificate Signing Request)?",
    "options": [
      "Requisição enviada à CA contendo chave pública e dados de identidade para emissão do certificado",
      "Resposta da CA com o certificado pronto",
      "Lista de certificados revogados",
      "Chave privada do servidor"
    ],
    "correctIndex": 0,
    "explanation": "CSR é gerado no servidor e contém: chave pública, nome do domínio (CN), organização, localização. A CA recebe o CSR, valida a identidade e emite o certificado assinado. A chave privada NUNCA sai do servidor.",
    "example": "Geração: `openssl req -new -key server.key -out server.csr`. CSR contém: Subject (CN, O, C), chave pública, algoritmo. CA assina com sua chave privada → certificado X.509 emitido."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Médio",
    "question": "O que é OCSP (Online Certificate Status Protocol)?",
    "options": [
      "Protocolo que verifica em tempo real se um certificado específico foi revogado",
      "Método de criptografia de certificados",
      "Protocolo de emissão automática de certificados",
      "Lista completa de todos os certificados válidos"
    ],
    "correctIndex": 0,
    "explanation": "OCSP permite ao cliente perguntar diretamente à CA: 'este certificado ainda é válido?' A resposta é individual (good, revoked, unknown), ao contrário da CRL que é uma lista completa. Mais eficiente, mas permite que a CA rastreie acessos.",
    "example": "CRL: baixa lista inteira (pesada). OCSP: consulta individual (leve, mas privacidade). OCSP Stapling: servidor busca resposta OCSP e annexa ao TLS handshake → resolvie privacidade + performance."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Médio",
    "question": "O que é o formato X.509 em certificados digitais?",
    "options": [
      "Padrão que define a estrutura do certificado, incluindo sujeito, chave pública, CA e validade",
      "Algoritmo de criptografia simétrica",
      "Formato de arquivo exclusivo para chaves privadas",
      "Protocolo de transferência de certificados"
    ],
    "correctIndex": 0,
    "explanation": "X.509 é o padrão ITU-T/ISO para certificados digitais. Define campos como: versão, número serial, algoritmo de assinatura, emissor (CA), validade, sujeito, chave pública e extensões (SAN, Key Usage).",
    "example": "Formatos de arquivo: PEM (Base64, .pem/.crt), DER (binário, .der), PKCS#12 (.p12/.pfx, inclui chave privada). Comando: `openssl x509 -in cert.pem -text -noout`. Versão atual: X.509v3."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Médio",
    "question": "O que é Let's Encrypt e por que revolucionou o uso de HTTPS?",
    "options": [
      "CA gratuita e automatizada que emite certificados DV, democratizando o acesso a HTTPS",
      "Navegador web com criptografia integrada",
      "Firewall gratuito para servidores web",
      "Software de VPN de código aberto"
    ],
    "correctIndex": 0,
    "explanation": "Let's Encrypt é uma Autoridade Certificadora gratuita, automatizada e aberta. Emite certificados DV com validade de 90 dias, renováveis automaticamente via protocolo ACME (certbot). Responsável por criptografar grande parte da web.",
    "example": "Antes: certificados custavam $$/ano, instalação manual. Let's Encrypt (2015): gratuito + ACME (automático). Certbot: cliente oficial. Suporta wildcard (*.exemplo.com) via DNS-01 challenge. +300 milhões de sites protegidos."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Médio",
    "question": "O que é Certificate Pinning e quais os riscos e benefícios dessa prática?",
    "options": [
      "Certificate Pinning: app embute o hash/cert do servidor esperado; impede MITM com CA comprometida ou SSL inspection; risco: app quebra ao renovar certificado sem atualizar o pin",
      "Certificate Pinning é uma técnica de compressão de certificados TLS",
      "Pinning substitui completamente o trust store do sistema operacional",
      "Certificate Pinning é obrigatório pelo RFC TLS 1.3"
    ],
    "correctIndex": 0,
    "explanation": "Pin: hash SHA-256 da chave pública (SPKI) ou do certificado. Mobile apps: Android/iOS hardcodam o pin no APK/IPA. Proteção: mesmo com CA corporativa instalada via MDM, o pin rejeita o certificado falso. Risco: se o certificado for renovado com nova chave, app falha conexão até atualização. Backup pins: incluir 2 pins (ativo + backup).",
    "example": "HTTP Public Key Pinning (HPKI): header HTTP (deprecated). Static pinning: hash no código. Dynamic pinning: pin atualizado via API segura. Contornar pinning: Frida, Objection (hook SSL functions). Defesa adicional: certificate transparency monitoring (certspotter). Google removeu HPKP do Chrome em 2018 por risco de lock-out."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Difícil",
    "question": "O que é OCSP Stapling e qual problema ele resolve em relação à verificação de revogação de certificados?",
    "options": [
      "O servidor web consulta o OCSP e anexa a resposta ao handshake TLS, eliminando consulta do cliente ao CA",
      "O cliente armazena todos os CRLs localmente",
      "É uma forma de criptografia pós-quântica",
      "Substitui completamente os certificados X.509"
    ],
    "correctIndex": 0,
    "explanation": "Sem stapling: o navegador precisa consultar o servidor OCSP da CA para verificar se o certificado foi revogado, causando latência e problemas de privacidade (a CA sabe quais sites você visita). Com OCSP Stapling: o servidor web consulta periodicamente o OCSP e inclui a resposta assinada no TLS handshake. O cliente valida a resposta sem contatar a CA.",
    "example": "CRL: lista completa de revogados (grande, lenta). OCSP: consulta individual (latência + privacidade). OCSP Stapling: melhor dos dois — resposta OCSP cacheada e servida pelo servidor web, assinada pela CA, com timestamp (válida por horas)."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Difícil",
    "question": "O que é Certificate Transparency (CT) e como protege contra certificados fraudulentos?",
    "options": [
      "Logs públicos onde CAs registram todos os certificados emitidos, permitindo auditoria",
      "Técnica para tornar certificados invisíveis",
      "Método para revogar certificados automaticamente",
      "Versão transparente do certificado sem dados privados"
    ],
    "correctIndex": 0,
    "explanation": "Certificate Transparency exige que CAs publiquem cada certificado em logs públicos (append-only). Navegadores como Chrome exigem SCTs. Proprietários de domínios podem monitorar logs para detectar certificados emitidos indevidamente.",
    "example": "Sem CT: CA comprometida emite cert falso e ninguém percebe. Com CT: cert aparece no log → detectado → revogado. Sites como crt.sh permitem buscar certificados por domínio."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Difícil",
    "question": "O que é um HSM (Hardware Security Module) e qual seu papel em PKI?",
    "options": [
      "Dispositivo físico dedicado a gerar, armazenar e proteger chaves criptográficas",
      "Software para gerenciar certificados",
      "Servidor de backup de chaves",
      "Protocolo de comunicação segura"
    ],
    "correctIndex": 0,
    "explanation": "HSM é um dispositivo tamper-resistant que gera e armazena chaves criptográficas. As chaves nunca deixam o HSM — operações criptográficas são executadas dentro do dispositivo. Essencial para proteger a chave privada da AC Raiz.",
    "example": "HSM: chave nunca exportada, auto-destrói se adulterado. FIPS 140-2 Level 3/4. Cloud HSM: AWS CloudHSM, Azure Dedicated HSM. Uso: PKI, pagamentos, assinaturas digitais."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Difícil",
    "question": "O que é certificate pinning e por que é usado?",
    "options": [
      "Técnica que associa um certificado específico a um domínio/app, prevenindo MitM com CAs comprometidas",
      "Método de fixar a data de expiração do certificado",
      "Backup de certificados em hardware",
      "Protocolo para compartilhar certificados entre servidores"
    ],
    "correctIndex": 0,
    "explanation": "Certificate pinning: o app/navegador aceita APENAS o certificado específico (ou CA específica) para aquele domínio, ignorando outras CAs do trust store. Protege contra CAs comprometidas ou ataques MitM corporativos. Comum em apps bancários.",
    "example": "HPKP (HTTP Public Key Pinning): deprecado em navegadores (risco de DoS se pin errado). Apps móveis: ainda comum (Alamofire/iOS, OkHttp/Android). Desafio: atualizar pin quando certificado renova."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre certificados wildcard e SAN (Subject Alternative Name)?",
    "options": [
      "Wildcard cobre todos os subdomínios de um nível; SAN lista múltiplos domínios diferentes em um certificado",
      "São a mesma coisa com nomes diferentes",
      "Wildcard é gratuito e SAN é pago",
      "SAN só funciona com EV e wildcard com DV"
    ],
    "correctIndex": 0,
    "explanation": "Wildcard (*.exemplo.com): cobre qualquer subdomínio de primeiro nível (www, mail, api). Não cobre sub-subdomínios (dev.api.exemplo.com). SAN: um certificado lista vários domínios distintos (exemplo.com, empresa.net, loja.org) no campo Subject Alternative Name.",
    "example": "Wildcard: *.exemplo.com cobre www.exemplo.com, api.exemplo.com. SAN: cert único para exemplo.com + exemplo.net + outrodominio.com. Combinação: wildcard + SAN no mesmo cert. Let's Encrypt suporta ambos."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Difícil",
    "question": "O que é mTLS (mutual TLS) e quando é usado?",
    "options": [
      "Autenticação onde ambos os lados apresentam certificados; comum em APIs e microsserviços",
      "TLS com criptografia dupla",
      "Versão mais rápida do TLS",
      "TLS exclusivo para redes internas"
    ],
    "correctIndex": 0,
    "explanation": "No TLS normal, só o servidor apresenta certificado. No mTLS (mutual TLS), o cliente TAMBÉM apresenta certificado para o servidor. Garante autenticação bidirecional. Usado em comunicação entre microsserviços, APIs B2B e Zero Trust.",
    "example": "mTLS: Client → cert + Server → cert. Service mesh (Istio, Linkerd): mTLS automático entre pods. APIs bancárias (Open Banking): mTLS obrigatório. Desafio: gerenciar certificados de todos os clientes."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Difícil",
    "question": "O que é o protocolo ACME usado pelo Let's Encrypt?",
    "options": [
      "Protocolo que automatiza emissão e renovação de certificados via desafios de validação",
      "Algoritmo de criptografia pós-quântica",
      "Protocolo de backup de certificados",
      "Método de revogação automática"
    ],
    "correctIndex": 0,
    "explanation": "ACME (Automated Certificate Management Environment, RFC 8555) automatiza o ciclo de vida de certificados: solicitação, validação de domínio, emissão e renovação. Desafios: HTTP-01 (arquivo no webserver), DNS-01 (registro TXT no DNS).",
    "example": "Fluxo ACME: cliente (certbot) → cria conta → solicita cert → CA envia desafio → cliente prova controle do domínio → CA emite cert. DNS-01: necessário para wildcard. HTTP-01: mais simples, arquivo em /.well-known/acme-challenge/."
  },
  {
    "id": "seguranca-da-informacao__Certificados Digitais e PKI__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Certificados Digitais e PKI",
    "difficulty": "Difícil",
    "question": "Como funciona o protocolo OCSP Stapling e como ele melhora desempenho e privacidade sobre OCSP clássico?",
    "options": [
      "OCSP Stapling: servidor web faz a consulta OCSP antecipadamente e inclui a resposta assinada no handshake TLS; cliente não precisa contactar CA; melhora latência e privacidade",
      "OCSP Stapling remove completamente a necessidade de verificação de revogação",
      "OCSP Stapling é consultado pelo cliente diretamente na CA a cada segundo",
      "OCSP substitui CRL; Stapling é apenas um alias para OCSP clássico"
    ],
    "correctIndex": 0,
    "explanation": "OCSP clássico: cliente consulta CA a cada handshake TLS (latência extra, privacy leak: CA sabe quem acessa qual site). OCSP Stapling (RFC 6066): servidor consulta CA periodicamente (ex: 1h), cacheia resposta assinada pela CA, inclui no TLS handshake via Certificate Status Request extension. Must-staple (RFC 7633): extensão X.509 que exige OCSP stapling.",
    "example": "Nginx: 'ssl_stapling on; ssl_stapling_verify on; resolver 8.8.8.8'. Apache: 'SSLUseStapling on'. Diagnóstico: 'openssl s_client -connect host:443 -status | grep OCSP'. OCSP response lifetime: 24h típico. Hard-fail vs soft-fail: hard-fail recusa conexão se OCSP indisponível (seguro mas arriscado); soft-fail aceita (Chrome default). CRL Distribution Points: fallback clássico."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Fácil",
    "question": "O que significa a tríade CIA na segurança da informação?",
    "options": [
      "Confidencialidade, Integridade e Disponibilidade",
      "Criptografia, Internet e Autenticação",
      "Controle, Identidade e Acesso",
      "Certificação, Infraestrutura e Aplicação"
    ],
    "correctIndex": 0,
    "explanation": "CIA: Confidentiality (apenas pessoas autorizadas acessam a informação), Integrity (informação não é alterada indevidamente), Availability (informação está disponível quando necessária). São os três pilares fundamentais da segurança da informação.",
    "example": "Confidencialidade → criptografia, controle de acesso. Integridade → hashes, assinaturas digitais. Disponibilidade → redundância, backups, DDoS protection. Toda política de segurança gira em torno da CIA."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Fácil",
    "question": "O que é autenticação de dois fatores (2FA)?",
    "options": [
      "Uso de dois tipos de verificação para confirmar identidade (ex: senha + código SMS)",
      "Duas senhas diferentes para a mesma conta",
      "Login em dois dispositivos ao mesmo tempo",
      "Backup de senha em dois locais"
    ],
    "correctIndex": 0,
    "explanation": "2FA combina dois fatores diferentes: algo que você sabe (senha), algo que tem (celular, token) ou algo que é (biometria). Mesmo com senha vazada, o atacante precisa do segundo fator.",
    "example": "Fatores: 1) Conhecimento (senha, PIN). 2) Posse (celular, token). 3) Inerência (digital, face). SMS é vulnerável a SIM swap. TOTP (Google Authenticator) ou FIDO2/WebAuthn são mais seguros."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Fácil",
    "question": "O que é um firewall e qual sua importância na segurança?",
    "options": [
      "Sistema que filtra tráfego de rede com base em regras de segurança",
      "Programa que remove vírus do computador",
      "Hardware que aumenta a velocidade da internet",
      "Software de backup de dados"
    ],
    "correctIndex": 0,
    "explanation": "O firewall é a primeira linha de defesa entre redes. Filtra tráfego por IP, porta, protocolo e estado de conexão. Pode ser hardware (appliance), software (iptables) ou cloud (WAF).",
    "example": "Tipos: packet filter, stateful inspection, WAF, NGFW (inspeção profunda + IPS + controle de apps). Regra básica: deny all por padrão, liberar apenas o necessário."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Fácil",
    "question": "O que é backup e por que é essencial para a segurança da informação?",
    "options": [
      "Cópia de segurança dos dados para recuperação em caso de perda, corrupção ou ataque",
      "Software que remove vírus do sistema",
      "Técnica de criptografia de arquivos",
      "Firewall que bloqueia acessos suspeitos"
    ],
    "correctIndex": 0,
    "explanation": "Backup protege o pilar da Disponibilidade: garante recuperação após ransomware, falha de hardware, desastre ou erro humano. Regra 3-2-1: 3 cópias, em 2 mídias diferentes, 1 offsite (fora do local).",
    "example": "Tipos: completo (tudo), incremental (só alterações desde último backup), diferencial (desde último completo). RPO (Recovery Point Objective): tolerância a perda de dados. RTO (Recovery Time Objective): tempo aceitável de restauração."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Fácil",
    "question": "O que significa 'vulnerabilidade' em segurança da informação?",
    "options": [
      "Fraqueza em um sistema que pode ser explorada por uma ameaça",
      "Vírus que infecta o sistema",
      "Ataque de força bruta",
      "Tipo de firewall desatualizado"
    ],
    "correctIndex": 0,
    "explanation": "Vulnerabilidade é uma falha ou fraqueza (técnica, humana ou processual) que pode ser explorada. Ameaça é o agente que pode explorar. Risco = Ameaça × Vulnerabilidade × Impacto. Exemplos: software desatualizado, senha fraca, falta de criptografia.",
    "example": "Vulnerabilidade: porta aberta. Ameaça: hacker. Risco: invasão. CVE (Common Vulnerabilities and Exposures): catálogo público de vulnerabilidades. CVSS: pontuação de severidade (0-10)."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Fácil",
    "question": "O que é engenharia social em cibersegurança?",
    "options": [
      "Técnica de manipulação psicológica para obter informações ou acesso não autorizado",
      "Software de proteção contra vírus",
      "Antivirus de última geração",
      "Ferramenta de análise de rede"
    ],
    "correctIndex": 0,
    "explanation": "Engenharia social explora o fator humano: convence pessoas a revelar informações, clicar em links maliciosos ou realizar ações inseguras. Inclui phishing, pretexting (história inventada), baiting (isca), tailgating (seguir alguém por porta).",
    "example": "Phishing: email falso. Pretexting: 'sou do TI, preciso da sua senha'. Baiting: pen drive infectado no estacionamento. Tailgating: seguir funcionário pela porta. Defesa: treinamento de security awareness."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Fácil",
    "question": "O que é um antivírus e como ele protege o computador?",
    "options": [
      "Software que detecta e remove malware usando assinaturas, heurística e análise comportamental",
      "Hardware que bloqueia tráfego malicioso",
      "Protocolo de criptografia de dados",
      "Firewall para redes domésticas"
    ],
    "correctIndex": 0,
    "explanation": "Antivírus usa múltiplas técnicas: assinaturas (padrões conhecidos de malware), heurística (comportamento suspeito) e sandboxing (execução isolada). Moderno: EDR (Endpoint Detection and Response) com IA e resposta automatizada.",
    "example": "Assinatura: eficaz contra known threats. Heurística: detecta variações. Sandbox: executa em ambiente isolado. EDR: CrowdStrike, SentinelOne, Microsoft Defender for Endpoint. EPP + EDR = proteção completa."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Médio",
    "question": "O que caracteriza um ataque de ransomware?",
    "options": [
      "Malware que criptografa dados da vítima e exige pagamento para desbloqueá-los",
      "Vírus que apaga todos os arquivos permanentemente",
      "Ataque que rouba largura de banda",
      "Software que monitora teclas digitadas"
    ],
    "correctIndex": 0,
    "explanation": "Ransomware criptografa arquivos da vítima usando criptografia forte e exige um resgate (geralmente em criptomoedas) para fornecer a chave de descriptografia. Exemplos famosos: WannaCry (2017), NotPetya, REvil. Defesas: backups offline, patching, treinamento de usuários.",
    "example": "Cadeia: email phishing → download de malware → escalação de privilégio → criptografia de dados → nota de resgate. Prevenção: backups 3-2-1, segmentação de rede, EDR, patches em dia. Nunca garanta pagamento = dados de volta."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Médio",
    "question": "O que é um ataque de phishing e como se proteger?",
    "options": [
      "Email/site falso que imita entidade confiável para roubar dados; proteção: verificar URLs, 2FA",
      "Ataque que sobrecarrega servidores",
      "Vírus que criptografa dados",
      "Software que monitora teclado"
    ],
    "correctIndex": 0,
    "explanation": "Phishing usa engenharia social via email, SMS ou sites falsos para obter credenciais. Proteções: verificar URLs, usar 2FA, treinamento, filtros anti-phishing no email.",
    "example": "Sinais: URL levemente diferente (g00gle.com), urgência forçada, erros de gramática. Variantes: spear phishing (alvo específico), whaling (executivos), vishing (telefone), smishing (SMS)."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Médio",
    "question": "O que é um SIEM (Security Information and Event Management)?",
    "options": [
      "Sistema que coleta, correlaciona e analisa logs de segurança em tempo real",
      "Tipo de firewall para aplicações web",
      "Antivírus para servidores corporativos",
      "Protocolo de criptografia de emails"
    ],
    "correctIndex": 0,
    "explanation": "SIEM centraliza logs de firewalls, servidores, IDS/IPS e endpoints, aplica regras de correlação para detectar ameaças, gera alertas e permite análise forense. Exemplos: Splunk, IBM QRadar, Microsoft Sentinel.",
    "example": "Regra exemplo: 'login falho 5x em 1min do mesmo IP' → alerta de brute force. SOAR (Security Orchestration, Automation and Response) automatiza as respostas aos alertas do SIEM."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Médio",
    "question": "O que é um SOC (Security Operations Center)?",
    "options": [
      "Centro que monitora, detecta e responde a incidentes de segurança 24/7",
      "Software de criptografia de dados",
      "Tipo de firewall de última geração",
      "Sala onde ficam os servidores"
    ],
    "correctIndex": 0,
    "explanation": "O SOC é uma equipe dedicada que opera 24/7, monitora alertas do SIEM, analisa incidentes, coordena respostas e melhora continuamente as defesas. Níveis: L1 (triagem), L2 (análise), L3 (threat hunting/forense).",
    "example": "Ferramentas SOC: SIEM (Splunk/Sentinel), EDR (CrowdStrike), SOAR (Cortex XSOAR), TIP (Threat Intelligence Platform). KPIs: MTTD (Mean Time to Detect), MTTR (Mean Time to Respond)."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Médio",
    "question": "O que é um pentest (teste de penetração)?",
    "options": [
      "Simulação autorizada de ataque para identificar vulnerabilidades em sistemas",
      "Antivírus que detecta malwares",
      "Backup de segurança criptografado",
      "Firewall que testa conexões"
    ],
    "correctIndex": 0,
    "explanation": "Pentest: profissional (pentester) simula ataques reais, com autorização, para encontrar vulnerabilidades antes que atacantes o façam. Tipos: black box (sem info), white box (acesso total), gray box (parcial). Resulta em relatório com achados e recomendações.",
    "example": "Fases: Reconhecimento → Scanning → Exploração → Pós-exploração → Relatório. Ferramentas: Nmap, Burp Suite, Metasploit, SQLmap. Certificações: OSCP, CEH, PNPT."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Médio",
    "question": "O que é Zero Trust em segurança da informação?",
    "options": [
      "Modelo que não confia em nenhum usuário ou dispositivo por padrão, verificando continuamente",
      "Firewall que bloqueia todo o tráfego",
      "Software de criptografia total",
      "VPN exclusiva para redes internas"
    ],
    "correctIndex": 0,
    "explanation": "Zero Trust: 'nunca confie, sempre verifique'. Cada acesso é autenticado e autorizado com base em identidade, dispositivo, contexto e políticas — mesmo dentro da rede corporativa. Substitui o modelo de perímetro (confia no interno).",
    "example": "Princípios: verificação explícita, menor privilégio, assume comprometimento. Pilares: identidade, dispositivo, rede, aplicação, dados. Soluções: ZTNA (Zscaler, Cloudflare), micro-segmentação, MFA everywhere."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Médio",
    "question": "O que é EDR (Endpoint Detection and Response)?",
    "options": [
      "Ferramenta que monitora endpoints, detecta ameaças avançadas e permite resposta automatizada",
      "Tipo de firewall para servidores",
      "Protocolo de backup de endpoints",
      "Antivírus tradicional com interface gráfica"
    ],
    "correctIndex": 0,
    "explanation": "EDR vai além do antivírus tradicional: monitora continuamente atividades nos endpoints, detecta comportamentos anômalos (fileless malware, movimentação lateral), permite investigação forense e resposta remota (isolamento de máquina).",
    "example": "Antivírus: prevenção baseada em assinatura. EDR: detecção + resposta + forense. XDR: EDR + NDR + SIEM integrados. Ferramentas: CrowdStrike Falcon, SentinelOne, Microsoft Defender for Endpoint, Carbon Black."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Difícil",
    "question": "O que é uma APT (Advanced Persistent Threat) e como ela difere de ataques comuns?",
    "options": [
      "Ataque sofisticado, prolongado e direcionado por grupos organizados com objetivos específicos",
      "Qualquer vírus que se espalha rapidamente",
      "Um tipo de firewall avançado",
      "Ataque automatizado sem alvo específico"
    ],
    "correctIndex": 0,
    "explanation": "APT: atacantes altamente qualificados (geralmente state-sponsored) que infiltram uma rede e permanecem por meses/anos, extraindo dados de forma lenta e silenciosa. Diferente de ataques oportunistas (rápidos, automatizados), APTs são direcionados, persistentes e usam técnicas avançadas (zero-days, supply chain attacks).",
    "example": "Fases: Reconhecimento → Weaponization → Delivery → Exploitation → Installation → C2 (Command & Control) → Actions on Objectives. Exemplos: Stuxnet (nuclear iraniano), SolarWinds (supply chain), APT28/Fancy Bear (espionagem)."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Difícil",
    "question": "O que é threat hunting e como difere da detecção convencional?",
    "options": [
      "Busca proativa de ameaças sem esperar alertas; detecção convencional é reativa",
      "É o mesmo que varredura de antivírus",
      "Resposta a incidentes após invasão detectada",
      "Monitoramento passivo de tráfego"
    ],
    "correctIndex": 0,
    "explanation": "Threat hunting é busca proativa por ameaças que escaparam das defesas. O hunter formula hipóteses e busca evidências nos dados. Diferente de detecção reativa (SIEM aguardando alertas pré-definidos).",
    "example": "Detecção: espera alerta → reage. Hunting: assume comprometimento → busca proativamente. Framework: MITRE ATT&CK (TTPs). Sqrrl Hunting Loop: hypothesize → investigate → discover → inform."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Difícil",
    "question": "O que é o framework MITRE ATT&CK e como é utilizado?",
    "options": [
      "Base de conhecimento de táticas, técnicas e procedimentos (TTPs) de atacantes",
      "Software de antivírus corporativo",
      "Norma de certificação como ISO 27001",
      "Protocolo de comunicação entre firewalls"
    ],
    "correctIndex": 0,
    "explanation": "MITRE ATT&CK cataloga táticas (objetivos do atacante), técnicas (como alcança) e procedimentos (implementações específicas) de adversários reais. Usado para mapear defesas, detectar gaps e avaliar ferramentas de segurança.",
    "example": "Táticas: Initial Access, Execution, Persistence, Privilege Escalation, Defense Evasion, Credential Access, Lateral Movement, Collection, Exfiltration, C2, Impact. Cada tática tem múltiplas técnicas."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Difícil",
    "question": "O que é Red Team vs Blue Team em cibersegurança?",
    "options": [
      "Red Team simula atacantes; Blue Team defende; Purple Team integra ambos",
      "São níveis de certificação de segurança",
      "Tipos de firewall corporativo",
      "Classificação de malwares por cor"
    ],
    "correctIndex": 0,
    "explanation": "Red Team: equipe ofensiva que simula ataques reais (TTPs de adversários) para testar as defesas. Blue Team: equipe defensiva que monitora, detecta e responde. Purple Team: integra red+blue, garantindo que achados do red melhorem defesas do blue.",
    "example": "Red: OSCP, Cobalt Strike, C2 frameworks. Blue: SIEM, EDR, forense, IR. Purple: red ataca, blue defende, ambos discutem gaps em tempo real. White Team: árbitros/management do exercício."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Difícil",
    "question": "O que é um supply chain attack e por que é tão perigoso?",
    "options": [
      "Ataque via componente/software de terceiros confiável que atinge múltiplas organizações",
      "Ataque que derruba cadeias de produção físicas",
      "Roubo de mercadorias em trânsito",
      "Vírus que ataca apenas fornecedores"
    ],
    "correctIndex": 0,
    "explanation": "Supply chain attack compromete um fornecedor/componente que organizações confiam: biblioteca, atualização de software, hardware. O atacante injeta código malicioso na fonte, atingindo todos que usam aquele componente. Exemplo: SolarWinds (2020), CodeCov, Log4Shell.",
    "example": "SolarWinds: backdoor na atualização Orion → 18.000 organizações infectadas. Prevenção: SBOM (Software Bill of Materials), assinatura de código, verificação de integridade, supply chain security frameworks."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Difícil",
    "question": "O que é SOAR e como complementa o SIEM?",
    "options": [
      "Plataforma que automatiza respostas a incidentes com playbooks, orquestração e integrações",
      "Versão avançada do antivírus",
      "Protocolo de criptografia corporativa",
      "Firewall com inteligência artificial"
    ],
    "correctIndex": 0,
    "explanation": "SOAR (Security Orchestration, Automation and Response) automatiza a resposta a incidentes. SIEM detecta e alerta; SOAR executa playbooks automatizados (ex: bloquear IP no firewall, isolar endpoint, notificar analista).",
    "example": "SIEM: detecta → alerta → analista manual. SOAR: detecta → playbook automático → remediação. Ferramentas: Cortex XSOAR (Palo Alto), Splunk SOAR, IBM Resilient. Reduz MTTR de horas para minutos."
  },
  {
    "id": "seguranca-da-informacao__Cibersegurança__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Cibersegurança",
    "difficulty": "Difícil",
    "question": "Quais são as fases do framework de resposta a incidentes do NIST?",
    "options": [
      "Preparação, Detecção e Análise, Contenção/Erradicação/Recuperação, Pós-Incidente",
      "Apenas Detecção e Recuperação",
      "Planejamento, Execução, Monitoramento",
      "Auditoria, Remediação, Documentação"
    ],
    "correctIndex": 0,
    "explanation": "NIST SP 800-61: 1) Preparação (planos, ferramentas, treinamento). 2) Detecção e Análise (identificar e classificar incidente). 3) Contenção, Erradicação e Recuperação (limitar dano, remover ameaça, restaurar). 4) Atividades Pós-Incidente (lessons learned).",
    "example": "Fase 1: IRP (Incident Response Plan), playbooks, contatos. Fase 2: alertas SIEM, triagem, escalonamento. Fase 3: isola máquina, remove malware, restaura backup. Fase 4: post-mortem, IOCs compartilhados, melhoria contínua."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre criptografia simétrica e assimétrica?",
    "options": [
      "Simétrica usa uma chave para cifrar/decifrar; assimétrica usa um par de chaves (pública/privada)",
      "Simétrica é mais segura que assimétrica",
      "Assimétrica usa apenas uma chave",
      "Não há diferença prática"
    ],
    "correctIndex": 0,
    "explanation": "Simétrica: mesma chave para cifrar e decifrar (AES, DES, 3DES). Rápida, mas o desafio é compartilhar a chave de forma segura. Assimétrica: usa par de chaves — pública (cifra/verifica) e privada (decifra/assina) — RSA, ECC. Mais lenta, mas resolve o problema de distribuição de chaves.",
    "example": "Simétrica (AES-256): velocidade, usada para dados em trânsito/repouso. Assimétrica (RSA): troca de chaves, assinatura digital. HTTPS usa ambas: assimétrica no handshake TLS para trocar a chave simétrica de sessão."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Fácil",
    "question": "O que é criptografia e para que serve?",
    "options": [
      "Técnica de transformar dados legíveis em ilegíveis para proteger contra acesso não autorizado",
      "Método para comprimir arquivos",
      "Software de backup de dados",
      "Protocolo de transferência de arquivos"
    ],
    "correctIndex": 0,
    "explanation": "Criptografia transforma plaintext (legível) em ciphertext (ilegível) usando algoritmos e chaves. Só quem possui a chave correta pode decifrar. Protege dados em trânsito (HTTPS) e em repouso (disco criptografado).",
    "example": "Exemplo: 'OLÁ' → criptografia com chave → 'X7f#' → decriptação → 'OLÁ'. Histórico: Cifra de César, Enigma. Modernos: AES (simétrico), RSA (assimétrico), ChaCha20."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Fácil",
    "question": "O que é AES e por que é considerado seguro?",
    "options": [
      "Algoritmo simétrico com chaves de 128/192/256 bits, padrão mundial atual",
      "Protocolo de rede segura",
      "Tipo de certificado digital",
      "Algoritmo de hash para senhas"
    ],
    "correctIndex": 0,
    "explanation": "AES (Advanced Encryption Standard) é o padrão mundial de criptografia simétrica, aprovado pelo NIST em 2001. Usa chaves de 128, 192 ou 256 bits. Nenhum ataque prático conhecido contra AES-256. Usado em HTTPS, WPA2/WPA3, BitLocker.",
    "example": "DES (56 bits): obsoleto. 3DES (168 bits): lento, em desuso. AES-256: 2²⁵⁶ combinações — impossível força bruta. Modos: CBC, GCM (autenticado), CTR."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Fácil",
    "question": "O que é criptografia de ponta a ponta (end-to-end encryption)?",
    "options": [
      "Apenas remetente e destinatário podem ler as mensagens; nem o provedor do serviço acessa",
      "Criptografia apenas no servidor",
      "Criptografia só durante a transmissão",
      "Backup criptografado das mensagens"
    ],
    "correctIndex": 0,
    "explanation": "Na E2EE (end-to-end encryption), os dados são criptografados no dispositivo do remetente e só decifrados no dispositivo do destinatário. O provedor do serviço (WhatsApp, Signal) não tem acesso ao conteúdo, pois não possui as chaves.",
    "example": "WhatsApp: Signal Protocol (E2EE por padrão). Telegram: Secret Chats (E2EE opt-in). Signal: referência em privacidade. Sem E2EE: provedor pode ler mensagens. Desafio: backup — WhatsApp oferece backup E2EE opcional."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Fácil",
    "question": "O que são chave pública e chave privada na criptografia assimétrica?",
    "options": [
      "Pública: compartilhada, usada para cifrar/verificar. Privada: secreta, usada para decifrar/assinar",
      "Ambas são idênticas e intercambiáveis",
      "Pública é para assinar e privada para cifrar",
      "São nomes diferentes para a mesma chave"
    ],
    "correctIndex": 0,
    "explanation": "Par de chaves matematicamente relacionadas: chave pública (distribuída livremente) cifra dados ou verifica assinaturas. Chave privada (mantida em segredo) decifra dados ou gera assinaturas. Quem cifra com a pública só pode decifrar com a privada.",
    "example": "Analogia: chave pública = cadeado aberto (qualquer pessoa pode trancar). Chave privada = chave do cadeado (só o dono abre). Geração: `openssl genrsa -out priv.pem 4096` → `openssl rsa -pubout`."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Fácil",
    "question": "O que é RSA e para que é usado?",
    "options": [
      "Algoritmo assimétrico baseado na fatoração de números primos, usado para troca de chaves e assinaturas",
      "Algoritmo simétrico para criptografia de disco",
      "Protocolo de rede segura",
      "Função hash de 256 bits"
    ],
    "correctIndex": 0,
    "explanation": "RSA (Rivest-Shamir-Adleman) é o algoritmo assimétrico mais difundido. Baseado na dificuldade de fatorar o produto de dois primos grandes. Usado em TLS (handshake), assinaturas digitais e certificados. Chaves: 2048 ou 4096 bits.",
    "example": "RSA-2048: seguro até ~2030. RSA-4096: mais seguro, mais lento. Alternativa moderna: ECC (mesma segurança com chave menor). RSA é ~100x mais lento que AES → usado só para trocar chave simétrica (modelo híbrido)."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Fácil",
    "question": "O que é um hash e para que serve?",
    "options": [
      "Função que gera valor fixo a partir de dados para verificar integridade; qualquer alteração muda o hash",
      "Método de criptografia reversível",
      "Protocolo de transferência segura",
      "Tipo de chave de criptografia"
    ],
    "correctIndex": 0,
    "explanation": "Hash é uma função unidirecional que gera uma 'impressão digital' de tamanho fixo a partir de qualquer dado. Qualquer modificação no dado original produz hash completamente diferente. Usado para verificar integridade de arquivos, senhas e assinaturas.",
    "example": "Exemplos: SHA-256 (seguro), MD5/SHA-1 (inseguros, colísões conhecidas). Uso: verificar downloads (checksum), armazenar senhas (com salt), blockchain (hash encadeados). Hash NÃO é criptografia — não é reversível."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Médio",
    "question": "O que é uma função hash e qual propriedade garante que dois arquivos diferentes NÃO gerem o mesmo hash?",
    "options": [
      "Resistência a colisões",
      "Confidencialidade",
      "Reversibilidade",
      "Autenticação mútua"
    ],
    "correctIndex": 0,
    "explanation": "Hash: função que transforma dados de qualquer tamanho em uma saída de tamanho fixo (digest). Propriedades: 1) Determinística (mesma entrada = mesmo hash). 2) Irreversível (não é possível reverter). 3) Resistência a colisões (difícil encontrar duas entradas com mesmo hash). Exemplos: SHA-256, SHA-3.",
    "example": "SHA-256('abc') = ba7816bf... (sempre 256 bits). Mudar 1 bit na entrada muda ~50% dos bits do hash (efeito avalanche). MD5 e SHA-1 têm colisões conhecidas e são inseguros. Use SHA-256 ou SHA-3."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Médio",
    "question": "O que é uma assinatura digital e como funciona?",
    "options": [
      "Hash do documento criptografado com chave privada do autor, verificável com a chave pública",
      "Imagem digitalizada de assinatura manuscrita",
      "Senha usada para assinar documentos",
      "Certificado que permite editar documentos"
    ],
    "correctIndex": 0,
    "explanation": "Assinatura digital: 1) Calcula hash do documento. 2) Hash é criptografado com chave privada. 3) Destinatário decifra com chave pública e compara hashes. Garante autenticidade e integridade.",
    "example": "Autor: SHA-256(doc) = hash → RSA_encrypt(hash, privada) = assinatura. Verificação: RSA_decrypt(assinatura, pública) = hash → comparar. ICP-Brasil: validade jurídica."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Médio",
    "question": "O que é HMAC e qual a diferença de um hash simples?",
    "options": [
      "Hash com chave secreta que garante autenticidade além de integridade",
      "São a mesma coisa",
      "HMAC é mais rápido que hash",
      "Hash é mais seguro que HMAC"
    ],
    "correctIndex": 0,
    "explanation": "HMAC combina função hash com chave secreta. Hash simples garante apenas integridade (qualquer pessoa calcula). HMAC garante integridade E autenticidade (só quem tem a chave pode gerar/verificar).",
    "example": "Hash: SHA-256(msg). HMAC: SHA-256(chave + msg). Uso: APIs (JWT HS256), cookies, tokens. Sem a chave, atacante não pode forjar HMAC válido."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Médio",
    "question": "O que é 'salt' no contexto de hashing de senhas?",
    "options": [
      "Valor aleatório adicionado à senha antes do hash para impedir ataques com rainbow tables",
      "Chave de criptografia simétrica",
      "Algoritmo de compressão de hash",
      "Senha temporária gerada automaticamente"
    ],
    "correctIndex": 0,
    "explanation": "Salt: valor aleatório único concatenado à senha antes do hash. Mesmo duas senhas iguais geram hashes diferentes (salts diferentes). Impede rainbow tables (tabelas pré-computadas de hashes) e ataques de dicionário em lote.",
    "example": "Sem salt: hash('123456') = sempre o mesmo → rainbow table encontra. Com salt: hash('abc123' + '123456') = hash único. Salt armazenado junto ao hash (não precisa ser secreto). bcrypt, Argon2 incluem salt automaticamente."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Médio",
    "question": "O que é criptografia de disco completo (full disk encryption)?",
    "options": [
      "Criptografia de todo o disco/partição tornando dados ilegíveis sem autenticação",
      "Backup automático do disco",
      "Compressão de todos os arquivos",
      "Partição secreta no disco"
    ],
    "correctIndex": 0,
    "explanation": "Full Disk Encryption (FDE) criptografa todo o disco: SO, aplicações e dados. Sem a senha/TPM, o disco é inútil. Protege contra roubo/perda de dispositivos. Exemplos: BitLocker (Windows), FileVault (macOS), LUKS (Linux).",
    "example": "BitLocker: AES-128/256, usa TPM para boot seguro. FileVault: XTS-AES-128. LUKS: padrão Linux (+cryptsetup). FDE não protege enquanto o SO está rodando — protege dados em repouso (at rest)."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Médio",
    "question": "O que é o protocolo Diffie-Hellman?",
    "options": [
      "Método de troca de chaves que permite gerar chave compartilhada por canal inseguro",
      "Algoritmo de criptografia simétrica",
      "Protocolo de autenticação biométrica",
      "Função hash com chave secreta"
    ],
    "correctIndex": 0,
    "explanation": "Diffie-Hellman permite que dois participantes gerem uma chave secreta compartilhada mesmo comunicando-se por canal público. Nenhuma das partes transmite a chave diretamente. Vulnerável a MitM sem autenticação.",
    "example": "Processo: Alice e Bob escolhem p e g públicos, geram valores privados, trocam valores públicos e computam chave compartilhada. ECDHE (Elliptic Curve DH Ephemeral): versão moderna com PFS, usada no TLS 1.3."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Médio",
    "question": "O que é criptografia autenticada (AEAD)?",
    "options": [
      "Combina criptografia e autenticação de integridade em uma operação; ex: AES-GCM",
      "Criptografia que requer biometria",
      "Método de autenticação sem criptografia",
      "Criptografia exclusiva para certificados"
    ],
    "correctIndex": 0,
    "explanation": "AEAD (Authenticated Encryption with Associated Data) cifra dados E garante integridade em uma operação. AES-GCM e ChaCha20-Poly1305 são exemplos. Detecta adulteração do ciphertext, prevenindo ataques como padding oracle.",
    "example": "Sem AEAD: cifra com AES-CBC + HMAC separado (ordem importa, suscetível a problemas). Com AEAD: AES-GCM faz ambos. TLS 1.3 só aceita AEAD. Associated Data: dados autenticados mas não cifrados (headers)."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Médio",
    "question": "O que é AES-GCM e por que é preferido ao AES-CBC com HMAC em protocolos modernos?",
    "options": [
      "AES-GCM: AEAD (cifra + autenticação integrada, GCM usa contador+Galois Field); AES-CBC+HMAC: cifra e MAC separados, vulnerável a padding oracle se implementado incorretamente",
      "AES-GCM é mais lento que AES-CBC; preferido somente por compatibilidade",
      "AES-CBC é AEAD; GCM não oferece autenticação",
      "Ambos são equivalentes em segurança; GCM é apenas mais simples de configurar"
    ],
    "correctIndex": 0,
    "explanation": "AES-GCM (Galois/Counter Mode): modo AEAD (Authenticated Encryption with Associated Data). Em uma operação: cifra (CTR mode) + autenticação (GHASH). IV (nonce) de 96 bits: NUNCA reutilizar com a mesma chave (nonce reuse = catástrofe: chave XOR-able). AES-CBC: não autentica; requer HMAC separado. Padding oracle: CBC vulnerável a ataques de padding (POODLE, Lucky13).",
    "example": "TLS 1.3 remove CBC; somente AEAD (AES-GCM, AES-CCM, ChaCha20-Poly1305). OpenSSL: 'EVP_aes_256_gcm()'. Nonce randomness: 96-bit nonce aleatório para cada mensagem. AES-GCM hardware: AES-NI (Intel/AMD) + PCLMULQDQ para GHASH → throughput 40+ Gbps. CCM: alternativa AEAD para IoT (menor estado)."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Difícil",
    "question": "No protocolo TLS 1.3, quantos round trips (RTTs) são necessários para o handshake completo?",
    "options": [
      "1 RTT (ou 0-RTT com resumption)",
      "3 RTTs",
      "2 RTTs",
      "4 RTTs"
    ],
    "correctIndex": 0,
    "explanation": "TLS 1.3 reduziu o handshake para 1-RTT (vs 2-RTT no TLS 1.2). O cliente envia ClientHello com key shares, o servidor responde com ServerHello + certificado + finish em uma mensagem. Com 0-RTT (early data), conexões resumidas podem enviar dados no primeiro pacote, embora com risco de replay.",
    "example": "TLS 1.2: ClientHello → ServerHello → Certificate → KeyExchange → Finished (2 RTT). TLS 1.3: ClientHello(+KeyShare) → ServerHello(+KeyShare+Cert+Finish) → Finished (1 RTT). 0-RTT: dados no primeiro pacote em resumptions."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Difícil",
    "question": "O que é criptografia homomórfica e qual sua aplicação?",
    "options": [
      "Permite computar sobre dados criptografados sem decifrar; uso em cloud mantendo privacidade",
      "Criptografia que funciona apenas em computadores quânticos",
      "Método de compressão com criptografia simultânea",
      "Hash que permite reverter o processo"
    ],
    "correctIndex": 0,
    "explanation": "Criptografia homomórfica permite operações (soma, multiplicação) em dados criptografados. Resultados decifrados correspondem à operação nos dados originais. Permite processamento em cloud sem expor dados. Ainda computacionalmente cara.",
    "example": "Enc(a) + Enc(b) = Enc(a+b). Cloud processa sem ver valores. Tipos: parcial (uma operação), fully (FHE, qualquer operação). Bibliotecas: Microsoft SEAL, Google FHE. Uso: saúde, finanças."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre ECC (Elliptic Curve Cryptography) e RSA?",
    "options": [
      "ECC oferece mesma segurança com chaves menores; ECC-256 ≈ RSA-3072",
      "RSA é mais rápido que ECC",
      "ECC usa chaves maiores que RSA",
      "Ambos são algoritmos simétricos"
    ],
    "correctIndex": 0,
    "explanation": "ECC baseia-se no logaritmo discreto em curvas elípticas; RSA na fatoração de primos. ECC atinge mesma segurança com chaves menores: ECC-256 ≈ RSA-3072. Resultado: ECC é mais rápido e consome menos recursos.",
    "example": "ECC-256 ≈ RSA-3072 ≈ AES-128 (mesmo nível). TLS 1.3 prefere ECDHE+ECDSA. Curvas: P-256, P-384, Curve25519 (moderna, usada em WireGuard)."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Difícil",
    "question": "O que é criptografia pós-quântica e por que é necessária?",
    "options": [
      "Algoritmos resistentes a computadores quânticos que quebrariam RSA e ECC",
      "Criptografia que só funciona em computadores quânticos",
      "Versão mais rápida do AES",
      "Método de criptografia usando fótons"
    ],
    "correctIndex": 0,
    "explanation": "Computadores quânticos com algoritmo de Shor poderiam quebrar RSA e ECC. Criptografia pós-quântica usa problemas matemáticos resistentes a quânticos: lattices, códigos, hashes. NIST selecionou CRYSTALS-Kyber (encapsulação) e CRYSTALS-Dilithium (assinatura).",
    "example": "Shor: quebra RSA/ECC. Grover: reduz segurança de AES pela metade (AES-256 → 128 bits quânticos). NIST PQC: Kyber (ML-KEM), Dilithium (ML-DSA). Hybrid: TLS com clássico + PQC simultaneamente. 'Colha agora, decifre depois' → urgência."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Difícil",
    "question": "O que são funções de derivação de chave como bcrypt, scrypt e Argon2?",
    "options": [
      "Funções propositalmente lentas para dificultar força bruta em hashes de senhas",
      "Algoritmos rápidos de criptografia simétrica",
      "Métodos de compressão de chaves",
      "Protocolos de troca de chaves"
    ],
    "correctIndex": 0,
    "explanation": "KDFs (Key Derivation Functions) para senhas são intencionalmente lentas e consomem muita memória/CPU. bcrypt: custo configurável (rounds). scrypt: custo de memória. Argon2: vencedor do PHC (Password Hashing Competition), custo de tempo + memória + paralelismo.",
    "example": "SHA-256(senha): bilhões/segundo em GPU. bcrypt(12 rounds): ~3/segundo. Argon2id: recomendado (resistência a GPU/ASIC). Configuração: pelo menos 250ms por hash. OWASP recomenda Argon2id."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Difícil",
    "question": "O que é o algoritmo de Shor e qual seu impacto na criptografia?",
    "options": [
      "Algoritmo quântico que fatoriza primos em tempo polinomial, quebrando RSA e ECC",
      "Algoritmo clássico de criptografia simétrica",
      "Método de geração de números aleatórios",
      "Função hash resistente a colisões"
    ],
    "correctIndex": 0,
    "explanation": "O algoritmo de Shor (1994) pode fatorar números primos e resolver logaritmos discretos em tempo polinomial em um computador quântico. Isso quebraria RSA, ECC e Diffie-Hellman. Por isso a urgência em migrar para criptografia pós-quântica.",
    "example": "RSA: segurança baseada em fatoração de primos. ECC: logaritmo discreto em curvas elípticas. Shor resolve ambos. AES é menos afetado (Grover: reduz segurança pela metade). Timeline: 10-20 anos para quantum prático, mas 'harvest now, decrypt later'."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Difícil",
    "question": "O que é Key Wrapping e como é usado em gerenciamento de chaves?",
    "options": [
      "Técnica de criptografar uma chave com outra chave (KEK) para proteger chaves em trânsito ou armazenamento",
      "Método de geração de chaves aleatórias",
      "Protocolo de distribuição de chaves públicas",
      "Backup de chaves em hardware"
    ],
    "correctIndex": 0,
    "explanation": "Key Wrapping criptografa uma chave (DEK — Data Encryption Key) usando outra chave (KEK — Key Encryption Key). Permite armazenar e transportar chaves de forma segura. Algoritmo: AES Key Wrap (RFC 3394).",
    "example": "Modelo envelope: dados cifrados com DEK → DEK cifrado com KEK → KEK protegido em HSM. AWS KMS: dados cifrados com data key, data key cifrada com master key (envelope encryption). Evita exposição da master key."
  },
  {
    "id": "seguranca-da-informacao__Criptografia__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Criptografia",
    "difficulty": "Difícil",
    "question": "O que é criptografia pós-quântica (PQC) e quais algoritmos foram padronizados pelo NIST em 2024?",
    "options": [
      "PQC: algoritmos resistentes a computadores quânticos (Shor quebra RSA/ECC); NIST 2024: ML-KEM (CRYSTALS-Kyber) para KEM, ML-DSA (CRYSTALS-Dilithium) e SLH-DSA (SPHINCS+) para assinatura",
      "PQC usa chaves simétricas maiores; RSA-4096 é considerado pós-quântico",
      "NIST ainda não padronizou nenhum algoritmo PQC; o processo está em fase inicial",
      "AES-256 é quebrado por computadores quânticos; PQC substitui somente criptografia simétrica"
    ],
    "correctIndex": 0,
    "explanation": "Shor's algorithm: quebra RSA, DSA, ECDSA, DH em tempo polinomial em QC. Grover's algorithm: reduz segurança simétrica à metade (AES-128 → AES-64-equivalent; AES-256 suficiente). NIST PQC (2024, FIPS 203/204/205): ML-KEM (lattice, key encapsulation), ML-DSA (lattice, digital signature), SLH-DSA (hash-based, stateless). CRYSTALS: Cryptographic Suite for Algebraic Lattices.",
    "example": "'Harvest now, decrypt later': adversários coletam tráfego criptografado atual para decifrar quando QC disponível. TLS PQC: hybrid mode (X25519 + Kyber). CNSA 2.0 (NSA): prazo 2030-2035 para migração. XMSS/LMS: alternativas hash-based stateful para assinatura. OpenSSL 3.x + liboqs: integração PQC. Quantum-safe VPN: implementações piloto na Europa."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Fácil",
    "question": "Qual conceito de segurança diz que um usuário deve ter apenas as permissões mínimas necessárias para realizar seu trabalho?",
    "options": [
      "Princípio do menor privilégio (Least Privilege)",
      "Segregação de funções",
      "Defesa em profundidade",
      "Zero Trust"
    ],
    "correctIndex": 0,
    "explanation": "O princípio do menor privilégio (PoLP) limita o acesso de cada usuário, processo ou sistema ao mínimo necessário. Reduz a superfície de ataque e o impacto de contas comprometidas. Exemplo: um analista financeiro não precisa de acesso admin ao servidor.",
    "example": "Aplicação prática: usar conta padrão (não admin) no dia a dia; dar acesso somente às pastas necessárias; usar sudo em vez de login como root. Se uma conta for comprometida, o dano é limitado."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Fácil",
    "question": "O que é autenticação em segurança da informação?",
    "options": [
      "Processo de verificar a identidade de um usuário antes de conceder acesso",
      "Permissão para acessar qualquer recurso",
      "Registro de atividades do usuário",
      "Criptografia de dados do usuário"
    ],
    "correctIndex": 0,
    "explanation": "Autenticação verifica 'quem é você'. Métodos: senha (algo que sabe), token (algo que tem), biometria (algo que é). Diferente de autorização (o que pode fazer) e auditoria (o que fez). Juntos formam AAA.",
    "example": "AAA: Authentication (quem é), Authorization (o que pode), Accounting (o que fez). Login com senha = autenticação. Acesso à pasta financeira = autorização. Log de arquivos abertos = auditoria."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Fácil",
    "question": "O que é MFA (Multi-Factor Authentication) e por que é importante?",
    "options": [
      "Autenticação com dois ou mais fatores diferentes; protege mesmo se a senha for comprometida",
      "Usar múltiplas senhas para a mesma conta",
      "Login em múltiplos dispositivos",
      "Firewall com múltiplas regras"
    ],
    "correctIndex": 0,
    "explanation": "MFA exige fatores de categorias diferentes. Se a senha vaza, o atacante ainda precisa do segundo fator. FIDO2/WebAuthn é o padrão mais seguro (phishing-resistant).",
    "example": "Segurança: SMS (SIM swap vulnerável) < TOTP (Google Authenticator) < FIDO2/hardware key. MFA ≠ duas senhas (mesmo fator). Fatores: Conhecimento, Posse, Inerência."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre autenticação e autorização?",
    "options": [
      "Autenticação verifica a identidade; autorização define o que o usuário pode acessar",
      "São a mesma coisa",
      "Autorização vem antes da autenticação",
      "Autenticação é para redes e autorização para aplicações"
    ],
    "correctIndex": 0,
    "explanation": "Autenticação (AuthN): 'quem é você?' (login). Autorização (AuthZ): 'o que você pode fazer?' (permissões). Primeiro autentica, depois autoriza. Exemplo: login (AuthN) → acesso à pasta financeira negado (AuthZ).",
    "example": "OAuth 2.0 = AuthZ framework (access token). OIDC = AuthN layer (ID token). SAML = ambos. Erro comum: confundir os dois. Um usuário autenticado não necessariamente está autorizado."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Fácil",
    "question": "O que é uma política de senhas?",
    "options": [
      "Conjunto de regras sobre comprimento mínimo, complexidade e renovação de senhas",
      "Software que gera senhas automáticas",
      "Lista de senhas proibidas",
      "Método de criptografia de senhas"
    ],
    "correctIndex": 0,
    "explanation": "Política de senhas define: comprimento mínimo (ex: 12+ caracteres), complexidade (maiúsculas, números, símbolos), histórico (não repetir), bloqueio após tentativas falhas. NIST 800-63 moderno: priorizar comprimento sobre complexidade.",
    "example": "NIST atual: mín 8 chars, sem obrigar complexidade forçada, verificar contra listas de senhas vazadas, sem expirar forçada. Melhor: passphrase longa ('cavalo-bateria-grampo-correto') + MFA."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Fácil",
    "question": "O que é biometria e como é usada no controle de acesso?",
    "options": [
      "Uso de características físicas únicas como impressão digital, rosto ou íris para autenticação",
      "Senha gerada por algoritmo matemático",
      "Certificado digital pessoal",
      "Cartão de acesso com chip RFID"
    ],
    "correctIndex": 0,
    "explanation": "Biometria usa características físicas ou comportamentais para autenticar. Tipos: impressão digital, reconhecimento facial, íris, voz, padrão de digitação. É o fator 'algo que você é' (inerência). Vantagem: não pode ser esquecida nem emprestada.",
    "example": "FAR (False Acceptance Rate): aceitar impostores. FRR (False Rejection Rate): rejeitar usuários legítimos. CER (Crossover Error Rate): equilíbrio ideal. Problema: biometria comprometida não pode ser 'trocada' como senha."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Fácil",
    "question": "O que é bloqueio de conta (account lockout)?",
    "options": [
      "Mecanismo que bloqueia temporariamente a conta após várias tentativas de login falhas",
      "Desativação permanente de conta inativa",
      "Criptografia de credenciais",
      "Backup de senhas no servidor"
    ],
    "correctIndex": 0,
    "explanation": "Account lockout bloqueia a conta após N tentativas falhas (ex: 5 falhas → bloqueio de 30 min). Previne força bruta. Risco: DoS intencional (atacante bloqueia contas legítimas). Mitigação: lockout progressivo, CAPTCHA.",
    "example": "Configuração típica: 5 tentativas → lockout 15-30 min. Alternativas: rate limiting (limitar tentativas por IP), CAPTCHA após 3 falhas, MFA. AD: Account Lockout Policy (GPO). Monitorar via Event ID 4740."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre os modelos de controle de acesso DAC, MAC e RBAC?",
    "options": [
      "DAC: dono do recurso define acesso; MAC: sistema de rótulos de segurança (top secret, classified) define acesso; RBAC: acesso baseado em papéis/funções do usuário na organização",
      "DAC é o modelo mais seguro; MAC é usado somente em redes sociais",
      "RBAC e DAC são equivalentes; MAC é somente para ambientes militares online",
      "MAC controla acesso por endereço MAC de rede; DAC por domínio Active Directory"
    ],
    "correctIndex": 0,
    "explanation": "DAC (Discretionary Access Control): proprietário controla (chmod Unix, ACLs Windows). MAC (Mandatory Access Control): rótulos de sigilo (SELinux, AppArmor, Trusted Solaris); sistema define, não o usuário. RBAC (Role-Based): roles (administrador, analista); usuários atribuídos a roles; NIST RBAC model. ABAC (Attribute-Based): política baseada em atributos (departamento, local, hora).",
    "example": "SELinux: MAC no Linux (contexts: user:role:type:level). AppArmor: MAC por perfil de aplicação. Active Directory: RBAC via grupos de segurança. Zero Trust: ABAC + identity verification contínua. Princípio do menor privilégio: usuário tem apenas permissões necessárias. Separation of Duties: duas pessoas aprovam ação crítica."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Médio",
    "question": "Qual modelo de controle de acesso usa papéis (roles) para atribuir permissões aos usuários?",
    "options": [
      "RBAC (Role-Based Access Control)",
      "DAC (Discretionary Access Control)",
      "MAC (Mandatory Access Control)",
      "ABAC (Attribute-Based Access Control)"
    ],
    "correctIndex": 0,
    "explanation": "RBAC: permissões são atribuídas a papéis (admin, editor, leitor), e usuários são atribuídos a papéis. Simplifica a gestão de permissões. DAC: o dono do recurso define permissões. MAC: acesso baseado em classificação (secreto, confidencial). ABAC: baseado em atributos (hora, local, departamento).",
    "example": "RBAC: User → Role → Permission. Ex: 'Médico' tem permissão de 'ler prontuário' e 'prescrever'. Novo médico → atribui role 'Médico' → herda todas as permissões. Escalável e auditável."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Médio",
    "question": "O que é o modelo AAA (Authentication, Authorization, Accounting)?",
    "options": [
      "Framework que combina autenticação (quem é), autorização (o que pode) e contabilização (o que fez)",
      "Três tipos de firewall diferentes",
      "Classificação de risco em três níveis",
      "Três camadas de criptografia"
    ],
    "correctIndex": 0,
    "explanation": "AAA: Authentication (identidade), Authorization (permissões), Accounting (registro de ações). Implementado com RADIUS e TACACS+. Exemplo: login via RADIUS, permissões do papel, ações registradas.",
    "example": "RADIUS (porta 1812): AuthN+AuthZ juntos, criptografa só a senha. TACACS+ (porta 49): separa os três, criptografa pacote inteiro. RADIUS: redes. TACACS+: dispositivos Cisco."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Médio",
    "question": "O que é Single Sign-On (SSO) e quais seus benefícios?",
    "options": [
      "Login único que dá acesso a múltiplos sistemas sem reautenticar",
      "Senha que funciona apenas uma vez",
      "Login que exige senha a cada ação",
      "Sistema que bloqueia acesso após uma tentativa"
    ],
    "correctIndex": 0,
    "explanation": "SSO permite login uma vez para acessar múltiplos sistemas. Benefícios: melhor experiência, menos senhas, controle centralizado. Protocolos: SAML, OAuth 2.0, OpenID Connect.",
    "example": "Exemplo: login Google dá acesso a Gmail, Drive, YouTube. SAML (enterprise, XML), OAuth 2.0 (authorization), OIDC (authentication, JSON). Risco: conta SSO comprometida = acesso a tudo."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Médio",
    "question": "O que é NAC (Network Access Control)?",
    "options": [
      "Sistema que verifica conformidade do dispositivo antes de permitir acesso à rede",
      "Firewall de próxima geração",
      "Protocolo de criptografia de rede",
      "Software de monitoramento de tráfego"
    ],
    "correctIndex": 0,
    "explanation": "NAC verifica se o dispositivo atende às políticas de segurança antes de conceder acesso: antivírus atualizado, patches em dia, disk encryption, conformidade. Se não conforme: quarentena ou acesso limitado.",
    "example": "Implementação: 802.1X + RADIUS + agent no endpoint. Pré-admission: verifica antes de dar acesso. Post-admission: monitora continuamente. Ferramentas: Cisco ISE, Aruba ClearPass, Forescout."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Médio",
    "question": "O que é Segregação de Funções (Separation of Duties/SoD)?",
    "options": [
      "Princípio em que nenhuma pessoa tem privilégios suficientes para cometer fraude sozinha",
      "Dividir a rede em segmentos",
      "Ter dois firewalls em série",
      "Usar senhas diferentes para cada sistema"
    ],
    "correctIndex": 0,
    "explanation": "SoD divide responsabilidades críticas entre múltiplas pessoas. Exemplo: quem solicita pagamento ≠ quem aprova ≠ quem executa. Previne fraude e erros. Complementar ao menor privilégio.",
    "example": "DevOps: dev não faz deploy em prod sozinho. Financeiro: 4-eyes principle (dupla aprovação). IAM: RBAC com roles mutuamente exclusivas. SOX compliance exige SoD para empresas públicas."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Médio",
    "question": "O que é SAML e onde é usado?",
    "options": [
      "Protocolo baseado em XML para Single Sign-On em ambientes corporativos",
      "Algoritmo de criptografia simétrica",
      "Software de gerenciamento de senhas",
      "Firewall para aplicações web"
    ],
    "correctIndex": 0,
    "explanation": "SAML (Security Assertion Markup Language) é um protocolo baseado em XML que permite SSO entre Identity Provider (IdP) e Service Provider (SP). Muito usado em ambientes corporativos para login único em múltiplas aplicações.",
    "example": "Fluxo: usuário acessa SP → redireciona para IdP (ex: Okta, Azure AD) → autentica → IdP envia SAML Assertion (assinada) → SP valida e dá acesso. SAML vs OIDC: SAML é XML (enterprise), OIDC é JSON/JWT (moderno)."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Médio",
    "question": "O que é IAM (Identity and Access Management)?",
    "options": [
      "Sistema centralizado que gerencia identidades, autenticação, autorização e ciclo de vida de contas",
      "Tipo de firewall para aplicações",
      "Protocolo de criptografia",
      "Software de backup de credenciais"
    ],
    "correctIndex": 0,
    "explanation": "IAM é o framework que gerencia: criação e exclusão de contas, autenticação (MFA/SSO), autorização (RBAC/ABAC), auditoria e compliance. Centraliza o controle sobre quem acessa o quê em toda a organização.",
    "example": "Componentes: Identity Provider (IdP), Directory (AD/LDAP), SSO, MFA, PAM, Identity Governance. Soluções: Azure AD (Entra ID), Okta, AWS IAM, Google Workspace. Onboarding/offboarding automatizado."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Médio",
    "question": "O que é PAM (Privileged Access Management) e como reduz o risco de contas privilegiadas?",
    "options": [
      "PAM: solução que controla, monitora e audita acesso de contas privilegiadas (admin, root, SA); cofre de senhas, sessões gravadas, just-in-time access, aprovação para uso de credenciais",
      "PAM é o módulo de autenticação plugável do Linux (Linux-PAM)",
      "PAM gerencia apenas senhas de usuários comuns; admins têm acesso irrestrito",
      "PAM é equivalente a um firewall para tráfego administrativo SSH"
    ],
    "correctIndex": 0,
    "explanation": "No contexto de segurança corporativa, PAM (Privileged Access Management): CyberArk, BeyondTrust, Thycotic. Cofre de senhas: credenciais privilegiadas armazenadas cifradas; checkout por sessão. Session recording: gravação de terminal/RDP para auditoria e forense. Just-in-time (JIT): acesso temporário com prazo. Privilege escalation justificada + aprovação de gestor.",
    "example": "Threat: credential theft (Pass-the-Hash, Kerberoasting) de contas privilegiadas. PAM mitiga: credenciais rotacionadas automaticamente; humanos nunca veem senha real. PEDM (Privilege Elevation and Delegation Management): sudo com logging. Bastion host: jump server com PAM para acesso a servidores internos. NIST SP 1800-18: guia PAM."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Difícil",
    "question": "No modelo Zero Trust, qual é o princípio fundamental que o diferencia do modelo de segurança perimetral?",
    "options": [
      "Nunca confiar, sempre verificar — toda requisição é autenticada e autorizada independentemente da origem",
      "Confiar em tudo dentro da rede corporativa",
      "Usar apenas firewalls de próxima geração",
      "Eliminar senhas e usar apenas biometria"
    ],
    "correctIndex": 0,
    "explanation": "Zero Trust elimina o conceito de 'rede confiável'. Mesmo dentro da rede corporativa, cada requisição é autenticada, autorizada e criptografada. Assume que qualquer dispositivo/usuário pode estar comprometido. Pilares: verificação contínua, menor privilégio, microsegmentação, MFA.",
    "example": "Modelo antigo: 'dentro da rede = confiável'. Zero Trust: 'ninguém é confiável por padrão'. Implementação: IAM robusto, MFA, microsegmentação, cifração end-to-end, monitoramento contínuo. Frameworks: NIST SP 800-207, Google BeyondCorp."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Difícil",
    "question": "Como funciona o OAuth 2.0 e qual a diferença para OpenID Connect (OIDC)?",
    "options": [
      "OAuth 2.0 é para autorização (access tokens); OIDC adiciona autenticação (ID tokens)",
      "OAuth é mais seguro que OIDC",
      "Ambos são protocolos de criptografia",
      "OIDC substituiu completamente o OAuth"
    ],
    "correctIndex": 0,
    "explanation": "OAuth 2.0: framework de autorização — permite apps acessarem recursos em nome do usuário (access token), sem expor senha. NÃO autentica. OIDC: camada de identidade sobre OAuth 2.0 com ID token (JWT).",
    "example": "OAuth: 'app X pode acessar suas fotos' (autorização). OIDC: 'faça login com Google' (autenticação). Grant types: authorization code, implicit, client credentials. OAuth sozinho não diz quem é o usuário."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Difícil",
    "question": "O que é PAM (Privileged Access Management) e por que é essencial?",
    "options": [
      "Gerenciamento de contas privilegiadas para controlar, monitorar e auditar acessos admin",
      "Software antivírus para administradores",
      "Plugin de autenticação para Linux",
      "Módulo de autorização em servidores web"
    ],
    "correctIndex": 0,
    "explanation": "PAM protege contas privilegiadas (admin, root, DBA). Cofre de senhas, rotação automática, sessões gravadas, acesso just-in-time. Contas privilegiadas são o alvo #1 de atacantes.",
    "example": "Sem PAM: admin compartilha senha root. Com PAM: solicita acesso → aprovação → senha temporária → sessão gravada → revogado. Ferramentas: CyberArk, BeyondTrust, HashiCorp Vault."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Difícil",
    "question": "O que é ABAC (Attribute-Based Access Control) e como difere do RBAC?",
    "options": [
      "ABAC usa atributos (horário, localização, risco) para decisões; mais granular que RBAC baseado em papéis",
      "São idênticos",
      "ABAC é mais simples que RBAC",
      "RBAC usa atributos e ABAC usa papéis"
    ],
    "correctIndex": 0,
    "explanation": "RBAC: User → Role → Permission. ABAC: avalia atributos do sujeito (cargo, departamento), recurso (classificação), ação (ler/escrever) e contexto (horário, localização, risco) para cada decisão. ABAC é mais flexível mas mais complexo.",
    "example": "RBAC: 'Médico pode ler prontuário'. ABAC: 'Médico pode ler prontuário SE no horário de expediente E no hospital E é seu paciente'. Políticas XACML ou OPA (Open Policy Agent). AWS IAM usa ABAC."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Difícil",
    "question": "O que é JIT (Just-In-Time) access em controle de acesso?",
    "options": [
      "Acesso privilegiado concedido temporariamente sob demanda e revogado automaticamente",
      "Acesso permanente a recursos críticos",
      "Login imediato sem autenticação",
      "Backup just-in-time de credenciais"
    ],
    "correctIndex": 0,
    "explanation": "JIT access: privilégios elevados são concedidos apenas quando necessários, por tempo limitado, com aprovação. Após o período, acesso é revogado automaticamente. Reduz a janela de exposição de contas privilegiadas.",
    "example": "Sem JIT: admin tem acesso 24/7 (risco). Com JIT: solicita → justificativa → aprovação → acesso por 4h → revogado. Azure AD PIM (Privileged Identity Management) e AWS IAM Identity Center suportam JIT."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Difícil",
    "question": "O que é microsegmentação e como melhora o controle de acesso?",
    "options": [
      "Divisão da rede em segmentos granulares com políticas individuais, limitando movimentação lateral",
      "Uso de múltiplos firewalls em série",
      "Criptografia de cada segmento separadamente",
      "Backup segmentado por departamento"
    ],
    "correctIndex": 0,
    "explanation": "Microsegmentação cria zonas de segurança granulares (até nível de workload/container). Cada segmento tem políticas de acesso próprias. Se um atacante compromete um segmento, não consegue mover-se lateralmente para outros.",
    "example": "VLAN: segmentação macro. Microsegmentação: políticas por workload (VM, container, bare-metal). Ferramentas: VMware NSX, Illumio, Guardicore. Zero Trust: microsegmentação é pilar fundamental."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Difícil",
    "question": "O que é FIDO2/WebAuthn e por que é resistente a phishing?",
    "options": [
      "Padrão de autenticação com chave pública vinculada ao domínio; chave privada nunca sai do dispositivo",
      "Versão avançada de senhas de uso único",
      "Protocolo de criptografia de email",
      "Método de autenticação por SMS"
    ],
    "correctIndex": 0,
    "explanation": "FIDO2/WebAuthn usa criptografia de chave pública: a chave privada fica no dispositivo (hardware key ou biometria), vinculada ao domínio específico. Site falso com domínio diferente não consegue se autenticar → phishing-resistant.",
    "example": "Fluxo: registro gera par de chaves (privada no dispositivo, pública no servidor). Login: servidor envia challenge → dispositivo assina com privada → servidor verifica com pública. Hardware: YubiKey, Titan Key. Passwordless: futuro da autenticação (passkeys)."
  },
  {
    "id": "seguranca-da-informacao__Controle de Acesso__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Controle de Acesso",
    "difficulty": "Difícil",
    "question": "Como o modelo Zero Trust Architecture (ZTA) difere do modelo de segurança perimetral e quais seus pilares?",
    "options": [
      "ZTA: 'nunca confiar, sempre verificar'; sem zona interna confiável; verificação contínua de identidade, dispositivo, contexto; microsegmentação; least-privilege por sessão",
      "Zero Trust elimina completamente firewalls e proxies na arquitetura",
      "ZTA é equivalente ao modelo de defesa em profundidade com DMZ",
      "Zero Trust confia em todos os usuários internos; desconfia somente de externos"
    ],
    "correctIndex": 0,
    "explanation": "Modelo perimetral: tudo dentro da rede corporativa é confiável (VPN = passa pelo firewall = confiável). Zero Trust (NIST SP 800-207): nenhum usuário/dispositivo é confiável por padrão, mesmo internamente. Pilares: (1) Identity verification (MFA, continuous auth); (2) Device health (EDR, compliance check); (3) Microsegmentation (lateralidade bloqueada); (4) Least-privilege (JIT, RBAC granular); (5) Assume breach (XDR, SIEM, monitoring).",
    "example": "Implementação ZTA: Google BeyondCorp (acesso baseado em device cert + identity, sem VPN). Microsoft ZTA: Conditional Access (Azure AD), Intune (device compliance), Defender. SASE (Secure Access Service Edge): ZTA + SD-WAN como serviço (Zscaler, Cloudflare One). Lateral movement prevention: microsegmentação (VMware NSX, Illumio). Continuous validation: re-autenticação por risco (UEBA)."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Fácil",
    "question": "Qual é o primeiro passo ao realizar uma investigação forense digital?",
    "options": [
      "Preservar as evidências (cadeia de custódia)",
      "Deletar logs suspeitos",
      "Reiniciar o computador",
      "Instalar um antivírus"
    ],
    "correctIndex": 0,
    "explanation": "A preservação de evidências é fundamental: qualquer alteração pode invalidar a prova judicialmente. Deve-se isolar o dispositivo, fazer imagem forense bit-a-bit do disco e documentar cada ação (cadeia de custódia). Nunca trabalhe na evidência original.",
    "example": "Cadeia de custódia: quem, quando, onde, o quê. Usar write-blockers para evitar alteração do disco. Criar imagem forense com dd ou FTK Imager. Calcular hash (SHA-256) da imagem para garantir integridade."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Fácil",
    "question": "O que é uma imagem forense de um disco?",
    "options": [
      "Cópia bit-a-bit exata de todo o conteúdo do disco, incluindo dados deletados",
      "Screenshot da tela do computador",
      "Foto do equipamento apreendido",
      "Backup dos arquivos visíveis do disco"
    ],
    "correctIndex": 0,
    "explanation": "Imagem forense é clone exato bit-a-bit do disco, incluindo espaço livre e dados não alocados. Diferente de backup comum, que copia só arquivos visíveis. Usa-se write-blockers para não alterar o original.",
    "example": "Ferramentas: dd (Linux), FTK Imager, EnCase. Hash SHA-256 garante integridade. Formatos: raw (.001), E01 (EnCase), AFF. Análise é feita na cópia, NUNCA no original."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Fácil",
    "question": "Para que serve um write-blocker em forense digital?",
    "options": [
      "Impedir qualquer escrita no disco original durante a coleta de evidências",
      "Bloquear vírus no computador",
      "Impedir cópia de arquivos do disco",
      "Criptografar dados antes de copiar"
    ],
    "correctIndex": 0,
    "explanation": "Write-blocker (hardware ou software) permite apenas leitura do disco de evidência, impedindo alteração acidental. Essencial para manter integridade da evidência e validade legal da cadeia de custódia.",
    "example": "Hardware: dispositivo físico entre disco e computador forense. Software: PALADIN, regras de somente-leitura. Sem write-blocker: montar o disco pode alterar timestamps e metadados."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Fácil",
    "question": "O que é hash em forense digital e para que serve?",
    "options": [
      "Valor único gerado a partir de dados que garante a integridade da evidência",
      "Senha criptografada do disco",
      "Método de compressão de arquivos forenses",
      "Backup do disco de evidência"
    ],
    "correctIndex": 0,
    "explanation": "Hash (SHA-256, MD5) gera um valor fixo a partir de qualquer dado. Qualquer alteração gera hash diferente, provando que a evidência foi modificada. Deve-se calcular hash ao coletar e ao analisar.",
    "example": "Fluxo: coletar disco → calcular SHA-256 → gerar imagem forense → calcular SHA-256 da imagem → comparar. Se hashes iguais = cópia íntegra. Ferramentas: sha256sum, md5sum, hashdeep."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Fácil",
    "question": "O que é cadeia de custódia em forense digital?",
    "options": [
      "Documentação de todas as pessoas e ações realizadas sobre uma evidência",
      "Corrente usada para prender equipamentos apreendidos",
      "Sequência de senhas de acesso ao sistema",
      "Lista de softwares instalados no computador"
    ],
    "correctIndex": 0,
    "explanation": "Cadeia de custódia registra quem coletou, transportou, armazenou e analisou cada evidência, com datas e assinaturas. Qualquer falha invalida a prova judicialmente. Deve ser ininterrupta.",
    "example": "Campos: data/hora, responsável, ação (coleta/transporte/análise), local, condição. Sem cadeia de custódia ⇒ advogado contesta integridade ⇒ prova rejeitada pelo juiz."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Fácil",
    "question": "O que é volatilidade de dados em forense digital?",
    "options": [
      "Classificação dos dados conforme a rapidez com que se perdem ao desligar o dispositivo",
      "Capacidade de armazenamento do disco rígido",
      "Velocidade de leitura da memória RAM",
      "Taxa de falha de componentes eletrônicos"
    ],
    "correctIndex": 0,
    "explanation": "Dados voláteis (RAM, cache, registradores) se perdem ao desligar; dados não voláteis (disco, flash) persistem. A RFC 3227 define a ordem de coleta: mais volátil primeiro.",
    "example": "Ordem de volatilidade (RFC 3227): registradores → cache → RAM → tabelas de roteamento → disco → mídias removíveis → logs remotos. RAM deve ser capturada ANTES de desligar com LiME ou winpmem."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Fácil",
    "question": "O que é a ferramenta Autopsy em forense digital?",
    "options": [
      "Plataforma open-source de análise forense que examina discos, recupera arquivos e analisa artefatos",
      "Software para criptografar evidências digitais",
      "Antivírus especializado em forense",
      "Ferramenta de backup forense proprietária"
    ],
    "correctIndex": 0,
    "explanation": "Autopsy é plataforma GUI open-source baseada no Sleuth Kit para análise forense. Permite: examinar imagens de disco, recuperar arquivos deletados, analisar timeline, extrair artefatos web e e-mail.",
    "example": "Autopsy + Sleuth Kit: padrão open-source. Funcionalidades: file carving, keyword search, hash filtering, EXIF extraction, timeline. Alternativas comerciais: EnCase, FTK (Forensic Toolkit), X-Ways."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Fácil",
    "question": "O que é a cadeia de custódia em forense digital e por que é essencial em investigações?",
    "options": [
      "Cadeia de custódia: documentação cronológica de quem coletou, transportou e acessou a evidência; garante integridade e admissibilidade legal das evidências digitais",
      "Cadeia de custódia é o registro de todos os arquivos apagados de um sistema",
      "É um protocolo de comunicação entre peritos forenses via rede cifrada",
      "Refere-se ao hash MD5 calculado antes e após análise de evidência"
    ],
    "correctIndex": 0,
    "explanation": "Cadeia de custódia: quem, quando, onde coletou e acessou a evidência. Evidência digital: volátil (RAM, processos, conexões) e não-volátil (disco, logs). Integridade: hash SHA-256 do image antes e após. Admissibilidade: se a cadeia for quebrada, evidência pode ser descartada no processo judicial. ISO/IEC 27037: diretrizes para identificação, coleta e preservação de evidências.",
    "example": "Hash de imagem: 'sha256sum imagem.dd'. Write blocker: hardware que impede escrita no disco original (Tableau, WiebeTech). FTK Imager / dd / dcfldd: ferramentas de imagem forense. Live acquisition: AVML, LiME (RAM acquisition). Formulário de custódia: data, hora, responsável, hashes, assinatura. Evidência original: nunca analisada diretamente (analisa-se cópia)."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Médio",
    "question": "O que são metadados em contexto forense e por que são importantes?",
    "options": [
      "Dados sobre dados (autoria, data, localização) que podem revelar informações ocultas sobre um arquivo",
      "São os dados visíveis no conteúdo do arquivo",
      "São vírus escondidos em documentos",
      "São backups automáticos do sistema"
    ],
    "correctIndex": 0,
    "explanation": "Metadados são 'dados sobre dados': informações como data de criação/modificação, autor, localização GPS (em fotos), dispositivo usado, histórico de edições. Em forense, metadados revelam quem criou o arquivo, quando, onde e com qual software — mesmo que o conteúdo visível não mostre.",
    "example": "Foto JPEG: EXIF contém modelo da câmera, data, coordenadas GPS. Documento Word: autor, datas, impressora, revisões. Email: headers com IPs de origem, rota, timestamps. Ferramenta: ExifTool, Autopsy."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Médio",
    "question": "O que é esteganografia e como se relaciona com forense?",
    "options": [
      "Técnica de esconder informações dentro de arquivos como imagens, sem alterar a aparência",
      "Criptografia de nível militar",
      "Técnica de compressão de dados",
      "Método de recuperar arquivos deletados"
    ],
    "correctIndex": 0,
    "explanation": "Esteganografia oculta dados dentro de outros arquivos (imagens, áudio) de forma imperceptível. Diferente de criptografia (esconde conteúdo), esteganografia esconde que há mensagem. Forense: detectar com steganalysis.",
    "example": "Técnica: substituir bits menos significativos (LSB) de pixels. Foto parece normal mas contém dados ocultos. Detecção: StegDetect, zsteg, binwalk. Esteganografia + criptografia = muito difícil de detectar."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Médio",
    "question": "O que são artefatos forenses em um sistema operacional?",
    "options": [
      "Vestígios de atividade: registros, logs, arquivos temporários e histórico de navegação",
      "Hardware apreendido como evidência",
      "Vírus encontrados no sistema",
      "Backups automáticos do sistema"
    ],
    "correctIndex": 0,
    "explanation": "Artefatos são vestígios digitais: Windows Registry, prefetch (programas executados), browser history, LNK files (atalhos recentes), Event Logs, arquivos temporários, lixeira.",
    "example": "Windows: Registry (NTUSER.DAT, SAM, SYSTEM), Prefetch, $MFT, Event Logs. Linux: /var/log, .bash_history, wtmp/btmp. Browser: SQLite (History, Cookies). Ferramentas: Autopsy, KAPE."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Médio",
    "question": "O que é file carving em forense digital?",
    "options": [
      "Técnica de recuperação de arquivos usando assinaturas de cabeçalho e rodapé em dados brutos",
      "Técnica de criptografia de disco",
      "Método de formatação segura",
      "Processo de compactação de evidências"
    ],
    "correctIndex": 0,
    "explanation": "File carving recupera arquivos de espaço não alocado do disco usando assinaturas (headers/footers) como JPEG (FF D8 FF), PDF (%PDF), ZIP (PK). Funciona mesmo sem sistema de arquivos intacto.",
    "example": "Ferramentas: Scalpel, PhotoRec, Foremost. Cada tipo de arquivo tem magic bytes: JPEG=FF D8 FF, PNG=89 50 4E 47, EXE=4D 5A. Limitação: arquivos fragmentados podem ser recuperados incompletos."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Médio",
    "question": "O que são logs de eventos do sistema operacional e qual sua importância forense?",
    "options": [
      "Registros de atividades do SO essenciais para reconstruir ações do atacante",
      "Backup automático de arquivos do usuário",
      "Relatórios de antivírus",
      "Registros de garantia do hardware"
    ],
    "correctIndex": 0,
    "explanation": "Event Logs registram logins, execuções, erros e alterações. No Windows: Security (4624=login, 4625=falha, 4688=processo), System, Application. No Linux: auth.log, syslog, journalctl.",
    "example": "Windows Event IDs críticos: 4624 (logon), 4625 (logon falho), 4648 (logon explícito), 4688 (novo processo), 1102 (log limpo = suspeito!). Ferramenta: EvtxECmd, LogParser, ELK Stack."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Médio",
    "question": "O que é análise de registro (Registry) do Windows em forense?",
    "options": [
      "Exame dos hives do Registry para identificar programas executados, dispositivos USB conectados e configurações alteradas",
      "Análise de logs de antivírus",
      "Verificação de integridade de drivers",
      "Recuperação de senhas do administrador"
    ],
    "correctIndex": 0,
    "explanation": "O Windows Registry armazena configurações do SO e rastros de atividade do usuário. Hives forenses: SAM (contas), SYSTEM (configuração), NTUSER.DAT (atividade do usuário), SOFTWARE (programas instalados).",
    "example": "Artefatos: MRU (Most Recently Used), UserAssist (programas executados com contagem), ShellBags (pastas acessadas), USB (USBSTOR). Ferramentas: RegRipper, Registry Explorer, RECmd."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Médio",
    "question": "O que é slack space e como pode conter evidências?",
    "options": [
      "Espaço entre o fim lógico de um arquivo e o fim do cluster, podendo conter restos de dados anteriores",
      "Espaço livre no disco para novos arquivos",
      "Área de swap da memória RAM",
      "Partição oculta criada pelo sistema operacional"
    ],
    "correctIndex": 0,
    "explanation": "Quando um arquivo não preenche o cluster inteiro, o espaço restante (slack space) pode conter dados residuais de arquivos anteriores. É fonte valiosa de evidências que ferramentas forenses podem recuperar.",
    "example": "Tipos: RAM slack (entre fim do arquivo e fim do setor) e file slack (entre fim do setor e fim do cluster). Ferramentas: EnCase, FTK, Sleuth Kit (`blkstat`). Dados em slack space sobrevivem a formatação rápida."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Médio",
    "question": "Quais artefatos Windows são mais relevantes em uma investigação de incidente e onde são encontrados?",
    "options": [
      "Prefetch, LNK files, Registry (UserAssist, MRU, ShimCache), Event Logs (EVTX), $MFT, $LogFile, hiberfil.sys, pagefile.sys, browser history, amcache.hve",
      "Apenas o Event Log é relevante; outros artefatos não contêm evidências",
      "Artefatos Windows ficam exclusivamente em C:\\Windows\\System32\\",
      "RAM não é artefato; somente disco rígido contém evidências relevantes"
    ],
    "correctIndex": 0,
    "explanation": "Windows forensics: Prefetch (C:\\Windows\\Prefetch\\*.pf): execução de programas. Registry: NTUSER.DAT (UserAssist: execuções GUI), ShimCache (AppCompatCache: execuções + timestamps), Amcache.hve (hash de executáveis). Event Log: Security (4624=logon, 4688=process create), System, Application. $MFT: tabela mestre de arquivos NTFS. LNK files: %APPDATA%\\Recent.",
    "example": "Ferramentas: Autopsy (open-source), FTK (comercial), Volatility (RAM analysis), Eric Zimmermann Tools (MFTECmd, AppCompatCacheParser, LECmd). Timeline: Plaso/Log2Timeline agrega artefatos em linha do tempo. PowerShell history: %APPDATA%\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt. VSS (Volume Shadow Copies): cópias anteriores de arquivos."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Difícil",
    "question": "O que é uma análise de memória volátil (RAM forensics) e quando ela é preferível à análise de disco?",
    "options": [
      "Análise do conteúdo da RAM que captura processos em execução, chaves de criptografia e malware fileless não presente no disco",
      "Análise mais rápida do disco rígido",
      "Verificação de integridade de hardware",
      "Recuperação de arquivos deletados do disco"
    ],
    "correctIndex": 0,
    "explanation": "RAM forensics captura dados voláteis: processos ativos, conexões de rede, chaves de criptografia em uso, malware fileless (que existe apenas na memória). Essencial porque desligar o computador destrói esses dados. Ferramentas: Volatility Framework, Rekall. Um dump de RAM pode revelar senhas, URLs visitadas e artefatos que nunca tocam o disco.",
    "example": "Captura: `winpmem` (Windows), `LiME` (Linux). Análise com Volatility: `pslist` (processos), `netscan` (conexões), `malfind` (código injetado), `hashdump` (hashes de senhas). Malware moderno é fileless — só existe na RAM."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Difícil",
    "question": "O que é anti-forensics e quais técnicas são utilizadas?",
    "options": [
      "Técnicas para dificultar investigação forense: wiping, criptografia de disco, timestomping",
      "Ferramentas usadas pela polícia",
      "Antivírus especializado para forense",
      "Técnica de recuperação de dados deletados"
    ],
    "correctIndex": 0,
    "explanation": "Anti-forensics: técnicas para destruir, ocultar ou manipular evidências. Inclui: wiping seguro (sobrescrever dados), criptografia de disco (VeraCrypt), esteganografia, timestomping (alterar timestamps), fileless malware, Tor/VPN.",
    "example": "Ferramentas: Eraser/SDelete (wiping), timestomping (alterar datas NTFS), CCleaner (limpar artefatos), VeraCrypt (hidden volume), Tails Linux (sem disco). Contra-medida: captura de RAM antes de desligar."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Difícil",
    "question": "O que é análise de timeline forense e por que é importante?",
    "options": [
      "Reconstrução cronológica de todos os eventos para entender a sequência de ações do atacante",
      "Verificação de datas de garantia do hardware",
      "Análise de desempenho do disco ao longo do tempo",
      "Monitoramento de backup em tempo real"
    ],
    "correctIndex": 0,
    "explanation": "Timeline reconstrói cronologicamente eventos: criação/modificação de arquivos, execução de programas, conexões de rede, logins. Permite entender desde a entrada até a exfiltração de dados.",
    "example": "Ferramentas: plaso/log2timeline (super timeline), Autopsy. Fontes: $MFT, $UsnJrnl, Event Logs, prefetch, browser history. Timestomping tenta enganar, mas $UsnJrnl mantém registros."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Difícil",
    "question": "O que é análise de tráfego de rede (PCAP) em forense digital?",
    "options": [
      "Captura e análise de pacotes de rede para identificar comunicação maliciosa e exfiltração de dados",
      "Análise de cabos de rede físicos",
      "Teste de velocidade da internet",
      "Verificação de configuração do roteador"
    ],
    "correctIndex": 0,
    "explanation": "Análise de PCAP (Packet Capture) reconstrói comunicações de rede: conexões C2 (command & control), exfiltração de dados, DNS tunneling, transferências de arquivos. Captura com tcpdump, Wireshark.",
    "example": "Ferramentas: Wireshark, NetworkMiner, Zeek/Bro, tcpdump. Análise: filtrar IPs suspeitos, exportar objetos HTTP, detectar beacons C2 (conexões periódicas), DNS queries anômalas. Formato: .pcap, .pcapng."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Difícil",
    "question": "O que é live forensics e quando é preferível à análise post-mortem?",
    "options": [
      "Investigação com sistema ligado para capturar dados voláteis e conexões ativas antes de desligar",
      "Análise feita em laboratório após desligar o sistema",
      "Forense realizada em tempo real por câmeras de vigilância",
      "Investigação de sistemas que já foram formatados"
    ],
    "correctIndex": 0,
    "explanation": "Live forensics coleta dados com sistema ativo: RAM (processos, chaves cripto), conexões de rede, discos criptografados montados, malware fileless. Necessária quando desligar destruiria evidências críticas.",
    "example": "Ordem de volatilidade (RFC 3227): registradores > cache > RAM > disco > logs remotos. Live: netstat -anob, tasklist, dump RAM com winpmem. Risco: o investigador altera o sistema (footprint mínimo)."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Difícil",
    "question": "O que é análise forense de containers e quais os desafios?",
    "options": [
      "Investigação de containers efêmeros que exige captura em execução, logs do orquestrador e análise de camadas de imagem",
      "Análise física de servidores em data centers",
      "Verificação de integridade de contêineres de transporte",
      "Auditoria de máquinas virtuais tradicionais"
    ],
    "correctIndex": 0,
    "explanation": "Containers (Docker/K8s) são efêmeros: ao parar, dados não persistidos se perdem. Forense exige: capturar filesystem em execução (`docker export`), coletar logs do orquestrador, analisar camadas da imagem e volumes.",
    "example": "Desafios: containers vivem segundos/minutos, sem persistência padrão, overlay filesystem. Ferramentas: `docker diff`, `docker logs`, Sysdig Inspect, Falco (runtime). K8s: audit logs do API server."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Difícil",
    "question": "O que é DFIR e como forense digital e resposta a incidentes se integram?",
    "options": [
      "Digital Forensics and Incident Response: forense fornece evidências para entender o ataque enquanto IR contém a ameaça",
      "Software de backup e recuperação de desastres",
      "Certificação de segurança da informação",
      "Metodologia de desenvolvimento seguro"
    ],
    "correctIndex": 0,
    "explanation": "DFIR combina forense digital (coletar e analisar evidências) com resposta a incidentes (conter, erradicar, recuperar). IR precisa de forense para entender o vetor; forense precisa de IR para preservar evidências a tempo.",
    "example": "Fluxo DFIR: detecção → triagem → contenção → coleta de evidências → análise → erradicação → recuperação → lições aprendidas. Ferramentas: Velociraptor, GRR, TheHive + Cortex. SANS DFIR e FIRST são referências."
  },
  {
    "id": "seguranca-da-informacao__Forense Digital__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Forense Digital",
    "difficulty": "Difícil",
    "question": "Como funciona a análise de memória RAM com Volatility e quais plugins são mais úteis em resposta a incidente?",
    "options": [
      "Volatility analisa dumps de RAM extraindo processos, conexões, DLLs injetadas, handles, credenciais (hashdump, lsadump), código malicioso (malfind); plugins pslist, netscan, cmdline, malfind, dlllist, hashdump",
      "Volatility analisa somente arquivos de log; não processa imagens de RAM",
      "Análise de RAM é desnecessária se o disco foi imageado corretamente",
      "Volatility requer o sistema em execução; não funciona com dumps offline"
    ],
    "correctIndex": 0,
    "explanation": "Volatility 3: framework Python para análise de dumps de memória (Windows, Linux, macOS). Plugins essenciais: pslist/pstree (processos), netscan (conexões ativas), cmdline (argumentos de processo), malfind (código injetado: PAGE_EXECUTE_READWRITE em regiões sem backing), dlllist (DLLs carregadas), handles, hashdump (NTLM hashes do SAM), lsadump (LSA secrets).",
    "example": "AVML / LiME / WinPmem: acquisition de RAM em sistemas live. malfind: detecta process hollowing, DLL injection (stealthy malware). Credential theft: mimikatz deixa rastros em lsass.exe. Volatility 2 vs 3: V3 é mais rápido, sem Python 2 dependency. Memory forensics cobre: fileless malware, backdoors em memória, rootkits."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Fácil",
    "question": "Na gestão de riscos, qual é a fórmula básica para calcular o nível de risco?",
    "options": [
      "Risco = Probabilidade × Impacto",
      "Risco = Ameaça + Vulnerabilidade",
      "Risco = Custo ÷ Benefício",
      "Risco = Ameaça × Custo"
    ],
    "correctIndex": 0,
    "explanation": "O risco é o produto da probabilidade de um evento ocorrer pelo impacto que ele causaria. Probabilidade alta + impacto alto = risco crítico. Probabilidade baixa + impacto baixo = risco aceitável. A matriz de riscos organiza isso visualmente.",
    "example": "Exemplo: vazamento de dados de clientes. Probabilidade: média (3/5). Impacto: alto (5/5). Risco = 3 × 5 = 15 (alto). Ação: implementar criptografia, controle de acesso e treinamento."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Fácil",
    "question": "O que é uma vulnerabilidade em segurança da informação?",
    "options": [
      "Fraqueza em um sistema que pode ser explorada por uma ameaça",
      "Tipo de vírus de computador",
      "Software de proteção de rede",
      "Relatório de segurança periódico"
    ],
    "correctIndex": 0,
    "explanation": "Vulnerabilidade é fraqueza em hardware, software, processo ou pessoas que pode ser explorada. Exemplos: software sem patches, configuração incorreta, senhas fracas. Ameaça explora vulnerabilidade para causar impacto.",
    "example": "Ameaça × Vulnerabilidade = Risco. CVE: banco de vulnerabilidades conhecidas. CVSS: pontuação de severidade (0-10). Exemplo: CVE-2021-44228 (Log4Shell) = CVSS 10.0."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Fácil",
    "question": "O que é uma ameaça em segurança da informação?",
    "options": [
      "Agente ou evento que pode explorar uma vulnerabilidade e causar dano",
      "Patch de segurança para sistemas",
      "Ferramenta de monitoramento de rede",
      "Tipo de controle de acesso"
    ],
    "correctIndex": 0,
    "explanation": "Ameaça é qualquer agente ou circunstância com potencial de causar dano. Tipos: natural (enchente), humana intencional (hacker), humana acidental (erro de configuração), ambiental (falha de energia).",
    "example": "Hacker (intencional), funcionário desatento (acidental), ransomware (tecnológica), terremoto (natural). Risco = Ameaça × Vulnerabilidade × Impacto. Sem vulnerabilidade, ameaça não se materializa."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Fácil",
    "question": "O que é um ativo de informação?",
    "options": [
      "Qualquer recurso com valor para a organização: dados, sistemas, pessoas, infraestrutura",
      "Apenas hardware físico da empresa",
      "Somente documentos impressos confidenciais",
      "Software antivírus instalado nos computadores"
    ],
    "correctIndex": 0,
    "explanation": "Ativo de informação inclui dados (banco de dados, planilhas), software (ERP, CRM), hardware (servidores, notebooks), pessoas (conhecimento), infraestrutura (datacenter, rede) e reputação.",
    "example": "ISO 27001: inventariar todos os ativos, classificá-los (público, interno, confidencial, secreto) e atribuir proprietários. Ativo mais valioso atualmente: dados pessoais de clientes (LGPD, GDPR)."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Fácil",
    "question": "O que significa risco residual?",
    "options": [
      "Risco que permanece mesmo após a aplicação de controles de segurança",
      "Risco que foi completamente eliminado",
      "Risco que ainda não foi identificado",
      "Risco transferido para seguradoras"
    ],
    "correctIndex": 0,
    "explanation": "Risco residual é o que sobra após aplicar controles de mitigação. Risco inerente (sem controle) − eficácia dos controles = risco residual. Deve ser aceito formalmente pela gestão se estiver dentro do apetite ao risco.",
    "example": "Exemplo: risco inerente de ransomware = alto. Controles: backup, antimalware, treinamento. Risco residual = médio (ainda existe, mas reduzido). Gestão aceita formalmente o risco residual."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Fácil",
    "question": "O que é mitigação de riscos?",
    "options": [
      "Implementar controles para reduzir a probabilidade ou o impacto de um risco",
      "Eliminar completamente qualquer possibilidade de risco",
      "Transferir todos os riscos para terceiros",
      "Ignorar riscos de baixa probabilidade"
    ],
    "correctIndex": 0,
    "explanation": "Mitigação reduz o risco a um nível aceitável por meio de controles preventivos ou detectivos. É a estratégia de tratamento mais comum. Exemplos: instalar firewall, implementar MFA, treinar funcionários.",
    "example": "Mitigação ≠ eliminação total. Sempre resta risco residual. Custo do controle deve ser menor que o impacto esperado. Controles compensatórios são usados quando o controle ideal é inviável."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Fácil",
    "question": "O que é transferência de risco?",
    "options": [
      "Passar o impacto financeiro de um risco para terceiros, como seguradoras ou provedores",
      "Mover dados para outro servidor",
      "Deletar informações confidenciais",
      "Contratar mais funcionários de segurança"
    ],
    "correctIndex": 0,
    "explanation": "Transferência de risco repassa consequências financeiras a terceiros: seguro cyber (cobre custos de breach), outsourcing (SLA com penalidades), cláusulas contratuais. A responsabilidade legal geralmente permanece.",
    "example": "Seguro cyber: cobre custos de notificação, forense, multas, perda de receita. SLA: provedor paga penalidade se indisponibilidade > limite. Atenção: transferência não elimina responsabilidade regulatória (LGPD)."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Fácil",
    "question": "O que é o processo de gestão de riscos segundo a ISO 31000 e quais suas etapas?",
    "options": [
      "Identificação → análise (probabilidade × impacto) → avaliação → tratamento (aceitar, mitigar, transferir, eliminar) → monitoramento e revisão contínuos",
      "Gestão de riscos consiste apenas em instalar antivírus e firewall",
      "O processo inicia por tratamento; identificação ocorre somente após incidentes",
      "ISO 31000 é exclusiva para riscos financeiros; não se aplica à segurança da informação"
    ],
    "correctIndex": 0,
    "explanation": "ISO 31000:2018: Princípios, Framework, Processo. Processo: comunicação e consulta → estabelecimento de contexto → identificação → análise (qualitativa/quantitativa) → avaliação (priorização pelo risk appetite) → tratamento → monitoramento. Opções de tratamento: mitigar (controles), aceitar (risco residual), transferir (seguro), evitar (eliminar atividade).",
    "example": "Análise quantitativa: ALE (Annual Loss Expectancy) = ARO × SLE. ALE: base para ROI de controles. Risk register: documenta riscos, owner, probabilidade, impacto, controles, residual. NIST RMF (SP 800-37): framework de gestão de riscos federais EUA. OCTAVE: metodologia orientada a ativos. Apetite de risco vs tolerância vs capacidade."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Médio",
    "question": "Quais são as quatro estratégias básicas de tratamento de riscos?",
    "options": [
      "Evitar, Mitigar, Transferir e Aceitar",
      "Prevenir, Detectar, Responder e Recuperar",
      "Negar, Ignorar, Escalar e Documentar",
      "Planejar, Executar, Verificar e Agir"
    ],
    "correctIndex": 0,
    "explanation": "1) Evitar: eliminar a atividade que gera o risco. 2) Mitigar: reduzir probabilidade e/ou impacto com controles. 3) Transferir: passar o risco a terceiro (seguro, outsourcing). 4) Aceitar: reconhecer o risco e não agir (quando o custo do controle > impacto). Cada risco recebe uma estratégia baseada em custo-benefício.",
    "example": "Evitar: não coletar dados desnecessários. Mitigar: instalar firewall, MFA. Transferir: contratar seguro cyber. Aceitar: risco de queda de energia de 5min/ano em sistema não-crítico."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Médio",
    "question": "O que é uma matriz de riscos e como é utilizada?",
    "options": [
      "Ferramenta visual que cruza probabilidade e impacto para classificar riscos",
      "Planilha de inventário de ativos de TI",
      "Diagrama de rede da organização",
      "Lista de políticas de segurança"
    ],
    "correctIndex": 0,
    "explanation": "A matriz de riscos cruza probabilidade (eixo Y) e impacto (eixo X), resultando em níveis: baixo, médio, alto, crítico. Permite priorizar: riscos críticos recebem atenção imediata; baixos podem ser aceitos.",
    "example": "Exemplo 5×5: probabilidade (raro a quase certo) × impacto (insignificante a catastrófico). Cores: verde (baixo), amarelo (médio), laranja (alto), vermelho (crítico)."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Médio",
    "question": "O que é BIA (Business Impact Analysis) e para que serve?",
    "options": [
      "Análise que identifica processos críticos e o impacto de sua interrupção",
      "Software de backup empresarial",
      "Auditoria de conformidade legal",
      "Análise de performance de rede"
    ],
    "correctIndex": 0,
    "explanation": "BIA identifica processos críticos e avalia o impacto de sua interrupção. Define: RTO (tempo máximo de indisponibilidade) e RPO (perda de dados aceitável). Alimenta o Plano de Continuidade de Negócios (BCP/DRP).",
    "example": "RTO = quanto tempo pode ficar fora? RPO = quantos dados pode perder? Sistema financeiro: RTO = 1h, RPO = 0. Email: RTO = 4h, RPO = 1h. BIA → BCP/DRP."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Médio",
    "question": "O que é um registro de riscos (risk register)?",
    "options": [
      "Documento que lista riscos identificados, classificação, responsáveis e ações de tratamento",
      "Software de monitoramento de rede",
      "Backup de logs do sistema",
      "Contrato com empresa de seguros"
    ],
    "correctIndex": 0,
    "explanation": "Risk register documenta cada risco: descrição, probabilidade, impacto, nível, proprietário, estratégia de tratamento, status e prazo. É atualizado periodicamente e revisado pela gestão.",
    "example": "Colunas: ID | Risco | Probabilidade | Impacto | Nível | Proprietário | Tratamento | Status | Prazo. Alimenta: relatórios gerenciais, reuniões de comitê de risco, auditorias internas."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Médio",
    "question": "O que é apetite ao risco (risk appetite)?",
    "options": [
      "Nível de risco que a organização está disposta a aceitar para atingir seus objetivos",
      "Quantidade máxima de funcionários em TI",
      "Orçamento total destinado à segurança",
      "Número de incidentes de segurança por ano"
    ],
    "correctIndex": 0,
    "explanation": "Risk appetite é definido pela alta gestão e orienta todas as decisões de risco. Um banco tem apetite baixo (regulação rígida); uma startup pode aceitar mais risco para inovar. Tolerância ao risco é a variação aceitável.",
    "example": "Apetite (estratégico, amplo) vs Tolerância (operacional, específica). Exemplo: 'aceitamos risco médio em TI' (apetite). 'Downtime máximo de 4h/mês' (tolerância). COSO ERM e ISO 31000 abordam risk appetite."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Médio",
    "question": "O que é análise de cenários em gestão de riscos?",
    "options": [
      "Simulação de situações hipotéticas para avaliar impacto de diferentes ameaças e preparar respostas",
      "Análise do desempenho financeiro passado",
      "Comparação de preços entre fornecedores de segurança",
      "Estudo da concorrência no mercado de TI"
    ],
    "correctIndex": 0,
    "explanation": "Análise de cenários (what-if) simula situações como 'e se houver um ransomware?', 'e se o datacenter pegar fogo?'. Permite avaliar impacto, testar planos de resposta e priorizar investimentos em segurança.",
    "example": "Cenários: melhor caso, caso esperado, pior caso. Tabletop exercises: simulação sem impacto real. Exemplo: cenário de breach → equipe discute ações → identifica gaps. NIST SP 800-84 guia exercícios."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Médio",
    "question": "O que são KRI (Key Risk Indicators)?",
    "options": [
      "Métricas que sinalizam aumento de exposição a riscos antes que incidentes ocorram",
      "Indicadores de desempenho de funcionários de TI",
      "Classificações de vulnerabilidades em software",
      "Relatórios mensais de compliance"
    ],
    "correctIndex": 0,
    "explanation": "KRIs são métricas preditivas que alertam quando o risco está aumentando. Diferente de KPIs (medem desempenho passado), KRIs antecipam problemas. Exemplo: aumento de tentativas de login falhas pode indicar ataque iminente.",
    "example": "Exemplos de KRI: % de patches pendentes, nº de tentativas de acesso não autorizado, tempo médio para corrigir vulnerabilidades, turnover de equipe de segurança. KRI → dashboard de riscos → ação proativa."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Médio",
    "question": "O que é BIA (Business Impact Analysis) e como ele guia a definição de RPO e RTO?",
    "options": [
      "BIA identifica processos críticos e quantifica impactos de interrupção; RPO (Recovery Point Objective): máximo de dados tolerável a perder; RTO (Recovery Time Objective): tempo máximo aceitável para restaurar operação",
      "BIA é relatório de vulnerabilidades técnicas; RPO é tempo de resposta a incidente",
      "RTO e RPO são definidos pelo time de TI sem consultar o negócio",
      "BIA é realizado somente após um desastre para medir o impacto real"
    ],
    "correctIndex": 0,
    "explanation": "BIA: mapa de processos de negócio → criticidade → impacto temporal (financeiro, reputacional, legal). MTPD (Maximum Tolerable Period of Disruption): tempo até falência do processo. RPO: tolerância à perda de dados (RPO=0: replicação síncrona; RPO=24h: backup diário). RTO: tempo para retomar operação (RTO=4h: manter infraestrutura quente; RTO=72h: cold standby).",
    "example": "BIA alimenta o BCP (Business Continuity Plan) e DRP (Disaster Recovery Plan). RPO baixo: replicação síncrona (SAN, database log shipping). RTO baixo: failover automático (active-passive cluster, hot site). Teste de DR: exercícios tabletop, simulações, failover real (gameday). WRT (Work Recovery Time): tempo para normalizar operações após restauração técnica. BCMS: ISO 22301."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Difícil",
    "question": "Qual é a diferença entre análise de risco qualitativa e quantitativa?",
    "options": [
      "Qualitativa classifica riscos em categorias (alto/médio/baixo); quantitativa atribui valores monetários e probabilidades numéricas",
      "Qualitativa é mais precisa que quantitativa",
      "Quantitativa não usa dados numéricos",
      "Ambas são idênticas na prática"
    ],
    "correctIndex": 0,
    "explanation": "Qualitativa: classifica riscos em escalas (1-5 ou alto/médio/baixo) por opinião de especialistas. Rápida, mas subjetiva. Quantitativa: calcula valores monetários (SLE = Single Loss Expectancy, ALE = Annual Loss Expectancy) e probabilidades reais. Mais precisa, mas requer dados históricos e é mais demorada.",
    "example": "Quantitativa: Asset Value = R$1M. EF (Exposure Factor) = 30%. SLE = 1M × 0,3 = R$300K. ARO (Annual Rate of Occurrence) = 0,5. ALE = SLE × ARO = 300K × 0,5 = R$150K/ano. Se controle custa R$50K/ano → vale a pena."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Difícil",
    "question": "O que é RTO, RPO e MTPD no planejamento de continuidade?",
    "options": [
      "RTO: tempo de recuperação. RPO: perda de dados aceitável. MTPD: período máximo tolerável de interrupção",
      "São três tipos de backup",
      "Métricas de performance de rede",
      "Classificações de certificados"
    ],
    "correctIndex": 0,
    "explanation": "RTO (Recovery Time Objective): tempo máximo para restaurar. RPO (Recovery Point Objective): perda máxima de dados (em tempo). MTPD (Maximum Tolerable Period of Disruption): tempo total que o negócio sobrevive sem o processo.",
    "example": "Relação: RPO ≤ RTO ≤ MTPD. RPO = 1h (backup horário). RTO = 4h (restaurar em 4h). MTPD = 24h (negócio sobrevive 24h). RTO > MTPD = plano insuficiente."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Difícil",
    "question": "O que é a ISO 31000 e como se relaciona com segurança da informação?",
    "options": [
      "Framework genérico de gestão de riscos; ISO 27005 o especializa para segurança da informação",
      "Norma de criptografia internacional",
      "Certificação de profissionais de segurança",
      "Protocolo de comunicação segura"
    ],
    "correctIndex": 0,
    "explanation": "ISO 31000: framework genérico de gestão de riscos (não certificável). ISO 27005: especializa para riscos de SI, integrando-se com ISO 27001 (SGSI). ISO 27001 cláusula 6.1.2 exige avaliação de riscos.",
    "example": "ISO 31000: gestão de riscos genérica. ISO 27005: riscos de SI. NIST SP 800-30: alternativa americana. ISO 27001: SGSI (certificável). A 27005 detalha COMO fazer a avaliação de riscos exigida pela 27001."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Difícil",
    "question": "O que é o framework FAIR (Factor Analysis of Information Risk)?",
    "options": [
      "Modelo quantitativo que decompõe risco em frequência de eventos de perda e magnitude de perdas",
      "Framework de desenvolvimento ágil",
      "Padrão de criptografia simétrica",
      "Metodologia de teste de software"
    ],
    "correctIndex": 0,
    "explanation": "FAIR quantifica risco em termos financeiros. Decompõe: LEF (Loss Event Frequency) × LM (Loss Magnitude). LEF = TEF (Threat Event Frequency) × Vulnerability. LM = Primary Loss + Secondary Loss.",
    "example": "Exemplo FAIR: probabilidade de breach = 10%/ano. Perda primária (resposta): R$500K. Perda secundária (multas, reputação): R$2M. ALE = 10% × R$2,5M = R$250K/ano. Justifica controle de R$200K."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Difícil",
    "question": "O que é threat modeling e quais metodologias são utilizadas?",
    "options": [
      "Identificação sistemática de ameaças a um sistema; metodologias incluem STRIDE, PASTA e DREAD",
      "Modelagem 3D de data centers",
      "Simulação de ataques DDoS",
      "Teste de carga em servidores"
    ],
    "correctIndex": 0,
    "explanation": "Threat modeling analisa arquitetura para encontrar ameaças antes que sejam exploradas. STRIDE (Microsoft): Spoofing, Tampering, Repudiation, Information Disclosure, DoS, Elevation. PASTA: 7 estágios focados em risco.",
    "example": "STRIDE: modelo por ameaça. DREAD: classifica severidade (Damage, Reproducibility, Exploitability, Affected users, Discoverability). PASTA: Process for Attack Simulation and Threat Analysis. LINDDUN: privacidade."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Difícil",
    "question": "O que é o método Monte Carlo aplicado à gestão de riscos?",
    "options": [
      "Simulação estatística que gera milhares de cenários aleatórios para estimar distribuição de probabilidades de perdas",
      "Método de criptografia baseado em números aleatórios",
      "Técnica de teste de penetração automatizado",
      "Algoritmo de balanceamento de carga em servidores"
    ],
    "correctIndex": 0,
    "explanation": "Monte Carlo executa milhares/milhões de simulações com variáveis aleatórias para gerar distribuição de resultados possíveis. Em riscos: estima intervalo de perdas financeiras com graus de confiança (ex: 95% de chance de perda < R$2M).",
    "example": "Processo: definir variáveis (probabilidade, impacto) → atribuir distribuições → rodar 10.000+ simulações → gerar histograma de resultados. Ferramentas: @RISK, Crystal Ball, Python (NumPy/SciPy). FAIR usa Monte Carlo."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Difícil",
    "question": "O que é bow-tie analysis em gestão de riscos?",
    "options": [
      "Diagrama visual que conecta ameaças ao evento de risco e consequências, mostrando barreiras preventivas e reativas",
      "Tipo de criptografia bidirecional",
      "Metodologia de desenvolvimento seguro",
      "Técnica de backup incremental e diferencial"
    ],
    "correctIndex": 0,
    "explanation": "Bow-tie mostra: à esquerda as ameaças com barreiras preventivas, no centro o evento de risco, à direita as consequências com barreiras de mitigação. Formato de gravata-borboleta. Visão clara de como prevenir e responder.",
    "example": "Esquerda: ameaças → barreiras preventivas → EVENTO → barreiras reativas → consequências (direita). Cada barreira tem indicadores de degradação. Usado em óleo/gás, aviação e cybersecurity. Ferramentas: BowTieXP, CGE Risk."
  },
  {
    "id": "seguranca-da-informacao__Gestão de Riscos__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Gestão de Riscos",
    "difficulty": "Difícil",
    "question": "Como funciona a análise de risco quantitativa com os conceitos ALE, ARO, SLE e como calcular o ROI de um controle de segurança?",
    "options": [
      "SLE = Valor do Ativo × Fator de Exposição; ARO = frequência anual de ocorrência; ALE = SLE × ARO; ROI controle = (ALE antes − ALE depois) − Custo controle",
      "ALE = custo de um incidente individual; ARO é calculado somente por auditors externos",
      "ROI = ALE × ARO; controles com ROI negativo devem ser implementados prioritariamente",
      "SLE inclui somente custos tangíveis; ARO é sempre igual a 1 para riscos críticos"
    ],
    "correctIndex": 0,
    "explanation": "SLE (Single Loss Expectancy) = Valor do Ativo × EF (Exposure Factor, % destruído). Ativo = R$500k, EF=40% → SLE = R$200k. ARO (Annualized Rate of Occurrence) = probabilidade anual (1x/2anos = 0,5). ALE = R$200k × 0,5 = R$100k/ano. Controle: R$30k/ano, reduz ALE para R$20k. ROI = (100k - 20k) - 30k = R$50k/ano economizados.",
    "example": "Análise quantitativa: mais defensável para C-suite e board. Análise qualitativa (low/medium/high): mais rápida, subjetiva. FAIR (Factor Analysis of Information Risk): metodologia quantitativa estruturada. Monte Carlo simulation: modelagem de risco com distribuição de probabilidade. CVSS Score: não é análise de risco (é severidade técnica, não impacto ao negócio)."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Fácil",
    "question": "O que significa 'compliance' no contexto de segurança da informação?",
    "options": [
      "Estar em conformidade com leis, normas e regulamentações",
      "Compilar código-fonte sem erros",
      "Completar todos os treinamentos de segurança",
      "Comprar equipamentos certificados"
    ],
    "correctIndex": 0,
    "explanation": "Compliance é o ato de estar em conformidade com leis (LGPD, GDPR), normas (ISO 27001), regulamentações setoriais (PCI-DSS, HIPAA) e políticas internas. Envolve processos, controles e auditorias para garantir que a organização cumpre requisitos legais e regulatórios.",
    "example": "Exemplos: PCI-DSS (cartões de crédito), HIPAA (saúde nos EUA), SOX (finanças), LGPD (dados pessoais no Brasil), GDPR (dados na UE). Não compliance → multas, processos, perda de reputação."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Fácil",
    "question": "O que é uma auditoria de segurança da informação?",
    "options": [
      "Avaliação sistemática para verificar se controles estão implementados e funcionando",
      "Instalação de antivírus em todos os computadores",
      "Atualização de software do firewall",
      "Teste de velocidade da rede"
    ],
    "correctIndex": 0,
    "explanation": "Auditoria verifica se controles de segurança estão conforme políticas, normas e regulamentações. Pode ser interna (equipe própria) ou externa (auditores independentes). Gera relatório com achados e recomendações.",
    "example": "Tipos: interna, externa, de certificação (ISO 27001). Etapas: planejamento → coleta de evidências → análise → relatório → acompanhamento."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Fácil",
    "question": "O que é PCI-DSS e a quem se aplica?",
    "options": [
      "Padrão de segurança para empresas que processam dados de cartões de pagamento",
      "Lei brasileira de proteção de dados",
      "Certificação de profissionais de segurança",
      "Protocolo de criptografia bancária"
    ],
    "correctIndex": 0,
    "explanation": "PCI-DSS são requisitos de segurança para empresas que lidam com dados de cartões. Visa, MasterCard e outras bandeiras exigem conformidade. Inclui criptografia, controle de acesso, testes regulares e políticas de segurança.",
    "example": "12 requisitos: firewall, proteção de dados, criptografia, antivírus, desenvolvimento seguro, controle de acesso, testes de penetração. Níveis: 1 (>6M transações) a 4 (<20K)."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Fácil",
    "question": "O que é uma política de segurança da informação?",
    "options": [
      "Documento formal que define diretrizes e regras de segurança para a organização",
      "Software de proteção contra vírus",
      "Contrato de seguro contra ataques",
      "Manual técnico de configuração de firewall"
    ],
    "correctIndex": 0,
    "explanation": "A política de segurança é o documento base que define princípios, responsabilidades e regras que todos devem seguir. Deve ser aprovada pela alta gestão e comunicada a todos os colaboradores.",
    "example": "Hierarquia: Política (diretrizes gerais) → Normas (regras específicas) → Procedimentos (passo-a-passo). Exemplo: política diz 'senhas fortes'; norma define '12+ caracteres'; procedimento ensina como trocar."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Fácil",
    "question": "O que são controles de segurança da informação?",
    "options": [
      "Medidas técnicas, administrativas ou físicas para proteger informações",
      "Apenas software antivírus",
      "Somente câmeras de vigilância",
      "Controle remoto de computadores"
    ],
    "correctIndex": 0,
    "explanation": "Controles podem ser: técnicos (firewall, criptografia, MFA), administrativos (políticas, treinamento, processos) e físicos (catracas, biometria, CFTV). ISO 27001 Anexo A lista 93 controles organizados em 4 temas.",
    "example": "Preventivos (evitar incidente), Detectivos (identificar incidente), Corretivos (responder ao incidente). Exemplos: firewall (preventivo), IDS (detectivo), backup restore (corretivo)."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Fácil",
    "question": "O que é HIPAA e a quem se aplica?",
    "options": [
      "Lei americana que protege informações de saúde; aplica-se a hospitais, seguradoras e parceiros",
      "Lei brasileira de proteção de dados",
      "Certificação de segurança para redes",
      "Protocolo de criptografia médica"
    ],
    "correctIndex": 0,
    "explanation": "HIPAA (Health Insurance Portability and Accountability Act) protege informações de saúde (PHI) nos EUA. Aplica-se a covered entities (hospitais, clínicas, seguradoras) e business associates (parceiros que tratam PHI).",
    "example": "HIPAA Security Rule: controles técnicos, administrativos e físicos para ePHI. Multas: $100 a $50.000 por violação (máx $1,5M/ano). Breach notification: 60 dias. Comparação: LGPD protege dados pessoais em geral."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Fácil",
    "question": "O que é um framework de segurança da informação?",
    "options": [
      "Conjunto estruturado de diretrizes, práticas e controles para gerenciar e proteger informações",
      "Software de proteção contra vírus",
      "Linguagem de programação segura",
      "Hardware especializado em criptografia"
    ],
    "correctIndex": 0,
    "explanation": "Um framework fornece estrutura organizada para implementar segurança: define O QUE proteger, COMO proteger e COMO medir. Exemplos: NIST CSF, ISO 27001, CIS Controls. Cada organização escolhe conforme seu setor e maturidade.",
    "example": "Principais: NIST CSF (5+1 funções), ISO 27001 (SGSI certificável), CIS Controls (18 controles priorizados), COBIT (governança de TI). Escolha: regulação exige? → ISO 27001/PCI-DSS. Maturidade baixa? → CIS Controls."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Fácil",
    "question": "O que é o framework COBIT e qual sua relação com governança de TI?",
    "options": [
      "COBIT (Control Objectives for Information and Related Technologies): framework de governança e gestão de TI que alinha TI ao negócio, define objetivos de controle e mede maturidade",
      "COBIT é um protocolo de segurança de rede desenvolvido pela ISACA",
      "COBIT é equivalente ao ITIL; ambos tratam exclusivamente de gestão de incidentes",
      "COBIT é obrigatório apenas para empresas listadas na bolsa de valores"
    ],
    "correctIndex": 0,
    "explanation": "COBIT 2019 (ISACA): 40 objetivos de controle em 5 domínios (EDM: Evaluate/Direct/Monitor; APO: Align/Plan/Organize; BAI: Build/Acquire/Implement; DSS: Deliver/Service/Support; MEA: Monitor/Evaluate/Assess). Princípios: atender necessidades das partes interessadas, cobrir a empresa de ponta a ponta, aplicar framework integrado único.",
    "example": "COBIT vs ITIL: COBIT = governança/controle (o quê e por quê); ITIL = melhores práticas de gerenciamento de serviços (como). COBIT vs ISO 27001: COBIT é framework amplo; ISO 27001 foca em SGSI. Maturidade CMMI: COBIT usa PAM (Process Capability). SOX compliance: COBIT frequentemente usado para controles ITGCs. ISACA certifications: CISA, CRISC."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Médio",
    "question": "Qual framework de governança de TI é mais utilizado para alinhar serviços de TI às necessidades do negócio?",
    "options": [
      "ITIL",
      "SCRUM",
      "Kanban",
      "XP"
    ],
    "correctIndex": 0,
    "explanation": "ITIL (Information Technology Infrastructure Library) é o framework mais adotado para gerenciamento de serviços de TI (ITSM). Define práticas para alinhar serviços de TI às necessidades de negócio: gerenciamento de incidentes, problemas, mudanças, configuração, SLAs. COBIT é outra opção voltada para governança.",
    "example": "ITIL v4 práticas: Incident Management, Problem Management, Change Enablement, Service Desk. COBIT: governança e gestão de TI (mais estratégico). ITIL: operacional. ISO 20000: certificação de ITSM baseada em ITIL."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Médio",
    "question": "O que é o COBIT e para que serve?",
    "options": [
      "Framework de governança e gestão de TI que alinha TI aos objetivos de negócio",
      "Linguagem de programação segura",
      "Certificação de segurança para redes",
      "Tipo de firewall empresarial"
    ],
    "correctIndex": 0,
    "explanation": "COBIT (Control Objectives for IT) é framework de governança do ISACA. Define objetivos de controle, métricas e modelos de maturidade. Complementa ITIL (operacional) com visão estratégica.",
    "example": "COBIT 2019: 40 objetivos de governança e gestão. Princípios: atender necessidades das partes interessadas, cobrir ponta a ponta. COBIT → estratégico. ITIL → operacional."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Médio",
    "question": "O que é segregação de funções (SoD) e por que é importante?",
    "options": [
      "Separar responsabilidades para que ninguém controle todas as etapas de um processo crítico",
      "Dividir a equipe de TI em departamentos",
      "Separar redes com VLANs",
      "Usar senhas diferentes para cada sistema"
    ],
    "correctIndex": 0,
    "explanation": "SoD garante que nenhuma pessoa controle todo um processo crítico. Exemplo: quem solicita pagamento ≠ quem aprova ≠ quem executa. Previne fraudes, requisito de SOX, PCI-DSS e ISO 27001.",
    "example": "Sem SoD: funcionário cria fornecedor fictício + aprova + recebe = fraude. Com SoD: etapas feitas por pessoas diferentes. Matrix RACI: Responsible, Accountable, Consulted, Informed."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Médio",
    "question": "O que é um SLA (Service Level Agreement) em segurança da informação?",
    "options": [
      "Acordo que define níveis de serviço, tempo de resposta e metas de disponibilidade",
      "Software de monitoramento de logs",
      "Certificação de segurança",
      "Tipo de firewall empresarial"
    ],
    "correctIndex": 0,
    "explanation": "SLA define métricas e metas entre provedor e cliente: disponibilidade (99,9%), tempo de resposta a incidentes (4h), RPO/RTO. Inclui penalidades por descumprimento. Essencial em contratos de cloud e outsourcing.",
    "example": "SLA: 99,9% = 8,76h downtime/ano. 99,99% = 52min/ano. SLI (Service Level Indicator): métrica real. SLO (Objective): meta interna. SLA: compromisso contratual externo."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Médio",
    "question": "O que é a lei SOX (Sarbanes-Oxley) e como afeta a área de TI?",
    "options": [
      "Lei de governança corporativa dos EUA que exige controles internos sobre relatórios financeiros, incluindo TI",
      "Lei brasileira de segurança cibernética",
      "Certificação de profissionais de TI",
      "Protocolo de criptografia financeira"
    ],
    "correctIndex": 0,
    "explanation": "SOX (2002) exige que empresas listadas nos EUA tenham controles internos sobre relatórios financeiros. TI é afetada porque sistemas ERP, bancos de dados e acessos devem ter controles auditáveis.",
    "example": "Seção 302: CEO/CFO atestam precisão dos relatórios. Seção 404: auditoria de controles internos. TI: controle de acesso ao ERP, logs de alteração, segregação de funções, backup de dados financeiros."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Médio",
    "question": "O que é gestão de mudanças (change management) em TI?",
    "options": [
      "Processo controlado para implementar alterações em sistemas minimizando riscos de interrupção",
      "Troca de fornecedores de hardware",
      "Mudança de escritório da empresa",
      "Atualização de políticas de RH"
    ],
    "correctIndex": 0,
    "explanation": "Change management controla alterações em sistemas de TI para evitar incidentes. Processo: solicitação → avaliação de impacto → aprovação (CAB) → implementação → revisão pós-implementação. Reduz riscos de downtime.",
    "example": "ITIL Change Enablement: Normal (CAB aprova), Standard (pré-aprovada, baixo risco), Emergency (urgente, aprovação posterior). CAB = Change Advisory Board. Sem gestão de mudanças → 80% dos incidentes são causados por mudanças mal planejadas."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Médio",
    "question": "O que é o GDPR e qual sua relação com a LGPD?",
    "options": [
      "Regulamento europeu de proteção de dados que inspirou a LGPD brasileira",
      "Lei americana de segurança cibernética",
      "Protocolo de criptografia europeu",
      "Framework de governança de TI global"
    ],
    "correctIndex": 0,
    "explanation": "GDPR (2018) é o regulamento europeu de proteção de dados pessoais. Inspirou a LGPD brasileira. Ambas protegem dados pessoais, exigem bases legais, DPO e notificação de incidentes. GDPR tem multas maiores (até 4% do faturamento global).",
    "example": "GDPR: 4% faturamento global ou €20M. LGPD: 2% faturamento Brasil ou R$50M. GDPR tem decisões de adequação; LGPD está regulamentando. GDPR: DPA (Data Protection Authority) = ANPD. Schrems II impactou transferências EUA-UE."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Médio",
    "question": "O que é o PCI-DSS e quais são seus 12 requisitos principais?",
    "options": [
      "PCI-DSS: padrão de segurança para ambientes de cartão de pagamento; 12 requisitos: rede segura (FW, senhas), proteção de dados CHD, programa de vulnerabilidades, controle de acesso, monitoramento, política de segurança",
      "PCI-DSS é lei federal brasileira que rege transações bancárias digitais",
      "PCI-DSS tem apenas 3 requisitos; os demais são opcionais conforme o nível",
      "PCI-DSS se aplica somente a varejistas; bancos e processadoras estão isentos"
    ],
    "correctIndex": 0,
    "explanation": "PCI-DSS v4.0: criado por Visa, Mastercard, Amex, Discover, JCB. 12 requisitos agrupados em 6 objetivos: (1-2) Rede segura; (3-4) Proteção de CHD (Cardholder Data); (5-6) Programa de vulnerabilidades; (7-9) Controle de acesso; (10-11) Monitoramento e testes; (12) Política de segurança da informação. Aplicável a qualquer entidade que processa/armazena/transmite dados de cartão.",
    "example": "Níveis de compliance: nível 1 (>6M transações/ano): QSA externo; nível 2-4: SAQ (Self-Assessment Questionnaire). CHD: PAN, CVV, track data, PIN. Tokenização: substitui PAN por token; reduz escopo PCI. P2PE: criptografia ponto-a-ponto; reduz escopo. ASV scan: varredura externa trimestral. Pentest anual obrigatório. v4.0: customized approach, MFA expandido."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Difícil",
    "question": "Qual a relação entre COBIT, ITIL e ISO 27001 na governança corporativa de TI?",
    "options": [
      "COBIT: governança estratégica. ITIL: gestão de serviços operacional. ISO 27001: sistema de gestão de segurança da informação",
      "São três versões do mesmo framework",
      "COBIT substitui ITIL e ISO 27001",
      "ISO 27001 inclui COBIT e ITIL integralmente"
    ],
    "correctIndex": 0,
    "explanation": "São complementares: COBIT (Control Objectives for IT) — framework de governança para alinhar TI ao negócio (nível estratégico). ITIL — melhores práticas para gestão de serviços de TI (nível operacional). ISO 27001 — sistema de gestão de segurança da informação (SGSI) com requisitos para implementar, manter e melhorar controles de segurança.",
    "example": "COBIT → 'O que fazer' (objetivos, métricas). ITIL → 'Como fazer' (processos operacionais). ISO 27001 → 'Como proteger' (controles de segurança). Organizações maduras usam os três: COBIT para governança, ITIL para serviços, ISO 27001 para segurança."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Difícil",
    "question": "O que é o SOC 2 e quais são seus Trust Service Criteria?",
    "options": [
      "Relatório de auditoria para provedores; critérios: Segurança, Disponibilidade, Integridade, Confidencialidade, Privacidade",
      "Certificação ISO para segurança",
      "Centro de operações de segurança",
      "Segundo nível de compliance SOX"
    ],
    "correctIndex": 0,
    "explanation": "SOC 2 avalia controles de provedores de serviço em 5 critérios: Segurança (obrigatório), Disponibilidade, Integridade de Processamento, Confidencialidade e Privacidade. Tipo I: design (momento). Tipo II: efetividade (período).",
    "example": "SOC 1: controles financeiros. SOC 2: operacionais/segurança (mais solicitado por clientes cloud/SaaS). SOC 3: relatório público (resumido). SOC 2 Tipo II é o padrão do mercado."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Difícil",
    "question": "Qual a relação entre governança, gestão de riscos e compliance (GRC)?",
    "options": [
      "Três disciplinas integradas: governança define direção, riscos avalia ameaças, compliance garante conformidade",
      "GRC é um tipo de firewall",
      "São três certificações independentes",
      "GRC é software de monitoramento"
    ],
    "correctIndex": 0,
    "explanation": "GRC integra: Governança (estrutura decisória), Riscos (identificar e tratar riscos) e Compliance (conformidade com leis). Abordagem integrada evita silos, reduz custos e melhora visão de riscos.",
    "example": "Sem GRC integrado: cada área gerencia riscos isoladamente. Com GRC: visão unificada. Ferramentas: ServiceNow GRC, RSA Archer. Framework: COSO ERM para Enterprise Risk Management."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Difícil",
    "question": "O que é o NIST Cybersecurity Framework e como se estrutura?",
    "options": [
      "Framework em 5 funções (Identify, Protect, Detect, Respond, Recover) para gestão de riscos cibernéticos",
      "Certificação de segurança do governo americano",
      "Software de detecção de intrusão",
      "Protocolo de comunicação segura"
    ],
    "correctIndex": 0,
    "explanation": "NIST CSF organiza segurança em 5 funções: Identify (inventário, riscos), Protect (controles preventivos), Detect (monitoramento), Respond (resposta a incidentes), Recover (restauração). Amplamente adotado internacionalmente.",
    "example": "NIST CSF 2.0 (2024): adicionou Govern como 6ª função. Tiers: 1 (Parcial) a 4 (Adaptivo). Profiles: estado atual vs desejado. Complementa ISO 27001. NIST SP 800-53: catálogo de controles detalhados."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Difícil",
    "question": "O que é compliance as code e qual sua importância na governança?",
    "options": [
      "Automação de verificações de compliance usando código e ferramentas; garante conformidade contínua",
      "Linguagem de programação para auditores",
      "Certificação de código-fonte",
      "Manual de compliance em formato digital"
    ],
    "correctIndex": 0,
    "explanation": "Compliance as Code automatiza verificações de conformidade: políticas escritas como código, testadas continuamente em pipelines CI/CD. Reduz erro humano e garante compliance em tempo real, não apenas em auditorias periódicas.",
    "example": "Ferramentas: Open Policy Agent (OPA/Rego), AWS Config Rules, Azure Policy, Chef InSpec, HashiCorp Sentinel. Exemplo: política 'S3 buckets nunca públicos' verificada a cada deploy automaticamente."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Difícil",
    "question": "O que é o modelo de maturidade CMMI e como se aplica à segurança?",
    "options": [
      "Framework que avalia maturidade de processos em 5 níveis; adaptável para medir evolução de controles de segurança",
      "Certificação de hardware seguro",
      "Linguagem de programação para auditoria",
      "Tipo de criptografia por nível"
    ],
    "correctIndex": 0,
    "explanation": "CMMI (Capability Maturity Model Integration): 5 níveis — 1) Inicial (ad hoc), 2) Gerenciado (por projeto), 3) Definido (padronizado), 4) Quantitativamente Gerenciado (métricas), 5) Otimizado (melhoria contínua). Aplicado à segurança, mede evolução da postura organizacional.",
    "example": "C2M2 (Cybersecurity Capability Maturity Model): versão específica para cibersegurança. NIST CSF Tiers: 1-Partial a 4-Adaptive (similar). ISO 27001: ciclo PDCA para melhoria contínua. Organizações maduras: nível 3+ com processos padronizados."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Difícil",
    "question": "O que é third-party risk management (TPRM)?",
    "options": [
      "Gestão de riscos introduzidos por fornecedores e parceiros; inclui due diligence e monitoramento contínuo",
      "Gerenciamento de três tipos de firewall",
      "Terceirização completa da segurança",
      "Transferência de dados para terceiros"
    ],
    "correctIndex": 0,
    "explanation": "TPRM avalia e monitora riscos de fornecedores que acessam dados ou sistemas. Inclui: due diligence pré-contrato, questionários de segurança (SIG), cláusulas contratuais, auditorias periódicas e monitoramento contínuo de riscos.",
    "example": "Supply chain attacks (SolarWinds) mostraram a importância. Ferramentas: BitSight, SecurityScorecard (rating externo). Processo: tiering de fornecedores → assessment → contrato com SLA → monitoramento → revisão anual. NIST SP 800-161: supply chain risk."
  },
  {
    "id": "seguranca-da-informacao__Governança e Compliance__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Governança e Compliance",
    "difficulty": "Difícil",
    "question": "Como estruturar um programa de Third-Party Risk Management (TPRM) e quais controles avaliar em fornecedores?",
    "options": [
      "TPRM: inventário de fornecedores por criticidade → questionnaire/due diligence → análise de controles (ISO 27001, SOC 2, pentest) → contrato com SLAs e direito de auditoria → monitoramento contínuo",
      "TPRM se aplica somente a fornecedores de cloud; on-premise está isento",
      "Basta solicitar ao fornecedor carta de conformidade; auditoria direta é desnecessária",
      "TPRM é responsabilidade exclusiva do setor jurídico; equipe de segurança não participa"
    ],
    "correctIndex": 0,
    "explanation": "Risco de terceiros: fornecedores com acesso a dados sensíveis são extensão da superfície de ataque (SolarWinds, Kaseya, MOVEit). TPRM: (1) Inventário e classificação; (2) Due diligence inicial (questionário, certificações, pentest reports); (3) Contrato: DPA, SLAs de segurança, direito de auditoria; (4) Monitoramento: renewed assessment anual, SecurityScorecard, notícias de incidentes.",
    "example": "ISO 27036: gestão de segurança em relacionamentos com fornecedores. SOC 2 Type II: auditoria independente de controles de fornecedor. CAIQ (Cloud Security Alliance): questionário padronizado para provedores cloud. Fourth-party risk: risco dos fornecedores dos seus fornecedores. SOW: incluir requisitos de segurança, obrigação de notificação de incidente (72h per LGPD/GDPR)."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Fácil",
    "question": "O que é a LGPD e quando ela entrou em vigor?",
    "options": [
      "Lei Geral de Proteção de Dados Pessoais, em vigor desde setembro de 2020",
      "Lei de Governança Digital, 2018",
      "Lei Geral de Proteção Digital, 2021",
      "Lei de Gestão de Dados Públicos, 2019"
    ],
    "correctIndex": 0,
    "explanation": "A LGPD (Lei nº 13.709/2018) é a lei brasileira que regula o tratamento de dados pessoais por pessoas físicas e jurídicas. Inspirada no GDPR europeu. Entrou em vigor em setembro de 2020, com sanções aplicáveis a partir de agosto de 2021. A ANPD é o órgão fiscalizador.",
    "example": "LGPD protege dados pessoais (nome, CPF, email) e dados sensíveis (saúde, religião, biometria). Bases legais: consentimento, legítimo interesse, cumprimento de obrigação legal, etc. Multa: até 2% do faturamento, limitada a R$ 50 milhões por infração."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Fácil",
    "question": "O que são dados pessoais segundo a LGPD?",
    "options": [
      "Qualquer informação que identifique ou possa identificar uma pessoa natural",
      "Apenas CPF e RG",
      "Dados de empresas e organizações",
      "Informações públicas disponíveis na internet"
    ],
    "correctIndex": 0,
    "explanation": "Dado pessoal é toda informação de pessoa identificada ou identificável: nome, CPF, email, IP, cookies, localização. Dados anonimizados não são dados pessoais para a LGPD.",
    "example": "Dado pessoal: nome, CPF, email, IP, cookies. Dado sensível (art. 5, II): saúde, etnia, religião, biometria, genética, opinião política. Dados sensíveis têm proteção extra (art. 11)."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Fácil",
    "question": "O que é a ANPD e qual seu papel na LGPD?",
    "options": [
      "Autoridade Nacional de Proteção de Dados — órgão que fiscaliza e aplica sanções",
      "Agência Nacional de Processamento de Dados",
      "Empresa de certificados digitais",
      "Sistema de backup do governo"
    ],
    "correctIndex": 0,
    "explanation": "A ANPD fiscaliza o cumprimento da LGPD, orienta empresas e aplica sanções (multas até R$50M). Análoga à CNIL (França) e ICO (UK). Recebe reclamações de titulares e edita normas complementares.",
    "example": "Sanções: advertência, multa (até 2% faturamento / R$50M), publicização da infração, bloqueio/eliminação de dados. ANPD: fiscaliza, orienta, edita normas, recebe reclamações."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Fácil",
    "question": "O que são dados pessoais sensíveis na LGPD?",
    "options": [
      "Dados sobre saúde, religião, etnia, biometria, genética, opinião política e filiação sindical",
      "Apenas dados bancários",
      "Dados de empresas e CNPJs",
      "Qualquer dado armazenado em computador"
    ],
    "correctIndex": 0,
    "explanation": "Art. 5º, II da LGPD: dado sensível é sobre origem racial/étnica, religião, opinião política, filiação sindical, saúde, vida sexual, dado genético ou biométrico. Tem proteção reforçada (art. 11).",
    "example": "Dados sensíveis: bases legais mais restritivas (art. 11). Não se aplicam: legítimo interesse e proteção do crédito. Comum: consentimento específico ou obrigação legal. Exemplos: prontuário médico, digital biométrica."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Fácil",
    "question": "O que é consentimento na LGPD?",
    "options": [
      "Manifestação livre, informada e inequívoca do titular concordando com o tratamento de seus dados",
      "Aceitar termos de uso sem ler",
      "Autorização automática ao criar uma conta",
      "Permissão dada pelo governo para tratar dados"
    ],
    "correctIndex": 0,
    "explanation": "Consentimento deve ser livre (sem coerção), informado (saber para quê), inequívoco (claro) e para finalidade específica. Pode ser revogado a qualquer momento. Consentimento genérico é nulo.",
    "example": "Requisitos: finalidade específica, destaque no contrato, revogável, granular. Erro comum: checkbox pré-marcado (não é livre). Dados sensíveis: consentimento específico e destacado (art. 11, I)."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Fácil",
    "question": "O que é tratamento de dados pessoais segundo a LGPD?",
    "options": [
      "Toda operação com dados pessoais: coleta, armazenamento, uso, compartilhamento e eliminação",
      "Apenas armazenar dados em banco de dados",
      "Somente o uso comercial de dados",
      "Criptografia obrigatória de todos os dados"
    ],
    "correctIndex": 0,
    "explanation": "Art. 5º, X da LGPD: tratamento é toda operação realizada com dados pessoais — coleta, produção, recepção, classificação, utilização, acesso, reprodução, transmissão, distribuição, processamento, arquivamento, armazenamento, eliminação, avaliação, controle, modificação, comunicação, transferência, difusão ou extração.",
    "example": "Até visualizar dados é tratamento. Imprimir, enviar por email, fazer backup — tudo é tratamento. Cada operação precisa de base legal. Controlador decide COMO tratar; operador executa a mando do controlador."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Fácil",
    "question": "O que é o princípio da finalidade na LGPD?",
    "options": [
      "Dados devem ser tratados para propósitos legítimos, específicos e informados ao titular",
      "Dados podem ser usados para qualquer finalidade",
      "Finalidade se refere ao prazo de armazenamento",
      "Princípio que define o formato dos dados"
    ],
    "correctIndex": 0,
    "explanation": "Art. 6º, I: finalidade é a realização do tratamento para propósitos legítimos, específicos, explícitos e informados ao titular. Não se pode coletar dados para um fim e usar para outro sem nova base legal ou consentimento.",
    "example": "10 princípios da LGPD (art. 6º): finalidade, adequação, necessidade, livre acesso, qualidade, transparência, segurança, prevenção, não discriminação, responsabilização. Finalidade é o primeiro e mais fundamental."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Fácil",
    "question": "O que é dado pessoal sensível segundo a LGPD e quais exemplos a lei enumera?",
    "options": [
      "Dado pessoal sensível: origem racial/étnica, convicção religiosa, opinião política, saúde, vida sexual, dado genético/biométrico, filiação sindical; tratamento requer consentimento específico ou hipótese legal",
      "Dado sensível é qualquer dado pessoal identificável; a lei não diferencia categorias",
      "Dados financeiros são sempre sensíveis segundo a LGPD",
      "Dado sensível inclui somente dados médicos; os demais são dados pessoais comuns"
    ],
    "correctIndex": 0,
    "explanation": "LGPD (Lei 13.709/2018), artigo 5°, II: dado pessoal sensível = dado pessoal sobre origem racial ou étnica, convicção religiosa, opinião política, filiação sindical, organização de caráter religioso, filosófico ou político, dado referente à saúde ou à vida sexual, dado genético ou biométrico.",
    "example": "Tratamento de dado sensível: somente em hipóteses do art. 11 (consentimento específico e destacado, obrigação legal, políticas públicas, estudos de pesquisa, proteção da vida, tutela da saúde, prevenção à fraude, proteção do titular). Consentimento: deve ser inequívoco, informado, específico (não pode ser genérico). ANPD: Autoridade Nacional de Proteção de Dados."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Médio",
    "question": "Quais são os agentes de tratamento de dados pessoais definidos pela LGPD?",
    "options": [
      "Controlador e Operador",
      "Titular e Processador",
      "Administrador e Usuário",
      "Proprietário e Gerente"
    ],
    "correctIndex": 0,
    "explanation": "Controlador: toma as decisões sobre o tratamento dos dados (para que, como, quando). Operador: realiza o tratamento em nome do controlador (segue instruções). Exemplo: empresa (controlador) contrata serviço de cloud (operador) para armazenar dados de clientes.",
    "example": "Controlador: empresa que coleta dados do cliente. Operador: AWS, Google Cloud, processador de pagamento que trata dados a mando do controlador. Encarregado (DPO): ponte entre controlador, ANPD e titulares."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Médio",
    "question": "O que é o encarregado de proteção de dados (DPO) na LGPD?",
    "options": [
      "Pessoa indicada pelo controlador para ser canal entre controlador, ANPD e titulares",
      "Servidor público da ANPD",
      "Software de proteção de dados",
      "Auditor externo de compliance"
    ],
    "correctIndex": 0,
    "explanation": "O DPO aceita reclamações de titulares, comunica-se com a ANPD, orienta funcionários sobre proteção de dados e executa atribuições do controlador. Obrigatório para controladores.",
    "example": "LGPD: 'encarregado'. GDPR: 'DPO'. Canal de comunicação entre controlador, titulares e ANPD. Pode ser pessoa física ou jurídica (terceirizado)."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Médio",
    "question": "Quais são os direitos dos titulares de dados na LGPD?",
    "options": [
      "Acesso, correção, anonimização, portabilidade, eliminação, informação e revogação de consentimento",
      "Apenas o direito de exclusão",
      "Direito de vender seus dados",
      "Direito de acessar dados de outras pessoas"
    ],
    "correctIndex": 0,
    "explanation": "Art. 18 garante: confirmação de tratamento, acesso, correção, anonimização/bloqueio/eliminação, portabilidade, informação sobre compartilhamento, revogação de consentimento.",
    "example": "Direitos: confirmar, acessar, corrigir, anonimizar, portar, eliminar, informar, revogar. Controlador deve responder em tempo razoável. Exceções legais para eliminação."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Médio",
    "question": "O que é Privacy by Design e como se relaciona com a LGPD?",
    "options": [
      "Incorporar privacidade desde a concepção do sistema; a LGPD exige medidas de segurança desde o projeto",
      "Design visual de políticas de privacidade",
      "Software de criptografia de dados",
      "Layout de página de consentimento"
    ],
    "correctIndex": 0,
    "explanation": "Privacy by Design (Ann Cavoukian) incorpora privacidade na arquitetura do sistema desde o início, não como remendo posterior. LGPD art. 46 §2: medidas de segurança devem ser observadas desde a concepção do produto/serviço.",
    "example": "7 princípios: proativo (não reativo), privacidade como padrão, embutida no design, funcionalidade total, segurança ponta-a-ponta, visibilidade/transparência, respeito ao usuário. GDPR art. 25: Data Protection by Design."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Médio",
    "question": "O que é transferência internacional de dados na LGPD?",
    "options": [
      "Envio de dados pessoais para outro país, permitida apenas com garantias adequadas de proteção",
      "Backup de dados em servidor no Brasil",
      "Compartilhamento entre empresas brasileiras",
      "Migração de banco de dados entre servidores"
    ],
    "correctIndex": 0,
    "explanation": "LGPD art. 33: transferência internacional permitida quando: país com proteção adequada (aprovado pela ANPD), cláusulas contratuais padrão, BCRs, consentimento específico, ou cooperação jurídica internacional.",
    "example": "Mecanismos: decisão de adequação (ANPD), cláusulas-padrão contratuais (SCCs), BCRs (Binding Corporate Rules), consentimento específico. Comparação GDPR: Schrems II invalidou Privacy Shield (EUA)."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Médio",
    "question": "O que é ROPA (Record of Processing Activities) na LGPD?",
    "options": [
      "Registro das operações de tratamento que documenta quais dados são tratados, para quê e por quem",
      "Relatório anual de auditoria",
      "Software de gerenciamento de consentimento",
      "Backup obrigatório de dados pessoais"
    ],
    "correctIndex": 0,
    "explanation": "ROPA documenta cada atividade de tratamento: dados coletados, finalidade, base legal, categorias de titulares, compartilhamentos, transferências internacionais, prazos de retenção e medidas de segurança. Exigido pela ANPD e GDPR (art. 30).",
    "example": "ROPA é obrigatório para controladores e operadores. Campos: atividade de tratamento, dados pessoais envolvidos, finalidade, base legal, compartilhamento, retenção, medidas de segurança. Ferramenta: Data Mapping → ROPA → RIPD."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Médio",
    "question": "O que é o princípio da minimização de dados na LGPD?",
    "options": [
      "Tratar apenas dados estritamente necessários para a finalidade, evitando coleta excessiva",
      "Usar menor quantidade de servidores possível",
      "Minimizar o custo de armazenamento",
      "Excluir todos os dados após o uso"
    ],
    "correctIndex": 0,
    "explanation": "Art. 6º, III (necessidade): limitação do tratamento ao mínimo necessário. Não coletar dados 'por precaução' ou 'pode ser útil no futuro'. Coletar CPF para cadastro em newsletter é excessivo — email basta.",
    "example": "Privacy by Design: coletar só o necessário. Data minimization: menos dados = menor risco. Exemplo ruim: formulário que pede CPF, endereço, renda para enviar email marketing. Exemplo bom: só email + nome."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Médio",
    "question": "Quais são as bases legais para tratamento de dados pessoais segundo a LGPD (art. 7°)?",
    "options": [
      "10 bases legais: consentimento, obrigação legal, execução de políticas públicas, pesquisa, execução de contrato, exercício regular de direito, proteção da vida, tutela da saúde, legítimo interesse, proteção do crédito",
      "A única base legal é o consentimento expresso do titular",
      "LGPD tem apenas 3 bases legais: consentimento, contrato e lei",
      "Bases legais aplicam-se somente a empresas privadas; órgãos públicos estão isentos"
    ],
    "correctIndex": 0,
    "explanation": "LGPD art. 7°: (I) consentimento; (II) obrigação legal ou regulatória; (III) execução de políticas públicas (poder público); (IV) pesquisa (anonimização quando possível); (V) execução de contrato; (VI) exercício regular de direito; (VII) proteção da vida; (VIII) tutela da saúde (profissional de saúde); (IX) legítimo interesse; (X) proteção do crédito. Dados sensíveis: bases mais restritas (art. 11).",
    "example": "Legítimo interesse: deve ser balanceado com direitos do titular; necessitar de LIA (Legitimate Interest Assessment). Consentimento: revogável a qualquer tempo; gratuito; não pode condicionar serviço. Data mapping (RoPA): mapeamento de atividades de tratamento por finalidade e base legal. Penalidades: até 2% do faturamento (R$50M por infração)."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Difícil",
    "question": "Quais são as bases legais da LGPD para tratamento de dados pessoais? Quantas existem?",
    "options": [
      "10 bases legais, incluindo consentimento, legítimo interesse, cumprimento de obrigação legal, entre outras",
      "Apenas consentimento",
      "3 bases: consentimento, contrato e lei",
      "7 bases legais"
    ],
    "correctIndex": 0,
    "explanation": "A LGPD define 10 bases legais (art. 7º): 1) Consentimento. 2) Obrigação legal/regulatória. 3) Administração pública. 4) Pesquisa. 5) Execução de contrato. 6) Exercício regular de direito. 7) Proteção da vida. 8) Tutela da saúde. 9) Legítimo interesse. 10) Proteção do crédito. O consentimento NÃO é a única base — cada tratamento deve ter uma base legal adequada.",
    "example": "Erro comum: achar que tudo precisa de consentimento. Exemplo: folha de pagamento usa base 'obrigação legal'. Cobrança usa 'proteção do crédito'. Dados sensíveis (art. 11) têm bases mais restritivas — não se aplica legítimo interesse nem proteção do crédito."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Difícil",
    "question": "O que é um RIPD (Relatório de Impacto à Proteção de Dados) na LGPD?",
    "options": [
      "Documento que descreve tratamentos de alto risco e medidas de mitigação adotadas",
      "Relatório de incidentes de segurança",
      "Laudo de auditoria anual obrigatório",
      "Registro de todas as bases de dados"
    ],
    "correctIndex": 0,
    "explanation": "O RIPD (DPIA no GDPR) é exigido quando o tratamento pode gerar alto risco. Descreve: dados tratados, finalidade, bases legais, riscos identificados e medidas de mitigação. A ANPD pode requisitá-lo a qualquer momento.",
    "example": "RIPD contém: tipos de dados, adequação, riscos, medidas de segurança. Cenários: dados sensíveis em larga escala, decisões automatizadas, monitoramento sistemático."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Difícil",
    "question": "Qual a diferença entre anonimização e pseudonimização de dados na LGPD?",
    "options": [
      "Anonimização é irreversível (dado não é mais pessoal); pseudonimização é reversível (dado continua pessoal)",
      "São sinônimos",
      "Anonimização é para sensíveis, pseudonimização para comuns",
      "Pseudonimização é mais segura"
    ],
    "correctIndex": 0,
    "explanation": "Anonimização: processo IRREVERSÍVEL que remove toda identificação — dados não são pessoais (LGPD não se aplica). Pseudonimização: REVERSÍVEL usando tokens/hash — dados continuam pessoais, LGPD se aplica integralmente.",
    "example": "Anonimizado: remove CPF, nome → impossível identificar. Pseudonimizado: CPF substituído por token → reversível com tabela. LGPD incentiva ambos como medidas de segurança."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Difícil",
    "question": "O que é o legítimo interesse como base legal da LGPD e quando pode ser utilizado?",
    "options": [
      "Base que permite tratar dados sem consentimento quando há interesse legítimo do controlador, equilibrado com direitos do titular",
      "Interesse do titular em ter seus dados protegidos",
      "Interesse do governo em coletar dados",
      "Base legal que substitui todas as outras"
    ],
    "correctIndex": 0,
    "explanation": "Legítimo interesse (art. 7, IX) permite tratar dados sem consentimento quando necessário para finalidades legítimas do controlador. Exige LIA (Legitimate Interest Assessment): teste de finalidade, necessidade, balanceamento e salvaguardas.",
    "example": "LIA: 1) Finalidade legítima? 2) Dados necessários (minimização)? 3) Equilíbrio com direitos do titular? 4) Salvaguardas (transparência, opt-out). NÃO se aplica a dados sensíveis. Não é carta branca."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Difícil",
    "question": "Como funciona o processo de notificação de incidentes de segurança na LGPD?",
    "options": [
      "Controlador deve comunicar ANPD e titulares em prazo razoável sobre incidentes que possam gerar risco ou dano relevante",
      "Apenas registrar internamente sem comunicar externamente",
      "Notificar somente a polícia federal",
      "Comunicar apenas os titulares após 1 ano"
    ],
    "correctIndex": 0,
    "explanation": "Art. 48: controlador deve comunicar ANPD e titulares afetados em prazo razoável (regulamento diz 72h para ANPD). Informar: natureza dos dados, titulares envolvidos, medidas técnicas, riscos, medidas de mitigação.",
    "example": "Conteúdo da notificação: descrição dos dados, titulares afetados, medidas de segurança, riscos, medidas tomadas. ANPD pode determinar: ampla divulgação, medidas para reverter efeitos. Comparação GDPR: 72h para DPA."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Difícil",
    "question": "O que são BCRs (Binding Corporate Rules) no contexto de transferência internacional de dados?",
    "options": [
      "Regras corporativas vinculantes aprovadas pela autoridade para transferência de dados dentro de grupo multinacional",
      "Certificação de backup de dados",
      "Regras de firewall entre filiais",
      "Contratos de SLA entre países"
    ],
    "correctIndex": 0,
    "explanation": "BCRs são políticas internas de um grupo empresarial multinacional aprovadas pela ANPD/DPA para permitir transferência internacional de dados entre suas entidades. Garantem nível adequado de proteção, semelhante ao país de origem.",
    "example": "BCRs: custosas e demoradas (meses para aprovação), mas permitem transferência livre dentro do grupo. Alternativas mais simples: SCCs (cláusulas-padrão), decisão de adequação. GDPR art. 47: BCRs aprovadas pela lead DPA."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Difícil",
    "question": "O que é o teste de proporcionalidade aplicado ao legítimo interesse na LGPD?",
    "options": [
      "Análise que equilibra o interesse do controlador com os direitos e liberdades fundamentais do titular",
      "Teste de performance de sistemas de segurança",
      "Cálculo do tamanho adequado do banco de dados",
      "Verificação da proporção de dados sensíveis"
    ],
    "correctIndex": 0,
    "explanation": "O LIA (Legitimate Interest Assessment) avalia: 1) Finalidade legítima do controlador? 2) Tratamento necessário e proporcional? 3) Direitos do titular preservados? 4) Salvaguardas adotadas? Se o impacto ao titular superar o interesse, o legítimo interesse não se aplica.",
    "example": "4 etapas: finalidade (legítima?), necessidade (proporcional?), balanceamento (impacto ao titular?), salvaguardas (opt-out, transparência, minimização). Recusado quando: dados sensíveis, crianças, tratamento em larga escala sem transparência. Art. 10 LGPD."
  },
  {
    "id": "seguranca-da-informacao__LGPD__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "LGPD",
    "difficulty": "Difícil",
    "question": "Como implementar Privacy by Design e Privacy by Default em sistemas conforme a LGPD/GDPR?",
    "options": [
      "Privacy by Design: integrar privacidade no ciclo de desenvolvimento (SDLC) desde o início; Privacy by Default: configuração mais restritiva como padrão; técnicas: minimização de dados, pseudonimização, controles de acesso granulares, data retention policies",
      "Privacy by Design é documentação jurídica; não envolve decisões técnicas de arquitetura",
      "Privacy by Default significa coletar dados máximos e permitir opt-out posterior",
      "Aplica-se somente a novos sistemas; sistemas legados estão isentos por padrão"
    ],
    "correctIndex": 0,
    "explanation": "Privacy by Design (Ann Cavoukian, 7 princípios): proativo não reativo, privacidade como padrão, embutida no design, funcionalidade plena, segurança end-to-end, visibilidade e transparência, respeito ao usuário. GDPR art. 25 / LGPD art. 46: obrigação legal. Data minimization: coletar somente o necessário. Pseudonimização: separar identificadores dos dados.",
    "example": "DPIA (Data Protection Impact Assessment): avaliação de risco antes de processar dados sensíveis em larga escala. Threat model: LINDDUN (Privacy-focused STRIDE). Técnicas PbD: field-level encryption, tokenização, mascaramento para não-prod, consent management platform (CMP), cookie banner, RoPA (Record of Processing Activities). Privacy debt: débito técnico de privacidade em sistemas legados."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Fácil",
    "question": "Qual tipo de malware se disfarça como software legítimo para enganar o usuário?",
    "options": [
      "Trojan (Cavalo de Troia)",
      "Worm",
      "Ransomware",
      "Adware"
    ],
    "correctIndex": 0,
    "explanation": "Trojan se disfarça de programa útil/desejado (jogo, utilitário, crack) para induzir o usuário a instalá-lo. Diferente de vírus, não se replica sozinho — depende da ação do usuário. Uma vez instalado, pode abrir backdoors, roubar dados ou instalar outros malwares.",
    "example": "Nome vem da mitologia grega (Cavalo de Troia). Exemplo: 'jogoGratis.exe' que na verdade instala um keylogger. Worm se propaga sozinho pela rede. Vírus se anexa a arquivos. Trojan engana o usuário."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Fácil",
    "question": "O que é malware?",
    "options": [
      "Software malicioso criado para danificar, explorar ou obter acesso não autorizado",
      "Software de proteção contra vírus",
      "Atualização de sistema operacional",
      "Programa de backup de dados"
    ],
    "correctIndex": 0,
    "explanation": "Malware (malicious software) é o termo genérico para qualquer software malicioso. Inclui: vírus, worms, trojans, ransomware, spyware, adware, rootkits, keyloggers. Pode roubar dados, danificar sistemas ou extorquir.",
    "example": "Tipos: Vírus (se anexa), Worm (se propaga), Trojan (se disfarça), Ransomware (criptografa), Spyware (espiona), Adware (anúncios), Keylogger (teclas), Rootkit (se oculta no SO)."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Fácil",
    "question": "O que é um spyware?",
    "options": [
      "Software que monitora atividades do usuário sem consentimento, coletando dados pessoais",
      "Antivírus que espiona outros programas",
      "Programa que protege contra espionagem",
      "Ferramenta de monitoramento autorizada"
    ],
    "correctIndex": 0,
    "explanation": "Spyware monitora secretamente: sites visitados, teclas digitadas (keylogger), capturas de tela. Coleta dados e envia ao atacante. Pode vir junto com software legítimo ou via exploits.",
    "example": "Tipos: Keylogger (teclas), Screen capture, Browser hijacker (altera navegador), Stalkerware (monitoramento de parceiros). Detecção: Malwarebytes, AdwCleaner."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Fácil",
    "question": "O que é ransomware?",
    "options": [
      "Malware que criptografa dados da vítima e exige pagamento (resgate) para liberá-los",
      "Software de proteção contra sequestéro de dados",
      "Tipo de antivírus premium",
      "Ferramenta de backup criptografado"
    ],
    "correctIndex": 0,
    "explanation": "Ransomware cifra arquivos ou bloqueia o sistema e exige pagamento (geralmente em criptomoeda) para fornecer a chave de descriptografia. Dupla extorsão: cifra + ameaça vazar dados roubados.",
    "example": "Exemplos: WannaCry (2017, SMB), NotPetya (2017, supply chain), LockBit, REvil. Proteção: backup 3-2-1, patch management, MFA, segmentação de rede. NUNCA pagar garante recuperação."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Fácil",
    "question": "O que é adware?",
    "options": [
      "Software que exibe anúncios indesejados e pode coletar dados de navegação",
      "Antivírus gratuito com proteção avançada",
      "Programa para criar anúncios publicitários",
      "Ferramenta de bloqueio de pop-ups"
    ],
    "correctIndex": 0,
    "explanation": "Adware exibe propagandas intrusivas (pop-ups, banners, redirecionamentos). Pode vir empacotado com software gratuito (bundleware). Versões mais agressivas coletam hábitos de navegação (grayware).",
    "example": "Nem todo adware é malicioso (apps suportados por anúncios), mas muitos são indesejados. Pode alterar página inicial do navegador (browser hijacker). Remoção: AdwCleaner, Malwarebytes."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Fácil",
    "question": "O que é um worm de computador?",
    "options": [
      "Malware que se autopropaga pela rede sem precisar de arquivo hospedeiro ou ação do usuário",
      "Vírus que infecta apenas documentos Word",
      "Software de monitoramento de rede",
      "Tipo de antivírus para Linux"
    ],
    "correctIndex": 0,
    "explanation": "Worm é malware autônomo que se propaga automaticamente explorando vulnerabilidades de rede. Diferente do vírus, não precisa de arquivo hospedeiro nem ação do usuário. Pode causar congestionamento de rede pela replicação massiva.",
    "example": "Exemplos: Code Red (2001, IIS), SQL Slammer (2003, SQL Server), Conficker (2008, SMB), WannaCry (2017, EternalBlue/SMB). Defesa: patch management, segmentação de rede, IPS."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Fácil",
    "question": "O que é phishing?",
    "options": [
      "Técnica de engenharia social que usa mensagens fraudulentas para roubar informações",
      "Tipo de antivírus corporativo",
      "Método de criptografia de emails",
      "Software de filtragem de spam"
    ],
    "correctIndex": 0,
    "explanation": "Phishing usa emails, SMS (smishing) ou ligações (vishing) se passando por entidades confiáveis para induzir vítimas a revelar senhas, dados bancários ou instalar malware. É o vetor de ataque mais comum (>90% dos breaches).",
    "example": "Tipos: spear phishing (alvo específico), whaling (executivos), smishing (SMS), vishing (voz). Defesa: treinamento, filtros de email (SPF/DKIM/DMARC), MFA. Ferramentas de simulação: GoPhish, KnowBe4."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre vírus, worm e trojan?",
    "options": [
      "Vírus: precisa de arquivo hospedeiro para se replicar; Worm: autorreplicante sem hospedeiro (explora redes); Trojan: disfarçado de software legítimo, não se replica sozinho",
      "São sinônimos usados intercambiavelmente na indústria",
      "Worm requer ação do usuário; vírus se propaga sozinho pela rede",
      "Trojan é sempre inofensivo; vírus e worm são os únicos malwares destrutivos"
    ],
    "correctIndex": 0,
    "explanation": "Vírus: anexa código malicioso a executáveis/documentos; precisa de execução pelo usuário; replica ao executar o hospedeiro (ILOVEYOU, Melissa). Worm: explora vulnerabilidades de rede autonomamente (WannaCry, Conficker - SMB/EternalBlue). Trojan: software aparentemente legítimo que esconde malware (backdoor, keylogger); não se replica. RAT (Remote Access Trojan): controle remoto completo.",
    "example": "Rootkit: esconde presença no OS (kernel hooks, DKOM). Ransomware: cifra dados e exige resgate (WannaCry, Ryuk, LockBit). Spyware: monitora atividade (keyloggers, screen capture). Adware: exibe anúncios indesejados. Botnet: rede de bots (DDoS, spam, click fraud). Fileless malware: persiste em memória/registro sem arquivo em disco (PowerShell, WMI)."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Médio",
    "question": "Qual a diferença entre um vírus e um worm?",
    "options": [
      "Vírus precisa de um arquivo hospedeiro e ação do usuário; worm se propaga automaticamente pela rede",
      "São termos sinônimos",
      "Worm é menos perigoso que vírus",
      "Vírus se propaga pela rede e worm precisa de arquivo"
    ],
    "correctIndex": 0,
    "explanation": "Vírus: precisa de arquivo hospedeiro (se anexa a executáveis, documentos) e ação do usuário para se propagar (abrir arquivo, executar programa). Worm: programa independente que se propaga automaticamente pela rede, explorando vulnerabilidades sem interação do usuário. Worms podem causar congestionamento de rede pela replicação massiva.",
    "example": "Vírus: ILOVEYOU (se anexava a emails). Worm: WannaCry (se propagava via SMB vulnerável, sem ação do usuário). Worm pode carregar payload de ransomware, vírus, etc."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Médio",
    "question": "O que é uma botnet e como funciona?",
    "options": [
      "Rede de dispositivos infectados controlados remotamente para ataques coordenados",
      "Rede de robôs industriais",
      "Software de automação de testes",
      "Rede social para hackers"
    ],
    "correctIndex": 0,
    "explanation": "Botnet: rede de dispositivos infectados (bots/zombies) controlados pelo botmaster via C2 (Comando e Controle). Usada para DDoS, spam, mineração de cripto, roubo de credenciais. Pode ter milhões de dispositivos.",
    "example": "Malware infecta PCs/IoT → conecta ao C2 → botmaster envia comandos → bots executam. Exemplos: Mirai (IoT), Emotet (email), Zeus (bancário). Detecção: tráfego anômalo para IPs de C2."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Médio",
    "question": "O que é um keylogger e como se proteger?",
    "options": [
      "Software/hardware que registra teclas digitadas; proteção: antimalware, 2FA, teclado virtual",
      "Tipo de teclado criptografado",
      "Software de teste de teclado",
      "Ferramenta de acessibilidade"
    ],
    "correctIndex": 0,
    "explanation": "Keylogger captura todas as teclas incluindo senhas e dados bancários. Pode ser software (via malware) ou hardware (dispositivo USB entre teclado e PC). Proteções: antimalware, 2FA (senha roubada não basta), teclado virtual.",
    "example": "Software: registra teclas, screenshots, clipboard. Hardware: dispositivo USB invisível ao SO. Detecção: antimalware + inspeção física. 2FA protege porque precisa do segundo fator."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Médio",
    "question": "O que é fileless malware e por que é difícil de detectar?",
    "options": [
      "Malware que opera na memória sem gravar arquivos no disco, evadindo antivírus tradicionais",
      "Malware que não usa internet",
      "Vírus que deleta seus próprios arquivos após infecção",
      "Malware que só funciona off-line"
    ],
    "correctIndex": 0,
    "explanation": "Fileless malware usa ferramentas legítimas do SO (PowerShell, WMI, macros) e opera apenas na RAM. Antivírus baseados em arquivo não detectam. Requer EDR com análise comportamental e monitoramento de processos.",
    "example": "Técnicas: PowerShell com base64, WMI persistence, inject em processos legítimos, macros Office. Ferramentas: LOLBins (Living off the Land Binaries). Detecção: AMSI, EDR, Sysmon, análise de memória."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Médio",
    "question": "O que é um dropper e como funciona?",
    "options": [
      "Malware projetado para instalar outros malwares no sistema da vítima",
      "Ferramenta de transferência de arquivos",
      "Software de instalação de patches",
      "Bot de download automático"
    ],
    "correctIndex": 0,
    "explanation": "Dropper é o primeiro estágio da infecção: parece inofensivo, mas baixa e instala o payload real (ransomware, RAT, etc). Pode vir como anexo de email, documento com macro ou exploit kit.",
    "example": "Dropper (contém payload embutido) vs Downloader (baixa payload da internet). Emotet: começou como trojan bancário, virou dropper-as-a-service para TrickBot/Ryuk. Kill chain: dropper → C2 → payload."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Médio",
    "question": "O que é um RAT (Remote Access Trojan)?",
    "options": [
      "Malware que dá ao atacante controle remoto completo do computador da vítima",
      "Ferramenta legítima de suporte remoto",
      "Tipo de roteador de acesso misto",
      "Software de acesso remoto corporativo"
    ],
    "correctIndex": 0,
    "explanation": "RAT permite ao atacante controlar remotamente o computador: acessar arquivos, ativar webcam/microfone, capturar tela, executar comandos. Geralmente distribuído via phishing ou dropper. Opera silenciosamente em background.",
    "example": "Exemplos: DarkComet, njRAT, Gh0st RAT, QuasarRAT (open-source). Funcionalidades: keylogger, screenshot, webcam, download/upload, shell reverso. Detecção: EDR, análise de tráfego de rede (beacons para C2)."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Médio",
    "question": "O que é cryptojacking?",
    "options": [
      "Uso não autorizado de recursos computacionais da vítima para minerar criptomoedas",
      "Criptografia de ransomware",
      "Roubo de carteiras de criptomoedas",
      "Mineração legal de Bitcoin"
    ],
    "correctIndex": 0,
    "explanation": "Cryptojacking usa CPU/GPU da vítima para minerar criptomoedas sem consentimento. Pode ser via malware instalado ou scripts no navegador (Coinhive, descontinuado). Sintomas: lentidão, alto uso de CPU, superaquecimento.",
    "example": "Browser-based: JavaScript minerando Monero (difícil de rastrear). Malware-based: persistente, opera em background. Detecção: monitoramento de CPU, EDR, bloqueio de domínios de mining pools. Impacto: contas de cloud infladas."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Médio",
    "question": "Como funciona um ataque de ransomware moderno e quais controles mitigam o risco?",
    "options": [
      "Ransomware: acesso inicial (phishing/RDP/vuln) → persistência → lateral movement → exfiltração → criptografia com RSA+AES → nota de resgate; controles: backup offline 3-2-1, EDR comportamental, MFA, segmentação de rede",
      "Ransomware criptografa somente arquivos .doc e .pdf; demais extensões não são afetadas",
      "O antivírus tradicional (assinatura) é suficiente para prevenir ransomwares modernos",
      "Pagar o resgate garante a recuperação total dos dados em 100% dos casos"
    ],
    "correctIndex": 0,
    "explanation": "Kill chain ransomware: (1) Initial access: phishing, RDP brute force, exploração de vuln (VPN, Exchange). (2) Execution: PowerShell/WMI. (3) Persistence: scheduled tasks. (4) Privilege escalation: Mimikatz. (5) Lateral movement: PsExec, SMB. (6) Exfiltration (double extortion). (7) Encryption: AES-256 por arquivo, chave cifrada com RSA public key do atacante.",
    "example": "Defesas: backup 3-2-1 (3 cópias, 2 mídias, 1 offsite/offline); testar restore. EDR (CrowdStrike, SentinelOne): comportamental, não por assinatura. MFA: impede acesso com credenciais roubadas. Segmentação de rede: limita lateral movement. Disable RDP ou mover porta. CISA: no more ransom (desencriptadores públicos). Seguro cibernético."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Difícil",
    "question": "O que é um rootkit e por que é considerado um dos malwares mais perigosos?",
    "options": [
      "Malware que se esconde no sistema operacional/kernel, tornando-se invisível para antivírus convencionais",
      "Vírus que ataca apenas a conta root",
      "Script que adivinha senhas de administrador",
      "Programa que formata o disco rígido remotamente"
    ],
    "correctIndex": 0,
    "explanation": "Rootkit modifica o kernel/sistema operacional para se ocultar: intercepta chamadas de sistema, esconde processos, arquivos e conexões de rede da visão do antivírus e do SO. Pode operar em nível de kernel (mais perigoso), bootloader (bootkits) ou firmware (UEFI rootkits). Detecção e remoção são extremamente difíceis.",
    "example": "Tipos: User-mode (hooks em APIs), Kernel-mode (modifica kernel), Bootkit (infecta MBR/UEFI), Firmware (persiste em BIOS). Detecção: ferramentas offline (boot de CD/USB), análise de memória com Volatility. Remoção: frequentemente exige reinstalação do SO."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Difícil",
    "question": "O que é malware polimórfico e por que é difícil de detectar?",
    "options": [
      "Malware que altera seu código a cada infecção para evitar detecção por assinaturas",
      "Malware com múltiplas funcionalidades",
      "Malware que se propaga por bluetooth",
      "Malware que ataca apenas polimorfismo de código"
    ],
    "correctIndex": 0,
    "explanation": "Polimórfico muda seu código (cifra o payload com chaves diferentes) a cada cópia, mantendo funcionalidade. Antivírus baseados em assinaturas não reconhecem variações. Requer heurística e análise comportamental.",
    "example": "Assinatura: identifica bytes conhecidos → falha com polimórfico. Heurístico: analisa comportamento. Metamórfico: reescreve código (ainda mais difícil). EDR/XDR: detecção baseada em comportamento."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Difícil",
    "question": "O que é um ataque de supply chain em malware?",
    "options": [
      "Comprometer o desenvolvimento/distribuição de software legítimo para inserir malware",
      "Ataque a caminhões de entrega",
      "Roubo de produtos em trânsito",
      "Bloqueio de importação de hardware"
    ],
    "correctIndex": 0,
    "explanation": "Supply chain attack: atacante compromete um fornecedor confiável e insere malware no produto legítimo. Vítimas instalam a atualização maliciosa confiando no fornecedor. Muito difícil de detectar.",
    "example": "SolarWinds (2020): backdoor no Orion → 18.000 organizações. Kaseya (2021): REvil via atualização. CodeCov (2021): script CI comprometido. Defesa: SBOM, verificar integridade, Zero Trust."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Difícil",
    "question": "O que é um zero-day exploit e por que é tão perigoso?",
    "options": [
      "Exploração de vulnerabilidade desconhecida pelo fabricante, sem patch disponível",
      "Ataque que ocorre à meia-noite",
      "Vírus que se ativa no primeiro dia do mês",
      "Malware que se auto-destrói em 24 horas"
    ],
    "correctIndex": 0,
    "explanation": "Zero-day: vulnerabilidade que o fabricante desconhece (0 dias para corrigir). Exploits zero-day são vendidos no mercado negro por milhões. Sem patch disponível, defesa depende de: EDR, segmentação, Zero Trust.",
    "example": "Mercado: zero-day para iOS ~R$10M (Zerodium). Stuxnet usou 4 zero-days. Defesa em profundidade: WAF com regras genéricas, EDR comportamental, microsegmentação, sandboxing. CVE só sai após descoberta."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Difícil",
    "question": "O que é APT (Advanced Persistent Threat) e como opera?",
    "options": [
      "Grupo hacker sofisticado com presença prolongada e furtiva na rede da vítima",
      "Tipo de antivírus avançado",
      "Ameaa temporária que se resolve sozinha",
      "Ataque rápido e destrutivo"
    ],
    "correctIndex": 0,
    "explanation": "APT são grupos (geralmente patrocinados por estados) que infiltram redes por meses/anos. Características: reconhecimento extenso, zero-days, movimentação lateral, exfiltração gradual, evasão de detecção.",
    "example": "APT29 (Cozy Bear, Rússia), APT41 (China), Lazarus (Coreia do Norte). Kill chain: recon → weaponize → deliver → exploit → install → C2 → exfiltrate. Defesa: threat intelligence, NDR, EDR, hunting."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Difícil",
    "question": "O que é um bootkit e como difere de um rootkit tradicional?",
    "options": [
      "Malware que infecta o processo de boot (MBR/UEFI), carregando antes do SO e sendo mais persistente",
      "Rootkit que opera apenas em modo usuário",
      "Kit de ferramentas para boot de emergência",
      "Software de gerenciamento de boot dual"
    ],
    "correctIndex": 0,
    "explanation": "Bootkit infecta MBR ou firmware UEFI, carregando antes do sistema operacional. É mais persistente que rootkit de kernel: sobrevive a formatação e reinstalação do SO. Antivírus comum não detecta porque já está ativo antes do boot.",
    "example": "Exemplos: TDL4/Alureon (MBR), LoJax (primeiro UEFI rootkit in-the-wild, 2018, APT28). Defesa: UEFI Secure Boot, TPM, medição de integridade de boot. Detecção: ferramentas offline, verificação de firmware."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Difícil",
    "question": "O que é a técnica de process hollowing em malware?",
    "options": [
      "Criar processo legítimo em estado suspenso, substituir seu código por malware e executá-lo para evadir detecção",
      "Esvaziar memória RAM para acelerar processos",
      "Técnica de compressão de executáveis",
      "Método de virtualização de processos"
    ],
    "correctIndex": 0,
    "explanation": "Process hollowing: malware cria um processo legítimo (ex: svchost.exe) suspenso, esvazia sua memória, injeta código malicioso e retoma a execução. O processo aparece legítimo no Task Manager, evadindo detecção.",
    "example": "MITRE ATT&CK: T1055.012. Fluxo: CreateProcess(SUSPENDED) → NtUnmapViewOfSection → VirtualAllocEx → WriteProcessMemory → ResumeThread. Detecção: Sysmon (Event ID 25), EDR com análise de memória."
  },
  {
    "id": "seguranca-da-informacao__Malwares__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Malwares",
    "difficulty": "Difícil",
    "question": "O que é process hollowing e como ferramentas de EDR detectam essa técnica de evasão?",
    "options": [
      "Process hollowing: processo legítimo (svchost.exe) criado suspenso; memória original desmapeada e substituída por código malicioso; processo retoma execução com código do atacante no contexto do processo legítimo",
      "Process hollowing injeta código em arquivos em disco em vez da memória",
      "EDR não detecta process hollowing; somente análise manual com debugger",
      "Process hollowing requer acesso físico ao hardware; impossível remotamente"
    ],
    "correctIndex": 0,
    "explanation": "Técnica: (1) CreateProcess com CREATE_SUSPENDED. (2) NtUnmapViewOfSection (desmapeia memória do processo). (3) VirtualAllocEx (aloca memória no processo filho). (4) WriteProcessMemory (escreve PE malicioso). (5) SetThreadContext (ajusta EIP/RIP para entry point). (6) ResumeThread. PID do processo legítimo: atividade maliciosa aparece sob svchost.exe no Task Manager.",
    "example": "Detecção EDR: monitoramento de APIs suspeitas (NtUnmapViewOfSection + WriteProcessMemory + SetThreadContext sequência). Memory scanning: regiões PAGE_EXECUTE_READWRITE sem backing file (Volatility malfind). Behavioral: svchost.exe fazendo chamadas de rede incomuns. Yara rules: patterns no PE malicioso injetado. MITRE ATT&CK: T1055.012. ACG (Arbitrary Code Guard)."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Fácil",
    "question": "Qual é o objetivo principal da ISO 27001?",
    "options": [
      "Estabelecer um Sistema de Gestão de Segurança da Informação (SGSI)",
      "Definir linguagens de programação seguras",
      "Certificar hardware contra ataques físicos",
      "Regular o comércio eletrônico internacional"
    ],
    "correctIndex": 0,
    "explanation": "A ISO/IEC 27001 especifica os requisitos para implementar, manter e melhorar continuamente um SGSI (Sistema de Gestão de Segurança da Informação). É uma norma certificável — organizações podem obter certificação ISO 27001 após auditoria. O SGSI utiliza o ciclo PDCA (Plan-Do-Check-Act).",
    "example": "ISO 27001: requisitos (O QUE implementar) — certificável. ISO 27002: diretrizes de controles (COMO implementar) — não certificável. Analogia: 27001 é o 'contrato' e 27002 é o 'manual de instruções'."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Fácil",
    "question": "O que é o ciclo PDCA e como se aplica à ISO 27001?",
    "options": [
      "Plan-Do-Check-Act: ciclo de melhoria contínua para o SGSI",
      "Quatro tipos de criptografia",
      "Protocolo de segurança de rede",
      "Software de gestão de projetos"
    ],
    "correctIndex": 0,
    "explanation": "PDCA: Plan (planejar controles), Do (implementar), Check (monitorar e auditar), Act (corrigir e melhorar). A ISO 27001 usa PDCA para melhoria contínua do SGSI.",
    "example": "Plan: escopo, análise de riscos, selecionar controles. Do: implementar. Check: auditorias internas. Act: ações corretivas. O ciclo se repete continuamente."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Fácil",
    "question": "O que significa SGSI (Sistema de Gestão de Segurança da Informação)?",
    "options": [
      "Conjunto de políticas, processos e controles para gerenciar riscos de SI sistematicamente",
      "Software de segurança nos servidores",
      "Tipo de firewall corporativo",
      "Certificação individual de profissionais"
    ],
    "correctIndex": 0,
    "explanation": "SGSI é abordagem sistemática para gerenciar informações sensíveis: políticas, processos, controles técnicos e pessoas. A ISO 27001 especifica os requisitos para estabelecer um SGSI.",
    "example": "SGSI inclui: política de segurança, análise de riscos, SoA (Declaração de Aplicabilidade), controles, treinamento, auditoria, melhoria contínua. É um SISTEMA de gestão, não um produto."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Fácil",
    "question": "A ISO 27001 é uma norma certificável?",
    "options": [
      "Sim, organizações podem ser certificadas após auditoria por organismo acreditado",
      "Não, é apenas um guia de boas práticas",
      "Sim, mas apenas para profissionais individuais",
      "Não, apenas a ISO 27002 é certificável"
    ],
    "correctIndex": 0,
    "explanation": "ISO 27001 é certificável: um organismo de certificação acreditado audita o SGSI da organização. A certificação vale 3 anos, com auditorias de vigilância anuais. Já a ISO 27002 não é certificável.",
    "example": "Processo: audit Estágio 1 (documentação) + Estágio 2 (implementação) → certificado (3 anos) → vigilância anual → recertificação. Organismos: BSI, DNV, Bureau Veritas, TÜV."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Fácil",
    "question": "O que é o Anexo A da ISO 27001?",
    "options": [
      "Lista de controles de segurança recomendados que servem como referência para o SGSI",
      "Formulário de inscrição para certificação",
      "Glossário de termos técnicos de segurança",
      "Lista de auditorias realizadas"
    ],
    "correctIndex": 0,
    "explanation": "O Anexo A é a lista de controles de segurança da ISO 27001. Na versão 2022: 93 controles em 4 categorias. A organização seleciona quais são aplicáveis via análise de riscos e documenta na SoA.",
    "example": "Categorias (2022): Organizacionais (37), Pessoais (8), Físicos (14), Tecnológicos (34) = 93 total. SoA: para cada controle, indicar aplicável/não aplicável com justificativa. ISO 27002 detalha cada um."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Fácil",
    "question": "O que são os três pilares da segurança da informação?",
    "options": [
      "Confidencialidade, Integridade e Disponibilidade (CIA triad)",
      "Prevenção, Detecção e Recuperação",
      "Criptografia, Firewall e Antivírus",
      "Políticas, Normas e Procedimentos"
    ],
    "correctIndex": 0,
    "explanation": "CIA triad: Confidencialidade (só autorizados acessam), Integridade (dados não alterados indevidamente), Disponibilidade (acessível quando necessário). Base de toda segurança da informação e fundação da ISO 27001.",
    "example": "Confidencialidade: criptografia, controle de acesso. Integridade: hash, assinatura digital, controle de versão. Disponibilidade: backup, redundancy, DRP. Hexagrama de Parkerian adiciona: autenticidade, posse, utilidade."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Fácil",
    "question": "O que é a família de normas ISO 27000?",
    "options": [
      "Conjunto de normas internacionais que orientam a gestão de segurança da informação",
      "Apenas a ISO 27001 e ISO 27002",
      "Normas exclusivas para criptografia",
      "Certificações individuais de profissionais"
    ],
    "correctIndex": 0,
    "explanation": "A família ISO 27000 inclui dezenas de normas: 27000 (vocabulário), 27001 (requisitos SGSI), 27002 (controles), 27005 (riscos), 27017 (cloud), 27018 (PII), 27701 (privacidade), entre outras.",
    "example": "Principais: 27001 (certificável), 27002 (implementação), 27005 (riscos), 27017/27018 (cloud), 27701 (privacidade/LGPD/GDPR), 27035 (resposta a incidentes), 27037 (forense digital)."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Fácil",
    "question": "Qual a diferença entre ISO 27001 e ISO 27002?",
    "options": [
      "ISO 27001: requisitos para certificação do SGSI (auditável, certificável); ISO 27002: guia de boas práticas e controles de referência (não certificável)",
      "ISO 27001 e 27002 são a mesma norma; diferem apenas pelo idioma",
      "ISO 27002 é obrigatória por lei; ISO 27001 é apenas recomendada",
      "ISO 27001 cobre somente segurança física; 27002 cobre segurança lógica"
    ],
    "correctIndex": 0,
    "explanation": "ISO 27001:2022: SGSI (Sistema de Gestão de Segurança da Informação). Estrutura HLS (High Level Structure) = compatível com ISO 9001, 22301. Cláusulas 4-10: requisitos auditáveis. Anexo A: 93 controles (reorganizados em 4 temas em 2022). ISO 27002:2022: guia de implementação dos controles do Anexo A. Certificação: somente pela 27001.",
    "example": "ISO 27001 cláusulas: 4 Contexto, 5 Liderança, 6 Planejamento, 7 Suporte, 8 Operação, 9 Avaliação, 10 Melhoria. Declaração de Aplicabilidade (SoA): lista controles Anexo A aplicáveis/excluídos com justificativa. GAP assessment: avalia maturidade atual × requisitos. PDCA: ciclo de melhoria contínua. Ciclo de certificação: 3 anos + auditorias anuais de manutenção."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Médio",
    "question": "Qual é a relação entre a ISO 27001 e a ISO 27002?",
    "options": [
      "ISO 27001 define requisitos do SGSI; ISO 27002 detalha os controles de segurança recomendados",
      "São a mesma norma com nomes diferentes",
      "ISO 27002 substituiu a ISO 27001",
      "ISO 27001 é para empresas grandes e ISO 27002 para pequenas"
    ],
    "correctIndex": 0,
    "explanation": "ISO 27001: norma de requisitos — diz O QUE a organização deve fazer para implementar um SGSI (certificável). ISO 27002: código de práticas — detalha COMO implementar os controles listados no Anexo A da ISO 27001. A 27002 serve como guia de implementação dos controles referenciados pela 27001.",
    "example": "ISO 27001 Anexo A lista os controles. ISO 27002 detalha cada um: objetivo, diretrizes de implementação, considerações. Versão 2022: 93 controles em 4 categorias (organizacionais, pessoais, físicos, tecnológicos) vs 114 controles em 14 domínios na versão anterior."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Médio",
    "question": "O que é a Declaração de Aplicabilidade (SoA) na ISO 27001?",
    "options": [
      "Documento que lista quais controles do Anexo A foram selecionados e justifica exclusões",
      "Formulário de candidatura para certificação",
      "Política de segurança da empresa",
      "Lista de funcionários com acesso ao SGSI"
    ],
    "correctIndex": 0,
    "explanation": "A SoA é documento obrigatório que lista todos os controles do Anexo A, indica quais foram selecionados, excluídos (com justificativa) e o status de implementação. Resumo dos controles aplicáveis.",
    "example": "SoA: para cada um dos 93 controles (2022), indica aplicável/não aplicável, implementado/não, justificativa. Documento-chave na auditoria de certificação."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Médio",
    "question": "O que é auditoria interna na ISO 27001 e qual sua frequência?",
    "options": [
      "Avaliação periódica pela própria organização para verificar conformidade do SGSI; ao menos anual",
      "Auditoria feita pela ANPD",
      "Verificação de antivírus",
      "Teste de penetração externo"
    ],
    "correctIndex": 0,
    "explanation": "Cláusula 9.2 exige auditorias internas para verificar conformidade do SGSI. Conduzidas por auditores independentes da área auditada. Frequência mínima: anual (antes da análise crítica da direção).",
    "example": "Verifica: políticas seguidas, controles eficazes, não-conformidades. Gera relatório → análise crítica da direção → ações corretivas. Base para auditoria de certificação externa."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Médio",
    "question": "O que é o escopo do SGSI e como é definido?",
    "options": [
      "Delimita quais áreas, processos e ativos são cobertos pelo SGSI; definido na cláusula 4.3",
      "Lista de todos os softwares da empresa",
      "Número de funcionários do departamento de TI",
      "Orçamento destinado à segurança"
    ],
    "correctIndex": 0,
    "explanation": "Cláusula 4.3: definir fronteiras e aplicabilidade do SGSI considerando questões internas/externas (4.1), partes interessadas (4.2) e interfaces/dependências. Pode ser toda a organização ou um departamento/sistema específico.",
    "example": "Exemplo: 'SGSI cobre as operações do datacenter de SP e sistemas de e-commerce'. Escopo muito amplo = caro. Muito estreito = incompleto. Deve incluir interfaces com áreas fora do escopo."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Médio",
    "question": "O que é a ISO 27005 e para que serve?",
    "options": [
      "Norma com diretrizes para gestão de riscos de segurança da informação, complementando a ISO 27001",
      "Certificação de profissionais de segurança",
      "Norma de criptografia",
      "Guia de configuração de firewalls"
    ],
    "correctIndex": 0,
    "explanation": "ISO 27005 fornece diretrizes para o processo de gestão de riscos de SI exigido pela ISO 27001 (cláusula 6.1.2). Detalha: contexto, identificação, análise, avaliação, tratamento e aceitação de riscos. Não é certificável.",
    "example": "Família 27000: 27001 (requisitos), 27002 (controles), 27005 (riscos), 27017 (cloud), 27018 (PII cloud), 27701 (privacidade). ISO 27005 + ISO 31000 = framework completo de riscos de SI."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Médio",
    "question": "O que é a ISO 27701 e como se relaciona com a LGPD?",
    "options": [
      "Extensão da ISO 27001 para gestão de privacidade; ajuda a demonstrar conformidade com LGPD e GDPR",
      "Subsótui a ISO 27001 para dados pessoais",
      "Certificação obrigatória da ANPD",
      "Norma exclusiva para criptografia de dados pessoais"
    ],
    "correctIndex": 0,
    "explanation": "ISO 27701 é extensão da ISO 27001/27002 que adiciona requisitos para Sistema de Gestão de Privacidade da Informação (PIMS). Mapeia para LGPD e GDPR, facilitando demonstração de conformidade. Certificável como extensão.",
    "example": "ISO 27701: requer ISO 27001 como base. Adiciona controles para: controlador (PII controller) e operador (PII processor). Anexos mapeiam para GDPR (Anexo D) e ISO 29100 (princípios de privacidade)."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Médio",
    "question": "O que são não-conformidades em auditoria ISO 27001?",
    "options": [
      "Desvios entre o que está documentado/requerido e o que é praticado; podem ser maiores ou menores",
      "Erros de criptografia nos sistemas",
      "Falhas de hardware nos servidores",
      "Bugs encontrados no software"
    ],
    "correctIndex": 0,
    "explanation": "Não-conformidade maior: falha sistêmica que compromete o SGSI (impede certificação até correção). Menor: desvio pontual que não compromete o sistema como um todo (correção até próxima audit). Oportunidade de melhoria: sugestão, não obrigatória.",
    "example": "Maior: ausência de análise de riscos, política de segurança inexistente. Menor: um registro de treinamento faltando. Ação corretiva: causa raiz + ação + verificação de eficácia. ISO 19011: diretrizes de auditoria."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Médio",
    "question": "O que é a Declaração de Aplicabilidade (SoA) na ISO 27001 e como ela é construída?",
    "options": [
      "SoA: documento que lista todos os 93 controles do Anexo A, indicando se cada um é aplicável ou excluído, com justificativa; base para escopo do SGSI e auditorias externas",
      "SoA é o manual de políticas de segurança da empresa",
      "SoA lista somente os controles implementados; controles excluídos não precisam ser mencionados",
      "SoA é preenchida pelo auditor externo durante a certificação, não pela empresa"
    ],
    "correctIndex": 0,
    "explanation": "SoA (Statement of Applicability): requisito mandatório ISO 27001 (cláusula 6.1.3d). Construção: (1) Lista os 93 controles (Anexo A ISO 27001:2022, 4 temas: Organizacionais, Pessoais, Físicos, Tecnológicos). (2) Para cada controle: aplicável/não aplicável. (3) Status de implementação. (4) Referência ao documento/política que evidencia o controle. (5) Justificativa para exclusão. Baseada no risk treatment plan.",
    "example": "ISO 27001:2022 Anexo A: 93 controles em 4 temas (era 114 em 14 domínios na versão 2013). Novos controles 2022: inteligência de ameaças, segurança na nuvem, data masking, monitoramento de atividades físicas. Risk treatment options: mitigar, aceitar, transferir, evitar. SoA alimenta o plano de continuidade e o programa de auditorias internas."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Difícil",
    "question": "Na ISO 27001:2022, como são organizados os controles do Anexo A?",
    "options": [
      "4 categorias: organizacionais, pessoais, físicos e tecnológicos (93 controles)",
      "14 domínios com 114 controles",
      "10 capítulos com 50 controles",
      "7 categorias correspondendo ao modelo OSI"
    ],
    "correctIndex": 0,
    "explanation": "A versão 2022 reorganizou os controles do Anexo A em 4 categorias com 93 controles: Organizacionais (37), Pessoais (8), Físicos (14) e Tecnológicos (34). A versão anterior (2013) tinha 14 domínios com 114 controles. Foram adicionados 11 novos controles, como Threat Intelligence, Cloud Security e Data Masking.",
    "example": "Novos controles na 2022: Threat Intelligence, ICT Readiness for Business Continuity, Information Security for Cloud Services, Physical Security Monitoring, Data Masking, Data Leakage Prevention, Web Filtering, Secure Coding, Configuration Management, Information Deletion, Monitoring Activities."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Difícil",
    "question": "O que é a análise crítica pela direção (management review) na ISO 27001?",
    "options": [
      "Reunião periódica da alta direção para avaliar o desempenho do SGSI e tomar decisões",
      "Revisão técnica do código-fonte",
      "Auditoria externa anual",
      "Teste de recuperação de desastres"
    ],
    "correctIndex": 0,
    "explanation": "Cláusula 9.3: alta direção avalia resultados de auditorias, status de ações corretivas, mudanças, feedback e oportunidades de melhoria. Saídas: decisões sobre alterações no SGSI e alocação de recursos.",
    "example": "Entradas: auditorias, incidentes, indicadores, feedback, mudanças de contexto. Saídas: melhorias, recursos, alterações no SGSI. Obrigatória periodicamente (ao menos anual)."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Difícil",
    "question": "O que é o processo de avaliação de riscos na ISO 27001?",
    "options": [
      "Identificação, análise (probabilidade × impacto) e priorização de riscos de SI; cláusula 6.1.2",
      "Apenas instalar antivírus e firewall",
      "Teste de penetração externo trimestral",
      "Verificação de SLAs com fornecedores"
    ],
    "correctIndex": 0,
    "explanation": "Cláusula 6.1.2: estabelecer critérios de risco, identificar riscos de SI, analisar (probabilidade × impacto), avaliar/priorizar, selecionar controles (Anexo A) e documentar no SoA e plano de tratamento.",
    "example": "Ciclo: identificar ativos → ameaças/vulnerabilidades → probabilidade × impacto → comparar com critérios → tratar (evitar, mitigar, transferir, aceitar) → Risk Treatment Plan + SoA."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Difícil",
    "question": "O que é o processo de certificação ISO 27001 e quais são suas etapas?",
    "options": [
      "Auditoria Estágio 1 (documentação) + Estágio 2 (implementação); certificado válido por 3 anos com vigilâncias anuais",
      "Exame online de múltipla escolha",
      "Apenas implementar os controles e declarar conformidade",
      "Auditoria única sem renovação"
    ],
    "correctIndex": 0,
    "explanation": "Estágio 1: auditoria documental (políticas, SoA, análise de riscos existem?). Estágio 2: auditoria de implementação (controles funcionam na prática?). Certificação: 3 anos, vigilância anual, recertificação no 3º ano.",
    "example": "Cronograma típico: preparação (6-12 meses) → Estágio 1 → correções → Estágio 2 → certificado. Não-conformidades maiores: impedem certificação até correção. Menores: correção até próxima vigilância."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Difícil",
    "question": "Como a ISO 27001:2022 aborda segurança em nuvem (cloud)?",
    "options": [
      "Novo controle A.5.23 (Information Security for Cloud Services) exige avaliação de riscos específica para cloud",
      "Proíbe uso de serviços em nuvem",
      "Apenas recomenda criptografia de dados",
      "Não aborda segurança em nuvem"
    ],
    "correctIndex": 0,
    "explanation": "ISO 27001:2022 incluiu controle A.5.23 específico para cloud: definir políticas de aquisição, uso, gestão e saída de serviços cloud. Complementado pela ISO 27017 (controles de segurança para cloud) e ISO 27018 (PII em cloud).",
    "example": "A.5.23: responsabilidades compartilhadas (shared responsibility model), localização de dados, portabilidade, estratégia de exit. ISO 27017: 37 controles cloud + 7 novos. ISO 27018: proteção de dados pessoais em cloud."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Difícil",
    "question": "O que é a ISO 27017 e como complementa a ISO 27001 para cloud?",
    "options": [
      "Norma com controles específicos para segurança em serviços de nuvem, estendendo a ISO 27002",
      "Substitui a ISO 27001 para provedores de cloud",
      "Certificação obrigatória para usar AWS",
      "Protocolo de comunicação entre nuvens"
    ],
    "correctIndex": 0,
    "explanation": "ISO 27017 fornece controles adicionais para provedores e clientes de cloud, estendendo a ISO 27002. Aborda: responsabilidades compartilhadas, virtualização, multitenancy, isolação e remoção de dados.",
    "example": "37 controles adaptados da 27002 + 7 novos específicos para cloud. ISO 27018: proteção de PII em cloud pública. Certificável como extensão da 27001. AWS, Azure e GCP possuem certificação ISO 27017."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Difícil",
    "question": "O que é risk treatment plan na ISO 27001?",
    "options": [
      "Documento que detalha ações para tratar cada risco identificado, incluindo controles, responsáveis e prazos",
      "Lista de todos os riscos aceitáveis",
      "Relatório de auditoria de riscos",
      "Software de gestão de riscos"
    ],
    "correctIndex": 0,
    "explanation": "O plano de tratamento de riscos documenta: cada risco identificado, estratégia de tratamento (evitar, mitigar, transferir, aceitar), controles selecionados do Anexo A, responsável, prazo e recursos. É requisito da cláusula 6.1.3.",
    "example": "Fluxo: avaliação de riscos (6.1.2) → selecionar controles (Anexo A) → Risk Treatment Plan + SoA (6.1.3) → implementar → monitorar eficácia. O plano alimenta a SoA e é revisado periodicamente."
  },
  {
    "id": "seguranca-da-informacao__Normas ISO 27001/27002__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Normas ISO 27001/27002",
    "difficulty": "Difícil",
    "question": "Como conduzir uma análise de riscos conforme ISO 27005 integrada ao SGSI da ISO 27001?",
    "options": [
      "ISO 27005: identificar ativos → ameaças → vulnerabilidades → calcular probabilidade × impacto → risk register → tratamento (SoA) → monitoramento; integrado à ISO 27001 cláusula 6.1 (planejamento de riscos)",
      "ISO 27005 substitui completamente a ISO 27001; não há necessidade de ambas",
      "Análise de riscos ISO 27005 é realizada somente uma vez na implementação inicial",
      "ISO 27005 define apenas controles técnicos; análise de riscos é responsabilidade do auditor"
    ],
    "correctIndex": 0,
    "explanation": "ISO 27005:2022 (alinhada com ISO 31000). Processo: (1) Estabelecimento de contexto (escopo, critérios de risco, apetite). (2) Identificação: ativos, ameaças, vulnerabilidades, controles existentes. (3) Análise: probabilidade × impacto = nível de risco. (4) Avaliação: comparar com critérios de aceitação, priorizar. (5) Tratamento: selecionar controles (SoA). (6) Aceitação: sign-off da direção. (7) Monitoramento.",
    "example": "Escala de probabilidade/impacto: 1-5 qualitativa ou quantitativa (ALE). Risk appetite: nível de risco aceitável antes de tratamento. Residual risk: risco após controles; deve ser aceito pela direção. Ferramentas: planilha, Archer, ServiceNow GRC. Threat intelligence: MITRE ATT&CK como fonte de ameaças. Revisão anual obrigatória (ISO 27001 cláusula 9.3 management review)."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Fácil",
    "question": "O que é uma Política de Segurança da Informação (PSI)?",
    "options": [
      "Documento que define diretrizes, regras e responsabilidades de segurança da informação na organização",
      "Software de proteção contra vírus",
      "Hardware de criptografia de dados",
      "Certificação internacional de segurança"
    ],
    "correctIndex": 0,
    "explanation": "A PSI é o documento de mais alto nível que estabelece as diretrizes gerais de segurança da informação da organização: responsabilidades, classificação da informação, uso aceitável, controle de acesso, resposta a incidentes. Deve ser aprovada pela alta direção e comunicada a todos os colaboradores.",
    "example": "Hierarquia: Política (O QUÊ — diretrizes gerais) → Normas (COMO — regras específicas) → Procedimentos (PASSO A PASSO — instruções detalhadas) → Guidelines (recomendações). Exemplo: 'Senhas devem ter no mínimo 12 caracteres' é uma norma derivada da política."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Fácil",
    "question": "O que é uma política de senha e quais são boas práticas?",
    "options": [
      "Regras para criação e uso de senhas; boas práticas: mínimo 12 chars, complexidade e MFA",
      "Documento que lista todas as senhas",
      "Software que gera senhas",
      "Protocolo de criptografia de senhas"
    ],
    "correctIndex": 0,
    "explanation": "Política de senha define: comprimento mínimo (12+), complexidade, não reutilização e MFA obrigatório. NIST 800-63: senhas longas são mais importantes que complexidade forçada.",
    "example": "NIST 800-63: tamanho > complexidade. Não forçar rotações periódicas (senhas fracas). Password manager recomendado. MFA é essencial."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Fácil",
    "question": "O que é classificação da informação e por que é importante?",
    "options": [
      "Categorizar informações por sensibilidade para aplicar controles proporcionais",
      "Organizar arquivos em pastas",
      "Ordenar emails por data",
      "Criar índice de documentos"
    ],
    "correctIndex": 0,
    "explanation": "Classificação categoriza dados por nível: pública, interna, confidencial, secreta/restrita. Cada nível recebe controles proporcionais. Sem classificação, dados sensíveis podem ser tratados como públicos.",
    "example": "Pública (site), Interna (políticas), Confidencial (financeiro), Restrita (planos estratégicos). Controles: restrita = criptografia + acesso limitado + DLP. ISO 27001 Anexo A controle 5.12."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Fácil",
    "question": "O que é uma AUP (Acceptable Use Policy — Política de Uso Aceitável)?",
    "options": [
      "Política que define o uso aceitável dos recursos de TI pelos funcionários",
      "Tipo de licença de software",
      "Contrato de garantia de equipamentos",
      "Política de preços de produtos"
    ],
    "correctIndex": 0,
    "explanation": "AUP define o que é permitido e proibido no uso de computadores, e-mail, internet e dispositivos da empresa. Inclui: proibição de software pirata, uso pessoal limitado, proteção de dados. Funcionário assina ao ser contratado.",
    "example": "Exemplos: não instalar software pirata, não acessar conteúdo impróprio, não compartilhar senhas, reportar incidentes. Violação pode resultar em sanções disciplinares. Base legal para ações da empresa."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Fácil",
    "question": "O que é conscientização em segurança da informação (security awareness)?",
    "options": [
      "Treinamentos e campanhas para que todos conheçam os riscos e regras de segurança",
      "Instalação de antivírus em todos os computadores",
      "Auditoria externa anual",
      "Contratação de equipe de segurança"
    ],
    "correctIndex": 0,
    "explanation": "Security awareness educa funcionários sobre phishing, senhas, engenharia social, classificação de dados e políticas. Pessoas são o elo mais fraco: 90% dos ataques começam com phishing. Treinamento periódico é requisito da ISO 27001.",
    "example": "Métodos: simulação de phishing, treinamentos online, gamificação, cartazes, newsletters. ISO 27001 cláusula 7.3: conscientização obrigatória. Ferramentas: KnowBe4, GoPhish. Meta: reduzir taxa de clique em phishing."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Fácil",
    "question": "O que é um plano de resposta a incidentes?",
    "options": [
      "Documento que define passos a seguir quando ocorre um incidente de segurança da informação",
      "Relatório gerado após um ataque",
      "Software de monitoramento de rede",
      "Contrato com empresa de seguros"
    ],
    "correctIndex": 0,
    "explanation": "O plano de resposta a incidentes define: o que constitui um incidente, quem são os responsáveis, como classificar severidade, procedimentos de contenção, comunicação interna/externa e lições aprendidas.",
    "example": "Fases: preparação → detecção → contenção → erradicação → recuperação → lições aprendidas. Sem plano: pânico, decisões erradas, tempo perdido. ISO 27035 e NIST SP 800-61 são referências."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Fácil",
    "question": "O que é backup e por que é importante para segurança?",
    "options": [
      "Cópia de segurança dos dados que permite recuperação em caso de perda, ataque ou falha",
      "Software antivírus para servidores",
      "Tipo de firewall para banco de dados",
      "Processo de criptografia de disco"
    ],
    "correctIndex": 0,
    "explanation": "Backup é a última linha de defesa contra ransomware, falhas de hardware e erros humanos. Regra 3-2-1: 3 cópias, em 2 mídias diferentes, 1 offsite. Testar restauração periodicamente é tão importante quanto fazer backup.",
    "example": "Tipos: completo (tudo), incremental (só alterações desde último backup), diferencial (alterações desde último completo). RPO define frequência. Air-gapped backup: desconectado da rede (proteção contra ransomware)."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Fácil",
    "question": "O que é uma Política de Segurança da Informação (PSI) e quais elementos deve conter?",
    "options": [
      "PSI: documento de alto nível que define objetivos, responsabilidades e diretrizes de segurança da informação; elementos: escopo, objetivos, definições, responsabilidades, sanções, referências a normas",
      "PSI é um documento técnico de configuração de firewall e sistemas",
      "PSI é elaborada somente pelo time de TI; não envolve a diretoria",
      "PSI define somente regras de uso de internet e e-mail corporativo"
    ],
    "correctIndex": 0,
    "explanation": "PSI: nível estratégico (política) → normas (nível tático) → procedimentos (operacional). Baseada em ISO 27001 (requisito da cláusula 5.2). Elementos: objetivos de segurança, escopo (ativos, pessoas, locais), princípios (CIA: confidencialidade, integridade, disponibilidade), papéis e responsabilidades, penalidades/sanções, revisão periódica (anual), aprovação da Alta Direção.",
    "example": "Hierarquia documental: PSI → Normas específicas (uso aceitável, classificação da informação, senhas, dispositivos móveis) → Procedimentos (backup, resposta a incidentes) → Instruções de trabalho. Comunicação: todos os colaboradores devem conhecer a PSI (treinamento anual, assinatura de ciência). SANS Policy Templates: modelos gratuitos."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Médio",
    "question": "O que deve conter uma política de resposta a incidentes?",
    "options": [
      "Definição de incidente, equipe responsável, procedimentos de detecção, contenção, erradicação e recuperação",
      "Lista de todos os vírus conhecidos",
      "Apenas telefones de emergência",
      "Somente procedimentos de backup"
    ],
    "correctIndex": 0,
    "explanation": "Uma política de resposta a incidentes define: classificação de incidentes, papéis e responsabilidades (CSIRT), procedimentos de detecção e notificação, fases de resposta (preparação, detecção, contenção, erradicação, recuperação, lições aprendidas), comunicação interna/externa e requisitos legais de notificação.",
    "example": "Fases NIST (SP 800-61): 1) Preparation. 2) Detection & Analysis. 3) Containment, Eradication & Recovery. 4) Post-Incident Activity (lessons learned). A política deve ser testada periodicamente com exercícios de simulação (tabletop exercises)."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Médio",
    "question": "Qual a diferença entre política, norma e procedimento em segurança?",
    "options": [
      "Política: diretrizes gerais. Norma: regras específicas. Procedimento: instruções passo a passo",
      "São termos sinônimos",
      "Política é técnica, norma é gerencial",
      "Procedimento é mais importante que política"
    ],
    "correctIndex": 0,
    "explanation": "Política (estratégico, 'o quê'): 'proteger dados sensíveis'. Norma (tático, 'como'): 'senhas mínimo 12 chars'. Procedimento (operacional): 'como trocar a senha no AD'. Guidelines são recomendações opcionais.",
    "example": "Política: aprovada pela direção, abrangente. Norma: obrigatória, específica. Procedimento: detalhado, técnico. Exemplo: política diz 'controlar acesso', norma diz 'usar MFA', procedimento diz 'como configurar MFA'."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Médio",
    "question": "O que é um BCP (Business Continuity Plan) e como se relaciona com DRP?",
    "options": [
      "BCP garante operação durante crises; DRP foca na recuperação da TI após desastre",
      "São sinônimos",
      "BCP é para pequenas empresas e DRP para grandes",
      "DRP substitui o BCP"
    ],
    "correctIndex": 0,
    "explanation": "BCP (Business Continuity): plano abrangente para manter operações críticas. DRP (Disaster Recovery): subconjunto focado em recuperar infraestrutura de TI. BCP é mais amplo (pessoas, processos). DRP é mais técnico.",
    "example": "BCP: comunicação de crise, trabalho remoto, local alternativo. DRP: backup/restore, site de contingência (hot/warm/cold), failover. RTO e RPO definidos pela BIA guiam o DRP."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Médio",
    "question": "O que é um CSIRT (Computer Security Incident Response Team)?",
    "options": [
      "Equipe responsável por coordenar a resposta a incidentes de segurança da informação",
      "Software de detecção de intrusão",
      "Certificação de profissionais de segurança",
      "Tipo de firewall corporativo"
    ],
    "correctIndex": 0,
    "explanation": "CSIRT/CERT é a equipe que recebe, analisa e responde a incidentes de segurança. Funções: triagem, análise forense, contenção, coordenação com áreas afetadas e comunicação. Pode ser interno ou externo.",
    "example": "CERT.br (Brasil), US-CERT (EUA), FIRST (comunidade global). Atividades: monitoramento, resposta, forense, inteligência de ameaças. Níveis: L1 (triagem), L2 (análise), L3 (forense/malware). SOC opera 24/7, CSIRT responde."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Médio",
    "question": "O que são exercícios tabletop em segurança da informação?",
    "options": [
      "Simulações de cenários de incidentes onde a equipe debate decisões sem ações reais",
      "Jogos de tabuleiro sobre segurança",
      "Reuniões de planejamento de orçamento",
      "Testes de penetração em sistemas"
    ],
    "correctIndex": 0,
    "explanation": "Tabletop exercise: simulação baseada em discussão de um cenário de incidente (ex: ransomware). A equipe debate: quem faz o quê, como comunicar, que decisões tomar. Identifica falhas no plano sem risco real.",
    "example": "Níveis: tabletop (discussão) < functional exercise (simulação parcial) < full-scale exercise (simulação completa). NIST SP 800-84: guia para testes de planos. Frequência recomendada: ao menos anual."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Médio",
    "question": "O que é gestão de patches (patch management)?",
    "options": [
      "Processo de identificar, testar e aplicar atualizações de segurança em sistemas e software",
      "Técnica de criptografia de atualizações",
      "Software de monitoramento de vulneráveis",
      "Política de troca de hardware"
    ],
    "correctIndex": 0,
    "explanation": "Patch management: identificar patches disponíveis → avaliar criticidade (CVSS) → testar em ambiente de homologação → aplicar em produção → verificar. Patches críticos devem ser aplicados rapidamente (ex: 48h).",
    "example": "Sem patching: WannaCry explorou MS17-010 (patch disponível 2 meses antes). Ferramentas: WSUS, SCCM (Microsoft), Ansible, Chef. Vulnerabilidades críticas (CVSS 9+): patch urgente. Média: ciclo regular (mensal)."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Médio",
    "question": "O que é segregação de ambientes em TI?",
    "options": [
      "Separar ambientes de desenvolvimento, teste e produção para evitar impactos de mudanças não testadas",
      "Dividir funcionários por andares diferentes",
      "Separar redes Wi-Fi por SSID",
      "Usar servidores de marcas diferentes"
    ],
    "correctIndex": 0,
    "explanation": "Segregação de ambientes (dev → staging → produção): código é desenvolvido em dev, testado em staging e só vai para produção após validação. Evita que erros afetem usuários reais. Dados de produção não devem estar em dev.",
    "example": "Princípios: dados de produção mascarados em dev/staging, acessos separados por ambiente, pipeline CI/CD controla promoção entre ambientes. ISO 27001 A.8.31: separação de ambientes."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Médio",
    "question": "Como implementar um programa de conscientização e treinamento em segurança da informação eficaz?",
    "options": [
      "Segmentar público por perfil de risco, usar conteúdo relevante ao cargo, aplicar simulações de phishing, medir métricas (click rate, reporting rate), revisar conteúdo anualmente e após incidentes",
      "Treinamento anual de 1 hora é suficiente; não é necessário segmentar por público",
      "Simulações de phishing são antiéticas e não devem ser usadas em programas corporativos",
      "Conscientização é responsabilidade exclusiva do RH; equipe de segurança não participa"
    ],
    "correctIndex": 0,
    "explanation": "Programa eficaz (NIST SP 800-50): identificar público-alvo e riscos específicos (executivo: CFO/whaling; dev: code injection; recepcionista: tailgating/vishing). Cobertura: phishing, senhas, uso aceitável, engenharia social, classificação da informação, LGPD. Formatos: e-learning, vídeos curtos (microlearning), posters, newsletters. Métricas: phishing click rate, completion rate.",
    "example": "Plataformas: KnowBe4, Proofpoint Security Awareness, Hoxhunt. Simulação phishing: campanha mensal com templates graduais (easy→hard). Spear phishing simulado: executivos. SANS MGT433: programa de treinamento de segurança. ROI awareness: correlação entre treinamento e redução de phishing bem-sucedido. Gamificação: pontos, rankings, badges."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Difícil",
    "question": "Qual norma do NIST fornece diretrizes para desenvolvimento de políticas de segurança e qual é seu principal framework?",
    "options": [
      "NIST CSF (Cybersecurity Framework) com funções: Identify, Protect, Detect, Respond, Recover",
      "NIST SP 800-53 com categorias: Plan, Do, Check, Act",
      "ISO 9001 com foco em qualidade de segurança",
      "NIST 800-12 com foco exclusivo em criptografia"
    ],
    "correctIndex": 0,
    "explanation": "O NIST CSF (Cybersecurity Framework) organiza segurança em 5 funções: Identify (inventário, riscos), Protect (controles preventivos), Detect (monitoramento), Respond (resposta a incidentes), Recover (recuperação). O NIST SP 800-53 complementa com catálogo detalhado de controles. CSF 2.0 (2024) adicionou 'Govern' como 6ª função.",
    "example": "CSF v1.1: Identify, Protect, Detect, Respond, Recover. CSF v2.0 (2024): + Govern (governança). SP 800-53: catálogo de controles detalhados. SP 800-171: proteção de CUI. O CSF mapeia para ISO 27001, CIS Controls e outros frameworks."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Difícil",
    "question": "O que são os CIS Controls e como complementam a ISO 27001?",
    "options": [
      "Lista priorizada de ações de segurança do CIS; complementam ISO 27001 com implementação prática",
      "Controles exclusivos para indústria financeira",
      "Substituição da ISO 27001 nos EUA",
      "Framework de gestão de projetos"
    ],
    "correctIndex": 0,
    "explanation": "CIS Controls são 18 controles priorizados em Implementation Groups (IG1, IG2, IG3) por maturidade. Mais prescritivos e técnicos que a ISO 27001, facilitando implementação prática.",
    "example": "IG1 (essencial): inventário, controle de software, configuração segura, acesso, proteção de dados. IG2: logging, proteção email/web. IG3: pentest avançado. CIS Benchmarks: configurações seguras para SO, servidores."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Difícil",
    "question": "O que é 'security by design' e como se aplica no desenvolvimento?",
    "options": [
      "Integrar segurança desde o início do design de sistemas, não como adição posterior",
      "Instalar firewall após incidente",
      "Design gráfico de dashboards de segurança",
      "Criar senhas visualmente complexas"
    ],
    "correctIndex": 0,
    "explanation": "Security by design: segurança como requisito desde a concepção, não adição posterior. SDLC seguro: threat modeling, code review, SAST/DAST. OWASP Top 10 2021: #4 é Insecure Design.",
    "example": "DevSecOps: segurança integrada ao CI/CD. Privacy by design (LGPD/GDPR). NIST CSF v2.0: função 'Govern' enfatiza segurança integrada à governança desde o início."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Difícil",
    "question": "O que é o modelo Zero Trust e seus princípios fundamentais?",
    "options": [
      "Nenhuma entidade é confiável por padrão; verificar explicitamente, menor privilégio, assumir violação",
      "Confiar em todos os dispositivos da rede interna",
      "Modelo de confiança baseado apenas em firewalls",
      "Framework de auditoria para nuvem"
    ],
    "correctIndex": 0,
    "explanation": "Zero Trust: 'never trust, always verify'. Princípios: verificar explicitamente (identidade, dispositivo, localização), menor privilégio (JIT/JEA), assumir breach (segmentação, monitoramento). Perímetro não é mais suficiente.",
    "example": "NIST SP 800-207: arquitetura Zero Trust. Pilares: identidade, dispositivos, rede, aplicações, dados. Implementação: MFA, microsegmentação, ZTNA (Zero Trust Network Access), EDR, SASE. Google BeyondCorp: referência."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Difícil",
    "question": "O que é o MITRE ATT&CK e como é usado na prática?",
    "options": [
      "Framework de táticas e técnicas de adversários usado para threat hunting, detecção e avaliação",
      "Software de detecção de malware",
      "Certificação de segurança ofensiva",
      "Protocolo de comunicação segura"
    ],
    "correctIndex": 0,
    "explanation": "MITRE ATT&CK cataloga táticas (objetivos: Initial Access, Execution, Persistence...) e técnicas (como: Phishing, PowerShell, Registry Run Keys). Usado para mapear detecções, avaliar cobertura e threat hunting.",
    "example": "14 táticas: Recon → Resource Dev → Initial Access → Execution → Persistence → Priv Esc → Defense Evasion → Credential Access → Discovery → Lateral Move → Collection → C2 → Exfiltration → Impact."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Difícil",
    "question": "O que é threat intelligence e como se aplica na defesa?",
    "options": [
      "Informações sobre ameaças (TTPs, IoCs) usadas para antecipar e detectar ataques",
      "Software de inteligência artificial para segurança",
      "Relatório anual de vulnerabilidades",
      "Treinamento de funcionários sobre riscos"
    ],
    "correctIndex": 0,
    "explanation": "Threat intelligence coleta, analisa e compartilha informações sobre ameaças: TTPs (táticas, técnicas, procedimentos), IoCs (indicadores de comprometimento: IPs, hashes, domínios). Alimenta SIEM, SOC e decisões estratégicas.",
    "example": "Níveis: estratégico (tendências para C-level), tático (TTPs para SOC), operacional (IoCs para SIEM/firewall). Fontes: MITRE ATT&CK, VirusTotal, OTX, OSINT. STIX/TAXII: padrões de compartilhamento."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Difícil",
    "question": "O que é purple teaming em segurança?",
    "options": [
      "Colaboração entre red team (ataque) e blue team (defesa) para melhorar detecção e resposta",
      "Equipe exclusiva de forense digital",
      "Time de desenvolvimento seguro",
      "Grupo de compliance e auditoria"
    ],
    "correctIndex": 0,
    "explanation": "Purple team: red team ataca e compartilha TTPs em tempo real com blue team, que ajusta detecções e respostas. Ciclo: atacar → detectou? → não → criar regra → atacar novamente → detectou? → sim → próxima técnica.",
    "example": "Red team: simula atacante (pentest, social engineering). Blue team: defende (SOC, SIEM, EDR). Purple team: colaboração. Resultado: cobertura de detecção mapeada no MITRE ATT&CK. Ferramentas: Atomic Red Team, Caldera."
  },
  {
    "id": "seguranca-da-informacao__Políticas de Segurança__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Políticas de Segurança",
    "difficulty": "Difícil",
    "question": "Como estruturar um programa de Vulnerability Management (VM) do ciclo de descoberta ao fechamento?",
    "options": [
      "Descoberta (scan ativos) → priorização (CVSS + EPSS + contexto de negócio) → remediation SLAs por criticidade → validação (rescan) → KPIs (MTTR, vuln density) → revisão contínua",
      "Vulnerability Management se limita a rodar o Nessus mensalmente e exportar o relatório",
      "Vulnerabilidades críticas devem ser corrigidas somente no próximo ciclo de manutenção mensal",
      "CVSS score 10 é suficiente para priorizar; contexto de negócio não é relevante"
    ],
    "correctIndex": 0,
    "explanation": "VM lifecycle: (1) Asset inventory (CMDB). (2) Scanning: credenciado (mais profundo) e não-credenciado. (3) Priorização: CVSS é ponto de partida; EPSS (Exploit Prediction Scoring System): probabilidade de exploração; contexto: exposição (internet-facing?), criticidade do ativo, existência de exploit público. (4) Remediation. (5) SLAs: Critical=7d, High=30d, Medium=90d. (6) Validation: rescan.",
    "example": "Ferramentas: Tenable Nessus/SC, Qualys, Rapid7 InsightVM, OpenVAS. EPSS (FIRST.org): modelo ML para priorização. CISA KEV (Known Exploited Vulnerabilities): lista de vulns exploradas in-the-wild; prioridade máxima. KPIs: MTTR (Mean Time to Remediate), vuln density por ativo, aging (tempo médio em aberto). Risk-based VM: priorizar pelo risco real, não somente CVSS."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Fácil__1",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Fácil",
    "question": "O que é o OWASP Top 10?",
    "options": [
      "Lista das 10 vulnerabilidades mais críticas em aplicações web",
      "Os 10 melhores antivírus do mercado",
      "Os 10 navegadores web mais seguros",
      "Lista dos 10 firewalls mais vendidos"
    ],
    "correctIndex": 0,
    "explanation": "O OWASP Top 10 é um documento de conscientização publicado pela OWASP (Open Web Application Security Project) que lista as 10 vulnerabilidades mais críticas em aplicações web. É atualizado periodicamente e serve como referência para desenvolvedores e profissionais de segurança.",
    "example": "OWASP Top 10 (2021): 1) Broken Access Control. 2) Cryptographic Failures. 3) Injection. 4) Insecure Design. 5) Security Misconfiguration. 6) Vulnerable Components. 7) Auth Failures. 8) Data Integrity Failures. 9) Logging Failures. 10) SSRF."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Fácil__2",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Fácil",
    "question": "O que é XSS (Cross-Site Scripting)?",
    "options": [
      "Injeção de scripts maliciosos em páginas web visualizadas por outros usuários",
      "Técnica de criptografia entre sites",
      "Protocolo de comunicação segura",
      "Método de autenticação cross-site"
    ],
    "correctIndex": 0,
    "explanation": "XSS injeta JavaScript em páginas web. O script executa no navegador da vítima, podendo roubar cookies, sessões ou redirecionar. Prevenção: sanitizar outputs, Content Security Policy (CSP), HttpOnly cookies.",
    "example": "Tipos: Reflected (parâmetro na URL), Stored (salvo no banco), DOM-based (manipulação do DOM). Prevenção: escape de HTML, CSP headers, HttpOnly cookies."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Fácil__3",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Fácil",
    "question": "O que é um WAF (Web Application Firewall)?",
    "options": [
      "Firewall especializado que protege aplicações web filtrando tráfego HTTP/HTTPS",
      "Firewall para redes locais",
      "Antivírus para servidores web",
      "Software de backup para websites"
    ],
    "correctIndex": 0,
    "explanation": "WAF protege contra SQL injection, XSS, SSRF e DDoS L7. Opera na camada de aplicação analisando requisições HTTP/HTTPS. Pode ser hardware, software ou cloud (Cloudflare, AWS WAF).",
    "example": "Firewall de rede: L3/L4 (IP/porta). WAF: L7 (conteúdo HTTP). Modos: block ou detect. OWASP CRS (Core Rule Set). Cloud WAFs: Cloudflare, AWS WAF, Azure Front Door."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Fácil__4",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Fácil",
    "question": "O que é HTTPS e por que é importante para segurança?",
    "options": [
      "Versão segura do HTTP usando TLS para criptografar comunicação entre navegador e servidor",
      "Protocolo exclusivo para e-commerce",
      "Tipo de antivírus online",
      "Software de firewall para navegadores"
    ],
    "correctIndex": 0,
    "explanation": "HTTPS = HTTP + TLS. Criptografa dados em trânsito impedindo interceptação (MitM). O cadeado no navegador indica conexaço TLS válida. Google penaliza sites HTTP no ranking de busca.",
    "example": "TLS 1.3: padrão atual (mais rápido, mais seguro). Certificado: Let's Encrypt (gratuito), DigiCert (pago). HSTS: força HTTPS. Mixed content: página HTTPS com recursos HTTP → aviso de segurança."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Fácil__5",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Fácil",
    "question": "O que é sanitização de entrada (input validation) em aplicações web?",
    "options": [
      "Processo de limpar e validar dados enviados pelo usuário antes de processá-los",
      "Limpeza física dos teclados",
      "Formatação visual dos formulários",
      "Compressão de dados antes de enviar"
    ],
    "correctIndex": 0,
    "explanation": "Input validation verifica e limpa dados do usuário: tipo (número, texto), formato (email, CPF), tamanho, caracteres especiais. Previne SQLi, XSS e outras injeções. Regra: NUNCA confiar no input do usuário.",
    "example": "Whitelist (aceitar só o esperado) > Blacklist (bloquear o malicioso). Server-side obrigatório (client-side é bypassável). Encoding de saída: HTML encode, URL encode. Frameworks modernos: validação automática (Zod, Joi)."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Fácil__6",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Fácil",
    "question": "O que é uma vulnerabilidade de autenticação fraca em aplicações web?",
    "options": [
      "Falha que permite acesso não autorizado por senhas fracas, falta de MFA ou gestão inadequada de sessões",
      "Bug visual na página de login",
      "Lentidão no carregamento do formulário",
      "Erro de layout no navegador"
    ],
    "correctIndex": 0,
    "explanation": "Autenticação fraca inclui: senhas fracas sem política, ausência de MFA, sessões que não expiram, tokens previsíveis, credential stuffing sem proteção. OWASP 2021 #7: Identification and Authentication Failures.",
    "example": "Ataques: brute force, credential stuffing (senhas vazadas), session fixation. Defesa: MFA, rate limiting, bcrypt/Argon2, sessões com expiração curta, CAPTCHA após falhas."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Fácil__7",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Fácil",
    "question": "O que é clickjacking?",
    "options": [
      "Ataque que usa iframes transparentes para enganar o usuário a clicar em elementos ocultos de outro site",
      "Técnica de otimização de cliques em anúncios",
      "Software de automação de cliques",
      "Método de teste de usabilidade"
    ],
    "correctIndex": 0,
    "explanation": "Clickjacking (UI redressing): atacante coloca iframe transparente do site alvo sobre sua página. Usuário pensa que clica em algo inofensivo, mas clica no site alvo (curtir, transferir, autorizar). Prevenção: X-Frame-Options, CSP frame-ancestors.",
    "example": "X-Frame-Options: DENY (bloqueia iframe) ou SAMEORIGIN. CSP: frame-ancestors 'none'. Likejacking: variante no Facebook. Defesa moderna: CSP frame-ancestors 'self' é preferível a X-Frame-Options."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Fácil__8",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Fácil",
    "question": "O que é SQL Injection e como preveni-lo?",
    "options": [
      "SQL Injection: inserção de código SQL via parâmetros da aplicação para manipular queries; prevenção: prepared statements/parameterized queries, stored procedures, validação de entrada, WAF",
      "SQL Injection é possível somente em banco de dados MySQL; outros bancos são imunes",
      "Codificar a entrada em Base64 previne completamente o SQL Injection",
      "Apenas WAF é suficiente para prevenir SQL Injection; código não precisa ser modificado"
    ],
    "correctIndex": 0,
    "explanation": "SQLi: atacante insere ' OR '1'='1 em campo de login → query retorna todos os usuários. Tipos: in-band (erro, union), blind (boolean, time-based), out-of-band. Impactos: extração de dados, bypass de autenticação, execução de comandos (xp_cmdshell no SQL Server). Prevenção primária: prepared statements (JDBC PreparedStatement, PDO PHP). Menor privilégio: conta de banco sem DROP/GRANT.",
    "example": "Exemplo PHP inseguro: 'SELECT * FROM users WHERE user=\\\"'.$_GET['user'].'\\\"'. Seguro: PreparedStatement. sqlmap: ferramenta de exploração automática. OWASP A03:2021. WAF: segunda linha de defesa (não substitui código seguro). Blind SQLi: inferência booleana ('... AND 1=1' vs '... AND 1=2') ou timing ('... AND sleep(5)'). Error-based: message expõe estrutura do BD."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Médio__1",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Médio",
    "question": "O que é SQL Injection e como preveni-la?",
    "options": [
      "Injeção de código SQL malicioso via inputs; previne-se com prepared statements/parameterized queries",
      "Um tipo de criptografia para bancos de dados",
      "Técnica de otimização de queries SQL",
      "Backup automático de banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "SQL Injection ocorre quando inputs do usuário são inseridos diretamente em queries SQL sem sanitização, permitindo ao atacante executar comandos SQL arbitrários. Prevenção: prepared statements (parameterized queries), ORMs, validação/sanitização de inputs, princípio do menor privilégio no banco de dados.",
    "example": "Vulnerável: `SELECT * FROM users WHERE name = '\" + input + \"'`. Input: `' OR '1'='1` → retorna todos os usuários. Seguro: `SELECT * FROM users WHERE name = ?` com parâmetro vinculado. ORMs modernos (Prisma, Sequelize) usam parameterized queries por padrão."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Médio__2",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Médio",
    "question": "O que é CSRF (Cross-Site Request Forgery) e como prevenir?",
    "options": [
      "Ataque que força o navegador a enviar requisição para site onde a vítima está autenticada; prevenção: tokens CSRF",
      "Falsificação de certificados SSL",
      "Técnica de criptografia entre sites",
      "Método de autenticação forte"
    ],
    "correctIndex": 0,
    "explanation": "CSRF: atacante engana vítima (já autenticada) a executar ação involuntária no site alvo. Prevenção: tokens CSRF (valor único por formulário), SameSite cookies, verificar Origin/Referer header.",
    "example": "Exemplo: <img src='banco.com/transferir?para=atacante&valor=1000'> → navegador envia com cookies de sessão. CSRF token: campo hidden verificado pelo servidor. SameSite=Strict impede o envio de cookies cross-site."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Médio__3",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Médio",
    "question": "O que é Content Security Policy (CSP) e como protege contra XSS?",
    "options": [
      "Header HTTP que define quais fontes de conteúdo o navegador pode executar",
      "Política de criptografia de conteúdo",
      "Tipo de firewall para CDN",
      "Protocolo de cache de navegador"
    ],
    "correctIndex": 0,
    "explanation": "CSP é um header HTTP que instrui o navegador sobre quais fontes de scripts, estilos e imagens são permitidas. Bloqueia scripts inline e fontes não autorizadas, sendo defesa eficaz contra XSS.",
    "example": "Exemplo: Content-Security-Policy: script-src 'self' https://cdn.ex.com. Bloqueia: <script>alert('XSS')</script>. Report-only mode: monitorar sem bloquear. CSP + HttpOnly = proteção robusta."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Médio__4",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Médio",
    "question": "O que é SAST e DAST e qual a diferença?",
    "options": [
      "SAST analisa código-fonte (white box); DAST testa aplicação em execução (black box)",
      "São dois tipos de firewall",
      "São protocolos de criptografia",
      "São certificações de segurança"
    ],
    "correctIndex": 0,
    "explanation": "SAST (Static): analisa código-fonte sem executar; detecta vulnerabilidades cedo no desenvolvimento. DAST (Dynamic): testa aplicação rodando, simulando ataques reais. IAST combina ambos.",
    "example": "SAST: SonarQube, Semgrep, Checkmarx. DAST: OWASP ZAP, Burp Suite. SCA (Software Composition Analysis): Snyk, Dependabot. Pipeline DevSecOps ideal: SAST + SCA no código + DAST no staging."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Médio__5",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Médio",
    "question": "Quais são os principais cabeçalhos de segurança HTTP?",
    "options": [
      "CSP, HSTS, X-Frame-Options, X-Content-Type-Options e Referrer-Policy",
      "Accept, Content-Type e Authorization apenas",
      "Cache-Control e ETag",
      "User-Agent e Cookie"
    ],
    "correctIndex": 0,
    "explanation": "Headers de segurança: CSP (fontes permitidas), HSTS (força HTTPS), X-Frame-Options (anti-clickjacking), X-Content-Type-Options (nosniff), Referrer-Policy (controla referência), Permissions-Policy (APIs do navegador).",
    "example": "HSTS: Strict-Transport-Security: max-age=31536000; includeSubDomains; preload. X-Frame-Options: DENY (bloqueia iframe = anti-clickjacking). securityheaders.com: verifica headers de qualquer site."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Médio__6",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Médio",
    "question": "O que é JWT (JSON Web Token) e quais riscos de segurança envolve?",
    "options": [
      "Token para autenticação/autorização em formato JSON; riscos incluem algoritmo 'none' e segredos fracos",
      "Tipo de criptografia para bancos de dados",
      "Protocolo de comunicação entre servidores",
      "Formato de backup de dados"
    ],
    "correctIndex": 0,
    "explanation": "JWT (header.payload.signature) é usado para autenticação stateless. Riscos: algoritmo 'none' (bypass de verificação), segredos fracos (força bruta), falta de expiração, armazenamento inseguro (localStorage → XSS).",
    "example": "Ataques: alg:none, key confusion (RS256→HS256), JWK injection, token sem exp. Defesa: validar alg no servidor, segredo forte (256+ bits), exp curto + refresh token, armazenar em httpOnly cookie."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Médio__7",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Médio",
    "question": "O que é CORS (Cross-Origin Resource Sharing) e como afeta a segurança?",
    "options": [
      "Mecanismo que controla quais domínios podem acessar APIs; configuração incorreta pode expor dados",
      "Protocolo de criptografia entre servidores",
      "Tipo de firewall para APIs",
      "Método de compressão de requisições"
    ],
    "correctIndex": 0,
    "explanation": "CORS controla quais origens podem fazer requisições cross-origin. Headers: Access-Control-Allow-Origin, Allow-Methods, Allow-Headers. Configuração errônea (`*` com credentials) expoe APIs a ataques cross-site.",
    "example": "Erro comum: Access-Control-Allow-Origin: * com Allow-Credentials: true (navegador bloqueia). Risco: refletir Origin sem validação. Seguro: whitelist explícita de origens. Preflight: OPTIONS verifica permissões antes."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Médio__8",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Médio",
    "question": "O que é SSRF (Server-Side Request Forgery) e como está relacionado a ambientes cloud?",
    "options": [
      "SSRF: servidor faz requisição a URL controlada pelo atacante; em cloud, acessa metadata endpoint (169.254.169.254) obtendo credenciais IAM; prevenção: whitelist de URLs, bloquear metadata endpoint",
      "SSRF é exclusivo de aplicações mobile; não afeta servidores backend",
      "SSRF permite somente leitura de arquivos locais do servidor",
      "Metadata endpoint cloud (169.254.169.254) não contém dados sensíveis"
    ],
    "correctIndex": 0,
    "explanation": "SSRF (OWASP A10:2021): aplicação aceita URL do usuário e faz request do servidor. Exemplos: download de imagem externa, webhook, PDF generator. Impactos: acesso a serviços internos (localhost:8080), metadata cloud (AWS: 169.254.169.254/latest/meta-data/iam/security-credentials/), port scan interno. Capital One breach (2019): SSRF + privilégio excessivo no IAM Role.",
    "example": "AWS IMDSv2: requer PUT com X-aws-ec2-metadata-token header (mitiga SSRF simples). Azure IMDS: 169.254.169.254 com Metadata:true header. Prevenção: whitelist (esquema+domínio+porta), bloquear 169.254.0.0/16, 10.0.0.0/8, 192.168.0.0/16. DNS rebinding: bypass de whitelist via DNS. Burp Collaborator: detecta SSRF blind."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Difícil__1",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Difícil",
    "question": "O que é um ataque SSRF (Server-Side Request Forgery) e por que é particularmente perigoso em ambientes cloud?",
    "options": [
      "O atacante faz o servidor realizar requisições para recursos internos, podendo acessar metadados de cloud e credenciais",
      "Falsificação de certificados SSL do servidor",
      "Envio de spam pelo servidor da vítima",
      "Sobrecarga do servidor com requisições falsas"
    ],
    "correctIndex": 0,
    "explanation": "SSRF explora funcionalidades do servidor que fazem requisições HTTP para URLs fornecidas pelo usuário. O atacante direciona essas requisições para recursos internos (localhost, rede interna, metadata services). Em cloud, o ataque ao endpoint de metadados (169.254.169.254) pode expor credenciais IAM, tokens de acesso e configurações sensíveis.",
    "example": "Exemplo AWS: input = `http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name` → retorna Access Key, Secret Key e Token. Proteção: whitelist de URLs, bloqueio de IPs internos, IMDSv2 (requer token), WAF com regras SSRF."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Difícil__2",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Difícil",
    "question": "O que é IDOR (Insecure Direct Object Reference) e como prevenir?",
    "options": [
      "Acesso direto a objetos sem verificação de autorização; prevenção: verificar permissão a cada acesso",
      "Referência indireta a objetos internos",
      "Tipo de injeção em bancos de dados",
      "Falha de criptografia em URLs"
    ],
    "correctIndex": 0,
    "explanation": "IDOR: atacante manipula IDs em URLs para acessar dados de outros usuários. Exemplo: mudar /api/users/123 para /api/users/456. Prevenção: sempre verificar autorização do usuário logado antes de retornar dados.",
    "example": "GET /invoices/1001 → minha fatura. /invoices/1002 → fatura de outro! Prevenção: verificar owner_id == user_id. UUIDs dificultam mas não substituem verificação de autorização."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Difícil__3",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Difícil",
    "question": "O que é DevSecOps e como integra segurança no desenvolvimento?",
    "options": [
      "Integrar segurança em todo o pipeline CI/CD, desde o código até produção",
      "Equipe de segurança separada que audita após deploy",
      "Framework de gestão ágil",
      "Ferramenta de deploy automatizado"
    ],
    "correctIndex": 0,
    "explanation": "DevSecOps integra segurança em todo o pipeline: planejamento (threat modeling), código (SAST), build (SCA), teste (DAST), deploy (container scanning), operação (monitoramento). 'Shift left': segurança o mais cedo possível.",
    "example": "Pipeline: código → SAST (estática) → SCA (dependências) → build → DAST (dinâmica) → container scan → deploy → monitoring. Ferramentas: SonarQube, Snyk, OWASP ZAP, Trivy."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Difícil__4",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Difícil",
    "question": "O que é desserialização insegura e como pode ser explorada?",
    "options": [
      "Manipulação de objetos serializados para executar código remoto no servidor",
      "Erro ao converter dados JSON",
      "Falha na compressão de arquivos",
      "Bug em conversão de tipos numéricos"
    ],
    "correctIndex": 0,
    "explanation": "Desserialização insegura: aplicativo aceita objetos serializados sem validação. Atacante modifica o objeto para executar código arbitrário (RCE). Comum em Java (ObjectInputStream), PHP (unserialize), Python (pickle).",
    "example": "Java: gadget chains (ysoserial) exploram desserialização para RCE. Prevenção: não aceitar objetos serializados de fontes não confiáveis, usar JSON/XML, assinar objetos. OWASP 2017 #8."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Difícil__5",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Difícil",
    "question": "O que são ataques de injeção de template (SSTI) em aplicações web?",
    "options": [
      "Injeção de código em templates server-side que permite execução remota de código",
      "Ataque contra templates de email",
      "Modificação de templates CSS",
      "Injeção em templates de banco de dados"
    ],
    "correctIndex": 0,
    "explanation": "SSTI (Server-Side Template Injection): atacante injeta expressões no template engine (Jinja2, Twig, FreeMarker). Se o input é renderizado como template, pode executar código no servidor (RCE).",
    "example": "Teste: {{7*7}} retorna 49 = vulnerável. Jinja2 (Python): {{config.items()}} vaza configuração. Escalação: __class__.__mro__[1].__subclasses__() para RCE. Prevenção: sandbox do template, não usar input no template."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Difícil__6",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Difícil",
    "question": "O que é prototype pollution em JavaScript e como pode ser explorado?",
    "options": [
      "Modificação do prototype de objetos base que afeta todos os objetos derivados, podendo levar a RCE",
      "Poluição de variáveis de ambiente",
      "Exaustão de memória do navegador",
      "Conflito de versões de bibliotecas"
    ],
    "correctIndex": 0,
    "explanation": "Prototype pollution: atacante modifica Object.prototype adicionando propriedades que propagam para todos os objetos. Pode causar: bypass de autenticação (isAdmin=true), RCE (via child_process em Node.js), XSS.",
    "example": "Vetor: merge/clone profundo de objetos com '__proto__' ou 'constructor.prototype'. Exemplo: {\"__proto__\": {\"isAdmin\": true}}. Defesa: Object.create(null), Map em vez de {}, validar chaves, Object.freeze(Object.prototype)."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Difícil__7",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Difícil",
    "question": "O que é race condition em aplicações web e como pode ser explorada?",
    "options": [
      "Falha de concorrência que permite explorar o intervalo entre verificação e uso para resultados não autorizados",
      "Competição entre navegadores por recursos",
      "Conflito de DNS entre servidores",
      "Corrida de cache entre CDNs"
    ],
    "correctIndex": 0,
    "explanation": "Race condition (TOCTOU — Time of Check to Time of Use): atacante envia requisições simultâneas para explorar o intervalo entre verificação e ação. Exemplo: usar cupom de desconto múltiplas vezes, sacar mais que o saldo.",
    "example": "Exemplo: saldo = R$100, atacante envia 10 saques de R$100 simultaneamente → todos passam na verificação antes do débito. Defesa: locks otimistas/pessimistas, transações atômicas, idempotency keys. Ferramenta: Turbo Intruder (Burp)."
  },
  {
    "id": "seguranca-da-informacao__Segurança em Aplicações Web__Difícil__8",
    "track": "seguranca-da-informacao",
    "category": "Segurança em Aplicações Web",
    "difficulty": "Difícil",
    "question": "Como funciona JWT (JSON Web Token) e quais vulnerabilidades comuns existem na sua implementação?",
    "options": [
      "JWT: header.payload.signature; ataque 'alg:none' remove verificação de assinatura; confusion RS256→HS256 usa chave pública como segredo HMAC; weak key força bruta; kid injection → path traversal ou SQLi",
      "JWT é sempre seguro por padrão; vulnerabilidades são somente teóricas",
      "Payload JWT é criptografado; atacante não pode ler as claims",
      "Trocar algoritmo de RS256 para HS256 aumenta a segurança do token"
    ],
    "correctIndex": 0,
    "explanation": "JWT: Base64url(header).Base64url(payload).Base64url(signature). Payload: não cifrado (apenas encoded); dados visíveis. Vulnerabilidades: (1) alg:none: biblioteca aceita token sem assinatura; (2) RS256→HS256 confusion: biblioteca verifica HMAC-SHA256 com chave pública (conhecida) como secret; (3) Weak HMAC secret: força bruta offline; (4) kid injection: interpolação direta → SQLi/LFI.",
    "example": "Ferramentas: jwt_tool (ticarpi), jwt.io. Mitigações: forçar algoritmo no servidor (não aceitar do cliente); chave HMAC >= 256 bits aleatória; validar exp/nbf/iss/aud; HttpOnly+Secure cookies para armazenar JWT (não localStorage). JWE (JSON Web Encryption): cifra payload. OIDC: OAuth 2.0 + ID Token JWT. hashcat -a 0 -m 16500 hash.txt wordlist.txt."
  }
]