import type { SeedCard } from "../generator";

type UserLevel = "Fácil" | "Médio" | "Difícil";

// ─── Linguagens de Programação · 10 categorias × 3 níveis × 7 questões (rodada 4/30) ───

const linguagensBankBase: Record<string, Record<UserLevel, SeedCard[]>> = {
  // ── C ──
  C: {
    Fácil: [
      {
        q: "Em C, qual função da biblioteca padrão é usada para alocar memória dinamicamente no heap?",
        o: ["malloc", "alloc", "new", "heap"],
        c: 0,
        e: "A função malloc (memory allocation) reserva um bloco contíguo de bytes no heap e retorna um ponteiro void* para o início do bloco. O programador é responsável por liberar a memória com free() para evitar memory leaks.",
        x: "int *arr = (int *)malloc(10 * sizeof(int)); — aloca espaço para 10 inteiros. Após uso: free(arr);",
      },
      {
        q: "Em C, qual é a diferença entre 'printf' e 'scanf'?",
        o: [
          "printf exibe dados na tela; scanf lê dados do teclado",
          "São idênticos",
          "printf lê e scanf exibe",
          "Ambos escrevem em arquivo",
        ],
        c: 0,
        e: "printf (print formatted) envia saída formatada para stdout (tela). scanf (scan formatted) lê entrada formatada de stdin (teclado). Ambos usam format specifiers como %d para inteiros, %s para strings, %f para floats.",
        x: "printf('Idade: %d', idade); // Exibe 'Idade: 25'. scanf('%d', &idade); // Lê um inteiro do teclado e armazena em 'idade'. Note o & para passar o endereço.",
      },
      {
        q: "Em C, qual é a diferença entre um array e um ponteiro?",
        o: [
          "Array é bloco contíguo de tamanho fixo; ponteiro é variável que armazena endereço de memória",
          "São exatamente a mesma coisa",
          "Ponteiro é mais rápido",
          "Array pode mudar de tamanho",
        ],
        c: 0,
        e: "Um array em C é um bloco contíguo de memória de tamanho fixo definido em tempo de compilação. Um ponteiro é uma variável que armazena um endereço. Arrays 'decaem' para ponteiros em expressões, mas sizeof(array) retorna o tamanho total, enquanto sizeof(ponteiro) retorna o tamanho do ponteiro.",
        x: "int arr[5]; sizeof(arr) == 20 (5×4 bytes). int *p = arr; sizeof(p) == 8 (tamanho do ponteiro em 64-bit). arr[2] é equivalente a *(p+2).",
      },
      {
        q: "O que são os tipos de dados básicos em C e quantos bytes cada um ocupa?",
        o: [
          "char (1 byte), int (4 bytes), float (4 bytes), double (8 bytes) — tamanhos típicos em 64-bit",
          "Todos ocupam 4 bytes",
          "C não tem tipos definidos",
          "char (8 bytes), int (1 byte)",
        ],
        c: 0,
        e: "Em C, os tipos básicos incluem: char (1 byte, -128 a 127 ou 0-255), int (tipicamente 4 bytes), float (4 bytes, ~7 dígitos), double (8 bytes, ~15 dígitos). Tamanhos podem variar por plataforma — usar sizeof() para confirmar. stdint.h fornece tipos com tamanho exato (int32_t).",
        x: "printf('%zu %zu %zu %zu', sizeof(char), sizeof(int), sizeof(float), sizeof(double)); // 1 4 4 8 (típico 64-bit). Use int32_t do stdint.h para garantir 4 bytes em qualquer plataforma.",
      },
      {
        q: "O que é a diferença entre stack e heap em C?",
        o: [
          "Stack: alocação automática e rápida, tamanho limitado; Heap: alocação manual (malloc/free), maior mas mais lenta",
          "São iguais",
          "Heap é mais rápido",
          "Stack precisa de malloc",
        ],
        c: 0,
        e: "Stack: variáveis locais, alocação/desalocação automática (LIFO), muito rápida, tamanho limitado (~1-8MB). Heap: alocação dinâmica via malloc/free, maior, mais lenta, risco de memory leaks se não fizer free. Variáveis globais ficam no data segment.",
        x: "void foo() { int x = 10; // stack (liberado ao sair). int *p = malloc(100); // heap (precisa de free). } Se esquecer free(p) → memory leak. Se acessar x fora de foo → undefined behavior.",
      },
      {
        q: "O que é um header file (.h) em C e por que usamos a diretiva #include?",
        o: [
          "Arquivo com declarações de funções/tipos que #include copia textualmente para o .c, permitindo reutilização",
          "Arquivo compilado separadamente",
          "Biblioteca binária",
          "Arquivo de configuração do compilador",
        ],
        c: 0,
        e: "#include faz o pré-processador copiar o conteúdo do header no arquivo .c. Headers declaram protótipos de funções, tipos, macros e constantes. Usa-se #ifndef/#define/#endif (include guards) para evitar inclusão dupla que causaria erros de redefinição.",
        x: '// math_utils.h\n#ifndef MATH_UTILS_H\n#define MATH_UTILS_H\nint soma(int a, int b);\n#endif\n// main.c\n#include "math_utils.h"\nint main() { printf("%d", soma(2,3)); }',
      },
      {
        q: "Qual a diferença entre 'const' e '#define' para declarar constantes em C?",
        o: [
          "const cria variável tipada respeitando escopo; #define faz substituição textual sem tipo nem escopo",
          "São a mesma coisa",
          "#define é mais moderno",
          "const só funciona com inteiros",
        ],
        c: 0,
        e: "const: variável com tipo, respeitada pelo compilador (type checking), tem escopo. #define: substituição textual pelo pré-processador, sem tipo, sem escopo, sem debug symbol. const é preferido em C99+ por segurança. Enum também é alternativa para inteiros.",
        x: "#define PI 3.14159 // sem tipo, global. const double pi = 3.14159; // tipo double, escopo respeitado, visível no debugger. Em C, const não cria constante de compilação (diferente de C++).",
      },
    ],
    Médio: [
      {
        q: "Em C, qual é a diferença entre um ponteiro para array e um array de ponteiros?",
        o: [
          "Ponteiro para array aponta para o array inteiro; array de ponteiros é um array onde cada elemento é um ponteiro",
          "São a mesma coisa",
          "Ponteiro para array usa ** e array de ponteiros usa *",
          "Não existe ponteiro para array em C",
        ],
        c: 0,
        e: "int (*p)[10] é um ponteiro para um array de 10 ints — p aponta para o bloco inteiro. int *p[10] é um array de 10 ponteiros para int — cada p[i] aponta para um int diferente. A diferença é na precedência: (*p) vs *p[].",
        x: "int arr[10]; int (*p)[10] = &arr; // p aponta para o array completo. int *ptrs[3] = {&a, &b, &c}; // array com 3 ponteiros independentes.",
      },
      {
        q: "Em C, o que são structs e como elas permitem agrupar dados de tipos diferentes?",
        o: [
          "Tipo composto que agrupa variáveis de tipos diferentes sob um único nome",
          "São classes como em Java",
          "São apenas arrays nomeados",
          "Só agrupam dados do mesmo tipo",
        ],
        c: 0,
        e: "Structs em C permitem criar tipos de dados compostos que agrupam variáveis (membros/campos) de tipos diferentes em uma única unidade. Diferente de classes em OOP, structs em C não têm métodos, herança ou encapsulamento — são apenas agrupamento de dados.",
        x: "struct Ponto { int x; int y; }; struct Ponto p1 = {10, 20}; printf('%d', p1.x); // 10. Com ponteiro: struct Ponto *pp = &p1; pp->x; // 10 (operador seta).",
      },
      {
        q: "Em C, qual é a diferença entre passar argumentos por valor e por referência (via ponteiro)?",
        o: [
          "Por valor copia o dado (original inalterado); por ponteiro passa o endereço (permite modificar o original)",
          "São a mesma coisa",
          "C só permite passagem por valor",
          "Por referência é mais lento",
        ],
        c: 0,
        e: "C sempre passa argumentos por valor (cópia). Para simular passagem por referência, passa-se o endereço da variável (ponteiro). A função recebe o ponteiro e pode modificar o valor original através de desreferenciação (*ptr).",
        x: "void dobrar(int *p) { *p = *p * 2; } int x = 5; dobrar(&x); // x agora é 10. Sem ponteiro: void dobrar(int n) { n = n * 2; } — x continua 5 (cópia).",
      },
      {
        q: "O que é uma struct em C e como ela difere de um array?",
        o: [
          "Struct agrupa variáveis de tipos diferentes sob um nome; array armazena elementos do mesmo tipo",
          "São idênticos",
          "Array pode ter tipos diferentes",
          "Struct só aceita inteiros",
        ],
        c: 0,
        e: "Struct: tipo definido pelo usuário que agrupa membros de tipos diferentes (como classe sem métodos). Array: sequência de elementos do MESMO tipo. Structs permitem modelar entidades complexas (ponto, usuário). Acessam membros com . (dot) ou -> (ponteiro).",
        x: "struct Point { int x; int y; }; struct Point p = {10, 20}; p.x = 30; // acesso direto. struct Point *pp = &p; pp->y = 40; // acesso via ponteiro.",
      },
      {
        q: "O que é um macro com #define em C e quais são seus riscos?",
        o: [
          "Substituição textual feita pelo pré-processador antes da compilação; risco de efeitos colaterais sem type safety",
          "Função optimizada pelo compilador",
          "Variável global",
          "Comentário especial",
        ],
        c: 0,
        e: "#define cria macros resolvidas pelo pré-processador (substituição textual). Não tem type checking, escopo, ou debug fácil. Riscos: efeitos colaterais (#define SQUARE(x) x*x → SQUARE(a+1) = a+1*a+1). Inline functions são alternativa type-safe em C99+.",
        x: "#define MAX(a,b) ((a)>(b)?(a):(b)) — parece função mas é texto. MAX(i++,j++) pode incrementar i ou j duas vezes! Solução C99: static inline int max(int a, int b) { return a>b?a:b; }",
      },
      {
        q: "O que são variáveis 'static' em C e como se comportam dentro e fora de funções?",
        o: [
          "Dentro de função: mantém valor entre chamadas; fora de função: restringe visibilidade ao arquivo",
          "Sempre são constantes",
          "Equivalem a variáveis globais",
          "São alocadas no heap",
        ],
        c: 0,
        e: "static dentro de função: variável local que persiste entre chamadas (inicializada uma vez). static fora de função/em função global: limita o escopo ao translation unit (arquivo .c), impedindo acesso por outros arquivos — internal linkage.",
        x: "void counter() { static int n = 0; n++; printf('%d ', n); } counter(); counter(); counter(); // 1 2 3 (n persiste). static int x = 10; // em escopo de arquivo, invisível para outros .c.",
      },
      {
        q: "O que é 'typedef' em C e como melhora a legibilidade do código?",
        o: [
          "Cria alias para tipos existentes, simplificando declarações complexas de ponteiros, structs e function pointers",
          "Define novas variáveis",
          "Cria macros de pré-processador",
          "Declara funções inline",
        ],
        c: 0,
        e: "typedef cria sinônimos para tipos. Simplifica structs (typedef struct { int x; } Point; — sem repetir 'struct'), function pointers (typedef void (*Callback)(int);) e tipos complexos. Melhora portabilidade e legibilidade.",
        x: "typedef unsigned long ulong; typedef struct { int x, y; } Vec2; typedef int (*Comparator)(const void*, const void*); Comparator cmp = compare; // muito mais legível que int (*cmp)(const void*, const void*).",
      },
    ],
    Difícil: [
      {
        q: "Em C, o que é 'undefined behavior' causado por 'strict aliasing violation' e como evitá-lo?",
        o: [
          "Acessar um objeto via ponteiro de tipo incompatível; usar memcpy ou union em vez de casting direto",
          "Usar variáveis sem inicializar",
          "Acessar array fora dos limites",
          "Usar goto em loops aninhados",
        ],
        c: 0,
        e: "Strict aliasing rule determina que um ponteiro de tipo T* só pode acessar objetos do tipo T (com exceções para char*). Violar isso (ex.: ler um float via int*) é undefined behavior pois o compilador assume que ponteiros de tipos diferentes não apontam para o mesmo endereço, otimizando agressivamente.",
        x: "float f = 3.14; int i = *(int*)&f; // UB! strict aliasing violation. Correto: int i; memcpy(&i, &f, sizeof(i)); // OK, memcpy é safe.",
      },
      {
        q: "Em C, o que são function pointers e qual sua utilidade prática?",
        o: [
          "Ponteiros que armazenam o endereço de funções, permitindo chamar funções indiretamente e implementar callbacks",
          "Ponteiros para variáveis globais",
          "Funções que retornam ponteiros",
          "Não existem em C",
        ],
        c: 0,
        e: "Function pointers armazenam o endereço de funções, permitindo: callbacks (qsort usa comparator), tabelas de dispatch (simulando polimorfismo), e carregamento dinâmico de funções (dlsym). A sintaxe é: tipo_retorno (*nome)(parâmetros).",
        x: "int compare(const void *a, const void *b) { return *(int*)a - *(int*)b; } qsort(arr, n, sizeof(int), compare); — 'compare' é passada como function pointer para qsort.",
      },
      {
        q: "Em C, o que é 'volatile' e quando essa keyword deve ser usada?",
        o: [
          "Indica ao compilador que a variável pode mudar a qualquer momento fora do controle do programa, impedindo otimizações",
          "Torna variável imutável",
          "Aloca na stack",
          "Marca variável para garbage collection",
        ],
        c: 0,
        e: "volatile informa ao compilador que o valor da variável pode mudar inesperadamente (hardware registers, variáveis modificadas por ISR ou outra thread). O compilador não pode otimizar acessos (cache em registrador, reordenar, eliminar leituras 'redundantes'). Crucial em embedded e device drivers.",
        x: "volatile uint32_t *status_reg = (uint32_t*)0x40001000; while (*status_reg & 0x01) {} // Sem volatile, compilador poderia ler uma vez e cachear, criando loop infinito.",
      },
      {
        q: "O que é undefined behavior (UB) em C e por que é perigoso?",
        o: [
          "Comportamento não definido pelo padrão C; o compilador pode fazer qualquer coisa, incluindo otimizar o código de formas inesperadas",
          "Apenas um warning",
          "Erro de compilação",
          "Bug do sistema operacional",
        ],
        c: 0,
        e: "UB: o padrão C não define o que acontece. Exemplos: acesso fora do array, dereferenciar NULL, integer overflow com signed int, usar variável não inicializada. O compilador pode: ignorar, otimizar removendo código, ou gerar código que funciona em debug mas falha em release.",
        x: "int a[3]; a[5] = 42; // UB: acesso fora do array. int *p = NULL; *p = 1; // UB: seg fault provável. int x = INT_MAX; x++; // UB: signed overflow. Pode funcionar em -O0 e crashar em -O2.",
      },
      {
        q: "O que é memory alignment em C e por que importa para performance?",
        o: [
          "Dados alinhados em endereços múltiplos do seu tamanho para acesso eficiente pela CPU; desalinhamento causa penalidade",
          "Ordenação de bytes no arquivo",
          "Alocação contígua de arrays",
          "Compactação de memória pelo OS",
        ],
        c: 0,
        e: "CPUs acessam memória mais eficientemente quando dados estão alinhados (int de 4 bytes em endereço múltiplo de 4). Structs podem ter padding para manter alinhamento. sizeof(struct) pode ser maior que a soma dos membros. #pragma pack reduz padding.",
        x: "struct A { char c; int i; }; // sizeof = 8 (não 5! 3 bytes de padding após char). struct B { int i; char c; }; // sizeof = 8 também. struct C { char c; char d; int i; }; // sizeof = 8 (2 bytes padding após d).",
      },
      {
        q: "O que são operadores bitwise em C e quais os principais usos de bit manipulation?",
        o: [
          "Operadores &, |, ^, ~, <<, >> manipulam bits individuais; usados em flags, máscaras e otimizações de baixo nível",
          "Operadores aritméticos padrão",
          "Operadores de comparação",
          "Funções de string",
        ],
        c: 0,
        e: "& (AND), | (OR), ^ (XOR), ~ (NOT), << (shift left), >> (shift right). Usados para: flags (permissions |= WRITE), máscaras (valor & 0xFF extrai byte), toggle (flag ^= BIT), teste (if (flags & READ)), multiplicação/divisão por 2 (n << 1).",
        x: "#define READ 0x01\n#define WRITE 0x02\n#define EXEC 0x04\nint perms = READ | WRITE; // 0x03. if (perms & EXEC) {} // false. perms |= EXEC; // adiciona. perms &= ~WRITE; // remove WRITE.",
      },
      {
        q: "O que é o qualificador 'restrict' em C99 e como ajuda o compilador a otimizar?",
        o: [
          "Garante que um ponteiro é o único acesso àquela memória, permitindo otimizações de aliasing",
          "Torna o ponteiro constante",
          "Limita o tamanho do array",
          "Impede alocação no heap",
        ],
        c: 0,
        e: "restrict informa ao compilador que o ponteiro é o ÚNICO meio de acessar aquela memória no escopo. Sem restrict, o compilador assume que ponteiros podem apontar para o mesmo endereço (aliasing), impedindo otimizações como vetorização SIMD e reordenação de loads/stores.",
        x: "void add(int * restrict a, int * restrict b, int * restrict c, int n) { for (int i=0; i<n; i++) c[i] = a[i] + b[i]; } // Com restrict, compilador pode vetorizar com SIMD. memcpy usa restrict; memmove não (permite overlap).",
      },
    ],
  },

  // ── C++ ──
  "C++": {
    Fácil: [
      {
        q: "Em C++, qual a diferença entre 'new' e 'malloc' para alocação de memória?",
        o: [
          "new chama o construtor do objeto e retorna o tipo correto; malloc apenas aloca bytes brutos",
          "São equivalentes",
          "malloc é mais rápido que new",
          "new não pode ser usado com arrays",
        ],
        c: 0,
        e: "O operador 'new' em C++ aloca memória E chama o construtor do objeto, retornando um ponteiro tipado. malloc() apenas reserva bytes brutos sem chamar construtores e retorna void*. Para liberar: delete para new, free() para malloc.",
        x: 'std::string *s = new std::string("hello"); // aloca + chama construtor. delete s; // chama destrutor + libera memória.',
      },
      {
        q: "Em C++, o que é RAII (Resource Acquisition Is Initialization) e por que é importante?",
        o: [
          "Princípio onde recursos são adquiridos no construtor e liberados no destrutor, garantindo cleanup automático",
          "Um tipo de garbage collector",
          "Técnica de otimização",
          "Padrão de design de UI",
        ],
        c: 0,
        e: "RAII amarra a vida de um recurso (memória, arquivo, lock, conexão) ao tempo de vida de um objeto. O recurso é adquirido no construtor e liberado no destrutor. Como destructors são chamados automaticamente ao sair do escopo, o cleanup é garantido mesmo com exceções.",
        x: "{ std::lock_guard<std::mutex> lock(mtx); // adquire lock no construtor. doWork(); // se lançar exceção... } // destrutor de lock_guard libera o mutex automaticamente.",
      },
      {
        q: "Em C++, qual a diferença entre referência (&) e ponteiro (*) ?",
        o: [
          "Referência é alias imutável para um objeto existente; ponteiro é variável que armazena endereço e pode ser reatribuído",
          "São idênticos",
          "Referência pode ser nula",
          "Ponteiro não pode ser reatribuído",
        ],
        c: 0,
        e: "Referência (&): alias para um objeto, deve ser inicializada na declaração, não pode ser nula, não pode ser reatribuída. Ponteiro (*): variável com endereço, pode ser nulo, pode ser reatribuído, exige desreferenciação (*ptr). Referências são mais seguras; ponteiros mais flexíveis.",
        x: "int x = 10; int &ref = x; ref = 20; // x agora é 20. int *ptr = &x; *ptr = 30; // x agora é 30. ptr = &y; // OK. &ref = y; // ERRO, não pode reatribuir referência.",
      },
      {
        q: "O que é RAII (Resource Acquisition Is Initialization) em C++?",
        o: [
          "Padrão onde recursos são adquiridos no construtor e liberados no destrutor, garantindo cleanup automático",
          "Técnica de alocação dinâmica",
          "Padrão de inicialização de arrays",
          "Garbage collection em C++",
        ],
        c: 0,
        e: "RAII vincula o ciclo de vida de um recurso (memória, arquivo, mutex) ao ciclo de vida de um objeto. Construtor adquire, destrutor libera. Ao sair do escopo, destrutor é chamado automaticamente. Smart pointers (unique_ptr, shared_ptr) são RAII para memória.",
        x: "{ std::unique_ptr<int> p = std::make_unique<int>(42); // aloca. use(*p); } // destrutor chamado automaticamente, memória liberada. Sem RAII: int *p = new int(42); use(*p); delete p; // esqueceu delete = leak.",
      },
      {
        q: "O que são templates em C++ e como diferem de generics em outras linguagens?",
        o: [
          "Mecanismo de metaprogramação que gera código em tempo de compilação para cada tipo usado",
          "São idênticos a generics Java",
          "Só funcionam com classes",
          "São interpretados em runtime",
        ],
        c: 0,
        e: "Templates C++: o compilador gera código específico para cada tipo (monomorphization). vector<int> e vector<string> são classes completamente separadas no binário. Generics Java: type erasure em runtime (List<Integer> e List<String> são o mesmo bytecode). Templates permitem metaprogramação.",
        x: "template<typename T> T max(T a, T b) { return a > b ? a : b; } max(3, 5); // gera função max<int>. max(3.14, 2.71); // gera função max<double>. Duas funções separadas no binário.",
      },
      {
        q: "O que é um namespace em C++ e por que 'using namespace std' pode ser problemático?",
        o: [
          "Namespace agrupa identificadores para evitar conflitos; 'using namespace std' expõe todos os nomes e pode causar ambiguidades",
          "Namespace é uma classe especial",
          "using namespace é obrigatório",
          "Namespaces só existem em headers",
        ],
        c: 0,
        e: "Namespaces evitam colisões de nome (std::vector vs custom::vector). 'using namespace std;' importa TODOS os nomes de std para o escopo global, podendo conflitar com seu código (ex.: count, distance, size). Em headers é especialmente perigoso pois polui o namespace de quem inclui.",
        x: "namespace math { double pi = 3.14; } math::pi; // acesso qualificado. using math::pi; // importa só pi. using namespace std; // EVITE em headers! std::cout é preferível a 'using namespace std; cout;'.",
      },
      {
        q: "O que são construtores e destrutores em C++ e quando são chamados automaticamente?",
        o: [
          "Construtor inicializa o objeto na criação; destrutor limpa recursos quando o objeto sai de escopo ou é deletado",
          "São funções normais chamadas manualmente",
          "Construtores são opcionais em todas as classes",
          "Destrutores só existem com herança",
        ],
        c: 0,
        e: "Construtor: mesmo nome da classe, sem tipo de retorno, chamado na criação. Destrutor: ~NomeClasse(), chamado automaticamente ao sair do escopo (stack) ou com delete (heap). Pode ter múltiplos construtores (overload), mas apenas um destrutor. Essenciais para RAII.",
        x: "class File { FILE* f; public: File(const char* name) { f = fopen(name, 'r'); } ~File() { if(f) fclose(f); } }; { File f('data.txt'); // construtor abre. } // destrutor fecha automaticamente.",
      },
    ],
    Médio: [
      {
        q: "Em C++11, qual smart pointer garante propriedade exclusiva de um recurso e não permite cópia?",
        o: [
          "std::unique_ptr",
          "std::shared_ptr",
          "std::weak_ptr",
          "std::auto_ptr",
        ],
        c: 0,
        e: "std::unique_ptr mantém propriedade exclusiva do recurso. Não pode ser copiado (copy constructor deletado), apenas movido com std::move(). Quando o unique_ptr sai de escopo, o recurso é automaticamente liberado pelo destrutor, implementando RAII.",
        x: "auto p = std::make_unique<int>(42); auto p2 = std::move(p); // OK: transfere propriedade. // auto p3 = p2; // Erro de compilação: cópia proibida.",
      },
      {
        q: "Em C++11, o que é move semantics e como 'std::move' melhora a performance?",
        o: [
          "Transfere recursos de um objeto para outro sem copiar, usando rvalue references (&&)",
          "Move arquivos no filesystem",
          "Otimiza loops for",
          "Equivalente a memcpy",
        ],
        c: 0,
        e: "Move semantics permite transferir a propriedade de recursos internos (heap memory, file handles) de um objeto temporário para outro, evitando cópias custosas. std::move() converte um lvalue em rvalue reference (&&), permitindo que o move constructor/assignment seja chamado em vez do copy.",
        x: "std::vector<int> v1 = {1,2,3,4,5}; std::vector<int> v2 = std::move(v1); // v2 'rouba' o buffer interno de v1. v1 agora está vazio. Zero cópia de elementos.",
      },
      {
        q: "Em C++, quando usar 'virtual' em métodos e o que é o vtable?",
        o: [
          "virtual habilita polimorfismo runtime; vtable é tabela de ponteiros para funções virtuais usada para dispatch dinâmico",
          "virtual é para templates",
          "vtable é uma tabela SQL",
          "virtual torna métodos mais rápidos",
        ],
        c: 0,
        e: "Métodos 'virtual' permitem que subclasses sobrescrevam o comportamento, com a versão correta sendo chamada em runtime baseada no tipo real do objeto (não do ponteiro). O compilador cria uma vtable (tabela de ponteiros para funções) por classe, e cada objeto tem um vptr para sua vtable.",
        x: "class Animal { virtual void speak() { cout << 'Animal'; } }; class Dog : public Animal { void speak() override { cout << 'Woof'; } }; Animal *a = new Dog(); a->speak(); // 'Woof' via vtable lookup.",
      },
      {
        q: "O que são smart pointers em C++ e quais os principais tipos?",
        o: [
          "Objetos que gerenciam memória automaticamente via RAII: unique_ptr (exclusivo), shared_ptr (compartilhado), weak_ptr (não-owner)",
          "Ponteiros mais rápidos",
          "Ponteiros para funções",
          "Alias para void*",
        ],
        c: 0,
        e: "unique_ptr: ownership exclusivo, não copiável, movível. shared_ptr: ownership compartilhado via reference counting. weak_ptr: referência não-owner para shared_ptr (evita ciclos). Todos liberam memória automaticamente. Substituem new/delete manuais.",
        x: "auto p = std::make_unique<Widget>(); // unique_ptr, 1 dono. auto s1 = std::make_shared<Widget>(); auto s2 = s1; // ref count = 2. s1.reset(); // ref count = 1. s2.reset(); // ref count = 0, Widget destruido.",
      },
      {
        q: "O que é move semantics em C++ e qual problema resolve?",
        o: [
          "Permite transferir recursos de um objeto temporário em vez de copiar, evitando alocações desnecessárias",
          "Mover arquivos no disco",
          "Reordenar elementos de array",
          "Mover variáveis entre escopos",
        ],
        c: 0,
        e: "Move semantics (C++11): ao invés de copiar dados de um objeto temporário (cópia profunda), transfere (steal) os recursos internos. O objeto original fica em estado válido mas vazio. Usa rvalue references (&&). Essencial para performance com containers grandes.",
        x: "std::vector<int> create() { std::vector<int> v(1000000); return v; } auto data = create(); // Move semantics: ponteiro interno transferido, zero cópia dos 1M elementos. Sem move: copiaria 4MB.",
      },
      {
        q: "O que são lambda expressions em C++11 e como capturam variáveis do escopo?",
        o: [
          "Funções anônimas inline com captura de variáveis por valor [=] ou por referência [&]",
          "Macros do pré-processador",
          "Funções template especiais",
          "Ponteiros de função simplificados",
        ],
        c: 0,
        e: "Lambdas: [capture](params) -> ret { body }. Capture list: [=] copia tudo, [&] referência tudo, [x, &y] misto. Compilador gera classe anônima com operator(). Útil para callbacks, STL algorithms, e código inline sem definir função separada.",
        x: "int x = 10; auto add = [x](int y) { return x + y; }; add(5); // 15, x capturado por valor. std::sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // ordena decrescente.",
      },
      {
        q: "O que é herança múltipla em C++ e qual é o 'problema do diamante'?",
        o: [
          "Classe herda de múltiplas bases; diamante ocorre quando duas bases têm ancestral comum, gerando ambiguidade",
          "C++ não permite herança múltipla",
          "Diamante é erro de compilação sem solução",
          "Herança múltipla é idêntica a interfaces",
        ],
        c: 0,
        e: "Herança múltipla: class C : public A, public B {}. Problema do diamante: A->B, A->C, D herda B e C — D tem duas cópias de A. Solução: virtual inheritance (class B : virtual public A), garantindo uma única cópia do ancestral comum.",
        x: "class Animal { public: int age; }; class Dog : virtual public Animal {}; class Pet : virtual public Animal {}; class PetDog : public Dog, public Pet {}; // Uma só cópia de age. Sem virtual: ambiguidade — PetDog::Dog::age vs PetDog::Pet::age.",
      },
    ],
    Difícil: [
      {
        q: "Em C++, o que é SFINAE (Substitution Failure Is Not An Error) e como ele é usado em template metaprogramming?",
        o: [
          "Quando a substituição de template falha, o compilador descarta silenciosamente o candidato em vez de gerar erro",
          "É um tipo de exceção do compilador",
          "É uma forma de polimorfismo dinâmico",
          "É um mecanismo de garbage collection",
        ],
        c: 0,
        e: "SFINAE permite que o compilador descarte overloads de template cuja substituição de tipos resulte em expressões inválidas, sem gerar erro de compilação. Isso é usado com std::enable_if, concepts (C++20) e if constexpr para selecionar implementações baseadas em propriedades dos tipos.",
        x: "template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>> void print(T val) { /* só para inteiros */ } — se T=double, SFINAE descarta este overload silenciosamente.",
      },
      {
        q: "Em C++20, o que são 'concepts' e como eles melhoram os templates?",
        o: [
          "Restrições nomeadas sobre tipos em templates que fornecem erros claros e substituem SFINAE",
          "São classes abstratas",
          "Interfaces como em Java",
          "Macros avançadas",
        ],
        c: 0,
        e: "Concepts definem restrições nomeadas para parâmetros de template. Em vez de SFINAE complexo e erros de compilação incompreensíveis, concepts fornecem mensagens claras ('T does not satisfy Sortable'). São part of the interface do template, não hack de implementação.",
        x: "template<typename T> concept Sortable = requires(T a, T b) { { a < b } -> std::convertible_to<bool>; }; template<Sortable T> void sort(vector<T>& v); sort(vec_of_ints); // OK. sort(vec_of_non_comparable); // Erro claro: tipo não satisfaz Sortable.",
      },
      {
        q: "Em C++, o que é o 'Rule of Five' e quando deve ser implementado?",
        o: [
          "Se definir destrutor, copy/move constructor ou copy/move assignment, deve definir todos os 5",
          "Regra de 5 threads",
          "Limite de 5 herança",
          "Máximo de 5 templates",
        ],
        c: 0,
        e: "Se uma classe gerencia recursos (memória, handles), o comportamento default de cópia/move pode causar double-free ou leaks. Rule of Five: definir destrutor, copy constructor, copy assignment, move constructor e move assignment — ou deletar os que não devem ser usados. Rule of Zero: preferir classes que não gerenciam recursos diretamente (usar smart pointers).",
        x: "class Buffer { int* data; size_t size; public: ~Buffer(); Buffer(const Buffer&); Buffer& operator=(const Buffer&); Buffer(Buffer&&) noexcept; Buffer& operator=(Buffer&&) noexcept; }; // Ou Rule of Zero: class Buffer { std::vector<int> data; }; // tudo automático.",
      },
      {
        q: "O que é CRTP (Curiously Recurring Template Pattern) em C++?",
        o: [
          "Classe base template parametrizada pela classe derivada, permitindo polimorfismo estático em tempo de compilação",
          "Template que se auto-referencia infinitamente",
          "Padrão para criação de singletons",
          "Recursividade em templates",
        ],
        c: 0,
        e: "CRTP: class Derived : public Base<Derived> {}. Permet polimorfismo estático (sem vtable, sem overhead de virtual). A base conhece o tipo derivado em compile-time. Usado para: mixin patterns, contadores de instâncias, operações genéricas (operator< gera >, <=, >=).",
        x: "template<typename T> class Counter { static int count; public: Counter() { ++count; } static int getCount() { return count; } }; class Dog : public Counter<Dog> {}; class Cat : public Counter<Cat> {}; // Contadores separados por tipo.",
      },
      {
        q: "O que são concepts em C++20 e como melhoram templates?",
        o: [
          "Restrições nomeadas para parâmetros de template que geram mensagens de erro claras e documentam requisitos",
          "Conceitos abstratos de POO",
          "Sinônimo de interfaces",
          "Comentários especiais para templates",
        ],
        c: 0,
        e: "Concepts (C++20): definem requisitos que tipos devem satisfazer para serem usados com um template. Substituem SFINAE complexo. Geram mensagens de erro legíveis (em vez de páginas de erros de template). Concepts standard: std::integral, std::floating_point, std::sortable.",
        x: 'template<typename T> concept Addable = requires(T a, T b) { a + b; }; template<Addable T> T sum(T a, T b) { return a + b; } sum(1, 2); // OK. sum("a", "b"); // Erro claro: string não satisfaz Addable.',
      },
      {
        q: "O que são variadic templates em C++ e como funcionam com parameter packs?",
        o: [
          "Templates que aceitam número variável de argumentos de tipos diferentes, expandidos recursivamente em compilação",
          "Templates com número fixo de parâmetros",
          "Variáveis globais template",
          "Arrays de templates",
        ],
        c: 0,
        e: "Variadic templates (C++11): template<typename... Args> aceita 0 ou mais tipos. Parameter pack Args... é expandido recursivamente ou com fold expressions (C++17). sizeof...(Args) retorna a contagem. Base case termina a recursão. Usado em std::tuple, std::make_shared, printf type-safe.",
        x: "template<typename T> void print(T val) { std::cout << val; } template<typename T, typename... Rest> void print(T first, Rest... rest) { std::cout << first << ' '; print(rest...); } print(1, 'hello', 3.14); // 1 hello 3.14",
      },
      {
        q: "O que é constexpr em C++ e como difere de const?",
        o: [
          "constexpr garante avaliação em tempo de compilação; const apenas impede modificação mas pode ser inicializado em runtime",
          "São sinônimos exatos",
          "constexpr é para strings apenas",
          "const é avaliado em compilação",
        ],
        c: 0,
        e: "const: valor não muda após inicialização, mas pode ser inicializado em runtime (const int x = rand()). constexpr: DEVE ser avaliável em compile-time. constexpr functions podem ser executadas em compilação se inputs são constexpr. C++20: consteval (obrigatório em compile-time).",
        x: "constexpr int fib(int n) { return n <= 1 ? n : fib(n-1) + fib(n-2); } constexpr int f10 = fib(10); // calculado em compilação! static_assert(f10 == 55); // validação compile-time. const int x = rand(); // OK. constexpr int y = rand(); // ERRO.",
      },
    ],
  },

  // ── C# ──
  "C#": {
    Fácil: [
      {
        q: "Em C#, qual keyword é usada para definir uma classe que não pode ser instanciada e serve apenas como base para herança?",
        o: ["abstract", "sealed", "static", "virtual"],
        c: 0,
        e: "A keyword 'abstract' define uma classe que não pode ser instanciada diretamente — só pode ser usada como classe base. Pode conter métodos abstratos (sem corpo) que subclasses são obrigadas a implementar, e métodos concretos com implementação.",
        x: "abstract class Shape { public abstract double Area(); public void Print() { Console.WriteLine(Area()); } } class Circle : Shape { public override double Area() => Math.PI * r * r; }",
      },
      {
        q: "Em C#, qual a diferença entre 'value types' e 'reference types'?",
        o: [
          "Value types (struct, int) ficam na stack e são copiados; reference types (class, string) ficam no heap e usam referências",
          "São iguais",
          "Value types são mais lentos",
          "Reference types não podem ser nulos",
        ],
        c: 0,
        e: "Value types (int, bool, struct, enum) são armazenados na stack e a atribuição copia o valor. Reference types (class, interface, delegate, array) são armazenados no heap e a atribuição copia a referência (ponteiro). Value types são mais eficientes para dados pequenos e imutáveis.",
        x: "int a = 5; int b = a; b = 10; // a continua 5 (cópia). var list1 = new List<int>{1}; var list2 = list1; list2.Add(2); // list1 também tem 2 (mesma referência).",
      },
      {
        q: "Em C#, o que é LINQ e como ele simplifica consultas em coleções?",
        o: [
          "Language Integrated Query: sintaxe de consulta integrada à linguagem para filtrar, ordenar e transformar dados",
          "Framework de banco de dados",
          "Biblioteca de UI",
          "Tipo de loop",
        ],
        c: 0,
        e: "LINQ permite escrever consultas sobre coleções (arrays, listas, XML, bancos de dados) usando sintaxe integrada à linguagem. Oferece métodos como Where(), Select(), OrderBy(), GroupBy() (method syntax) ou from/where/select (query syntax). Funciona com qualquer IEnumerable<T>.",
        x: "var adultos = pessoas.Where(p => p.Idade >= 18).OrderBy(p => p.Nome).Select(p => p.Nome); // Ou: var adultos = from p in pessoas where p.Idade >= 18 orderby p.Nome select p.Nome;",
      },
      {
        q: "O que são value types e reference types em C#?",
        o: [
          "Value types (struct, int) armazenam dados na stack; reference types (class, string) armazenam referência na stack e dados no heap",
          "São idênticos",
          "Value types são imutáveis",
          "Reference types são mais rápidos",
        ],
        c: 0,
        e: "Value types (int, bool, struct, enum): armazenados diretamente (stack ou inline). Cópia copia o valor. Reference types (class, string, array): variável contém referência (ponteiro) para dados no heap. Cópia copia a referência (ambos apontam para o mesmo objeto).",
        x: "int a = 5; int b = a; b = 10; // a ainda é 5 (value type, cópia). var list1 = new List<int>{1}; var list2 = list1; list2.Add(2); // list1 também tem {1,2} (reference type, mesma referência).",
      },
      {
        q: "O que é o operador null-conditional (?.) e null-coalescing (??) em C#?",
        o: [
          "?. acessa membros só se não for null; ?? fornece valor padrão quando a expressão é null",
          "Operadores matemáticos",
          "Operadores de comparação",
          "Operadores bit a bit",
        ],
        c: 0,
        e: "?. (null conditional): user?.Address?.City retorna null se qualquer parte for null, sem NullReferenceException. ?? (null coalescing): name ?? 'Unknown' retorna 'Unknown' se name for null. ??= (null coalescing assignment): name ??= 'Default' atribui só se null.",
        x: "string? city = user?.Address?.City ?? 'N/A'; // Se user ou Address for null, city = 'N/A'. int length = name?.Length ?? 0; // Se name for null, length = 0.",
      },
      {
        q: "O que é um namespace em C# e qual sua função na organização do código?",
        o: [
          "Agrupamento lógico de tipos que evita conflitos de nome entre bibliotecas e módulos",
          "Pasta física no disco",
          "Tipo de classe abstrata",
          "Modo de compilação",
        ],
        c: 0,
        e: "Namespaces organizam tipos (classes, structs, enums, interfaces) hierarquicamente. Evitam conflitos: System.IO.File vs MyApp.IO.File. Acessados com 'using System.Collections.Generic;'. C# 10+: file-scoped namespace (namespace MyApp; sem chaves) simplifica o arquivo.",
        x: "namespace MyApp.Models { public class User { } } // Acesso: MyApp.Models.User ou using MyApp.Models; User u = new User(); // C# 10: namespace MyApp.Models; (sem chaves, 1 por arquivo).",
      },
      {
        q: "O que são propriedades (properties) em C# e como diferem de campos públicos?",
        o: [
          "Membros com get/set que encapsulam acesso a dados, permitindo validação e lógica customizada",
          "São idênticos a campos públicos",
          "Só existem em interfaces",
          "São variáveis estáticas",
        ],
        c: 0,
        e: "Properties usam accessors get/set para encapsular campos. Vantagens sobre campos: validação no set, lógica computada no get, data binding em UI, serialização configurável. Auto-properties (public string Name { get; set; }) geram backing field automaticamente.",
        x: 'public class User { private string _name; public string Name { get => _name; set => _name = value ?? throw new ArgumentNullException(); } public int Age { get; set; } // auto-property. public string Display => $"{Name} ({Age})"; // read-only computed. }',
      },
    ],
    Médio: [
      {
        q: "Em C#, o que são os modificadores 'async' e 'await' e como eles facilitam programação assíncrona?",
        o: [
          "async marca um método como assíncrono que retorna Task; await pausa a execução até a Task completar sem bloquear a thread",
          "async cria uma nova thread; await a encerra",
          "São usados apenas para operações de banco de dados",
          "async torna o código mais lento por segurança",
        ],
        c: 0,
        e: "O modificador 'async' indica que o método contém operações assíncronas e retorna Task ou Task<T>. O 'await' pausa a execução do método naquele ponto, liberando a thread para outras tarefas. Quando a operação assíncrona completa, a execução retoma a partir do await. Não cria threads extras.",
        x: "async Task<string> FetchDataAsync() { var response = await httpClient.GetAsync(url); // thread liberada durante I/O return await response.Content.ReadAsStringAsync(); }",
      },
      {
        q: "Em C#, o que são 'extension methods' e como eles permitem adicionar métodos a tipos existentes?",
        o: [
          "Métodos estáticos que aparecem como métodos de instância em types existentes, sem modificar a classe original",
          "Herança múltipla",
          "Métodos que estendem a RAM",
          "Overloads de operadores",
        ],
        c: 0,
        e: "Extension methods são métodos estáticos em classes estáticas cujo primeiro parâmetro usa 'this'. Permitem 'adicionar' métodos a qualquer tipo (inclusive sealed classes e interfaces) sem herança. LINQ é implementado inteiramente com extension methods sobre IEnumerable<T>.",
        x: "static class StringExtensions { public static bool IsEmail(this string s) => s.Contains('@'); } // Uso: 'ana@email.com'.IsEmail(); // true — parece método de string, mas é extension.",
      },
      {
        q: "Em C#, o que são delegates e events e como eles implementam o padrão Observer?",
        o: [
          "Delegates são tipos que referenciam métodos; events são delegates encapsulados que permitem inscrição/notificação",
          "São classes abstratas",
          "São threads",
          "São tipos de exceção",
        ],
        c: 0,
        e: "Delegates são objetos type-safe que referenciam métodos com assinatura específica (como function pointers tipados). Events usam delegates com encapsulamento: só a classe declarante pode disparar (Invoke), outros podem apenas inscrever (+=) ou desinscrever (-=). Base do padrão Observer em C#.",
        x: "public event EventHandler<OrderEventArgs> OrderCreated; // Inscrever: orderService.OrderCreated += OnOrderCreated; // Disparar (dentro da classe): OrderCreated?.Invoke(this, args);",
      },
      {
        q: "O que é async/await em C# e como funciona o Task?",
        o: [
          "async marca método como assíncrono que retorna Task; await pausa execução até Task completar sem bloquear thread",
          "Cria threads novas",
          "Só funciona em console apps",
          "Substitui try/catch",
        ],
        c: 0,
        e: "async/await em C# usa state machine para suspender e retomar execução sem bloquear a thread (diferente de Thread.Sleep que bloqueia). Task<T> é o tipo de retorno para operações assíncronas. Uso com I/O (rede, disco) libera a thread para processar outras requisições.",
        x: "async Task<string> FetchDataAsync() { var response = await httpClient.GetAsync(url); return await response.Content.ReadAsStringAsync(); } // Thread liberada durante rede. Vs FetchData() bloqueante: thread presa esperando.",
      },
      {
        q: "O que são extension methods em C# e quando usá-los?",
        o: [
          "Métodos estáticos que parecem métodos de instância de outra classe, adicionando funcionalidade sem modificá-la",
          "Métodos que estendem a memória",
          "Herança múltipla",
          "Métodos abstratos",
        ],
        c: 0,
        e: "Extension methods: métodos estáticos em classe estática com 'this' no primeiro parâmetro. Chamados como se fossem métodos de instância. LINQ é construído inteiramente com extension methods (Where, Select, OrderBy são extensions de IEnumerable<T>).",
        x: "public static class StringExtensions { public static bool IsEmail(this string s) => s.Contains('@'); } 'ana@email.com'.IsEmail(); // true — parece método de string, mas é extension.",
      },
      {
        q: "O que são generics em C# e qual a vantagem sobre usar 'object'?",
        o: [
          "Tipos parametrizados que garantem type safety em compilação e evitam boxing/unboxing de value types",
          "São mais lentos que object",
          "Só funcionam com reference types",
          "Geram reflection em runtime",
        ],
        c: 0,
        e: "Generics: List<int> vs ArrayList (object). Vantagens: type safety em compilação (erro antes de runtime), sem boxing/unboxing de value types (int→object custa alocação no heap), melhor performance. Constraints: where T : IComparable, where T : class, where T : new().",
        x: "List<int> nums = new List<int>(); nums.Add(42); // sem boxing. int n = nums[0]; // sem casting. ArrayList old = new ArrayList(); old.Add(42); // boxing int→object. int x = (int)old[0]; // unboxing + cast.",
      },
      {
        q: "O que é Dependency Injection nativa no ASP.NET Core e como funciona?",
        o: [
          "Container IoC built-in que injeta dependências via construtor, com lifetimes Transient, Scoped e Singleton",
          "Injeção de SQL",
          "Pattern exclusivo de testes",
          "Técnica de otimização de memória",
        ],
        c: 0,
        e: "ASP.NET Core tem container DI nativo. Lifetimes: Transient (nova instância por injeção), Scoped (uma por request HTTP), Singleton (uma por app). Registra serviços em Program.cs. Injeção via construtor é o padrão. Promove testabilidade e desacoplamento.",
        x: "builder.Services.AddScoped<IUserRepo, UserRepo>(); builder.Services.AddSingleton<ICacheService, RedisCacheService>(); // Controller: public class UsersController(IUserRepo repo) { } // repo injetado automaticamente.",
      },
    ],
    Difícil: [
      {
        q: "Em C#, qual é a diferença entre 'Span<T>' e 'Memory<T>' e quando usar cada um?",
        o: [
          "Span<T> vive na stack e não pode ser usado em async; Memory<T> vive no heap e pode ser armazenado e usado em async",
          "São sinônimos",
          "Memory<T> é mais rápido que Span<T>",
          "Span<T> é para strings e Memory<T> para arrays",
        ],
        c: 0,
        e: "Span<T> é um ref struct que vive na stack, fornecendo acesso zero-copy a regiões contíguas de memória (arrays, strings, memória nativa). Por ser ref struct, não pode ser boxed, armazenado em campos de classe ou usado em métodos async. Memory<T> é similar mas vive no heap, podendo ser armazenado e usado em contextos async.",
        x: "void Process(Span<byte> data) { /* OK, sincrono */ } async Task ProcessAsync(Memory<byte> data) { var span = data.Span; /* usa span localmente dentro do await */ }",
      },
      {
        q: "Em C#, o que são Records (C# 9+) e como diferem de classes tradicionais?",
        o: [
          "Tipos imutáveis por padrão com igualdade por valor, with-expressions e deconstruction embutidos",
          "São tabelas de banco de dados",
          "São arrays tipados",
          "São idênticos a classes",
        ],
        c: 0,
        e: "Records são tipos de referência (record class) ou valor (record struct) otimizados para dados imutáveis. Fornecem: igualdade por valor (Equals compara propriedades, não referência), ToString legível, with-expression para cópias com modificações, e deconstruction automática.",
        x: "record Person(string Name, int Age); var p1 = new Person('Ana', 25); var p2 = p1 with { Age = 26 }; // cópia com Age modificado. p1 == new Person('Ana', 25); // true — igualdade por valor.",
      },
      {
        q: "Em C#, o que é o pattern matching avançado (C# 8-11) e quais padrões estão disponíveis?",
        o: [
          "Expressões que testam forma e conteúdo de dados: type, property, relational, logical, list patterns",
          "Regex embutido",
          "Switch tradicional apenas",
          "Apenas instanceof",
        ],
        c: 0,
        e: "Pattern matching em C# evoluiu para incluir: type patterns (is string s), property patterns ({ Length: > 5 }), relational (>= 18), logical (and, or, not), tuple patterns, positional patterns, list patterns ([_, .., last]). Usado com is, switch expression e switch statement.",
        x: "var desc = person switch { { Age: < 13 } => 'criança', { Age: >= 13 and < 18 } => 'adolescente', { Age: >= 18 } => 'adulto' }; int[] arr = {1,2,3}; if (arr is [1, .., var last]) // list pattern.",
      },
      {
        q: "O que são records em C# e como diferem de classes?",
        o: [
          "Tipos imutáveis por padrão com igualdade por valor, deconstruction e with-expression para cópias modificadas",
          "São idênticos a classes",
          "Só podem ter strings",
          "Não suportam herança",
        ],
        c: 0,
        e: "Records (C# 9+): reference types com semântica de valor. Geram automaticamente: Equals/GetHashCode por valor, ToString formatado, Deconstruct, e with-expression para cópia com modificação. Record struct (C# 10): value type com mesmos benefícios.",
        x: "record Person(string Name, int Age); var p1 = new Person('Ana', 25); var p2 = p1 with { Age = 26 }; // cópia com Age alterado. p1 == new Person('Ana', 25); // true (igualdade por valor).",
      },
      {
        q: "O que é Source Generators em C# e como difere de reflection?",
        o: [
          "Geram código C# em tempo de compilação analisando o código existente, evitando overhead de reflection em runtime",
          "Geradores de código em runtime",
          "Ferramentas de refactoring",
          "Templates de projeto",
        ],
        c: 0,
        e: "Source Generators (C# 9+): análogos a macros procedurais de Rust. Analisam o código fonte e geram código C# adicional durante a compilação. Eliminam reflection para serialização (System.Text.Json), logging, DI. Zero overhead em runtime.",
        x: "[JsonSerializable(typeof(User))] partial class MyContext : JsonSerializerContext { } // Source generator cria serializador otimizado em compile-time. Sem reflection: 10x mais rápido que Newtonsoft.Json, AOT-friendly.",
      },
      {
        q: "O que é ref struct em C# e por que Span<T> é implementado como um?",
        o: [
          "Struct que só pode existir na stack, impedindo boxing e captura em closures; Span<T> precisa disso para segurança de memória",
          "Struct passada por referência",
          "Struct com garbage collection especial",
          "Struct imutável",
        ],
        c: 0,
        e: "ref struct é alocado exclusivamente na stack. Restrições: não pode ser campo de classe, boxed, capturado em lambda/async, ou implementar interfaces. Span<T> é ref struct porque contém managed pointer — se fosse para o heap, o GC poderia mover o target e invalidar o ponteiro.",
        x: "ref struct MySpan { Span<byte> data; } // OK. class Container { Span<byte> data; } // ERRO: ref struct não pode ser campo de classe. async Task ProcessAsync() { Span<byte> s = ...; await ...; // ERRO: Span não pode cruzar await. Use Memory<T>. }",
      },
      {
        q: "O que é IAsyncEnumerable<T> em C# e como combina streaming com async?",
        o: [
          "Interface para produzir sequências de dados assincronamente item a item, com await foreach",
          "Lista assíncrona que carrega tudo de uma vez",
          "Versão async de List<T>",
          "Stream de bytes para rede",
        ],
        c: 0,
        e: "IAsyncEnumerable<T> (C# 8) permite yield return assíncrono. Produz items sob demanda (lazy) com awaits entre cada item. Ideal para streaming de dados de banco, APIs paginadas, processamento de arquivos grandes. Consumido com 'await foreach'. Suporta cancelamento.",
        x: "async IAsyncEnumerable<User> GetUsersAsync([EnumeratorCancellation] CancellationToken ct = default) { await foreach (var row in db.StreamAsync(sql, ct)) { yield return Map(row); } } // Consumo: await foreach (var user in GetUsersAsync()) { Process(user); }",
      },
    ],
  },

  // ── Go ──
  Go: {
    Fácil: [
      {
        q: "Em Go, qual construção da linguagem é usada para executar uma função concorrentemente?",
        o: ["goroutine (keyword go)", "thread", "async/await", "fork"],
        c: 0,
        e: "Em Go, adicionar a keyword 'go' antes de uma chamada de função cria uma goroutine — uma thread leve gerenciada pelo runtime do Go. Goroutines são multiplexadas sobre threads do SO, permitindo milhões de goroutines concorrentes com baixo overhead de memória (~2KB de stack inicial).",
        x: "go processarPedido(pedido) — executa processarPedido concorrentemente. A função chamadora continua imediatamente sem esperar.",
      },
      {
        q: "Em Go, qual é a função da keyword 'defer' e em que ordem as chamadas deferidas são executadas?",
        o: [
          "defer adia a execução de uma função até o retorno da função envolvente; ordem LIFO (pilha)",
          "Executa imediatamente",
          "Executa em paralelo",
          "Ordem FIFO (fila)",
        ],
        c: 0,
        e: "defer agenda uma função para executar quando a função envolvente retornar (normalmente ou por panic). Múltiplos defers são empilhados em LIFO (Last In, First Out). É idiomático para cleanup: fechar arquivos, liberar locks, liberar conexões.",
        x: "func read() { f, _ := os.Open('file.txt'); defer f.Close(); // garantido mesmo com panic. // ... usa o arquivo. } // f.Close() executado automaticamente aqui.",
      },
      {
        q: "Em Go, como o tratamento de erros funciona sem exceções?",
        o: [
          "Funções retornam o valor e um error como segundo retorno; o chamador verifica if err != nil",
          "Usa try/catch",
          "Ignora erros automaticamente",
          "Usa panic para tudo",
        ],
        c: 0,
        e: "Go não tem exceções. Funções retornam (resultado, error). O chamador verifica 'if err != nil' e trata o erro explicitamente. panic/recover existem mas são reservados para erros irrecuperáveis. Essa abordagem torna o fluxo de erros explícito e visível.",
        x: "data, err := os.ReadFile('config.json'); if err != nil { return fmt.Errorf('falha ao ler config: %w', err); } // 'err' é verificado a cada operação que pode falhar.",
      },
      {
        q: "O que são slices em Go e como diferem de arrays?",
        o: [
          "Slices são referências dinâmicas para arrays com length e capacity; arrays têm tamanho fixo",
          "São idênticos",
          "Arrays são dinâmicos em Go",
          "Slices são imutáveis",
        ],
        c: 0,
        e: "Arrays Go: tamanho fixo ([5]int), parte do tipo ([5]int ≠ [3]int). Slices: referência para array subjacente com len e cap dinâmicos ([]int). Slices são usados 99% das vezes. append() pode alocar novo array se cap for excedida.",
        x: "arr := [3]int{1,2,3} // array fixo. s := arr[:] // slice apontando para arr. s = append(s, 4) // cap excedida: Go aloca novo array, copia dados. len(s)==4, cap(s)==6 (dobrou).",
      },
      {
        q: "O que é defer em Go e quando usá-lo?",
        o: [
          "Adia a execução de uma função para quando a função atual retornar; útil para cleanup (fechar arquivo, unlock mutex)",
          "Adia para o próximo goroutine",
          "Cancela a função",
          "Executa em outra thread",
        ],
        c: 0,
        e: "defer garante que uma função será chamada quando a função atual retornar (mesmo em caso de panic). Múltiplos defers executam em ordem LIFO (pilha). Uso comum: fechar arquivos, unlock mutexes, flush buffers, log de duração.",
        x: "func readFile(path string) { f, err := os.Open(path); if err != nil { return; } defer f.Close(); // garante fechamento mesmo com erro. data := read(f); process(data); } // f.Close() roda aqui.",
      },
      {
        q: "O que é o operador ':=' em Go e como difere da declaração com 'var'?",
        o: [
          ":= declara e inicializa com tipo inferido (short declaration); var declara explicitamente, podendo omitir inicialização",
          "São idênticos",
          ":= é para constantes",
          "var não existe em Go",
        ],
        c: 0,
        e: ":= (short variable declaration): só dentro de funções, infere tipo do valor. var: funciona em qualquer escopo (inclusive pacote), pode declarar sem inicializar (zero value). var x int = 5 vs x := 5. := não pode ser usado em escopo de pacote.",
        x: "x := 42 // int inferido. name := 'Go' // string inferido. var count int // zero value = 0. var msg string // zero value = ''. // No escopo de pacote: var Version = '1.0' // OK. Version := '1.0' // ERRO: := não permitido fora de funções.",
      },
      {
        q: "O que é a keyword 'range' em Go e como usá-la em loops?",
        o: [
          "Itera sobre slices, arrays, maps, strings e channels retornando índice/chave e valor",
          "Gera números sequenciais",
          "Define limites de variáveis",
          "Cria intervalos numéricos como em Python",
        ],
        c: 0,
        e: "range retorna (índice, valor) para slices/arrays, (chave, valor) para maps, (índice, rune) para strings, e (valor) para channels. Use _ para ignorar um retorno. For sem range usa sintaxe C-like: for i := 0; i < n; i++.",
        x: "nums := []int{10, 20, 30}; for i, v := range nums { fmt.Println(i, v) } // 0 10, 1 20, 2 30. m := map[string]int{'a': 1}; for k, v := range m { fmt.Println(k, v) } // a 1. for _, v := range nums { } // ignora índice.",
      },
    ],
    Médio: [
      {
        q: "Em Go, qual é o mecanismo padrão para comunicação segura entre goroutines?",
        o: [
          "Channels (canais)",
          "Mutex global",
          "Variáveis compartilhadas",
          "Callbacks",
        ],
        c: 0,
        e: "Channels são o mecanismo padrão de comunicação entre goroutines em Go, seguindo o princípio 'não comunique compartilhando memória; compartilhe memória comunicando'. Channels podem ser unbuffered (síncronos) ou buffered, e enviar/receber são operações thread-safe.",
        x: "ch := make(chan int, 10) // channel buffered. go func() { ch <- 42 }() // envia. valor := <-ch // recebe: 42.",
      },
      {
        q: "Em Go, o que são slices e como diferem de arrays?",
        o: [
          "Arrays têm tamanho fixo em tempo de compilação; slices são visões dinâmicas sobre arrays que podem crescer",
          "São idênticos",
          "Slices são mais lentos",
          "Arrays podem crescer",
        ],
        c: 0,
        e: "Em Go, arrays têm tamanho fixo definido em tempo de compilação ([5]int). Slices ([]int) são referências a arrays com tamanho dinâmico. Slices têm length (len) e capacity (cap). append() cria novo array subjacente se cap for excedido. Slices são muito mais usados.",
        x: "s := []int{1, 2, 3} // slice, len=3, cap=3. s = append(s, 4) // len=4, cap=6 (dobrou). arr := [3]int{1, 2, 3} // array fixo, não pode crescer.",
      },
      {
        q: "Em Go, o que é o 'select' statement e como ele funciona com channels?",
        o: [
          "Permite esperar em múltiplas operações de channel simultaneamente, executando a primeira que estiver pronta",
          "Switch para strings",
          "Loop infinito",
          "Import de pacotes",
        ],
        c: 0,
        e: "select é como switch, mas para channels. Bloqueia até um dos cases ter um channel pronto para enviar/receber. Se múltiplos estão prontos, escolhe aleatoriamente. Com default, não bloqueia. É essencial para multiplexar operações de I/O e timeouts.",
        x: "select { case msg := <-ch1: fmt.Println(msg); case ch2 <- 42: fmt.Println('enviado'); case <-time.After(5*time.Second): fmt.Println('timeout'); } // espera o primeiro channel pronto.",
      },
      {
        q: "O que é o conceito de interfaces implícitas em Go?",
        o: [
          "Um tipo implementa uma interface automaticamente ao ter todos os métodos necessários, sem declaração explícita",
          "Precisa da keyword implements",
          "Interfaces são herdadas",
          "Só structs implementam interfaces",
        ],
        c: 0,
        e: "Em Go, não existe 'implements'. Se um tipo tem os métodos da interface, ele a satisfaz automaticamente (duck typing estático). io.Reader exige Read([]byte) (int, error). Qualquer tipo com esse método é um Reader. Permite desacoplamento sem dependência explícita.",
        x: "type Stringer interface { String() string }. type Dog struct{}; func (d Dog) String() string { return 'Woof' }. var s Stringer = Dog{} // compila sem 'implements'. fmt.Println(s) // 'Woof'.",
      },
      {
        q: "O que é o context package em Go e por que é importante?",
        o: [
          "Pacote para propagar cancelamento, deadlines e valores entre goroutines e chamadas de função",
          "Contexto de execução do OS",
          "Gerenciador de memória",
          "Pacote de logging",
        ],
        c: 0,
        e: "context.Context é passado como primeiro argumento de funções. Permite: cancelamento (WithCancel), timeout (WithTimeout), deadline (WithDeadline), valores (WithValue). Essencial para: HTTP handlers, queries de banco, chamadas entre serviços. Previne goroutine leaks.",
        x: "ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second); defer cancel(); result, err := db.QueryContext(ctx, sql); // Se query demorar >5s, ctx cancela automaticamente.",
      },
      {
        q: "O que são goroutine leaks em Go e como preveni-las?",
        o: [
          "Goroutines que ficam bloqueadas para sempre em channel/IO, consumindo memória; previne-se com context e timeouts",
          "Memory leaks no garbage collector",
          "Erros de sintaxe em goroutines",
          "Leaks de file descriptors",
        ],
        c: 0,
        e: "Goroutine leak: goroutine bloqueada em channel sem writer/reader, ou esperando I/O sem timeout. Cada goroutine consome ~2-8KB. Milhares de leaks = OOM. Prevenção: use context com timeout/cancel, feche channels quando terminar, use select com case <-ctx.Done().",
        x: "// LEAK: func fetch(url string) { ch := make(chan string); go func() { resp := http.Get(url); ch <- resp }(); // se ninguém lê ch, goroutine fica presa para sempre. } // FIX: ctx, cancel := context.WithTimeout(ctx, 5*time.Second); defer cancel(); select { case r := <-ch: ... case <-ctx.Done(): return }",
      },
      {
        q: "O que é sync.WaitGroup em Go e para que serve?",
        o: [
          "Mecanismo para esperar um grupo de goroutines terminar, usando Add, Done e Wait",
          "Mutex para sincronização",
          "Pool de goroutines",
          "Canal com buffer",
        ],
        c: 0,
        e: "WaitGroup: contador de goroutines pendentes. Add(n) incrementa, Done() decrementa (defer wg.Done()), Wait() bloqueia até contador = 0. Mais simples que channels para 'fire-and-wait'. Não propaga erros — para isso use errgroup.",
        x: "var wg sync.WaitGroup; for _, url := range urls { wg.Add(1); go func(u string) { defer wg.Done(); fetch(u); }(url); } wg.Wait(); // bloqueia até todas as goroutines terminarem. fmt.Println('todas prontas');",
      },
    ],
    Difícil: [
      {
        q: "Em Go, como a implementação de interfaces difere de linguagens como Java e qual é a implicação para design de código?",
        o: [
          "Go usa 'structural typing' implícito: um tipo satisfaz uma interface se implementar seus métodos, sem declarar explicitamente",
          "Go requer implements explícito como Java",
          "Go não suporta interfaces",
          "Interfaces em Go são idênticas a classes abstratas em Java",
        ],
        c: 0,
        e: "Em Go, interfaces são satisfeitas implicitamente (structural/duck typing). Se um tipo implementa todos os métodos de uma interface, ele a satisfaz sem usar 'implements'. Isso permite definir interfaces no pacote consumidor, não no pacote implementador, promovendo desacoplamento e interfaces menores.",
        x: "type Writer interface { Write([]byte) (int, error) } // Qualquer tipo com método Write([]byte)(int,error) satisfaz Writer automaticamente — inclusive os.File, bytes.Buffer, http.ResponseWriter.",
      },
      {
        q: "Em Go, o que é o 'context' package e por que é essencial para aplicações de servidor?",
        o: [
          "Propaga deadlines, cancelamento e valores request-scoped através da cadeia de chamadas entre goroutines",
          "Gerencia conexões de banco",
          "Cache de dados",
          "Logging framework",
        ],
        c: 0,
        e: "context.Context propaga sinais de cancelamento e deadlines pela árvore de goroutines. Quando um request HTTP é cancelado (cliente desconectou), o context cancela todas as operações derivadas (queries DB, chamadas a serviços externos). É o primeiro parâmetro idiomático em Go.",
        x: "func handler(w http.ResponseWriter, r *http.Request) { ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second); defer cancel(); result, err := db.QueryContext(ctx, 'SELECT ...'); // cancela automaticamente se timeout ou cliente desconectar. }",
      },
      {
        q: "Em Go, como o garbage collector funciona e quais são suas características de latência?",
        o: [
          "GC concorrente, tri-color mark-and-sweep com pausas sub-milissegundo, focado em baixa latência",
          "GC stop-the-world como Java antigo",
          "Não tem GC, é manual como C",
          "Reference counting como Python",
        ],
        c: 0,
        e: "O GC do Go usa mark-and-sweep concorrente com tri-color marking. Roda CONCORRENTEMENTE com o programa, com pausas STW (stop-the-world) tipicamente < 1ms. Prioriza latência sobre throughput. O compilador faz escape analysis para alocar na stack quando possível, reduzindo pressão no GC.",
        x: "O GC roda em 3 fases: 1) Mark Setup (STW ~10µs). 2) Marking (concorrente, marca objetos alcançáveis). 3) Mark Termination (STW ~10µs). GOGC=100 (default) dispara GC quando heap dobra. GOMEMLIMIT (Go 1.19+) permite controle por memória.",
      },
      {
        q: "O que são generics em Go (1.18+) e como funcionam?",
        o: [
          "Parâmetros de tipo com constraints que permitem escrever funções/tipos genéricos type-safe",
          "São interfaces",
          "Casting automático",
          "Macros de código",
        ],
        c: 0,
        e: "Generics Go (1.18): func Max[T constraints.Ordered](a, b T) T {}. Constraints são interfaces que restringem tipos aceitáveis. any = interface{}, comparable = tipos que suportam ==. Monomorphization: compilador gera código específico por tipo (como C++ templates).",
        x: "func Map[T, U any](s []T, f func(T) U) []U { r := make([]U, len(s)); for i, v := range s { r[i] = f(v) }; return r }. Map([]int{1,2,3}, func(n int) string { return fmt.Sprint(n) }) // []string{'1','2','3'}.",
      },
      {
        q: "O que é o padrão errgroup em Go para concorrência estruturada?",
        o: [
          "Pacote que gerencia um grupo de goroutines, coletando erros e cancelando as demais se uma falhar",
          "Grupo de erros de compilação",
          "Agrupamento de log de erros",
          "Padrão de retry",
        ],
        c: 0,
        e: "errgroup.Group: gerencia goroutines com propagação de erro e cancelamento. g.Go(func() error {...}): lança goroutine. g.Wait(): espera todas e retorna primeiro erro. Com WithContext: se uma goroutine falhar, ctx é cancelado, sinalizando as demais.",
        x: "g, ctx := errgroup.WithContext(ctx); g.Go(func() error { return fetchUser(ctx) }); g.Go(func() error { return fetchOrders(ctx) }); if err := g.Wait(); err != nil { // primeiro erro de qualquer goroutine }.",
      },
      {
        q: "O que é escape analysis em Go e como afeta alocação e performance?",
        o: [
          "Análise do compilador que decide se variável fica na stack (rápido) ou escapa para o heap (requer GC)",
          "Análise de segurança de código",
          "Verificação de SQL injection",
          "Análise de complexidade de algoritmo",
        ],
        c: 0,
        e: "O compilador Go analisa se uma variável 'escapa' do escopo da função (ex: retornada via ponteiro, capturada por goroutine). Se escapa → heap (GC gerencia). Se não → stack (liberação automática, zero custo). go build -gcflags='-m' mostra decisões. Reduzir escapes = menos pressão no GC.",
        x: "func noEscape() int { x := 42; return x } // x na stack. func escapes() *int { x := 42; return &x } // x escapa para heap (ponteiro retornado). // go build -gcflags='-m' → 'moved to heap: x'. Dica: retornar valor em vez de ponteiro quando possível.",
      },
      {
        q: "O que são channels direcionais em Go e como impõem segurança em compilação?",
        o: [
          "chan<- T (send-only) e <-chan T (receive-only) restringem uso do channel, prevenindo erros de comunicação",
          "Channels com prioridade",
          "Channels que ordenam mensagens",
          "Channels com timeout embutido",
        ],
        c: 0,
        e: "Channels direcionais: chan<- int (só envia), <-chan int (só recebe). O compilador impede operações inválidas. Um chan bidirecional pode ser passado como direcional (conversão implícita). Melhora a documentação da API e previne bugs.",
        x: "func producer(out chan<- int) { out <- 42 } // só pode enviar. func consumer(in <-chan int) { v := <-in } // só pode receber. ch := make(chan int); go producer(ch); go consumer(ch); // chan convertido implicitamente para direcional.",
      },
    ],
  },

  // ── Java ──
  Java: {
    Fácil: [
      {
        q: "Em Java, qual é a diferença entre '==' e o método '.equals()' ao comparar Strings?",
        o: [
          "== compara referências na memória; .equals() compara o conteúdo dos caracteres",
          "São equivalentes para Strings",
          "== é mais seguro que .equals()",
          ".equals() compara referências e == compara conteúdo",
        ],
        c: 0,
        e: "O operador == em Java compara se duas referências apontam para o mesmo objeto na memória. O método .equals() compara o conteúdo (valor) das Strings caractere por caractere. Duas Strings diferentes na memória podem ter o mesmo conteúdo.",
        x: 'String a = new String("hello"); String b = new String("hello"); a == b // false (objetos diferentes). a.equals(b) // true (mesmo conteúdo).',
      },
      {
        q: "Em Java, qual é a diferença entre 'ArrayList' e 'LinkedList'?",
        o: [
          "ArrayList usa array dinâmico (acesso O(1)); LinkedList usa nós encadeados (inserção/remoção O(1) nas extremidades)",
          "São idênticas",
          "LinkedList é mais rápida em tudo",
          "ArrayList não permite duplicatas",
        ],
        c: 0,
        e: "ArrayList: baseada em array dinâmico, acesso por índice O(1), inserção/remoção no meio O(n). LinkedList: nós duplamente encadeados, acesso por índice O(n), inserção/remoção nas pontas O(1). Na prática, ArrayList é melhor na maioria dos casos por cache locality.",
        x: "ArrayList<String> al = new ArrayList<>(); al.get(500); // O(1). LinkedList<String> ll = new LinkedList<>(); ll.get(500); // O(n), percorre 500 nós. ll.addFirst('x'); // O(1).",
      },
      {
        q: "Em Java, o que a keyword 'final' faz quando usada em variáveis, métodos e classes?",
        o: [
          "Variável: não reatribuível; método: não pode ser sobrescrito; classe: não pode ser estendida (herdada)",
          "Torna tudo privado",
          "Deleta após uso",
          "Só funciona em variáveis",
        ],
        c: 0,
        e: "final em variável: a referência não pode ser reatribuída (o objeto pode ser mutado). final em método: subclasses não podem sobrescrever (override). final em classe: não pode ser estendida (ex: String é final). Promove imutabilidade e segurança.",
        x: "final int MAX = 100; MAX = 200; // Erro. final List<String> list = new ArrayList<>(); list.add('ok'); // OK (objeto mutado). class Util extends String {} // Erro: String é final.",
      },
      {
        q: "O que é o JVM (Java Virtual Machine) e por que Java é multiplataforma?",
        o: [
          "Bytecode Java roda em qualquer plataforma que tenha uma JVM; 'Write Once, Run Anywhere'",
          "Java é compilado para código nativo",
          "JVM é um editor de código",
          "Java só roda em Linux",
        ],
        c: 0,
        e: "O compilador Java (javac) compila .java para bytecode (.class). A JVM interpreta e/ou compila JIT o bytecode para código nativo da plataforma. Cada OS tem sua JVM, mas o bytecode é o mesmo. JVM também gerencia memória (GC), threads e segurança.",
        x: "javac App.java → App.class (bytecode). java App → JVM carrega bytecode, JIT compila hot methods para código nativo. Mesmo .class roda em Windows, Linux, macOS.",
      },
      {
        q: "O que são collections em Java e quais as principais interfaces?",
        o: [
          "Framework de estruturas de dados: List (ordenada), Set (sem duplicatas), Map (chave-valor), Queue (FIFO)",
          "Apenas arrays",
          "Banco de dados em memória",
          "Tipo de variável",
        ],
        c: 0,
        e: "Collections Framework: List (ArrayList, LinkedList — ordenada, duplicatas OK). Set (HashSet, TreeSet — sem duplicatas). Map (HashMap, TreeMap — chave-valor). Queue (LinkedList, PriorityQueue — FIFO). Todas usam generics para type safety.",
        x: "List<String> names = new ArrayList<>(); names.add('Ana'); Set<Integer> ids = new HashSet<>(List.of(1,2,2)); // {1,2}. Map<String,Integer> ages = Map.of('Ana',25); ages.get('Ana'); // 25.",
      },
      {
        q: "O que é o operador 'instanceof' em Java e para que serve?",
        o: [
          "Verifica se um objeto é instância de uma classe ou interface em runtime, retornando boolean",
          "Cria uma nova instância",
          "Compara valores de strings",
          "Verifica se uma classe existe",
        ],
        c: 0,
        e: "instanceof verifica o tipo real do objeto em runtime. Retorna true se o objeto é da classe especificada ou de uma subclasse/implementação. Java 16+: pattern matching com instanceof permite cast automático (if (obj instanceof String s) — s já é String).",
        x: "Object obj = 'hello'; if (obj instanceof String s) { System.out.println(s.length()); // 5 — cast automático (Java 16+) } // Antes: if (obj instanceof String) { String s = (String) obj; }",
      },
      {
        q: "O que são interfaces em Java e como diferem de classes abstratas?",
        o: [
          "Interfaces definem contrato (métodos sem estado); classes abstratas podem ter estado e implementação parcial",
          "São idênticas",
          "Interfaces têm construtores",
          "Classes abstratas não têm métodos",
        ],
        c: 0,
        e: "Interface: contrato puro (métodos abstratos), sem estado (só constantes), suporta múltipla implementação. Classe abstrata: pode ter estado (campos), construtores, métodos concretos, só herança única. Java 8+: interfaces podem ter default methods (implementação padrão).",
        x: "interface Drawable { void draw(); default void reset() { /* impl padrão */ } } abstract class Shape { int x, y; abstract double area(); void move(int dx, int dy) { x += dx; y += dy; } } class Circle extends Shape implements Drawable { }",
      },
    ],
    Médio: [
      {
        q: "Em Java, qual é a finalidade dos Generics e como eles garantem type safety em tempo de compilação?",
        o: [
          "Permitem parametrizar tipos em classes/métodos, detectando erros de tipo em compilação em vez de runtime",
          "Permitem herança múltipla",
          "São usados apenas para coleções",
          "Adicionam checagem de tipos em runtime",
        ],
        c: 0,
        e: "Generics permitem definir classes, interfaces e métodos com tipos parametrizados. O compilador verifica a consistência dos tipos, evitando ClassCastException em runtime. Devido ao type erasure, as informações de tipo são removidas após compilação, mantendo compatibilidade com versões anteriores.",
        x: 'List<String> nomes = new ArrayList<>(); nomes.add("Ana"); // OK. nomes.add(123); // Erro de compilação! Sem generics: List nomes = new ArrayList(); nomes.add(123); // Compila, mas ClassCastException em runtime ao fazer (String) nomes.get(0).',
      },
      {
        q: "Em Java, o que são Streams (java.util.stream) e como diferem de loops tradicionais?",
        o: [
          "API funcional para processar coleções com operações como filter/map/reduce de forma declarativa e poss. paralela",
          "São streams de I/O",
          "Substituem ArrayList",
          "São threads",
        ],
        c: 0,
        e: "Streams API (Java 8+) permite processar coleções de forma funcional e declarativa. Operações intermediárias (filter, map, sorted) são lazy. Operações terminais (collect, forEach, reduce) disparam o processamento. parallelStream() paraleliza automaticamente.",
        x: "List<String> nomes = pessoas.stream().filter(p -> p.getIdade() >= 18).map(Person::getNome).sorted().collect(Collectors.toList()); // Declarativo vs for loop com if/add.",
      },
      {
        q: "Em Java, o que é a diferença entre 'checked' e 'unchecked' exceptions?",
        o: [
          "Checked devem ser declaradas/tratadas em compile time; unchecked (RuntimeException) não exigem tratamento explícito",
          "São idênticas",
          "Unchecked são mais graves",
          "Checked são mais rápidas",
        ],
        c: 0,
        e: "Checked exceptions (IOException, SQLException) herdam de Exception e DEVEM ser tratadas com try-catch ou declaradas com throws — o compilador exige. Unchecked (NullPointerException, IllegalArgumentException) herdam de RuntimeException e não exigem tratamento explícito. Erros de programação geralmente são unchecked.",
        x: "// Checked: void readFile() throws IOException { FileReader f = new FileReader('x'); } // Compilador exige throws. // Unchecked: int x = list.get(99); // IndexOutOfBoundsException — não exige try-catch.",
      },
      {
        q: "O que são Streams em Java 8+ e como diferem de collections?",
        o: [
          "Pipeline funcional para processar sequências de dados com operações lazy; não armazenam dados como collections",
          "Tipo de I/O",
          "Collections mais rápidas",
          "Threads paralelas",
        ],
        c: 0,
        e: "Streams: pipeline de operações funcionais (filter, map, reduce) sobre dados. Lazy: operações intermediárias só executam quando terminal é chamada. Não modificam a fonte. parallelStream() para paralelismo. Collections armazenam; Streams processam.",
        x: "List<String> names = users.stream().filter(u -> u.getAge() >= 18).map(User::getName).sorted().collect(Collectors.toList()); // Pipeline: filtra adultos → extrai nomes → ordena → coleta.",
      },
      {
        q: "O que é o Spring Framework e por que é usado em Java?",
        o: [
          "Framework enterprise com IoC/DI, MVC, data access e segurança; Spring Boot simplifica configuração",
          "Framework de UI",
          "Compilador Java",
          "Banco de dados",
        ],
        c: 0,
        e: "Spring: framework mais popular para Java enterprise. Core: IoC container + DI. Spring MVC: APIs REST. Spring Data: abstrai persistência. Spring Security: autenticação/autorização. Spring Boot: convenção sobre configuração, auto-config, servidor embutido.",
        x: "@RestController class UserController { @Autowired UserService service; @GetMapping('/users') List<User> list() { return service.findAll(); } } // DI injeta service, @GetMapping mapeia endpoint. Zero XML.",
      },
      {
        q: "O que são annotations em Java e como @Override funciona?",
        o: [
          "Metadados em código processados pelo compilador ou runtime; @Override valida que o método sobrescreve o da superclasse",
          "Comentários especiais",
          "Decoradores como em Python",
          "Macros de pré-processador",
        ],
        c: 0,
        e: "Annotations: @NomeAnotacao são metadados processados em compile-time ou runtime. @Override: compilador verifica que o método realmente sobrescreve um método da superclasse — erro de compilação se não. Outras: @Deprecated, @SuppressWarnings, @FunctionalInterface. Custom annotations com @interface.",
        x: "class Animal { void speak() {} } class Dog extends Animal { @Override void speak() { System.out.println('Woof'); } // OK @Override void spek() {} // ERRO de compilação: spek não existe na superclasse }",
      },
      {
        q: "O que é Optional<T> em Java 8+ e por que evitar retornar null?",
        o: [
          "Container que pode ou não conter um valor, forçando tratamento explícito de ausência e evitando NullPointerException",
          "Tipo de coleção",
          "Wrapper para primitivos",
          "Substituto de try-catch",
        ],
        c: 0,
        e: "Optional<T> encapsula um valor possivelmente ausente. Métodos: isPresent(), ifPresent(consumer), orElse(default), orElseThrow(), map(), flatMap(). Evita NullPointerException tornando a ausência explícita. Não usar para campos ou parâmetros — apenas retorno.",
        x: "Optional<User> user = repo.findById(id); String name = user.map(User::getName).orElse('Anônimo'); // Sem Optional: User u = repo.findById(id); if (u != null) { return u.getName(); } else { return 'Anônimo'; }",
      },
    ],
    Difícil: [
      {
        q: "Em Java, o que é o 'happens-before' relationship no Java Memory Model e por que é crucial para código multithread?",
        o: [
          "Garante que alterações de memória feitas por uma thread sejam visíveis para outra em pontos de sincronização definidos",
          "Garante que threads executem em ordem alfabética",
          "É uma regra de garbage collection",
          "Define a prioridade de execução das threads",
        ],
        c: 0,
        e: "O Java Memory Model define 'happens-before' como garantia de visibilidade: se ação A happens-before ação B, os efeitos de A são visíveis para B. Exemplos: unlock de monitor HB lock subsequente, write em volatile HB read subsequente, Thread.start() HB primeira ação da thread. Sem essas garantias, threads podem ver valores stale por cache/reordering.",
        x: "volatile boolean ready = false; Thread 1: data = 42; ready = true; Thread 2: if (ready) use(data); // Sem volatile, Thread 2 pode ver ready=true mas data=0 (reordering). Com volatile, write-ready HB read-ready, garantindo data=42 visível.",
      },
      {
        q: "Em Java, o que é o class loading mechanism e como funciona o classloader hierarchy?",
        o: [
          "Sistema hierárquico de classloaders que carregam classes sob demanda seguindo delegação parent-first",
          "Compilador JIT",
          "Garbage collector",
          "Thread scheduler",
        ],
        c: 0,
        e: "Java usa 3 classloaders em hierarquia: 1) Bootstrap (carrega java.lang, rt.jar). 2) Extension/Platform (ext jars). 3) Application (classpath do usuário). Seguem parent delegation: Application delega para Extension, que delega para Bootstrap. Apenas se o pai não encontrar, o filho carrega.",
        x: "Class.forName('com.app.MyService') → Application CL pergunta ao Extension CL → pergunta ao Bootstrap CL → Bootstrap não tem → Extension não tem → Application carrega de target/classes/. Custom classloaders permitem hot-reload.",
      },
      {
        q: "Em Java 21+, o que são Virtual Threads (Project Loom) e como diferem de platform threads?",
        o: [
          "Threads leves gerenciadas pela JVM que podem criar milhões de instâncias, ideal para I/O-bound concorrente",
          "Threads do sistema operacional",
          "São coroutines como Kotlin",
          "Substituem completamente platform threads",
        ],
        c: 0,
        e: "Virtual Threads (Java 21) são threads leves montadas sobre um pool de platform threads (carrier threads). Custam ~1KB vs ~1MB de platform threads. Ideais para I/O-bound: milhões de virtual threads podem esperar I/O simultaneamente. O scheduler da JVM desmonta/remonta virtual threads nos carriers automaticamente.",
        x: "try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { IntStream.range(0, 1_000_000).forEach(i -> executor.submit(() -> { Thread.sleep(Duration.ofSeconds(1)); return i; })); } // 1 milhão de threads virtuais — impossível com platform threads.",
      },
      {
        q: "O que é o GC (Garbage Collector) em Java e quais os principais coletores?",
        o: [
          "Gerenciador automático de memória que libera objetos inalcançáveis; G1, ZGC e Shenandoah são coletores modernos",
          "Compilador de código",
          "Ferramenta de profiling",
          "Otimizador de queries",
        ],
        c: 0,
        e: "GC Java: identifica e libera objetos sem referências. Gerações: Young (Eden + Survivors) e Old. G1 (default): pausas previsíveis. ZGC (Java 15+): pausas <1ms para heaps de TB. Shenandoah: pausas ultra-baixas. Tuning: -Xmx, -XX:+UseZGC.",
        x: "App com 32GB heap: G1 → pausas de ~50ms. ZGC → pausas <1ms (concurrent compaction). Shenandoah → similar a ZGC. Serial → pausas de segundos (só para apps pequenos single-thread).",
      },
      {
        q: "O que são sealed classes em Java 17+ e qual problema resolvem?",
        o: [
          "Classes que restringem quais outras classes podem estendê-las, permitindo hierarquias fechadas e exaustivas",
          "Classes encapsuladas",
          "Classes sem construtor",
          "Classes imutáveis",
        ],
        c: 0,
        e: "sealed classes (Java 17): a classe base declara quais subclasses são permitidas (permits). O compilador garante que todas as subclasses são conhecidas. Combina com pattern matching e switch exaustivo. Modelagem de domínio com ADTs (Algebraic Data Types).",
        x: "sealed interface Shape permits Circle, Rectangle, Triangle {} record Circle(double r) implements Shape {} record Rectangle(double w, double h) implements Shape {} // switch exaustivo: case Circle c -> ...; case Rectangle r -> ...; case Triangle t -> ...",
      },
      {
        q: "O que são record types em Java 14+ e como simplificam DTOs?",
        o: [
          "Classes imutáveis com construtor, getters, equals, hashCode e toString gerados automaticamente",
          "Tabelas de banco de dados",
          "Tipos primitivos especiais",
          "Classes com métodos estáticos",
        ],
        c: 0,
        e: "Records (Java 14+): declaração compacta para data carriers imutáveis. O compilador gera: construtor canônico, getters (name(), age()), equals/hashCode por valor, toString. Não podem ter campos mutáveis. Ideais para DTOs, value objects e retornos múltiplos.",
        x: "record Point(int x, int y) {} // Gera automaticamente: construtor Point(int x, int y), métodos x(), y(), equals, hashCode, toString. var p1 = new Point(1, 2); var p2 = new Point(1, 2); p1.equals(p2); // true.",
      },
      {
        q: "O que é o pattern matching para switch em Java 21+ e como melhora o código?",
        o: [
          "Switch expressions que testam tipo, valor e estrutura do objeto, com guards e exaustividade verificada pelo compilador",
          "Regex em switch",
          "Switch com strings apenas",
          "Substituto de if-else",
        ],
        c: 0,
        e: "Pattern matching switch (Java 21): case String s → testa tipo e vincula variável. Guarded patterns: case Integer i when i > 0. Sealed classes: compilador verifica exaustividade. Record patterns: case Point(int x, int y). Elimina cascatas de instanceof.",
        x: "String describe(Object obj) { return switch (obj) { case Integer i when i > 0 -> 'positivo: ' + i; case String s -> 'string len=' + s.length(); case Point(var x, var y) -> 'ponto(' + x + ',' + y + ')'; case null -> 'nulo'; default -> 'outro'; }; }",
      },
    ],
  },

  // ── JavaScript ──
  JavaScript: {
    Fácil: [
      {
        q: "No JavaScript, qual método de array retorna um novo array contendo apenas os elementos que passam em um teste (callback)?",
        o: ["filter()", "map()", "reduce()", "forEach()"],
        c: 0,
        e: "O método filter() cria um novo array com todos os elementos para os quais a função callback retorna true. Não modifica o array original (é imutável). Se nenhum elemento passar no teste, retorna um array vazio.",
        x: "const maiores = [1, 5, 3, 8, 2].filter(n => n > 3); // [5, 8] — apenas elementos maiores que 3.",
      },
      {
        q: "No JavaScript, qual a diferença entre 'null' e 'undefined'?",
        o: [
          "undefined: variável declarada mas sem valor; null: valor intencionalmente vazio atribuído pelo programador",
          "São idênticos",
          "null é para números e undefined para strings",
          "undefined não existe",
        ],
        c: 0,
        e: "undefined indica que uma variável foi declarada mas não recebeu valor, ou um parâmetro/propriedade não existe. null é atribuído explicitamente para indicar 'sem valor intencional'. typeof undefined === 'undefined', typeof null === 'object' (bug histórico).",
        x: "let x; console.log(x); // undefined. let y = null; // intencionalmente vazio. obj.prop // undefined se prop não existe. null == undefined // true. null === undefined // false.",
      },
      {
        q: "No JavaScript, o que é destructuring e como usá-lo com arrays e objetos?",
        o: [
          "Sintaxe que extrai valores de arrays/objetos em variáveis individuais de forma concisa",
          "Método para deletar propriedades",
          "Forma de clonar objetos",
          "Operação de banco de dados",
        ],
        c: 0,
        e: "Destructuring permite extrair valores de arrays ([a, b] = [1, 2]) e propriedades de objetos ({ name, age } = person) em variáveis separadas. Suporta valores default, renomeação, rest operator e aninhamento. Muito usado em imports e parâmetros de função.",
        x: "const { name, age = 0 } = user; // extrai name e age (default 0). const [first, ...rest] = [1,2,3]; // first=1, rest=[2,3]. function greet({ name }) { } // destructuring no parâmetro.",
      },
      {
        q: "O que são arrow functions em JavaScript e como diferem de funções tradicionais?",
        o: [
          "Sintaxe curta () => {}; não têm 'this' próprio, herdam do escopo léxico pai",
          "São idênticas a function(){}",
          "Só funcionam com callbacks",
          "Não podem retornar valores",
        ],
        c: 0,
        e: "Arrow functions: sintaxe compacta, não possuem 'this' próprio (herdam do escopo externo), não podem ser usadas como construtores (new), não têm 'arguments' object. Ideais para callbacks curtos. Funções tradicionais: têm 'this' dinâmico baseado em como são chamadas.",
        x: "const obj = { name: 'Ana', greet: function() { setTimeout(() => { console.log(this.name); }, 100); } }; // Arrow herda 'this' de greet(). Com function() dentro do setTimeout, 'this' seria undefined.",
      },
      {
        q: "O que são módulos ES (ESM) em JavaScript?",
        o: [
          "Sistema nativo de módulos com import/export para organizar código em arquivos independentes",
          "Bibliotecas externas",
          "Plugins do Node.js",
          "Funções globais",
        ],
        c: 0,
        e: "ES Modules (ESM): sistema de módulos nativo do JS (import/export). Cada arquivo é um módulo com escopo próprio. Named export: export function foo() {}. Default export: export default class X {}. Import: import { foo } from './mod'. Substituem CommonJS (require) no ecossistema moderno.",
        x: "// math.js: export const PI = 3.14; export function sum(a, b) { return a+b; }. // app.js: import { PI, sum } from './math.js'; sum(1, 2); // 3. import * as math from './math.js'; math.PI; // 3.14.",
      },
      {
        q: "O que é o spread operator (...) em JavaScript e quais seus usos?",
        o: [
          "Expande arrays/objetos em elementos individuais; usado para cópias, merge e passagem de argumentos",
          "Operador de divisão",
          "Declaração de variáveis múltiplas",
          "Operador de comparação",
        ],
        c: 0,
        e: "Spread (...): expande iteráveis em elementos. Em arrays: [...a, ...b] concatena. Em objetos: {...obj, key: val} faz shallow copy com override. Em funções: func(...args) recebe como array (rest). Shallow copy: não clona objetos aninhados.",
        x: "const a = [1, 2]; const b = [...a, 3, 4]; // [1, 2, 3, 4]. const obj = { x: 1 }; const obj2 = { ...obj, y: 2 }; // { x: 1, y: 2 }. Math.max(...[5, 3, 8]); // 8.",
      },
      {
        q: "O que são template literals em JavaScript e como diferem de strings normais?",
        o: [
          "Strings com crase (`) que suportam interpolação ${expr}, múltiplas linhas e tagged templates",
          "Strings com aspas duplas",
          "Templates HTML",
          "Constantes de texto",
        ],
        c: 0,
        e: "Template literals usam crase (`). Interpolação: ${expression} avalia qualquer expressão JS. Multi-line: quebras de linha preservadas. Tagged templates: func`text ${val}` — a função recebe strings e valores separados (usado em styled-components, GraphQL).",
        x: "const name = 'Ana'; const msg = `Olá, ${name}! Você tem ${2+1} msgs.`; // 'Olá, Ana! Você tem 3 msgs.' // Tagged: const html = tag`<p>${name}</p>`; // tag recebe strings e valores para sanitizar.",
      },
    ],
    Médio: [
      {
        q: "No JavaScript, o que são closures e como elas afetam o escopo de variáveis?",
        o: [
          "Uma closure é uma função que retém acesso ao escopo léxico onde foi criada, mesmo após esse escopo ter encerrado",
          "Closures são funções anônimas sem escopo",
          "Closures impedem o garbage collector de funcionar",
          "Closures só existem em classes ES6",
        ],
        c: 0,
        e: "Uma closure é criada quando uma função interna captura referências a variáveis da função externa. Mesmo após a função externa retornar, a função interna mantém acesso a essas variáveis, que permanecem vivas na memória. É a base para data privacy, módulos e fábricas de funções.",
        x: "function counter() { let count = 0; return () => ++count; } const inc = counter(); inc(); // 1. inc(); // 2. — a variável 'count' persiste via closure.",
      },
      {
        q: "No JavaScript, o que são Promises e como async/await simplificam código assíncrono?",
        o: [
          "Promises representam valores futuros; async/await é syntax sugar sobre Promises para escrita síncrona-like",
          "Promises são variáveis globais",
          "async cria threads",
          "São exclusivas do Node.js",
        ],
        c: 0,
        e: "Promise encapsula operação assíncrona com 3 estados: pending, fulfilled, rejected. .then() e .catch() encadeiam operações. async/await (ES2017) permite escrever código assíncrono que parece síncrono, sem callbacks aninhados (callback hell).",
        x: "// Sem async/await: fetch(url).then(r => r.json()).then(data => process(data)).catch(err => handle(err)); // Com async/await: const r = await fetch(url); const data = await r.json(); process(data);",
      },
      {
        q: "No JavaScript, o que é o prototype chain e como a herança prototpíca funciona?",
        o: [
          "Cada objeto tem um __proto__ que aponta para outro objeto; propriedades são buscadas subindo a cadeia até null",
          "Herança clássica como Java",
          "Apenas classes ES6 têm herança",
          "Não existe herança em JS",
        ],
        c: 0,
        e: "JavaScript usa herança prototípica: cada objeto tem um [[Prototype]] (acessível via __proto__). Ao acessar uma propriedade, JS busca no objeto, depois no prototype, depois no prototype do prototype... até Object.prototype (cujo __proto__ é null). Classes ES6 são syntax sugar sobre prototypes.",
        x: "const animal = { speak() { return 'som'; } }; const dog = Object.create(animal); dog.bark = () => 'woof'; dog.speak(); // 'som' — encontrado em animal via prototype chain. dog.bark(); // 'woof' — encontrado no próprio dog.",
      },
      {
        q: "O que é o Event Loop no JavaScript e por que é importante?",
        o: [
          "Mecanismo single-threaded que processa call stack, microtasks (Promises) e macrotasks (setTimeout) em ordem",
          "Thread pool de workers",
          "Gerenciador de memória",
          "Compilador JIT",
        ],
        c: 0,
        e: "JS é single-threaded. Event Loop: executa call stack até esvaziar → processa todas microtasks (Promise.then, queueMicrotask) → processa uma macrotask (setTimeout, I/O) → repete. Microtasks têm prioridade sobre macrotasks.",
        x: "console.log('1'); setTimeout(() => console.log('2'), 0); Promise.resolve().then(() => console.log('3')); console.log('4'); // Output: 1, 4, 3, 2. Síncrono → microtask → macrotask.",
      },
      {
        q: "O que é WeakMap/WeakSet em JavaScript e quando usar?",
        o: [
          "Coleções com referências fracas que não impedem garbage collection das chaves/valores",
          "Maps/Sets menores",
          "Versões mais rápidas de Map/Set",
          "Coleções imutáveis",
        ],
        c: 0,
        e: "WeakMap: chaves são referências fracas (só objetos). Se a única referência ao objeto for a chave do WeakMap, o GC pode coletar. Não iterável (sem .keys(), .size). Uso: metadata associada a objetos DOM, caches que não causam memory leaks.",
        x: "const cache = new WeakMap(); function process(obj) { if (cache.has(obj)) return cache.get(obj); const result = expensiveCalc(obj); cache.set(obj, result); return result; } // Se obj for coletado, entry no WeakMap some automaticamente.",
      },
      {
        q: "O que é optional chaining (?.) e nullish coalescing (??) em JavaScript?",
        o: [
          "?. acessa propriedades de forma segura retornando undefined se null/undefined; ?? fornece fallback só para null/undefined",
          "Operadores matemáticos",
          "Operadores de atribuição",
          "Operadores de comparação",
        ],
        c: 0,
        e: "?. (optional chaining): obj?.prop?.sub retorna undefined em vez de lançar TypeError. Funciona com métodos (obj?.method()) e índices (arr?.[0]). ?? (nullish coalescing): retorna o operando direito SOU se o esquerdo for null ou undefined (diferente de || que trata 0, '' e false como falsy).",
        x: "const city = user?.address?.city ?? 'N/A'; // Se user ou address for null/undefined, city = 'N/A'. const count = data?.length ?? 0; // 0 se data for null. // Diferença de ||: 0 ?? 42 = 0, mas 0 || 42 = 42.",
      },
      {
        q: "O que são Map e Set em JavaScript e como diferem de objetos e arrays?",
        o: [
          "Map: coleção chave-valor com qualquer tipo de chave; Set: coleção de valores únicos. Ambos mantêm ordem de inserção",
          "Sinônimos de {} e []",
          "Estruturas imutáveis",
          "Coleções exclusivas do Node.js",
        ],
        c: 0,
        e: "Map vs Object: chaves podem ser qualquer tipo (objetos, funções), .size integrado, iteração na ordem de inserção, sem poluição de prototype. Set vs Array: valores únicos automaticamente, has() O(1). Ambos são iteráveis com for...of.",
        x: "const map = new Map(); map.set({id:1}, 'user1'); map.size; // 1. const set = new Set([1,2,2,3]); set.size; // 3 (sem duplicatas). set.has(2); // true, O(1). [...new Set(array)]; // remove duplicatas de array.",
      },
    ],
    Difícil: [
      {
        q: "No JavaScript, como o Event Loop processa microtasks (Promises) e macrotasks (setTimeout) e qual tem prioridade?",
        o: [
          "Microtasks têm prioridade: todas são processadas antes da próxima macrotask; macrotasks executam uma por ciclo",
          "Macrotasks têm prioridade sobre microtasks",
          "São processadas alternadamente sem prioridade",
          "Microtasks e macrotasks são a mesma coisa",
        ],
        c: 0,
        e: "O Event Loop executa: 1) uma macrotask (setTimeout, I/O). 2) esvazia TODA a fila de microtasks (Promise.then, queueMicrotask, MutationObserver). 3) renderiza (se necessário). 4) próxima macrotask. Microtasks criadas durante a execução de microtasks também são processadas antes de qualquer macrotask.",
        x: "setTimeout(() => console.log(1), 0); Promise.resolve().then(() => console.log(2)); console.log(3); // Output: 3, 2, 1 — síncrono primeiro, depois microtask (Promise), depois macrotask (setTimeout).",
      },
      {
        q: "No JavaScript, o que são WeakMap e WeakRef e como ajudam no gerenciamento de memória?",
        o: [
          "Referências fracas que não impedem garbage collection dos objetos referenciados",
          "Maps mais rápidos",
          "Caches permanentes",
          "Substitutos para localStorage",
        ],
        c: 0,
        e: "WeakMap: chaves são referências fracas a objetos — se não houver outra referência ao objeto-chave, ele pode ser coletado pelo GC (e a entrada some). WeakRef (ES2021): referência fraca a qualquer objeto. Úteis para caches que não devem prevenir GC e evitar memory leaks.",
        x: "const cache = new WeakMap(); function process(obj) { if (cache.has(obj)) return cache.get(obj); const result = expensiveCalc(obj); cache.set(obj, result); return result; } // Quando obj não tem mais referência forte, GC coleta obj e a entrada do cache.",
      },
      {
        q: "No JavaScript, como Proxy e Reflect permitem interceptar e customizar operações fundamentais de objetos?",
        o: [
          "Proxy envolve objetos com traps que interceptam get/set/delete/etc; Reflect fornece métodos default para essas operações",
          "São para requisições HTTP",
          "São tipos de Promise",
          "Servem para criptografia",
        ],
        c: 0,
        e: "Proxy cria um wrapper com 'traps' (handlers) que interceptam operações como get, set, has, deleteProperty, apply. Reflect fornece os métodos padrão correspondentes. Juntos permitem: validação, logging, observabilidade reativa (como Vue.js 3), e virtualização de objetos.",
        x: "const reactive = new Proxy(obj, { set(target, key, value) { console.log(`${key} changed to ${value}`); Reflect.set(target, key, value); trigger(key); return true; } }); reactive.name = 'Ana'; // loga e dispara re-render (como Vue 3).",
      },
      {
        q: "O que é SharedArrayBuffer e Atomics em JavaScript para concorrência real?",
        o: [
          "Memória compartilhada entre threads (Workers) com operações atômicas para sincronização",
          "Array compartilhado entre tabs",
          "Buffer de rede",
          "Compactação de arrays",
        ],
        c: 0,
        e: "SharedArrayBuffer: memória compartilhada entre main thread e Web Workers (verdadeira concorrência). Atomics: operações atômicas (load, store, compareExchange, wait, notify) para evitar race conditions. Requer cross-origin isolation (COOP/COEP headers).",
        x: "const sab = new SharedArrayBuffer(4); const view = new Int32Array(sab); worker.postMessage(sab); // Worker compartilha mesma memória. Atomics.store(view, 0, 42); Atomics.notify(view, 0); // Sinaliza worker.",
      },
      {
        q: "O que são Generators e Iterators em JavaScript?",
        o: [
          "Generators (function*) produzem valores sob demanda com yield; Iterators implementam protocolo next()",
          "Funções que geram números aleatórios",
          "Loops avançados",
          "Funções assíncronas",
        ],
        c: 0,
        e: "Generator: function* que pausa execução em cada yield e retoma quando next() é chamado. Retorna um Iterator. Lazy evaluation: gera valores sob demanda (memória O(1) vs O(n)). Usado internamente por for...of, spread, destructuring.",
        x: "function* range(start, end) { for (let i = start; i < end; i++) yield i; } for (const n of range(0, 1000000)) { if (n > 5) break; } // Só gera 6 valores, não 1M. Memória constante.",
      },
      {
        q: "O que é o padrão Module em JavaScript e como closures criam encapsulamento?",
        o: [
          "IIFE ou closure que expõe API pública mantendo estado privado inacessível externamente",
          "Classe com métodos privados",
          "Arquivo com export default",
          "Namespace global",
        ],
        c: 0,
        e: "Module Pattern: usa IIFE + closure para criar escopo privado. Variáveis internas são inacessíveis de fora. Apenas o que é retornado é público. Pré-ESM, era o principal mecanismo de encapsulamento. Hoje ESM fornece escopo de módulo nativamente.",
        x: "const counter = (() => { let count = 0; // privado return { inc: () => ++count, get: () => count }; })(); counter.inc(); counter.get(); // 1. counter.count; // undefined (privado via closure).",
      },
      {
        q: "O que é structuredClone() e como difere de JSON.parse(JSON.stringify())?",
        o: [
          "Clonagem profunda nativa que suporta Date, Map, Set, ArrayBuffer e referências circulares; JSON não",
          "São equivalentes",
          "JSON é mais completo",
          "structuredClone é só para strings",
        ],
        c: 0,
        e: "structuredClone() (ES2022): deep clone nativo que serializa com o algoritmo structured clone. Suporta: Date, Map, Set, RegExp, ArrayBuffer, Error, referências circulares. Não suporta: funções, DOM nodes, Symbol. JSON perde Date (vira string), Map/Set, e lança em circulares.",
        x: "const obj = { date: new Date(), map: new Map([['a',1]]) }; const clone = structuredClone(obj); clone.date instanceof Date; // true. clone.map instanceof Map; // true. // JSON: JSON.parse(JSON.stringify(obj)).date — seria string, não Date.",
      },
    ],
  },

  // ── Kotlin ──
  Kotlin: {
    Fácil: [
      {
        q: "Em Kotlin, qual keyword é usada para declarar variáveis imutáveis (que não podem ser reatribuídas)?",
        o: ["val", "var", "const", "let"],
        c: 0,
        e: "A keyword 'val' declara uma variável de somente leitura cuja referência não pode ser reatribuída após inicialização (equivalente a 'final' em Java). 'var' declara variáveis mutáveis. 'const val' é para constantes de tempo de compilação.",
        x: 'val nome = "Ana" // imutável. nome = "Bob" // Erro de compilação. var idade = 25 // mutável. idade = 26 // OK.',
      },
      {
        q: "Em Kotlin, o que é null safety e como os operadores '?' e '!!' funcionam?",
        o: [
          "O tipo sistema distingue nullable (T?) de non-null (T); ? acessa seguro, !! força non-null (pode crashar)",
          "São operadores matemáticos",
          "? cria variável e !! deleta",
          "Não existe null em Kotlin",
        ],
        c: 0,
        e: "Kotlin distingue String (nunca null) de String? (pode ser null) em tempo de compilação. ?. (safe call) retorna null se o receptor for null. ?: (elvis) fornece valor default. !! (non-null assertion) lança NullPointerException se for null — deve ser evitado.",
        x: "val name: String? = null; name?.length // null (safe). name?.length ?: 0 // 0 (elvis). name!!.length // NullPointerException! val safe: String = getName() ?: 'default';",
      },
      {
        q: "Em Kotlin, o que são 'data classes' e o que elas geram automaticamente?",
        o: [
          "Classes que geram equals(), hashCode(), toString(), copy() e componentN() automaticamente a partir das propriedades",
          "Classes de banco de dados",
          "Classes abstratas",
          "Classes sem métodos",
        ],
        c: 0,
        e: "Data classes são declaradas com 'data class' e geram automaticamente: equals()/hashCode() baseados nas propriedades do construtor primário, toString() legível, copy() para cópia com modificações, e componentN() para destructuring. Equivalente a Records do Java 16+.",
        x: "data class User(val name: String, val age: Int); val u1 = User('Ana', 25); val u2 = u1.copy(age = 26); // User(name=Ana, age=26). val (name, age) = u1; // destructuring.",
      },
      {
        q: "Qual a diferença entre val e var em Kotlin?",
        o: [
          "val é imutável (read-only); var é mutável (pode ser reatribuído)",
          "São idênticos",
          "val é para números e var para strings",
          "var é imutável",
        ],
        c: 0,
        e: "val (value): referência imutável (como final em Java ou const em JS). Não pode ser reatribuído, mas o objeto referenciado pode ser mutável. var (variable): pode ser reatribuído. Preferência: usar val por padrão, var somente quando necessário.",
        x: "val name = 'Ana'; name = 'Bob'; // ERRO. var age = 25; age = 26; // OK. val list = mutableListOf(1,2); list.add(3); // OK (lista é mutável, referência não).",
      },
      {
        q: "O que é null safety em Kotlin e como funciona?",
        o: [
          "O tipo sistema distingue variáveis que podem ser null (String?) das que não podem (String)",
          "Kotlin não tem null",
          "Null é tratado como 0",
          "Todas variáveis podem ser null",
        ],
        c: 0,
        e: "Kotlin elimina NullPointerException em compile-time: String não pode ser null; String? pode. Operadores: ?. (safe call), ?: (elvis — valor padrão), !! (assert não-null, perigoso). Smart cast: após null check, compilador sabe que não é null.",
        x: "var name: String? = null; name.length // ERRO de compilação. name?.length // null (safe call). name?.length ?: 0 // 0 (elvis). name!!.length // NPE em runtime (evitar).",
      },
      {
        q: "O que é string interpolation em Kotlin e como usar template expressions?",
        o: [
          "Strings com $ para variáveis e ${} para expressões, embutidas diretamente na string",
          "Concatenação com +",
          "Método format() como Java",
          "Template literals com crase",
        ],
        c: 0,
        e: "Kotlin suporta string templates: $variavel insere o valor; ${expressao} avalia expressões complexas. Strings multilinha usam triple quotes (raw strings). Muito mais legível que concatenação manual ou String.format().",
        x: 'val name = \'Ana\'; val age = 25; println("$name tem $age anos") // \'Ana tem 25 anos\'. println("${name.length} letras") // \'3 letras\'. val json = """{ "name": "$name" }"""; // raw string multilinha.',
      },
      {
        q: "O que são when expressions em Kotlin e como diferem de switch/case?",
        o: [
          "Expressão que substitui switch com pattern matching, ranges, type checks e retorno de valor",
          "Loop condicional",
          "Bloco try-catch",
          "Idêntico ao switch de Java",
        ],
        c: 0,
        e: "when: substituto poderoso do switch. Pode ser expressão (retorna valor). Suporta: valores múltiplos (1, 2 ->), ranges (in 1..10), type checks (is String), condições arbitrárias. Com sealed classes, o compilador verifica exaustividade. Sem argumento: substitui if-else chains.",
        x: "val desc = when(x) { 0 -> 'zero'; in 1..9 -> 'um dígito'; is String -> 'texto'; else -> 'outro' }. // Sem argumento: when { temp > 30 -> 'quente'; temp > 15 -> 'ameno'; else -> 'frio' }.",
      },
    ],
    Médio: [
      {
        q: "Em Kotlin, o que são 'coroutines' e como diferem de threads tradicionais?",
        o: [
          "Coroutines são computações suspensíveis e leves que podem pausar e retomar sem bloquear threads",
          "Coroutines são threads com nomes diferentes",
          "Coroutines só funcionam em Android",
          "Coroutines são mais pesadas que threads",
        ],
        c: 0,
        e: "Coroutines em Kotlin são computações que podem ser suspensas em pontos de suspensão (suspend functions) e retomadas posteriormente, potencialmente em outra thread. São extremamente leves (~centenas de bytes vs ~1MB por thread), permitindo milhões de coroutines concorrentes.",
        x: "suspend fun fetchData(): Data { val response = httpClient.get(url) // suspende sem bloquear thread return response.body() } launch { val data = fetchData() // coroutine leve, não thread }",
      },
      {
        q: "Em Kotlin, o que são 'sealed classes' e quando usá-las?",
        o: [
          "Hierarquias restritas onde todas as subclasses são conhecidas em compile-time, permitindo when exaustivo",
          "Classes que não podem ter métodos",
          "Classes criptografadas",
          "Sinônimo de abstract",
        ],
        c: 0,
        e: "Sealed classes limitam quais classes podem herdá-las (todas definidas no mesmo módulo). O compilador Kotlin sabe todas as subclasses, permitindo 'when' exaustivo sem cláusula 'else'. Ideal para modelar estados, resultados (Success/Error) e eventos.",
        x: "sealed class Result { data class Success(val data: String) : Result(); data class Error(val msg: String) : Result(); } fun handle(r: Result) = when(r) { is Result.Success -> show(r.data); is Result.Error -> show(r.msg); } // sem else!",
      },
      {
        q: "Em Kotlin, o que são 'extension functions' e como diferem de herança?",
        o: [
          "Funções que adicionam métodos a classes existentes sem modificá-las ou herdá-las; resolvidas em compile-time",
          "Herança múltipla",
          "Funções globais",
          "Métodos protegidos",
        ],
        c: 0,
        e: "Extension functions adicionam 'virtualmente' métodos a qualquer classe (inclusive String, Int, classes de terceiros). São compiladas como funções estáticas com o receiver como primeiro parâmetro. Não são polimórficas (resolvidas em compile-time, não runtime).",
        x: "fun String.isPalindrome(): Boolean = this == this.reversed(); 'aba'.isPalindrome() // true. fun Int.isEven(): Boolean = this % 2 == 0; 4.isEven() // true — parece método de Int.",
      },
      {
        q: "O que são sealed classes em Kotlin e quando usá-las?",
        o: [
          "Classes com subclasses restritas conhecidas em compile-time; permitem when exaustivo",
          "Classes que não podem ser instanciadas",
          "Classes criptografadas",
          "Classes globais",
        ],
        c: 0,
        e: "sealed class: hierarquia fechada — todas subclasses devem ser definidas no mesmo arquivo/módulo. O compilador garante when exaustivo (sem else). Ideal para modelar estados, resultados (Success/Error), e navegação. Similar a enum mas com dados diferentes por subtipo.",
        x: "sealed class Result { data class Success(val data: User) : Result(); data class Error(val msg: String) : Result(); object Loading : Result() } when(result) { is Success -> show(result.data); is Error -> show(result.msg); Loading -> showSpinner() } // Sem else!",
      },
      {
        q: "O que são higher-order functions e lambdas em Kotlin?",
        o: [
          "Funções que recebem ou retornam outras funções; lambdas são funções anônimas curtas",
          "Funções mais rápidas",
          "Funções recursivas",
          "Funções globais",
        ],
        c: 0,
        e: "Kotlin trata funções como cidadãos de primeira classe. HOF: fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>. Lambda: { x: Int -> x * 2 }. Trailing lambda: list.filter { it > 5 }. Inline funções eliminam overhead de lambda object.",
        x: "val numbers = listOf(1, 2, 3, 4, 5); val evens = numbers.filter { it % 2 == 0 }; // [2, 4]. val doubled = numbers.map { it * 2 }; // [2, 4, 6, 8, 10]. 'it' é o parâmetro implícito de lambdas com 1 param.",
      },
      {
        q: "O que são scope functions (let, run, apply, also, with) em Kotlin?",
        o: [
          "Funções que executam um bloco de código no contexto de um objeto, diferindo em como acessam o objeto e o que retornam",
          "Funções de escopo de variáveis",
          "Funções de criação de singleton",
          "Funções matemáticas",
        ],
        c: 0,
        e: "let: it + retorna resultado. run: this + retorna resultado. apply: this + retorna o próprio objeto. also: it + retorna o próprio objeto. with: não-extension, this + retorna resultado. let com ?. é idiomático para null checks. apply para configurar objetos.",
        x: "user?.let { println(it.name) } // só executa se não for null. val dialog = Dialog().apply { title = 'Confirmar'; message = 'OK?'; show() } // retorna dialog configurado. list.also { println('size: ${it.size}') } // log sem alterar.",
      },
      {
        q: "O que é o operador de delegação 'by' em Kotlin e quais padrões habilita?",
        o: [
          "Delega implementação de interface ou propriedade para outro objeto, implementando delegation pattern nativamente",
          "Operador de divisão",
          "Criação de alias",
          "Import de módulos",
        ],
        c: 0,
        e: "'by' delega: 1) implementação de interface (class Wrapper(val inner: List<Int>) : List<Int> by inner). 2) propriedades (by lazy, by Delegates.observable). Property delegates: lazy (inicialização lazy), observable (reage a mudanças), map (propriedades de mapa).",
        x: "val name: String by lazy { fetchName() } // inicializa só no primeiro acesso. var age: Int by Delegates.observable(0) { _, old, new -> println('$old -> $new') }. class CountingSet<T>(val inner: MutableSet<T> = mutableSetOf()) : MutableSet<T> by inner.",
      },
    ],
    Difícil: [
      {
        q: "Em Kotlin, como os 'inline functions' com 'reified type parameters' superam a limitação de type erasure da JVM?",
        o: [
          "O compilador insere o corpo da função no call site, preservando o tipo real como parâmetro em vez de apagá-lo",
          "Usam reflection em runtime que é mais lento",
          "Criam uma classe anônima para cada tipo",
          "Não existem em Kotlin, apenas em Scala",
        ],
        c: 0,
        e: "Funções inline têm seu corpo copiado para o call site em tempo de compilação. Com 'reified', o parâmetro de tipo é preservado como tipo real no código inlined, permitindo operações como 'is T', 'T::class' e 'Gson().fromJson<T>()' que seriam impossíveis com type erasure normal da JVM.",
        x: "inline fun <reified T> parse(json: String): T = Gson().fromJson(json, T::class.java) // T::class funciona porque é reified. val user = parse<User>(jsonStr) // compila para Gson().fromJson(jsonStr, User.class)",
      },
      {
        q: "Em Kotlin, o que são 'Kotlin Flows' e como diferem de Sequences?",
        o: [
          "Flows são streams assíncronas frias baseadas em coroutines; Sequences são lazy e síncronas",
          "São idênticos",
          "Sequences são assíncronas",
          "Flows são síncronos",
        ],
        c: 0,
        e: "Sequences são iteradores lazy síncronos (processam item a item sem criar coleções intermediárias). Flows são o equivalente assíncrono: cold streams que emitem valores ao longo do tempo usando coroutines. Suportam operadores como map, filter, collect, e backpressure.",
        x: "fun temperatures(): Flow<Double> = flow { while(true) { emit(readSensor()); delay(1000); } } // Emite temperatura a cada segundo. lifecycleScope.launch { temperatures().collect { temp -> updateUI(temp) } }",
      },
      {
        q: "Em Kotlin, como o 'structured concurrency' das coroutines garante que não haja vazamento de resources?",
        o: [
          "Todo coroutine filho está vinculado a um escopo pai; se o pai for cancelado, todos os filhos são cancelados automaticamente",
          "Coroutines nunca podem ser canceladas",
          "Usam garbage collector",
          "Funcionam como threads daemon",
        ],
        c: 0,
        e: "Structured concurrency: coroutines são lançadas em um CoroutineScope (viewModelScope, lifecycleScope). O escopo pai NÃO completa até todos os filhos completarem. Se o pai for cancelado (tela fechada), todos os filhos são cancelados. Se um filho falhar, o pai propaga a exceção (ou usa SupervisorJob).",
        x: "viewModelScope.launch { val a = async { fetchUserProfile() }; val b = async { fetchUserOrders() }; updateUI(a.await(), b.await()); } // Se viewModel.onCleared() → scope cancela → ambos async cancelam → zero leak.",
      },
      {
        q: "O que é o Kotlin Multiplatform (KMP) e como funciona?",
        o: [
          "Permite compartilhar lógica de negócio entre Android, iOS, web e desktop com código Kotlin comum",
          "Emulador de Android",
          "Framework de UI multiplataforma",
          "Compilador para Java",
        ],
        c: 0,
        e: "KMP: código em commonMain é compilado para cada target (JVM, iOS/Native, JS, WASM). expect/actual: declara API em common, implementa por plataforma. Compose Multiplatform: UI compartilhada. Usado para: lógica de negócio, networking, serialization compartilhados.",
        x: "// commonMain: expect fun platformName(): String. // androidMain: actual fun platformName() = 'Android'. // iosMain: actual fun platformName() = 'iOS'. // Código de negócio em common usa platformName() transparentemente.",
      },
      {
        q: "O que são inline functions em Kotlin e por que são importantes para performance?",
        o: [
          "Funções cujo código é copiado no call site em compile-time, eliminando overhead de alocação de lambda object",
          "Funções mais curtas",
          "Funções que rodam em linha de comando",
          "Otimização de runtime",
        ],
        c: 0,
        e: "Sem inline: cada lambda cria um objeto Function + closure (alocação). Com inline: compilador copia o corpo da função e do lambda no call site. Zero alocação. Essencial para funções HOF usadas em hot paths. Kotlin stdlib: filter, map, let, apply são inline.",
        x: "inline fun <T> measure(block: () -> T): T { val start = System.nanoTime(); val result = block(); println(System.nanoTime() - start); return result; } // block() é inlined: zero alocação de Function object.",
      },
      {
        q: "O que são type aliases em Kotlin e quando são úteis?",
        o: [
          "Nomes alternativos para tipos existentes, simplificando tipos genéricos complexos e function types",
          "Novos tipos criados em runtime",
          "Cast entre tipos incompatíveis",
          "Apelidos de variáveis",
        ],
        c: 0,
        e: "typealias cria sinônimo para tipo existente. Não cria tipo novo (intercompatível). Útil para: tipos genéricos longos (typealias UserMap = Map<String, List<User>>), function types (typealias Predicate<T> = (T) -> Boolean), e classes internas (typealias NodeSet = Set<Network.Node>).",
        x: "typealias StringMap = Map<String, String>; typealias Predicate<T> = (T) -> Boolean; fun filter(list: List<Int>, pred: Predicate<Int>): List<Int> = list.filter(pred); // Mais legível que (Int) -> Boolean.",
      },
      {
        q: "O que são contracts em Kotlin e como ajudam o compilador em smart casts?",
        o: [
          "Declarações que informam ao compilador efeitos de uma função, habilitando smart casts após custom checks",
          "Contratos legais de API",
          "Validações em runtime",
          "Testes automatizados",
        ],
        c: 0,
        e: "Contracts (experimental): função declara ao compilador que se retornar true, o argumento é de determinado tipo. Permite smart cast após funções custom (isNullOrEmpty, require, check). callsInPlace garante que lambda executa exatamente uma vez (permite val em blocos).",
        x: "fun String?.isValid(): Boolean { contract { returns(true) implies (this@isValid != null) }; return this != null && isNotEmpty() } val s: String? = ...; if (s.isValid()) { s.length // smart cast! compilador sabe que não é null }.",
      },
    ],
  },

  // ── PHP ──
  PHP: {
    Fácil: [
      {
        q: "Em PHP, como se declara uma variável e qual é o prefixo obrigatório?",
        o: [
          "Com o símbolo $ antes do nome: $variavel",
          "Com # antes do nome: #variavel",
          "Com @ antes do nome: @variavel",
          "Sem prefixo, como em JavaScript",
        ],
        c: 0,
        e: "Em PHP, todas as variáveis são prefixadas com o símbolo $. Não é necessário declarar o tipo explicitamente (tipagem dinâmica). A variável é criada na primeira atribuição e seu tipo é determinado pelo valor atribuído.",
        x: "$nome = 'Ana'; $idade = 25; $ativo = true; echo $nome; // Ana",
      },
      {
        q: "Em PHP, o que são arrays associativos e como diferem de arrays indexados?",
        o: [
          "Arrays associativos usam chaves nomeadas (strings); indexados usam índices numéricos",
          "São idênticos",
          "Associativos são mais lentos",
          "Indexados usam strings",
        ],
        c: 0,
        e: "Arrays indexados usam índices numéricos automáticos ($arr = [1, 2, 3]; $arr[0]). Arrays associativos usam chaves string definidas pelo programador ($user = ['name' => 'Ana', 'age' => 25]; $user['name']). Internamente, todos os arrays PHP são hashmaps ordenados.",
        x: "$frutas = ['maçã', 'banana']; echo $frutas[0]; // maçã (indexado). $user = ['nome' => 'Ana', 'idade' => 25]; echo $user['nome']; // Ana (associativo).",
      },
      {
        q: "Em PHP, qual é a diferença entre 'echo' e 'print'?",
        o: [
          "echo aceita múltiplos argumentos e não retorna valor; print aceita 1 argumento e retorna 1",
          "São idênticos",
          "print é mais rápido",
          "echo retorna string",
        ],
        c: 0,
        e: "echo é um language construct que aceita múltiplos parâmetros separados por vírgula e não retorna valor. print também é language construct, aceita apenas 1 argumento e sempre retorna 1 (pode ser usado em expressões). echo é marginalmente mais rápido.",
        x: "echo 'Olá', ' ', 'mundo'; // vários args. $x = print 'ok'; // $x = 1 (retorna 1). echo 'ok'; // não retorna nada.",
      },
      {
        q: "O que são arrays em PHP e como diferem de arrays em outras linguagens?",
        o: [
          "Arrays PHP são na verdade mapas ordenados que funcionam como array, lista, hash table, pilha e fila",
          "São idênticos a arrays C",
          "Só aceitam números como índice",
          "Têm tamanho fixo",
        ],
        c: 0,
        e: "Arrays PHP: estrutura versátil que combina array indexado e array associativo (hash map). Chaves: int ou string. Valores: qualquer tipo. Funções úteis: array_map, array_filter, array_merge, in_array, array_push. Sintaxe curta: $a = [1, 2, 'key' => 'val'].",
        x: "$frutas = ['maçã', 'banana']; $user = ['name' => 'Ana', 'age' => 25]; $frutas[] = 'laranja'; // push. echo $user['name']; // 'Ana'. foreach ($user as $key => $val) { echo \"$key: $val\"; }",
      },
      {
        q: "O que são as diferenyas entre require, include, require_once e include_once em PHP?",
        o: [
          "require causa fatal error se falhar; include causa warning; _once garante inclusão única",
          "São todos idênticos",
          "require é para classes e include para funções",
          "_once é mais lento",
        ],
        c: 0,
        e: "require: inclui arquivo, fatal error se não encontrar (para execução). include: warning se não encontrar (continua). require_once/include_once: garante que o arquivo só é incluído uma vez (evita redeclaração). Na prática, autoload do Composer substituiu todos.",
        x: "require 'config.php'; // fatal error se não existir. include 'optional.php'; // warning, continua. require_once 'Database.php'; require_once 'Database.php'; // segundo call é ignorado.",
      },
      {
        q: "O que são os tipos de dados em PHP e como verificar o tipo de uma variável?",
        o: [
          "PHP tem tipos escalar (int, float, string, bool), compostos (array, object) e especiais (null, resource); gettype() e is_* verificam",
          "PHP só tem strings",
          "Todos são objects",
          "Não existe verificação de tipo",
        ],
        c: 0,
        e: "PHP é dinamicamente tipado. Escalares: int, float, string, bool. Compostos: array, object, callable, iterable. Especiais: null, resource. Verificação: gettype($x), is_int($x), is_array($x), instanceof para objetos. PHP 7+: type declarations para parâmetros e retorno.",
        x: "$x = 42; gettype($x); // 'integer'. is_int($x); // true. is_string($x); // false. $arr = [1,2]; is_array($arr); // true. function add(int $a, int $b): int { return $a + $b; } // tipo declarado (PHP 7+).",
      },
      {
        q: "Qual a diferença entre == e === em PHP e por que importa?",
        o: [
          "== compara com coercção de tipo (loose); === compara valor E tipo (strict), sem conversão",
          "São idênticos",
          "=== é mais lento",
          "== é para objetos e === para strings",
        ],
        c: 0,
        e: "== (loose): converte tipos antes de comparar (0 == 'foo' era true antes do PHP 8). === (strict): compara valor e tipo sem coercção (0 === '' é false). Best practice: sempre usar === para evitar bugs de coercção. in_array($val, $arr, true) usa strict.",
        x: "0 == 'foo'; // false (PHP 8+), era true em PHP 7. '' == false; // true (ambos falsy). '' === false; // false (tipos diferentes). null == false; // true. null === false; // false.",
      },
    ],
    Médio: [
      {
        q: "Em PHP, qual é a diferença entre 'include' e 'require' ao carregar arquivos?",
        o: [
          "require gera erro fatal (E_COMPILE_ERROR) se o arquivo não existir; include gera apenas warning e continua a execução",
          "São idênticos",
          "include é mais rápido",
          "require carrega o arquivo duas vezes",
        ],
        c: 0,
        e: "require para a execução com erro fatal se o arquivo não for encontrado, sendo indicado para dependências essenciais. include gera um warning (E_WARNING) e a execução continua, adequado para conteúdo opcional. Variantes _once evitam inclusões duplicadas.",
        x: "require 'config.php'; // Fatal error se não existir — sem config, o app não funciona. include 'sidebar.php'; // Warning se não existir — página renderiza sem sidebar.",
      },
      {
        q: "Em PHP, o que são namespaces e por que são importantes?",
        o: [
          "Organizam classes/funções em espaços nomeados para evitar colisões de nomes entre bibliotecas",
          "São pastas no servidor",
          "São tipos de variável",
          "São comments especiais",
        ],
        c: 0,
        e: "Namespaces (PHP 5.3+) permitem organizar código em hierarquias lógicas, evitando conflitos de nomes quando múltiplas bibliotecas definem classes com mesmo nome. Seguem a convenção PSR-4 para autoloading, onde namespace mapeia para diretório.",
        x: "namespace App\\Models; class User { } // App\\Models\\User. namespace App\\Controllers; use App\\Models\\User; class UserController { function show() { $u = new User(); } } // Sem conflito com outra lib que tenha classe User.",
      },
      {
        q: "Em PHP, o que é o Composer e qual seu papel no gerenciamento de dependências?",
        o: [
          "Gerenciador de dependências que instala pacotes, resolve versões e gera autoloader PSR-4",
          "Editor de código",
          "Servidor web",
          "Framework PHP",
        ],
        c: 0,
        e: "Composer é o gerenciador de dependências padrão do PHP. Usa composer.json para declarar dependências, resolve conflitos de versão, baixa pacotes do Packagist (repositório central) e gera autoloader PSR-4. composer.lock garante versões reproduzíveis.",
        x: "composer require guzzlehttp/guzzle // Instala Guzzle HTTP. composer install // Instala tudo do composer.lock. require 'vendor/autoload.php'; // Autoload gerado pelo Composer, carrega todas as classes.",
      },
      {
        q: "O que são traits em PHP e qual problema resolvem?",
        o: [
          "Mecanismo de reutilização de código em classes sem herança múltipla; similar a mixins",
          "Tipo de interface",
          "Classes abstratas",
          "Funções globais",
        ],
        c: 0,
        e: "Traits: grupos de métodos reutilizáveis que podem ser inclusos em múltiplas classes via 'use'. PHP não suporta herança múltipla, então traits resolvem isso. Uma classe pode usar múltiplos traits. Conflitos de métodos são resolvidos com insteadof/as.",
        x: "trait Timestampable { public function getCreatedAt() { } } trait SoftDeletable { public function softDelete() { } } class User { use Timestampable, SoftDeletable; } // User tem ambos os métodos.",
      },
      {
        q: "O que é o padrão MVC no contexto de frameworks PHP como Laravel?",
        o: [
          "Model (dados/lógica), View (apresentação), Controller (intermedia requisições) — separação de concerns",
          "Padrão de banco de dados",
          "Tipo de API",
          "Framework de testes",
        ],
        c: 0,
        e: "MVC em Laravel: Model (Eloquent ORM — mapeamento de tabelas para classes). View (Blade templates — HTML + diretivas). Controller (recebe request, chama model, retorna view/JSON). Routes mapeiam URLs para controller methods.",
        x: "Route::get('/users', [UserController::class, 'index']); class UserController { function index() { return view('users.index', ['users' => User::all()]); } } // Route → Controller → Model → View.",
      },
      {
        q: "O que são match expressions em PHP 8.0 e como diferem de switch?",
        o: [
          "Expressão que retorna valor, usa comparação strict (===) e não tem fall-through; switch usa loose (==)",
          "São idênticos a switch",
          "match só funciona com strings",
          "match é mais lento",
        ],
        c: 0,
        e: "match (PHP 8.0): expressão (retorna valor), comparação strict (===), sem fall-through (sem break necessário), deve ser exaustivo (UnhandledMatchError se nenhum caso casar). Mais seguro e conciso que switch.",
        x: "$result = match($status) { 'active' => 'Ativo', 'inactive', 'suspended' => 'Inativo', default => 'Desconhecido', }; // Retorna valor, sem break, strict comparison. switch usa == e precisa de break em cada case.",
      },
      {
        q: "O que são union types em PHP 8.0 e por que são importantes?",
        o: [
          "Permitem declarar que parâmetro/retorno aceita múltiplos tipos: int|string, aumentando a type safety",
          "Tipos de banco de dados",
          "União de arrays",
          "Herança múltipla",
        ],
        c: 0,
        e: "Union types (PHP 8.0): function foo(int|string $id): User|null {}. Antes: @param int|string no PHPDoc (sem enforce). Agora o engine valida em runtime. ?Type é atalho para Type|null. PHP 8.1+: intersection types (A&B). PHP 8.2: DNF types ((A&B)|C).",
        x: "function find(int|string $id): User|null { return match(true) { is_int($id) => User::find($id), is_string($id) => User::findBySlug($id), }; } // Engine lança TypeError se receber bool, array, etc.",
      },
    ],
    Difícil: [
      {
        q: "Em PHP 8.1+, o que são Fibers e como elas habilitam concorrência cooperativa?",
        o: [
          "Fibers são threads leves que podem pausar e retomar execução em pontos arbitrários do código, sem callbacks",
          "Fibers são threads do sistema operacional",
          "Fibers são específicas para banco de dados",
          "Fibers substituem completamente o modelo request-response",
        ],
        c: 0,
        e: "Fibers em PHP 8.1 permitem criar coroutines: blocos de código que podem ser pausados (Fiber::suspend()) e retomados (->resume()) em qualquer ponto da stack, sem reestruturar o código com callbacks ou generators. São a base para I/O assíncrono em frameworks como Amp e ReactPHP.",
        x: "$fiber = new Fiber(function(): void { $value = Fiber::suspend('paused'); echo $value; }); $result = $fiber->start(); // 'paused'. $fiber->resume('hello'); // imprime 'hello'.",
      },
      {
        q: "Em PHP, o que são 'Enums' (PHP 8.1+) e quais tipos existem?",
        o: [
          "Tipos que definem conjunto fixo de valores possíveis; podem ser 'Pure' (sem valor) ou 'Backed' (com valor string/int)",
          "Arrays constantes",
          "Classes abstratas",
          "Variáveis globais nomeadas",
        ],
        c: 0,
        e: "Enums PHP 8.1 definem um tipo com conjunto fechado de valores. Pure Enums não têm valor interno. Backed Enums têm um valor string ou int associado (para serialização/DB). Enums podem implementar interfaces, ter métodos e constantes. Não podem ser instanciados com new.",
        x: "enum Status: string { case Active = 'active'; case Inactive = 'inactive'; } $s = Status::Active; $s->value; // 'active'. Status::from('active'); // Status::Active. Status::tryFrom('x'); // null.",
      },
      {
        q: "Em PHP, o que são 'Attributes' (PHP 8.0+) e como substituem DocBlock annotations?",
        o: [
          "Metadados estruturados nativos da linguagem que podem ser lidos via Reflection em runtime",
          "Comentários de documentação",
          "Variáveis de ambiente",
          "Configurações do php.ini",
        ],
        c: 0,
        e: "Attributes (PHP 8.0) são metadados nativos definidos com #[...] que substituem @annotations em DocBlocks. São classes reais, type-safe, e podem ser lidos via ReflectionAttribute em runtime. Frameworks como Symfony e Doctrine usam attributes para rotas, validação e mapeamento ORM.",
        x: "#[Route('/users', methods: ['GET'])] #[IsGranted('ROLE_ADMIN')] public function list(): Response { } // Attributes substituem @Route e @IsGranted de DocBlocks. Lidos via (new ReflectionMethod(...))->getAttributes().",
      },
      {
        q: "O que são Fibers em PHP 8.1 e como habilitam concorrência cooperativa?",
        o: [
          "Threads leves cooperativas que podem suspender e retomar execução, base para I/O assíncrono",
          "Threads do sistema operacional",
          "Tipo de array",
          "Conexeões de rede",
        ],
        c: 0,
        e: "Fibers (PHP 8.1): execução que pode ser suspensa (Fiber::suspend()) e retomada (fiber->resume()). Cooperativas: a fiber decide quando ceder controle. Base para frameworks assíncronos (ReactPHP, Amp, Swoole). Não são paralelas — são concurrent no mesmo thread.",
        x: "$fiber = new Fiber(function() { $value = Fiber::suspend('pausado'); echo \"Recebeu: $value\"; }); $result = $fiber->start(); // 'pausado'. $fiber->resume('dados'); // 'Recebeu: dados'. Frameworks usam isso para async I/O.",
      },
      {
        q: "O que é o Eloquent ORM no Laravel e como funciona o Active Record pattern?",
        o: [
          "Cada model mapeia uma tabela do banco; instância do model representa uma linha; métodos fazem queries",
          "Linguagem de query",
          "Banco de dados NoSQL",
          "Framework de testes",
        ],
        c: 0,
        e: "Eloquent: Active Record ORM do Laravel. Cada classe Model mapeia uma tabela. Métodos estáticos fazem queries (User::where()->get()). Relações: hasMany, belongsTo, belongsToMany. Mass assignment protection, eager loading (with()), scopes, events.",
        x: "class User extends Model { public function posts() { return $this->hasMany(Post::class); } } User::where('active', true)->with('posts')->get(); // Eager loading: 2 queries em vez de N+1.",
      },
      {
        q: "O que são readonly properties e readonly classes em PHP 8.1/8.2?",
        o: [
          "Propriedades que só podem ser atribuídas uma vez (no construtor); readonly class torna todas as propriedades readonly",
          "Propriedades estáticas",
          "Propriedades privadas",
          "Propriedades computadas",
        ],
        c: 0,
        e: "readonly (PHP 8.1): propriedade só pode ser escrita uma vez, na inicialização (construtor). Depois é imutável. readonly class (PHP 8.2): todas as propriedades são readonly. Promove value objects e DTOs imutáveis. Não pode ter propriedades sem tipo.",
        x: "readonly class User { public function __construct(public string $name, public int $age) {} } $u = new User('Ana', 25); $u->name; // 'Ana'. $u->name = 'Bob'; // Error: Cannot modify readonly property.",
      },
      {
        q: "O que é o PHP-FPM e como processa requests web diferente do mod_php?",
        o: [
          "FastCGI Process Manager: pool de workers PHP persistentes que recebem requests do web server, mais eficiente que mod_php",
          "Framework PHP",
          "Compilador JIT",
          "Gerenciador de pacotes",
        ],
        c: 0,
        e: "PHP-FPM: gerencia pool de processos PHP worker. Nginx/Apache passa request via FastCGI. Vantagens sobre mod_php (embutido no Apache): melhor gerenciamento de memória, pools por site, configuração independente, suporta Nginx. Workers: static (fixo), dynamic (sob demanda), ondemand (cria por request).",
        x: "Nginx config: location ~ \\.php$ { fastcgi_pass 127.0.0.1:9000; } // PHP-FPM escuta na porta 9000. Pool config: pm = dynamic; pm.max_children = 50; pm.start_servers = 5; // 5 workers iniciais, até 50 sob demanda.",
      },
    ],
  },

  // ── Python ──
  Python: {
    Fácil: [
      {
        q: "Em Python, qual estrutura de dados é uma coleção ordenada e mutável que permite elementos duplicados?",
        o: [
          "Lista (list)",
          "Conjunto (set)",
          "Tupla (tuple)",
          "Dicionário (dict)",
        ],
        c: 0,
        e: "Listas em Python são coleções ordenadas e mutáveis definidas com colchetes []. Permitem elementos duplicados, acesso por índice, e operações como append(), insert(), pop() e slicing. São implementadas como arrays dinâmicos.",
        x: "frutas = ['maçã', 'banana', 'maçã'] // duplicatas OK. frutas.append('uva') // ['maçã', 'banana', 'maçã', 'uva']. frutas[1] // 'banana'.",
      },
      {
        q: "Em Python, o que é um dicionário (dict) e como acessar seus valores?",
        o: [
          "Coleção de pares chave-valor onde chaves são únicas; acesso via dict[key] ou dict.get(key)",
          "Lista ordenada",
          "Array de índices",
          "Objeto imutável",
        ],
        c: 0,
        e: "Dicionários (dict) armazenam pares chave-valor com chaves hasháveis e únicas. Acesso O(1) por chave. dict[key] lança KeyError se não existir; dict.get(key, default) retorna default. Desde Python 3.7, mantêm ordem de inserção.",
        x: "user = {'name': 'Ana', 'age': 25}; user['name'] // 'Ana'. user.get('email', 'N/A') // 'N/A' (default). user['email'] = 'ana@x.com' // adiciona. 'name' in user // True.",
      },
      {
        q: "Em Python, o que é uma list comprehension e como usá-la?",
        o: [
          "Sintaxe concisa para criar listas: [expressão for item in iterável if condição]",
          "Função de ordenação",
          "Método de classe",
          "Import condicional",
        ],
        c: 0,
        e: "List comprehensions criam listas de forma concisa em uma linha. Sintaxe: [expr for var in iterable if condition]. São mais legíveis e geralmente mais rápidas que loops equivalentes. Também existem dict, set e generator comprehensions.",
        x: "pares = [x for x in range(10) if x % 2 == 0] // [0, 2, 4, 6, 8]. quadrados = {x: x**2 for x in range(5)} // {0:0, 1:1, 2:4, 3:9, 4:16} (dict comprehension).",
      },
      {
        q: "O que são decorators em Python e para que servem?",
        o: [
          "Funções que modificam o comportamento de outras funções/classes usando a sintaxe @decorator",
          "Comentários especiais",
          "Estilos visuais",
          "Tipo de classe",
        ],
        c: 0,
        e: "Decorator: função que recebe uma função e retorna uma função modificada. @decorator é syntax sugar para func = decorator(func). Usos: logging, caching (@lru_cache), autentificação (@login_required), timing, retry. Podem ser empilhados e aceitar argumentos.",
        x: "from functools import wraps; def timer(f): @wraps(f) def wrapper(*args): start = time.time(); result = f(*args); print(f'{f.__name__}: {time.time()-start:.2f}s'); return result; return wrapper. @timer def slow(): time.sleep(1). slow() // 'slow: 1.00s'.",
      },
      {
        q: "Qual a diferença entre lista, tupla e set em Python?",
        o: [
          "Lista: mutável, ordenada; Tupla: imutável, ordenada; Set: mutável, sem duplicatas, não ordenado",
          "São todos idênticos",
          "Tupla é mutável",
          "Set é ordenado",
        ],
        c: 0,
        e: "List [1,2,3]: mutável, indexada, duplicatas OK. Tuple (1,2,3): imutável, indexada, hashable (pode ser chave de dict). Set {1,2,3}: mutável, sem duplicatas, sem ordem, operações de conjunto (união, interseção). Frozenset: set imutável.",
        x: "l = [1,2,2]; l.append(3) // [1,2,2,3]. t = (1,2); t[0] = 3 // TypeError. s = {1,2,2,3}; s // {1,2,3}. s & {2,3,4} // {2,3} (interseção).",
      },
      {
        q: "O que são f-strings em Python e como fazer interpolação de variáveis?",
        o: [
          "Strings com prefixo f que permitem inserir expressões Python entre chaves {}: f'{var}'",
          "Strings formatadas com %",
          "Strings com método .format()",
          "Strings de arquivo",
        ],
        c: 0,
        e: "f-strings (Python 3.6+): prefixo f antes da string, {expressão} avalia qualquer código Python. Suporta formatação: {val:.2f}, {val:>10}, {val!r}. Mais rápidas e legíveis que .format() e %. Python 3.12: f-strings podem ter { dentro de {}.",
        x: "name = 'Ana'; age = 25; f'{name} tem {age} anos' // 'Ana tem 25 anos'. f'{3.14159:.2f}' // '3.14'. f'{[x**2 for x in range(5)]}' // '[0, 1, 4, 9, 16]'. f'{'hello':>10}' // '     hello'.",
      },
      {
        q: "O que é a keyword 'with' em Python e como funciona o context manager?",
        o: [
          "Garante aquisição e liberação automática de recursos via __enter__ e __exit__, mesmo com exceções",
          "Import condicional",
          "Loop especial",
          "Declaração de classe",
        ],
        c: 0,
        e: "with statement: chama __enter__() no início e __exit__() ao final (mesmo com exceções). Equivalente a try/finally. Usado para: arquivos, locks, conexões DB, transações. contextlib.contextmanager permite criar context managers com yield.",
        x: "with open('data.txt', 'r') as f: content = f.read() // f.close() chamado automaticamente. // Equivale a: f = open('data.txt'); try: content = f.read(); finally: f.close(). // Custom: @contextmanager def timer(): start = time.time(); yield; print(time.time() - start).",
      },
    ],
    Médio: [
      {
        q: "Em Python, o que são decorators e como eles modificam o comportamento de funções?",
        o: [
          "São funções que envolvem outra função, adicionando comportamento antes/depois sem modificar o código original",
          "São comentários especiais para documentação",
          "São imports condicionais",
          "São variáveis globais decorativas",
        ],
        c: 0,
        e: "Decorators são funções de ordem superior que recebem uma função como argumento e retornam uma nova função com comportamento adicional. A sintaxe @decorator é syntactic sugar para func = decorator(func). São usados para logging, autenticação, caching, etc.",
        x: "def timer(f): def wrapper(*a): start = time.time(); result = f(*a); print(f'{time.time()-start:.2f}s'); return result; return wrapper. @timer def process(): ... // mede tempo automaticamente.",
      },
      {
        q: "Em Python, o que são generators e como diferem de funções normais?",
        o: [
          "Funções com yield que produzem valores sob demanda (lazy) sem manter toda a sequência em memória",
          "Funções mais rápidas",
          "Funções que retornam listas",
          "Classes especiais",
        ],
        c: 0,
        e: "Generators usam 'yield' em vez de 'return'. Cada chamada a next() executa até o próximo yield e pausa. O estado local (variáveis) é preservado entre chamadas. São lazy (produzem valores sob demanda), usando O(1) memória para sequências infinitas.",
        x: "def fibonacci(): a, b = 0, 1; while True: yield a; a, b = b, a+b. gen = fibonacci(); next(gen) // 0. next(gen) // 1. next(gen) // 1. next(gen) // 2. // Sequência infinita com memória O(1).",
      },
      {
        q: "Em Python, o que é a diferença entre métodos de instância, @classmethod e @staticmethod?",
        o: [
          "Instância recebe self; classmethod recebe cls (a classe); staticmethod não recebe nem self nem cls",
          "São idênticos",
          "staticmethod é mais rápido",
          "classmethod é privado",
        ],
        c: 0,
        e: "Método de instância: opera em self (instância específica). @classmethod: recebe cls (a classe), usado para factory methods e herança. @staticmethod: não recebe self nem cls, é como função normal agrupada na classe por organização lógica.",
        x: "class Date: def __init__(self, y, m, d): self.year=y. @classmethod def from_string(cls, s): return cls(*s.split('-')). @staticmethod def is_valid(s): ... // Date.from_string('2024-01-15'); Date.is_valid('abc').",
      },
      {
        q: "O que são generators em Python e como diferem de listas?",
        o: [
          "Funções com yield que produzem valores sob demanda (lazy), usando memória O(1) vs O(n) de listas",
          "Listas mais rápidas",
          "Funções recursivas",
          "Tipo de classe",
        ],
        c: 0,
        e: "Generator: função com yield que retorna um iterator. Cada chamada a next() executa até o próximo yield. Memória constante vs lista que armazena tudo. Generator expressions: (x**2 for x in range(10**9)). Usado para processar grandes datasets.",
        x: "def fib(): a, b = 0, 1; while True: yield a; a, b = b, a+b. g = fib(); [next(g) for _ in range(7)] // [0,1,1,2,3,5,8]. Memória: O(1) vs list(fib_list(10**9)) que crasharia.",
      },
      {
        q: "O que é o conceito de virtual environment (venv) em Python?",
        o: [
          "Ambiente isolado com suas próprias dependências, evitando conflitos entre projetos",
          "Máquina virtual",
          "Container Docker",
          "IDE para Python",
        ],
        c: 0,
        e: "venv cria um diretório com cópia/link do interpretador Python e pip próprio. Pacotes instalados ficam isolados do sistema. Cada projeto pode ter versões diferentes de dependências. Alternativas: conda, poetry, pyenv-virtualenv. Ativar: source venv/bin/activate.",
        x: "python -m venv .venv && source .venv/bin/activate && pip install flask==2.3 && pip freeze > requirements.txt. Projeto B pode ter flask==3.0 em seu próprio .venv sem conflito.",
      },
      {
        q: "O que são type hints em Python e por que usá-las?",
        o: [
          "Anotações de tipo opcionais que melhoram legibilidade, autocomplete e detecção de erros com mypy/pyright",
          "Declarações obrigatórias de tipo",
          "Validações em runtime",
          "Comentários de documentação",
        ],
        c: 0,
        e: "Type hints (PEP 484): anotações opcionais verificadas por ferramentas externas (mypy, pyright), não pelo runtime. def greet(name: str) -> str:. Tipos complexos: list[int], dict[str, Any], Optional[str] (= str | None). Python 3.10+: X | Y em vez de Union[X, Y].",
        x: "def greet(name: str, times: int = 1) -> str: return name * times. from typing import Optional; def find(id: int) -> Optional[User]: ... // User | None. # mypy check: greet(42) → erro: expected str, got int.",
      },
      {
        q: "O que é asyncio em Python e como difere de threading?",
        o: [
          "Framework de I/O assíncrono single-threaded baseado em event loop e coroutines (async/await); threading usa múltiplas threads",
          "São idênticos",
          "asyncio usa múltiplos processos",
          "threading é assíncrono",
        ],
        c: 0,
        e: "asyncio: concorrência cooperativa em uma thread via event loop. async def + await. Ideal para I/O-bound (HTTP, DB, files). Sem overhead de threads. Threading: concorrência preemptiva com GIL (sem paralelismo real CPU-bound). asyncio escala melhor para milhares de conexões.",
        x: "async def fetch_all(urls): async with aiohttp.ClientSession() as s: tasks = [s.get(url) for url in urls]; return await asyncio.gather(*tasks) // 1000 requests em paralelo, 1 thread. Threading: 1000 threads = overhead considerável.",
      },
    ],
    Difícil: [
      {
        q: "Em Python, o que é o GIL (Global Interpreter Lock) e como ele afeta a performance de código CPU-bound multithread?",
        o: [
          "O GIL permite que apenas uma thread execute bytecode Python por vez, limitando paralelismo CPU-bound; use multiprocessing para contornar",
          "O GIL acelera código multithread",
          "O GIL só existe no Jython, não no CPython",
          "O GIL foi removido no Python 3.10",
        ],
        c: 0,
        e: "O GIL no CPython é um mutex que protege o acesso a objetos Python, permitindo apenas uma thread executar bytecode por vez. Para I/O-bound, threads funcionam bem (GIL é liberado durante I/O). Para CPU-bound, multiprocessing (processos separados, cada um com seu GIL) ou extensões C são necessários para verdadeiro paralelismo.",
        x: "CPU-bound (calcular pi): threading → sem speedup (GIL). multiprocessing.Pool(4).map(calc, chunks) → 4x speedup (4 processos com GILs independentes). I/O-bound (HTTP requests): threading → speedup normal (GIL liberado durante await de rede).",
      },
      {
        q: "Em Python, o que são metaclasses e como elas controlam a criação de classes?",
        o: [
          "Classes de classes: definem como classes são criadas, permitindo modificar atributos, métodos e validações na definição da classe",
          "Classes abstratas",
          "Decorators de classe",
          "Módulos de import",
        ],
        c: 0,
        e: "Em Python, classes são objetos criados por metaclasses. type é a metaclass padrão. Ao definir class Foo(metaclass=Meta), Meta.__new__() e Meta.__init__() controlam como Foo é criada. Metaclasses podem validar, registrar ou modificar classes automaticamente. ORMs como Django usam metaclasses.",
        x: "class ValidateFields(type): def __new__(mcs, name, bases, namespace): for k, v in namespace.items(): if isinstance(v, str) and not k.startswith('_'): raise TypeError(f'{k} must not be string'). return super().__new__(mcs, name, bases, namespace). class Model(metaclass=ValidateFields): ...",
      },
      {
        q: "Em Python, o que são 'descriptors' e como os protocolos __get__, __set__, __delete__ funcionam?",
        o: [
          "Objetos que definem __get__/__set__/__delete__ e controlam o acesso a atributos de outras classes",
          "Tipos de iterator",
          "Funções de I/O",
          "Métodos de string",
        ],
        c: 0,
        e: "Descriptors são objetos com __get__, __set__ e/ou __delete__ que interceptam acesso a atributos quando usados como atributos de classe. @property, @classmethod, @staticmethod são implementados com descriptors. Data descriptors (__get__ + __set__) têm prioridade sobre o instance __dict__.",
        x: "class Positive: def __set_name__(self, owner, name): self.name = name. def __set__(self, obj, value): if value < 0: raise ValueError('Must be positive'). obj.__dict__[self.name] = value. def __get__(self, obj, type): return obj.__dict__.get(self.name, 0). class Product: price = Positive() // Product().price = -1 → ValueError.",
      },
      {
        q: "O que é o GIL (Global Interpreter Lock) em Python e como impacta concorrência?",
        o: [
          "Lock que permite apenas uma thread executar bytecode por vez; limita paralelismo CPU-bound mas não I/O-bound",
          "Lock de arquivo",
          "Firewall do Python",
          "Gerenciador de memória",
        ],
        c: 0,
        e: "GIL (CPython): mutex que protege o reference counting do GC. Consequência: threads Python não executam em paralelo real para código CPU-bound. Soluções: multiprocessing (processos separados), asyncio (I/O-bound), extenso C/Rust (libera GIL), Python 3.13 free-threaded (experimental).",
        x: "CPU-bound: threading = lento (GIL). multiprocessing.Pool(4).map(heavy_calc, data) = 4x mais rápido. I/O-bound: threading OK (GIL é liberado durante I/O). asyncio: ainda melhor para I/O com milhares de conexões.",
      },
      {
        q: "O que são metaclasses em Python e quando usá-las?",
        o: [
          "Classes de classes — controlam a criação e comportamento de classes em tempo de definição",
          "Classes abstratas",
          "Decorators para classes",
          "Classes estáticas",
        ],
        c: 0,
        e: "Metaclass: classe cujas instâncias são classes. type é a metaclass padrão. Ao definir class Foo(metaclass=Meta), Meta.__new__ e Meta.__init__ controlam a criação de Foo. Usos avançados: ORMs (Django models), registro automático, validação de classes, ABCs.",
        x: "class Meta(type): def __new__(cls, name, bases, ns): if 'validate' not in ns: raise TypeError(f'{name} must implement validate'). return super().__new__(cls, name, bases, ns). class User(metaclass=Meta): def validate(self): pass // OK. class Bad(metaclass=Meta): pass // TypeError!",
      },
      {
        q: "O que é __slots__ em Python e como melhora performance de memória?",
        o: [
          "Declara atributos fixos de instância, eliminando __dict__ e reduzindo memória por objeto em 40-50%",
          "Lista de métodos permitidos",
          "Cache de atributos",
          "Pool de conexões",
        ],
        c: 0,
        e: "__slots__ = ('x', 'y') impede criação de __dict__ por instância. Cada atributo usa descriptor (armazenamento fixo). Benefícios: ~40% menos memória, acesso ~10% mais rápido. Trade-off: não pode adicionar atributos dinâmicos, complica herança múltipla.",
        x: "class Point: __slots__ = ('x', 'y'); def __init__(self, x, y): self.x = x; self.y = y. p = Point(1, 2); p.z = 3 // AttributeError: 'Point' object has no attribute 'z'. # Sem __slots__: ~160 bytes/inst. Com __slots__: ~56 bytes/inst.",
      },
      {
        q: "O que são dataclasses em Python e como simplificam classes de dados?",
        o: [
          "Decorator que gera __init__, __repr__, __eq__ automaticamente a partir de anotações de tipo dos campos",
          "Classes de banco de dados",
          "Tipo especial de dict",
          "Classe abstrata",
        ],
        c: 0,
        e: "@dataclass (Python 3.7): gera __init__, __repr__, __eq__. frozen=True: imutável. field(default_factory=list): defaults mutáveis seguros. __post_init__: validação. Alternativas: NamedTuple (imutável, mais leve), attrs (mais features), Pydantic (validação runtime).",
        x: "from dataclasses import dataclass; @dataclass(frozen=True) class Point: x: float; y: float; def magnitude(self) -> float: return (self.x**2 + self.y**2)**0.5. p = Point(3, 4); p.magnitude() // 5.0. p.x = 0 // FrozenInstanceError.",
      },
    ],
  },

  // ── TypeScript ──
  TypeScript: {
    Fácil: [
      {
        q: "No TypeScript, como se define o tipo de uma variável que pode ser string ou number?",
        o: [
          "Usando union type: string | number",
          "Usando any",
          "Usando Object",
          "Usando string + number",
        ],
        c: 0,
        e: "Union types permitem que uma variável aceite dois ou mais tipos. A sintaxe usa o pipe (|) entre os tipos. O TypeScript exige que operações na variável sejam válidas para todos os tipos da union, ou que se faça narrowing para um tipo específico.",
        x: "let id: string | number; id = 'abc'; // OK. id = 123; // OK. id = true; // Erro: boolean não é string | number.",
      },
      {
        q: "No TypeScript, o que é uma 'interface' e como usá-la para tipar objetos?",
        o: [
          "Contrato que define a estrutura (propriedades e tipos) que um objeto deve ter",
          "Classe abstrata",
          "Função de validação",
          "Módulo de import",
        ],
        c: 0,
        e: "Interfaces definem a 'forma' de um objeto: quais propriedades existem e seus tipos. São apagadas em tempo de compilação (zero-cost). Suportam propriedades opcionais (?), readonly, e podem ser estendidas (extends). Classes podem implementá-las.",
        x: "interface User { name: string; age: number; email?: string; } const u: User = { name: 'Ana', age: 25 }; // email é opcional. u.phone; // Erro: 'phone' não existe em User.",
      },
      {
        q: "No TypeScript, o que são type guards e como usar 'typeof' e 'instanceof' para narrowing?",
        o: [
          "Condições que estreitam o tipo de uma variável dentro de um bloco, permitindo acesso seguro a propriedades",
          "Guardas de segurança",
          "Assertions de tipo",
          "Validações de runtime",
        ],
        c: 0,
        e: "Type guards são expressões condicionais que informam ao TypeScript o tipo específico dentro de um bloco. typeof funciona para primitivos (string, number, boolean). instanceof para classes. Também: 'in' operator, discriminated unions, e custom type predicates (is).",
        x: "function process(value: string | number) { if (typeof value === 'string') { value.toUpperCase(); // OK: TS sabe que é string aqui } else { value.toFixed(2); // OK: TS sabe que é number aqui } }",
      },
      {
        q: "O que é o TypeScript e por que usá-lo em vez de JavaScript puro?",
        o: [
          "Superset tipado de JS que adiciona tipos estáticos, detectando erros em compile-time antes de rodar",
          "Linguagem diferente de JS",
          "Framework de testes",
          "Substituto do Node.js",
        ],
        c: 0,
        e: "TypeScript: JavaScript + sistema de tipos estáticos. Compila para JS puro. Vantagens: erros detectados antes de executar, autocomplete no editor, refactoring seguro, documentação via tipos. Zero overhead em runtime (tipos são removidos na compilação).",
        x: "function greet(name: string): string { return `Hello ${name}`; } greet(42); // Erro em compile-time: Argument of type 'number' is not assignable to parameter of type 'string'. Em JS puro, só descobriria em runtime.",
      },
      {
        q: "O que são Union Types em TypeScript?",
        o: [
          "Tipo que pode ser um de vários tipos, usando | para combinar; requer narrowing para acessar membros específicos",
          "Tipo que combina todos os membros",
          "Array de tipos",
          "Tipo de união de tabelas SQL",
        ],
        c: 0,
        e: "Union type (A | B): valor pode ser A ou B. Para acessar membros específicos, precisa de narrowing (typeof, instanceof, discriminante). Literal unions: type Dir = 'up' | 'down'. Utilisímos para modelar estados.",
        x: "function format(value: string | number): string { if (typeof value === 'string') return value.toUpperCase(); return value.toFixed(2); } format('hello'); // 'HELLO'. format(3.14); // '3.14'.",
      },
      {
        q: "O que são enums em TypeScript e quais tipos estão disponíveis?",
        o: [
          "Conjunto nomeado de constantes: numeric enums (auto-incremento), string enums (valores explícitos) e const enums (inlined)",
          "Arrays de constantes",
          "Tipos de variáveis",
          "Funções especiais",
        ],
        c: 0,
        e: "Numeric enum: auto-incrementa (Up=0, Down=1). String enum: cada membro tem valor string explícito. const enum: inlined em compile-time (sem objeto em runtime). Alternativa moderna: union de literais ('up' | 'down') — mais simples, tree-shakeable.",
        x: "enum Direction { Up, Down, Left, Right } // Up=0, Down=1... enum Status { Active = 'ACTIVE', Inactive = 'INACTIVE' } // String enum. const enum Color { Red, Green, Blue } // Inlined: Color.Red vira 0 no JS. // Alternativa: type Dir = 'up' | 'down';",
      },
      {
        q: "O que é a keyword 'readonly' em TypeScript e onde usá-la?",
        o: [
          "Modifica propriedades para serem somente leitura após inicialização; aplicável em interfaces, classes e arrays",
          "Torna variáveis globais",
          "Impede importação",
          "Delete a propriedade",
        ],
        c: 0,
        e: "readonly impede reatribuição de propriedades após construção. Em interfaces: readonly id: number. Em classes: readonly name: string (só no construtor). ReadonlyArray<T> ou readonly T[]: array sem push/pop. Readonly<T> utility type: todas props readonly.",
        x: "interface User { readonly id: number; name: string; } const u: User = { id: 1, name: 'Ana' }; u.name = 'Bob'; // OK. u.id = 2; // Erro: Cannot assign to 'id' because it is a read-only property. const arr: readonly number[] = [1,2,3]; arr.push(4); // Erro.",
      },
    ],
    Médio: [
      {
        q: "No TypeScript, para que serve o utility type 'Partial<T>' e quando usá-lo?",
        o: [
          "Torna todas as propriedades de T opcionais, útil para atualizações parciais de objetos",
          "Remove todas as propriedades de T",
          "Torna T um array",
          "Faz todas as propriedades readonly",
        ],
        c: 0,
        e: "Partial<T> cria um novo tipo onde todas as propriedades de T são opcionais (?). É útil para funções de atualização parcial onde nem todos os campos precisam ser fornecidos. Internamente: type Partial<T> = { [P in keyof T]?: T[P] }.",
        x: "interface User { name: string; age: number; } function update(id: number, data: Partial<User>) { } update(1, { name: 'Ana' }); // OK: age é opcional.",
      },
      {
        q: "No TypeScript, o que são 'type assertions' (as) e quando usá-las com cuidado?",
        o: [
          "Afirmam ao compilador que um valor é de determinado tipo, sem verificar em runtime; podem mascarar erros",
          "Conversão de tipos em runtime",
          "Validação automática",
          "Criação de novos tipos",
        ],
        c: 0,
        e: "Type assertions (valor as Tipo) dizem ao TS 'confie em mim, eu sei o tipo'. NÃO fazem conversão em runtime — só afetam a verificação do compilador. Uso legítimo: quando você sabe mais que o TS (ex: após validação). Perigo: mascarar erros de tipo que só aparecem em runtime.",
        x: "const input = document.getElementById('name') as HTMLInputElement; input.value; // OK. // Perigoso: const data = response as User; // Se response não for User, erro em runtime, não em compiletime.",
      },
      {
        q: "No TypeScript, o que são 'discriminated unions' e como usam uma propriedade tag para narrowing?",
        o: [
          "Uniões onde cada membro tem uma propriedade literal única (tag) que permite narrowing exaustivo via switch/if",
          "Uniões de strings",
          "Enums",
          "Generics",
        ],
        c: 0,
        e: "Discriminated unions têm uma propriedade 'tag' (tipo literal) que identifica cada membro. TypeScript usa a tag para narrowing: dentro de cada case/if, o tipo é estreitado automaticamente. ExhaustiveCheck (é atribuír a never) garante cobertura total.",
        x: "type Shape = { kind: 'circle'; radius: number } | { kind: 'rect'; w: number; h: number }; function area(s: Shape) { switch(s.kind) { case 'circle': return Math.PI * s.radius ** 2; case 'rect': return s.w * s.h; } }",
      },
      {
        q: "O que são Utility Types em TypeScript e quais os mais usados?",
        o: [
          "Tipos genéricos built-in que transformam outros tipos: Partial, Required, Pick, Omit, Record",
          "Tipos para utilitários de string",
          "Funções helper",
          "Tipos numéricos",
        ],
        c: 0,
        e: "Utility Types: Partial<T> (todas props opcionais), Required<T> (todas required), Pick<T,K> (seleciona props), Omit<T,K> (remove props), Record<K,V> (mapa de chave-valor), Readonly<T>, ReturnType<T>, Parameters<T>. Construídos com Mapped Types.",
        x: "type User = { name: string; age: number; email: string }; type UpdateUser = Partial<Pick<User, 'name' | 'email'>>; // { name?: string; email?: string }. Omit<User, 'email'>; // { name: string; age: number }.",
      },
      {
        q: "O que é o conceito de type narrowing em TypeScript?",
        o: [
          "Processo de refinar um tipo amplo para um mais específico usando guards (typeof, instanceof, in, discriminant)",
          "Converter tipos automaticamente",
          "Criar tipos menores",
          "Comprimir tipos para performance",
        ],
        c: 0,
        e: "Type narrowing: TS refina o tipo dentro de blocos condicionais. typeof (primitivos), instanceof (classes), 'prop' in obj (presença de propriedade), discriminated unions (campo literal), type predicates (is). Após narrowing, TS conhece o tipo exato.",
        x: "function handle(x: string | string[]) { if (Array.isArray(x)) { x.join(', '); // TS sabe: string[] } else { x.toUpperCase(); // TS sabe: string } } // Custom guard: function isUser(x: any): x is User { return 'name' in x; }",
      },
      {
        q: "O que são Mapped Types em TypeScript e como funcionam?",
        o: [
          "Tipos que iteram sobre chaves de outro tipo criando novas propriedades: { [K in keyof T]: NovoTipo }",
          "Tipos de Map/Set",
          "Arrays tipados",
          "Mapeamento de rotas",
        ],
        c: 0,
        e: "Mapped Types: iteram sobre keys de um tipo com 'in keyof'. Base dos Utility Types. Modificadores: +/- readonly, +/- ?. Podem remapear chaves com 'as'. Partial<T> = { [K in keyof T]?: T[K] }. Readonly<T> = { readonly [K in keyof T]: T[K] }.",
        x: "type Optional<T> = { [K in keyof T]?: T[K] }; // = Partial<T>. type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] }; type UserGetters = Getters<{name: string}>; // { getName: () => string }.",
      },
      {
        q: "O que é o operador 'keyof' em TypeScript e como usá-lo?",
        o: [
          "Produz uma union type de todas as chaves (propriedades) de um tipo: keyof {a: 1, b: 2} = 'a' | 'b'",
          "Retorna as chaves de um objeto em runtime",
          "Cria chaves de array",
          "Operador de comparação",
        ],
        c: 0,
        e: "keyof T: produz union de chaves de T como string literal types. keyof {name: string; age: number} = 'name' | 'age'. Combinado com generics: function get<T, K extends keyof T>(obj: T, key: K): T[K] — retorno tipado corretamente. Indexed access: T[K].",
        x: "type User = { name: string; age: number }; type UserKey = keyof User; // 'name' | 'age'. function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; } getProperty(user, 'name'); // retorno tipo string. getProperty(user, 'xyz'); // ERRO.",
      },
    ],
    Difícil: [
      {
        q: "No TypeScript, como os 'template literal types' permitem construir tipos de string com padrões dinâmicos?",
        o: [
          "Usando backtick types que interpolam outros tipos para gerar unions de strings automaticamente",
          "Usando regex em runtime",
          "Usando typeof com strings",
          "Usando enums com string values",
        ],
        c: 0,
        e: "Template literal types usam a sintaxe de template strings para criar tipos. Quando combinados com unions, geram automaticamente o produto cartesiano de todas as combinações possíveis. Permitem tipagem precisa de padrões de string como event names, CSS properties, etc.",
        x: "type Color = 'red' | 'blue'; type Size = 'sm' | 'lg'; type ClassName = `${Color}-${Size}`; // 'red-sm' | 'red-lg' | 'blue-sm' | 'blue-lg' — 4 combinações geradas automaticamente.",
      },
      {
        q: "No TypeScript, o que são Conditional Types e como usar 'infer' para extrair tipos?",
        o: [
          "Tipos que escolhem entre dois ramos com T extends U ? X : Y; infer extrai sub-tipos dentro de condições",
          "If/else em runtime",
          "Validação de dados",
          "Loops de tipo",
        ],
        c: 0,
        e: "Conditional types permitem lógica no nível de tipos: T extends U ? TrueType : FalseType. 'infer' captura sub-tipos dentro da condição. ReturnType<T>, Parameters<T>, Awaited<T> são implementados com conditional types + infer. Distribui sobre unions automaticamente.",
        x: "type Flatten<T> = T extends Array<infer U> ? U : T; type A = Flatten<string[]>; // string. type B = Flatten<number>; // number. type Params<T> = T extends (...args: infer P) => any ? P : never; type P = Params<(a: string, b: number) => void>; // [string, number].",
      },
      {
        q: "No TypeScript, como os 'declaration files' (.d.ts) permitem tipar bibliotecas JavaScript?",
        o: [
          "Arquivos que declaram tipos sem implementação, descrevendo a interface de código JS para o compilador TS",
          "Arquivos de documentação",
          "Configurações do compilador",
          "Testes unitários",
        ],
        c: 0,
        e: "Declaration files (.d.ts) contêm apenas declarações de tipo (sem código executado). Permitem que o TypeScript entenda a API de bibliotecas JavaScript. @types/* no npm (DefinitelyTyped) fornece .d.ts para milhares de libs. 'declare module' tipar módulos sem tipos.",
        x: "// lodash.d.ts: declare module 'lodash' { export function chunk<T>(array: T[], size: number): T[][]; } // Agora: import { chunk } from 'lodash'; chunk([1,2,3,4], 2); // TypeScript sabe que retorna number[][].",
      },
      {
        q: "O que é Template Literal Types em TypeScript e como permitem tipagem de strings dinâmicas?",
        o: [
          "Tipos que usam template literals para criar uniões de strings automaticamente a partir de outros tipos",
          "Strings multilinhas",
          "Templates de código",
          "Formatação de strings",
        ],
        c: 0,
        e: "Template Literal Types: type EventName = `on${Capitalize<'click' | 'hover'>}` = 'onClick' | 'onHover'. Combinam com Mapped Types para gerar tipos de strings programaticamente. Usados em tipagem de APIs como CSS-in-JS, event handlers, path params.",
        x: "type Getter<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] }; type UserGetters = Getter<{name: string; age: number}>; // { getName: () => string; getAge: () => number }.",
      },
      {
        q: "O que é o TypeScript 'satisfies' operator e quando usá-lo?",
        o: [
          "Valida que um valor atende a um tipo sem alargar o tipo inferido, mantendo narrowing",
          "Operador de comparação",
          "Verifica igualdade em runtime",
          "Alternativa ao 'as'",
        ],
        c: 0,
        e: "satisfies (TS 4.9): valida conformidade com um tipo sem alterar o tipo inferido. Diferente de ': Type' (anotação que alarga) e 'as Type' (asserção que pode mentir). Com satisfies, TS valida E preserva o tipo literal/narrowed.",
        x: "const config = { port: 3000, host: 'localhost' } satisfies Record<string, string | number>; config.port; // tipo: number (preservado!). Com ': Record<...>': config.port seria string | number (alargado).",
      },
      {
        q: "O que são Mapped Types com modificação de chaves (key remapping) em TypeScript?",
        o: [
          "Mapped Types com 'as' que transformam ou filtram chaves durante a iteração: [K in keyof T as NewKey]: Type",
          "Renomeação de variáveis",
          "Import com alias",
          "Refactoring automático",
        ],
        c: 0,
        e: "Key remapping (TS 4.1): [K in keyof T as `get${Capitalize<K>}`]: permite renomear, transformar ou filtrar chaves. Filtrar: [K in keyof T as T[K] extends Function ? never : K] remove métodos. Combina com template literal types para gerar APIs tipadas.",
        x: "type EventConfig<T> = { [K in keyof T as `on${Capitalize<string & K>}Change`]: (val: T[K]) => void }; type UserEvents = EventConfig<{name: string; age: number}>; // { onNameChange: (val: string) => void; onAgeChange: (val: number) => void }.",
      },
      {
        q: "O que são branded/nominal types em TypeScript e qual problema resolvem?",
        o: [
          "Técnica para criar tipos estruturalmente únicos via propriedade fantasma, evitando troca acidental de valores",
          "Tipos de marca registrada",
          "Nomes de tipos exportados",
          "Tipos de classe nominal",
        ],
        c: 0,
        e: "TypeScript usa tipagem estrutural (dois tipos com mesma forma são compatíveis). Branded types adicionam propriedade única __brand para criar incompatibilidade: UserId e PostId são ambos number, mas branded types impedem passar UserId onde PostId é esperado.",
        x: "type UserId = number & { __brand: 'UserId' }; type PostId = number & { __brand: 'PostId' }; function getUser(id: UserId) {} function createUserId(id: number): UserId { return id as UserId; } getUser(createUserId(1)); // OK. getUser(42 as PostId); // ERRO: PostId != UserId.",
      },
    ],
  },
};

// ─── Round 1 · +1 questão por nível por categoria ───

const linguagensRound1Extras: Record<string, Record<UserLevel, SeedCard[]>> = {
  C: {
    Fácil: [
      {
        q: "O que são ponteiros em C e qual o operador para obter o endereço de uma variável?",
        o: [
          "Ponteiro armazena o endereço de memória de outra variável; '&' obtém o endereço e '*' acessa o valor apontado (dereference)",
          "Ponteiro é um array de bytes que armazena o valor de outra variável",
          "'@' obtém endereço e '->' acessa o valor em C padrão",
          "Ponteiros em C são iguais a referências em Java, sem aritmeticá de endereços",
        ],
        c: 0,
        e: "int x = 10; int *p = &x; *p = 20; // x agora vale 20. '&x' retorna o endereço de x na memória. '*p' acessa o valor naquele endereço (54321 por exemplo). Aritmética de ponteiros: p+1 avança sizeof(int) bytes. Ponteiros nulos: NULL; dereferenciar NULL causa segfault.",
        x: "Trocar dois valores sem retorno: void swap(int *a, int *b) { int tmp=*a; *a=*b; *b=tmp; }. Chamar: swap(&x, &y). Sem ponteiro: swap(x,y) receberia cópias, original não mudaria (pass by value). Ponteiro para ponteiro: int **pp = &p; — usado em allocações de matrizes dinâmicas.",
      },
    ],
    Médio: [
      {
        q: "O que é undefined behavior em C e cite dois exemplos clássicos que o causam?",
        o: [
          "Comportamento não definido pela norma C; exemplos: acessar array fora dos limites e ler variável não inicializada — compilador pode gerar qualquer resultado",
          "Resultado sempre previsível mas não especificado; ponteiros nulos causam UB por definição",
          "Erro de compilação gerado quando o compilador detecta comportamento indefinido",
          "Apenas overflow de inteiro signed é UB; outros casos são implementation-defined",
        ],
        c: 0,
        e: "Undefined Behavior (UB): a norma C não especifica o resultado. O compilador pode: crash, resultado incorreto, remover o código completamente (otimização). Exemplos: int arr[3]; arr[5]=1 (buffer overflow), int x; printf('%d', x) (leitura de lixo), signed integer overflow i=INT_MAX; i++, dereferenciar NULL. Ferramentas: Valgrind, AddressSanitizer (-fsanitize=address) detectam em runtime.",
        x: "arr[10] em array de 5: pode 'funcionar' em debug (memória válida ali por acaso), crash em release (otimização muda layout). UB permite GCC assumir que ponteiros não são nulos e remover checks de nulidade. 'Nasal demons': expressão da comunidade C para UB que faz qualquer coisa. Compile com -Wall -Wextra -fsanitize=address para detectar.",
      },
    ],
    Difícil: [
      {
        q: "Como funcionam as funções variadic em C (tipo printf) usando stdarg.h?",
        o: [
          "Usam va_list, va_start, va_arg, va_end para acessar argumentos extras em runtime; o número e tipo dos args deve ser inferido de outro argumento (ex: string de formato)",
          "Recebem array explícito com tamanho e ponteiro; stdarg.h apenas documenta a interface",
          "Compilador empacota todos os args em struct automático acessível por índice",
          "Somente o compilador usa va_list internamente; programadores usam `...` sem stdarg.h",
        ],
        c: 0,
        e: "Variadic: int soma(int n, ...) { va_list args; va_start(args, n); int tot=0; for(int i=0;i<n;i++) tot+=va_arg(args,int); va_end(args); return tot; }. va_start inicializa após o último parâmetro fixo. va_arg extrai próximo arg com o tipo especificado. va_end limpa. Sem informação de tipo em runtime: printf usa format string para saber tipos. Type mismatch = UB.",
        x: "soma(3, 10, 20, 30) = 60. printf utiliza format string '%d %s %f' para extrair int, char*, double nessa ordem. Dar tipo errado: printf('%d', 3.14) — UB (doubles passam diferente de ints na ABI x86-64). __attribute__((format(printf, 1, 2))) no GCC valida a format string em compile-time. C23 introduz typeof para variadic mais seguro.",
      },
    ],
  },
  "C++": {
    Fácil: [
      {
        q: "O que é RAII (Resource Acquisition Is Initialization) em C++ e como evita memory leaks?",
        o: [
          "Padrão onde recurso é adquirido no construtor e liberado no destrutor automaticamente ao sair do escopo; smart pointers (unique_ptr, shared_ptr) implementam RAII",
          "Inicializar todas as variáveis antes de usadas para evitar UB e memory leak",
          "Alocar memória somente na inicialização do programa para evitar fragmentação",
          "Padrão de código que exige construtor e destrutor em toda classe que usa heap",
        ],
        c: 0,
        e: "RAII: ligar ciclo de vida do recurso ao ciclo de vida do objeto. Construtor: open file / alloc memory. Destrutor: close file / free memory. Destrutor é chamado automaticamente ao sair do escopo (stack unwinding), mesmo em exceções. unique_ptr<T>: destrutor chama delete. shared_ptr<T>: contagem de referências, delete quando chega a 0. Elimina new/delete explícito.",
        x: "Sem RAII: int *p = new int[100]; if(erro) return; // LEAK! delete[] p; Com RAII: auto p = std::make_unique<int[]>(100); if(erro) return; // destrutor chama delete[] automaticamente. std::ifstream file('dados.txt'); // fecha automaticamente no destrutor. lock_guard<mutex> lk(mtx); // libera mutex ao sair do escopo, mesmo com exceção.",
      },
    ],
    Médio: [
      {
        q: "O que são templates em C++ e como o compilador realiza template instantiation?",
        o: [
          "Código genérico parametrizado por tipo; o compilador gera código específico para cada tipo usado (monomorfização em compile-time), sem overhead de runtime",
          "Macros de pré-processador tipadas que geram código com substituição textual",
          "Interfaces genéricas que o linker resolve dinamicamente com virtual dispatch",
          "Apenas templates de classe existem; funções genéricas usam virtual functions",
        ],
        c: 0,
        e: "Templates: template<typename T> T max(T a, T b) { return a>b?a:b; }. Compiler: ao ver max(3,4) gera max<int>; ao ver max(3.0,4.0) gera max<double>. Cada instanciação é código separado. Template specialization: implementação específica para tipo concreto. Concepts (C++20): restringem o tipo (requires Comparable). SFINAE: substituição que falha silenciosamente para seleção de overload.",
        x: "std::vector<int> e std::vector<string>: dois conjuntos de código separados gerados. Vantagem: sem overhead de boxin/unboxing como Java generics (erasure). Desvantagem: tempos de compilação maiores, binários maiores (code bloat). Concepts C++20: template<Numeric T> elimina erros de template cripíticos de N páginas de SFINAE.",
      },
    ],
    Difícil: [
      {
        q: "O que é move semantics em C++11 e como rvalue references (&& ) e std::move otimizam transferência de recursos?",
        o: [
          "Move semantics transfere propriedade de recursos (sem cópia profunda) via rvalue reference; std::move converte lvalue em rvalue; destrutor do original fica em estado válido mas indeterminado",
          "std::move copia o objeto e libera a memória do original imediatamente",
          "Move semantics é otimização do compilador que elimina cópias; o programador não tem controle",
          "Rvalue references são ponteiros temporários sem dono que o GC libera após o uso",
        ],
        c: 0,
        e: "Sem move: vector<string> b = a; copia todos os bytes de cada string. Com move: vector<string> b = std::move(a); transfere ponteiro interno de a para b, a fica em estado válido mas vazio. Construtor de move: String(String&& src) { data=src.data; src.data=nullptr; }. RVO/NRVO: compilador elide cópias em retornos. Perfect forwarding: template<T&&> forward<T>(t) preserva lvalue/rvalue.",
        x: "std::vector<std::string> v; v.push_back(std::string(10000, 'x')); // rvalue: move, não copia. std::string s(10000,'z'); v.push_back(std::move(s)); // s virou rvalue, move ocorre. Benchmark: mover vector com 100k strings: 10μs. Copiar: 500ms. emplace_back(args...) constrói diretamente no lugar — ainda melhor que move.",
      },
    ],
  },
  "C#": {
    Fácil: [
      {
        q: "O que é LINQ (Language Integrated Query) em C# e quais são os dois estilos de sintaxe?",
        o: [
          "LINQ permite consultas tipadas em coleões e fontes de dados usando sintaxe de query (SQL-like) ou sintaxe de método (fluent com lambda), integrada na linguagem com verificação de tipos em compile-time",
          "Biblioteca para acesso a banco de dados SQL sem ORM, integrada no compilador",
          "Apenas sintaxe de query existe; métodos LINQ são apenas wrappers internos",
          "LINQ só funciona com IList e Array; para outras coleções requer adapters externos",
        ],
        c: 0,
        e: "LINQ (Language Integrated Query): opera sobre IEnumerable<T> / IQueryable<T>. Query syntax: from p in products where p.Price > 100 select p.Name. Method syntax: products.Where(p => p.Price > 100).Select(p => p.Name). Query syntax é convertida pelo compilador para method syntax. Providers: LINQ to Objects (memória), EF Core (SQL gerado), LINQ to XML.",
        x: "var nomes = from p in pessoas where p.Idade >= 18 orderby p.Nome select p.Nome; // query syntax. var nomes2 = pessoas.Where(p => p.Idade >= 18).OrderBy(p => p.Nome).Select(p => p.Nome); // fluent. EF Core: Where() gera WHERE em SQL (deferred execution). ToList() executa a query. AsNoTracking() para queries read-only.",
      },
    ],
    Médio: [
      {
        q: "O que é async/await em C# e como difere de Task.Run para operações I/O-bound vs CPU-bound?",
        o: [
          "async/await libera thread durante I/O-bound (sem thread ocupada); Task.Run delega trabalho CPU-bound para thread pool; não usar Task.Run para I/O pois desperdiça thread",
          "async/await cria novas threads para cada operação; Task.Run reutiliza threads do pool",
          "São equivalentes; escolha é apenas estilística para qualquer tipo de operação",
          "Task.Run deve ser usado para I/O; async/await é apenas para CPU para não bloquear a UI",
        ],
        c: 0,
        e: "await HttpClient.GetAsync(): thread retorna ao pool enquanto aguarda rede. Sem thread bloqueada. Task.Run(() => PesadoCalculo()): envia para thread do pool para cálculo pesado (não bloquear main thread/UI). Anti-pattern: await Task.Run(async () => await httpClient.GetAsync()) — ocupa thread do pool esperando I/O. ConfigureAwait(false): não captura SynchronizationContext (libs).",
        x: "ASP.NET Core: public async Task<IActionResult> Get() { var data = await _db.Usuarios.ToListAsync(); return Ok(data); } — thread liberada durante query ao banco, suporta mais requisições simultâneas. Blazor/WinForms: Task.Run(() => calcularHash(bytes)) move CPU-bound para background, não trava UI. CancellationToken: cancela operação assíncrona em andamento.",
      },
    ],
    Difícil: [
      {
        q: "Como funcionam os Channels em C# (.NET 5+) para comunicação entre producers e consumers assíncronos?",
        o: [
          "Channel<T> é fila assíncrona thread-safe; ChannelWriter.WriteAsync produz; ChannelReader.ReadAsync consume; suporta bounded (backpressure) e unbounded; mais eficiente que BlockingCollection",
          "Channels são streams de rede TCP encapsulados para comunicação entre processos",
          "Equivalente a ConcurrentQueue com await; possui exatamente os mesmos trade-offs",
          "Channels exigem lock explícito; WriteAsync e ReadAsync não são thread-safe por padrão",
        ],
        c: 0,
        e: "Channel<T>: pipeline assíncrono eficiente. Bounded: Channel.CreateBounded<T>(capacity) — WriteAsync faz await se cheio (backpressure automático). Unbounded: nunca bloqueia escrita. ReadAsync: await se vazio. IAsyncEnumerable<T>: reader.ReadAllAsync() itera com await foreach. Cancelamento: CancellationToken em todas as operações. Multiple consumers: cada reader recebe item único (fan-out via múltiplos channels).",
        x: "var ch = Channel.CreateBounded<string>(100); // producer Task.Run(async () => { await ch.Writer.WriteAsync('item'); ch.Writer.Complete(); }); // consumer await foreach (var item in ch.Reader.ReadAllAsync()) { Process(item); }. Backpressure: producer pausa quando ch cheio até consumer consumir. Pipeline de processamento de imagens: decode → channel → resize → channel → encode.",
      },
    ],
  },
  Go: {
    Fácil: [
      {
        q: "O que são goroutines em Go e como diferem de threads do sistema operacional?",
        o: [
          "Goroutines são tarefas leves gerenciadas pelo runtime Go com stack inicial de 2KB; milhares podem coexistir; mapeadas em poucas threads do OS via scheduler M:N",
          "Goroutines são aliases para threads POSIX com sintaxe simplificada",
          "Cada goroutine tem uma thread do OS dedicada, ideal para paralelismo CPU",
          "Goroutines são callbacks assíncronos sem stack próprio executados no event loop",
        ],
        c: 0,
        e: "Goroutine: go func() {}(). Stack: começa em 2KB, cresce dinamicamente até 1GB. Thread OS: 1-8MB de stack fixo. Scheduler Go (GMP): G=goroutines, M=OS threads, P=processors (GOMAXPROCS). M:N multiplexing: N goroutines em M threads. Context switch goroutine: ~100ns; thread OS: ~10μs. 1 milhão de goroutines: factível (2TB de stack total máx).",
        x: "Servidor HTTP com 10k conexões simultâneas: Go → 10k goroutines (~20MB stack total). Node.js: event loop single-thread. Java (virtual threads Java 21: semelhante). go func() { http.Serve(conn) }(); // nova goroutine por conexão. GOMAXPROCS: default = número de CPUs. runtime.NumGoroutine() inspeciona goroutines ativas.",
      },
    ],
    Médio: [
      {
        q: "Como channels em Go implementam comunicação entre goroutines e o que é select?",
        o: [
          "Channel: fila tipada thread-safe; unbuffered bloqueia sender/receiver até ambos prontos; buffered não bloqueia até encher; select aguarda múltiplos channels simultaneamente",
          "Channels são shared memory com mutex embutido; select é switch para tipos de channel",
          "Channels só transmitem ponteiros; valores primitivos requerem sync.Mutex",
          "select executa todos os cases simultaneamente em goroutines separadas",
        ],
        c: 0,
        e: "Unbuffered: ch := make(chan int) — send bloqueia até receive, synchronization ponto a ponto. Buffered: ch := make(chan int, 10) — send não bloqueia até buffer cheio. Direcionais: chan<- (send only), <-chan (receive only). select: como switch para channels — executa o case cujo channel está pronto; se mútiplos prontos, escolhe aleatoriamente. default: não bloqueia.",
        x: "select { case msg := <-ch1: fmt.Println(msg) case ch2 <- 'ok': // enviou case <-time.After(1*time.Second): fmt.Println('timeout') }. Pipeline: producer → ch1 → transformer → ch2 → consumer. close(ch): receiver recebe zero value + ok=false. for v := range ch { } lê até fechar. Fan-out: várias goroutines lendo do mesmo channel.",
      },
    ],
    Difícil: [
      {
        q: "O que é o modelo de concorrência de Go e como defer, panic e recover formam o mecanismo de tratamento de erros?",
        o: [
          "defer: executa função ao retornar (LIFO); panic: interrompe execução normal e desempilha defers; recover: captura o panic dentro de defer e permite recuperação graceful",
          "panic é equivalente a throw; recover é catch; defer é finally; modelo igual a try-catch-finally Java",
          "recover pode ser chamado em qualquer ponto para capturar panics pendentes",
          "defer executa imediatamente antes da linha que o segue; não ao retornar",
        ],
        c: 0,
        e: "defer: empilha função para executar quando função atual retorna. LIFO: múltiplos defers em ordem inversa. Captura variáveis por referência. panic: como throw mas raramente usado — preferível retornar error. stack unwinding executa defers. recover(): só válido dentro de defer; captura o valor do panic e interrompe unwinding. Idioma: Go usa retorno de error explícito para fluxo normal, panic/recover para invariantes violadas.",
        x: "func safeDiv(a, b int) (result int, err error) { defer func() { if r := recover(); r != nil { err = fmt.Errorf('panic: %v', r) } }(); return a/b, nil }. safeDiv(10, 0): division by zero → panic → recover captura → retorna err='panic: runtime error: integer divide by zero'. Cleanup com defer: defer file.Close(); defer mu.Unlock(); ordem reversa garantida mesmo com panic.",
      },
    ],
  },
  Java: {
    Fácil: [
      {
        q: "O que é o Java Garbage Collector e quais as gerações (Young, Old, Metaspace)?",
        o: [
          "GC gerencia memória automaticamente; Young generation (objetos novos, GC frequente e rápido); Old generation (objetos longevos, GC menos frequente); Metaspace (metadados de classes)",
          "GC usa contagem de referências como Python; Young/Old são níveis de prioridade de coleta",
          "Java não tem gerações; todo GC varre toda a heap uniformemente",
          "Young generation só para arrays; Old generation para objetos com campos de instância",
        ],
        c: 0,
        e: "Heap generacional: Young (Eden + S0 + S1) — objetos novos alocados em Eden, Minor GC rápido (stop-the-world ms). Objetos que sobrevivem vaó para Survivor spaces, depois promovidos para Old gen. Old gen (Tenured): Major GC/Full GC mais lento. Metaspace (Java 8+, substitui PermGen): bytecode de classes, crescimento dinâmico.",
        x: "G1GC (default Java 9+): divide heap em regiões, GC incremental. ZGC (Java 11+): pause < 1ms mesmo em heaps de TB. GraalVM: ahead-of-time compilation elimina GC de JVM em native image. -Xms512m -Xmx4g: heap mínimo e máximo. jstat -gcutil PID: monitorar GC em runtime. OOM Error: heap esgotada após GC.",
      },
    ],
    Médio: [
      {
        q: "O que são Optional<T> e Stream<T> em Java 8+ e como compostos resolvem null checks e iterações verbosas?",
        o: [
          "Optional evita NullPointerException encapsulando valor possivelmente ausente com map/flatMap/orElse; Stream processa coleções de forma declarativa com operações encadeadas lazy",
          "Optional e Stream são wrappers de sincronização para thread-safety",
          "Stream substitui for loops mas executa ansiosamente (eagerly) gerando lista imediata",
          "Optional é apenas para retorno de métodos; usar null internamente ainda é correto",
        ],
        c: 0,
        e: "Optional.of/ofNullable/empty. map(): transforma valor se presente. flatMap(): evita Optional<Optional<T>>. orElse(default): valor alternativo. orElseGet(supplier): lazy. orElseThrow(): exceção se vazio. Stream: lazy (operações intermediárias: filter, map, sorted) + eager (terminais: collect, count, findFirst). Parallel streams: .parallelStream() para CPU-bound com Fork/Join pool.",
        x: "Verboso: String cidade = null; if(user != null && user.getAddress() != null) cidade = user.getAddress().getCidade(); Com Optional: String cidade = Optional.ofNullable(user).map(User::getAddress).map(Address::getCidade).orElse('N/D'). Stream: lista.stream().filter(p -> p.getAtivo()).mapToInt(Pedido::getValor).average().orElse(0.0).",
      },
    ],
    Difícil: [
      {
        q: "Como o Java Virtual Threads (Project Loom, Java 21) altera o modelo de concorrência e qual o impacto para servidores web?",
        o: [
          "Virtual threads são threads leves gerenciadas pela JVM montadas sobre carrier threads; operacoess bloqueantes (I/O, sleep) desmontam o carrier; permite thread-per-request sem overhead de 10k+ threads OS",
          "Virtual threads são apenas coroutines Kotlin compiladas para JVM",
          "Substituem CompletableFuture; código assíncrono com async/await é eliminado",
          "Cada virtual thread tem JVM própria isolada, similar a processos OS",
        ],
        c: 0,
        e: "Project Loom (Java 21 LTS): Thread.ofVirtual().start(() -> ...). Stack: KB vs MB de platform thread. JVM scheduler: ao encontrar op. bloqueante (socket read, sleep), desmonta a virtual thread do carrier thread, carrier continua com outra virtual thread. Nenhuma mudança de código: JDBC, HttpURLConnection, bloqueantes funcionam sem callback. Throughput: 10k conexões HTTP simultâneas com 10k virtual threads vs 200 platform threads (limite prático).",
        x: "Servlet com virtual threads: cada requisição em Thread.ofVirtual(). db.query() bloqueia → carrier segue outra virtual thread. Spring Boot 3.2: virtual threads por default em Tomcat com Loom. Antes: CompletableFuture.supplyAsync() necessário para não bloquear. Agora: código síncrono simples com throughput assíncrono. Pinning: synchronized block prende virtual thread ao carrier (evitar em hot paths).",
      },
    ],
  },
  JavaScript: {
    Fácil: [
      {
        q: "O que é o operador de optional chaining (?.) e o nullish coalescing (??) em JavaScript moderno?",
        o: [
          "?. acessa propriedade sem lancar erro se o objeto é null/undefined (retorna undefined); ?? retorna lado direito somente se lado esquerdo é null/undefined (diferente de || que considera 0 e string vazia falsy)",
          "?. é o operador ternário curto; ?? é o operador de coalescência OR lógico",
          "Ambos são equivalentes ao operador || com checagem de tipo explícita",
          "?. é usado somente com métodos; ?? somente com primitivos",
        ],
        c: 0,
        e: "Optional chaining: user?.address?.city — curto-circuito se null/undefined, retorna undefined sem TypeError. ?. com método: arr?.map(fn). ?. com índice: arr?.[0]. Nullish coalescing: a ?? b — retorna b só se a é null ou undefined. || retorna b para qualquer falsy (0, '', false) o que pode ser indesejado. Combinação: user?.settings?.theme ?? 'dark'.",
        x: "const cidade = usuario?.endereço?.cidade; // undefined se usuario ou endereço for null, sem crash. const port = config.port ?? 3000; // 3000 somente se config.port for null/undefined. config.port = 0: ?? retorna 0 (correto); || retornaria 3000 (bug!). Logical assignment: x ??= 'default'; x ||= 'fallback'; x &&= transform(x).",
      },
    ],
    Médio: [
      {
        q: "O que são WeakMap e WeakSet em JavaScript e quando usar ao invés de Map e Set?",
        o: [
          "WeakMap/WeakSet mantm referências fracas (não impedem GC); chave/elemento deve ser objeto; útil para metadados privados e caches sem memory leak quando objetos são removidos",
          "WeakMap tem performance melhor que Map para qualquer uso; preferível sempre",
          "São versões thread-safe de Map/Set para ambientes com Web Workers",
          "WeakMap permite chaves primitivas; WeakSet permite valores mistos com GC",
        ],
        c: 0,
        e: "WeakMap: chaves = objetos, valores = qualquer. Se não há outra referência ao objeto-chave, o GC pode coletar a entrada. Não é iterável (sem .keys(), não tem size). WeakSet: colecção de objetos sem duplicatas, GC pode coletar. Uso: armazenar metadados privados de objetos, cache por objeto, marcar objetos processados sem impedir GC.",
        x: "Cache por DOM element: const cache = new WeakMap(); function getMetadata(el) { if(!cache.has(el)) cache.set(el, computeExpensive(el)); return cache.get(el); }. Quando el é removido do DOM (sem outra referência), GC coleta automaticamente a entrada. Map guardé el como chave — memory leak. WeakRef (ES2021): referência fraca com deref() explicit.",
      },
    ],
    Difícil: [
      {
        q: "Como funcionam os Iterators e Generators em JavaScript e qual a relação com o protocolo Symbol.iterator?",
        o: [
          "Iterator: objeto com next() que retorna {value, done}; Generator: função* que produz valores lazy via yield; Symbol.iterator torna qualquer objeto iterável com for...of e spread",
          "Generators criam threads assíncronas; Symbol.iterator é apenas para arrays nativas",
          "Iterator é igual a Promise; yield é equivalente a await em funções generator",
          "Symbol.iterator só funciona com classes ES6; funcões factory não podem ser iteráveis",
        ],
        c: 0,
        e: "Iterator protocol: { next() { return {value: T, done: boolean} } }. Iterable: objeto com [Symbol.iterator]() retornando iterator. for...of, spread [...], destructuring usam Symbol.iterator. Generator: function* gen() { yield 1; yield 2; }. Lazy: valores calculados sob demanda. Infinite sequence: function* naturais() { let n=0; while(true) yield n++; }. Async generator: async function* para streams assíncronos.",
        x: "Sequencia de fibonacci lazy: function* fib() { let [a,b]=[0,1]; while(true) { yield a; [a,b]=[b,a+b]; } }. [...take(fib(), 10)] → primeiros 10. Custom iterable: class Range { [Symbol.iterator]() { let i=this.start; return { next: () => i<=this.end ? {value:i++,done:false} : {done:true} }; } }. for(const n of new Range(1,5)) — itera 1,2,3,4,5.",
      },
    ],
  },
  Kotlin: {
    Fácil: [
      {
        q: "O que são data classes em Kotlin e quais métodos são gerados automaticamente?",
        o: [
          "Classes para guardar dados; geram automaticamente equals, hashCode, toString, copy e componentN (destructuring) baseados nas propriedades do construtor primário",
          "Classes imutáveis sem métodos gerados; apenas síntaxe compacta de declaração",
          "Geram somente toString() e hashCode(); os demais precisam ser implementados",
          "São exclusivas para modelos de banco de dados com Room; não úteis em geral",
        ],
        c: 0,
        e: "data class Person(val name: String, val age: Int). Gerado: equals() (compara por valor dos campos), hashCode() (consistente com equals), toString() 'Person(name=Ana, age=25)', copy(age=26) (cria cópia com campos alterados), component1() retorna name, component2() retorna age. Destructuring: val (nome, idade) = person.",
        x: "val p1 = Person('Ana', 25); val p2 = Person('Ana', 25); p1 == p2 // true (valor, não referência). val p3 = p1.copy(age=26); // p3.name='Ana', p3.age=26. val (n, i) = p1; // destructuring. Kotlin sealed class + data class: ADT (algebraic data types) para when expressions exaustivas. Ideal para DTOs, eventos de domínio, estados de UI.",
      },
    ],
    Médio: [
      {
        q: "Como funcionam as coroutines em Kotlin e qual a diferença entre launch, async e runBlocking?",
        o: [
          "Coroutines: concorrência leve; launch: fire-and-forget (retorna Job); async: retorna Deferred<T> para resultado futuro com await(); runBlocking: bloqueia thread atual para testes ou main()",
          "launch e async são idênticos; runBlocking cria nova thread OS",
          "Coroutines Kotlin são alias de threads; suspend apenas documenta que a função é lenta",
          "async é fire-and-forget; launch retorna Deferred<T>; são trocados na documentação",
        ],
        c: 0,
        e: "Coroutine builders precisam de CoroutineScope. launch { ... } retorna Job (cancel, join). async { ... } retorna Deferred<T>; val r = async { calc() }; r.await() obtém resultado (suspende até pronto). Dispatchers: Main (UI), IO (I/O-bound), Default (CPU-bound). Structured concurrency: child coroutines são canceladas quando scope pai é cancelado. suspend fun: pode suspender sem bloquear thread.",
        x: "val job = launch(Dispatchers.IO) { fetchData() }. val deferred = async { calcularTotal() }; val total = deferred.await(). coroutineScope { val a = async { fetch('A') }; val b = async { fetch('B') }; a.await() + b.await() } // paralelo. viewModelScope.launch {}: lifecycle-aware. withContext(Dispatchers.IO) { ... } dentro de suspend fun para troca de dispatcher.",
      },
    ],
    Difícil: [
      {
        q: "O que é Kotlin Flow e como difere de LiveData e RxJava para streams reativos no Android?",
        o: [
          "Flow é stream frio (lazy, só executa com coletor), integrado com coroutines, cancelamento automático, backpressure por suspensão; LiveData: lifecycle-aware mas limitado; RxJava: poderoso mas complexo sem coroutines",
          "Flow é hot por padrão; LiveData é cold; ambos requerem Disposable para cancelamento",
          "Flow substitui todas as coroutines; launch e async tornam-se obsoletos",
          "LiveData suporta backpressure nativo via subscription; Flow não tem backpressure",
        ],
        c: 0,
        e: "Cold Flow: flow { emit(1); delay(100); emit(2) } — execução só ao coletar. SharedFlow: hot, múltiplos coletores. StateFlow: hot, tem valor atual (substitui LiveData sem lifecycle coupling). Operators: map, filter, debounce, flatMapLatest (cancela upstream ao novo evento). collectAsState() em Compose. Cancelamento: flowCollect cancela ao sair do scope. Backpressure: collector suspende emitter implicitamente.",
        x: "Search autocomplete: searchFlow.debounce(300).filter { it.length > 2 }.flatMapLatest { query -> flow { emit(api.search(query)) } }.collect { updateUI(it) }. flatMapLatest cancela requisição anterior ao digitar novo caractere. StateFlow para UI state: val uiState = MutableStateFlow<UiState>(Loading). viewModel.uiState.collectAsStateWithLifecycle() no Compose. Room retorna Flow<List<T>> diretamente.",
      },
    ],
  },
  PHP: {
    Fácil: [
      {
        q: "O que são arrays associativos em PHP e como diferem de arrays indexados?",
        o: [
          "Arrays associativos usam chaves string definidas pelo usuário como índice; arrays indexados usam inteiros automáticos; PHP unifica os dois no mesmo tipo array",
          "Arrays associativos são objetos stdClass; arrays indexados são o tipo array nativo",
          "PHP distingue array e hashmap como tipos distintos na engine",
          "Arrays associativos só aceitam chaves string; não pode misturar com índices numéricos",
        ],
        c: 0,
        e: "PHP array é ordenado, misto: $a = ['nome' => 'Ana', 'idade' => 25]; $a['nome'] retorna 'Ana'. Indexado: $b = [10, 20, 30]; $b[0] = 10. Misturado: ['a', 'chave' => 'valor', 1]. array_keys(), array_values(), foreach($arr as $k => $v). list() / [] para destructuring. array_merge(), array_combine(), array_flip(). Arrays PHP são sempre HashMap+OrderedMap internamente.",
        x: "$config = ['db_host' => 'localhost', 'db_port' => 3306, 'debug' => true]; echo $config['db_host']; foreach($config as $key => $val) echo '$key=$val\n'. in_array('debug', array_keys($config)): verifica existência de chave. array_key_exists() mais preciso (distingue null). compact() e extract() para trabalhar com escopo.",
      },
    ],
    Médio: [
      {
        q: "O que é o Composer em PHP e como o autoloading PSR-4 funciona?",
        o: [
          "Composer é o gerenciador de dependências PHP; PSR-4 mapeia namespace para diretório automaticamente (App\\Models\\User → src/Models/User.php) via autoloader gerado no vendor/",
          "Composer é um framework PHP; PSR-4 é bundle de segurança",
          "PSR-4 exige que todas as classes tenham o mesmo namespace independente do diretório",
          "Autoloading só funciona com classes estáticas; instâncias requerem require explícito",
        ],
        c: 0,
        e: 'composer.json: {"require": {"monolog/monolog": "^3.0"}, "autoload": {"psr-4": {"App\\\\": "src/"}}}. composer install: baixa dependências e gera vendor/autoload.php. PSR-4: App\\Controllers\\UserController mapeia para src/Controllers/UserController.php. Lazy loading: como não carregada até ser usada. composer update (atualiza semver), composer require, composer dump-autoload (regenera map).',
        x: "require 'vendor/autoload.php'; use App\\Models\\User; $u = new User(); // autoloader inclui src/Models/User.php automaticamente. spl_autoload_register(): mecanismo interno que Composer usa. Sem Composer: require_once em cada arquivo. Semantic versioning: ^3.0 aceita 3.x.x mas não 4.0. composer.lock: versões exatas para reprodução do ambiente.",
      },
    ],
    Difícil: [
      {
        q: "Como PHP 8.x Fibers implementam concorrência cooperativa e como diferem de goroutines e coroutines?",
        o: [
          "Fibers: pausam/retomam execução manualmente com Fiber::suspend/resume; concorrência cooperativa single-thread; base para async em PHP (ReactPHP, Revolt); goroutines têm scheduling automático",
          "Fibers criam threads reais no OS; goroutines são apenas corotinas de usuário",
          "Fibers e coroutines são idênticos; goroutines têm scheduling preemptivo como threads OS",
          "PHP Fibers são descontinuadas em PHP 8.2; async/await nativo foi introduzido",
        ],
        c: 0,
        e: "Fiber (PHP 8.1): $fiber = new Fiber(function() { $val = Fiber::suspend('primeiro'); echo 'segundo: ' . $val; }); $r1 = $fiber->start(); // 'primeiro'. $fiber->resume('hello'); // 'segundo: hello'. Stack própria. Não multithreading. Event loop (Revolt): Fiber::suspend cede controle ao loop que processa I/O (sockets, timers) e retoma fiber quando pronto. ampersand PHP diferente de Go go-routine scheduler.",
        x: "ReactPHP + Fibers: $response = Fiber::suspend($deferredRequest); event loop processa outros reqs enquanto aguarda I/O. Revolt event loop (base de Amp v3): readStream/writeStream, addTimer. $conn->query('SELECT...') retorna Promise que Fiber aguarda com suspend. Comparação: Go goroutines scheduler M:N automático; PHP Fibers = manual + event loop externo; ambas resolvêm I/O-bound sem threads.",
      },
    ],
  },
  Python: {
    Fácil: [
      {
        q: "O que são list comprehensions em Python e como diferem de generator expressions?",
        o: [
          "List comprehension cria lista em memória imediatamente [x*2 for x in range(10)]; generator expression é lazy (x*2 for x in range(10)) gerando valores sob demanda, mais eficiente em memória",
          "List comprehensions são mais rápidas que generator expressions em todas as situações",
          "Generator expressions criam listas internamente; a diferença é apenas sintática",
          "List comprehensions não aceitam condições (if); apenas loops for simples",
        ],
        c: 0,
        e: "List comp: [expr for item in iter if cond] — cria lista completa na memória. Set comp: {expr for ...}. Dict comp: {k:v for ...}. Generator: (expr for ...) — objeto gerador, lógica executada ao iterar. sum(x**2 for x in range(1000000)): usa gen, não aloca lista de 1M. Nested: [y for x in matrix for y in x]. Condição: [x for x in lst if x > 0].",
        x: "Lista: quadrados = [x**2 for x in range(10000)] — aloca 10k ints em memória. Generator: gen = (x**2 for x in range(10000)) — usa ~100 bytes. sum(gen) consome sob demanda. Para processar arquivo grande: (linha.strip() for linha in open('big.csv') if linha.startswith('2025')). any()/all()/sum() com gen expression são idiomáticos e memória-eficientes.",
      },
    ],
    Médio: [
      {
        q: "O que são decorators em Python e como implementar um decorator com argumentos?",
        o: [
          "Decorator: função de ordem superior que envolve outra função adicionando comportamento; decorator com argumentos requer três níveis de função (outer, wrapper, decorated)",
          "Decorators são classes especiais que herdam de type para modificar métodos",
          "Decorator com argumentos usa apenas dois níveis; o parâmetro vai no @decorator(arg)",
          "Decorators só são válidos para funções de módulo; não para métodos de classe",
        ],
        c: 0,
        e: "@dec equivale a func = dec(func). Decorator com args: @dec(n) → func = dec(n)(func). def retry(times): def decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): for _ in range(times): try: return func(*args, **kwargs) except: pass return wrapper return decorator. functools.wraps preserva __name__, __doc__ da função original. Class decorator: __call__.",
        x: "@retry(times=3) def call_api(): requests.get(url). Equivale a: call_api = retry(3)(call_api). @lru_cache(maxsize=128): memoização com LRU. @dataclass: gera __init__, __repr__, __eq__. @property: getter/setter. @staticmethod, @classmethod. Stacking: @login_required @cache_page(300): executa de baixo para cima (login_required(cache_page(view))).",
      },
    ],
    Difícil: [
      {
        q: "Como o GIL (Global Interpreter Lock) do CPython afeta multithread e quando usar multiprocessing ou asyncio?",
        o: [
          "GIL: um lock por processo CPython que impede execução paralela de bytecode Python; threads funcionam para I/O-bound (GIL liberado durante I/O); multiprocessing para CPU-bound (processos separados = GIL separado)",
          "GIL foi removido no Python 3.10; threads CPython são totalmente paralelas",
          "GIL afeta multiprocessing e asyncio igualmente; não há alternativa sem trocar o interpretador",
          "asyncio usa múltiplas threads internamente para paralelismo real de I/O",
        ],
        c: 0,
        e: "GIL garante que apenas uma thread execute bytecode Python por vez por processo. I/O-bound (network, disco): C extensions liberam GIL durante I/O — threads realmente paralelas. CPU-bound (cálculo puro): threads não ajudam (GIL serializa). Soluções: multiprocessing (processos com memoória separada), concurrent.futures.ProcessPoolExecutor. asyncio: event loop single-thread para I/O-bound com async/await. NumPy/Pandas: liberam GIL em operações C. Python 3.13 (experimental): no-GIL build.",
        x: "CPU benchmark: 4 cores, 4 threads Python = ~1x (GIL). 4 processes = ~3.8x. I/O: 100 requests HTTP, 4 threads = ~100x vs 1 thread. asyncio + aiohttp: lógica single-thread, alta concorrência. ProcessPoolExecutor: from concurrent.futures import ProcessPoolExecutor; with PPE(4) as ex: results = list(ex.map(cpu_task, data)). Celery: distribute tasks entre workers (processos diferentes).",
      },
    ],
  },
  TypeScript: {
    Fácil: [
      {
        q: "O que são union types e intersection types em TypeScript e quando usar cada um?",
        o: [
          "Union (A | B): valor pode ser A OU B; intersection (A & B): valor deve satisfazer A E B simultaneamente; union para variantes, intersection para composição de tipos",
          "Union combina todos os campos de A e B; intersection restringe a campos comuns",
          "São pré-condicionais; TypeScript seleciona automaticamente com base no contexto",
          "Union é somente para tipos primitivos; intersection somente para objetos",
        ],
        c: 0,
        e: "Union: type ID = string | number — função aceita string ou number. Narrowing: typeof, instanceof para tratar cada caso. Intersection: type AdminUser = User & Admin — deve ter todos os campos de User E Admin. Discriminated union: { type: 'circle', radius: number } | { type: 'square', side: number } — switch em 'type' faz narrowing exaustivo. never em default garante exaustividade.",
        x: "type Result<T> = { status: 'ok'; data: T } | { status: 'error'; message: string }. Narrowing: if(r.status === 'ok') r.data; else r.message. Intersection: type PaginatedResponse<T> = ApiResponse & { items: T[]; total: number }. Utility types: Partial<T> (todos opcionais), Required<T>, Pick<T, 'a'|'b'>, Omit<T, 'senha'>.",
      },
    ],
    Médio: [
      {
        q: "O que são template literal types em TypeScript e quais padrões permitem expressar?",
        o: [
          "Tipos construídos combinando string literals com interpolacão de tipos em compile-time; permitem expressar padrões como EventNames, CSS properties e API routes com type-safety total",
          "Strings de template com tipos genéricos usadas somente em runtime",
          "Funções que retornam strings de template; equivalem a template literals do JS com tipos",
          "Apenas documentam o formato esperado sem verificacão de tipo efetiva",
        ],
        c: 0,
        e: "type EventName = `on${Capitalize<string>}`; // onLoad, onClick... type CSSunit = `${number}px` | `${number}%` | `${number}rem`. Combinação: type Direction = 'left'|'right'|'top'|'bottom'; type Padding = `padding-${Direction}` — 4 strings. Inferrência com infer: type ExtractId<T> = T extends `${infer K}_id` ? K : never. Mapped + template: { [K in `get${string}`]: ... }.",
        x: "API type-safe: type Route = '/users' | '/users/:id' | '/posts'. type ApiGet = `GET ${Route}`. Emit events type-safe: type Emitter<T extends string> = { on(event: `${T}Changed`, cb: () => void): void }. Prisma usa template literal types para gerar tipos de queries. Deriveção automática: type GettersFor<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K] }.",
      },
    ],
    Difícil: [
      {
        q: "O que é o TypeScript type system sound vs unsound e por que ele aceita algumas inseguranças por design?",
        o: [
          "TypeScript é unsound por design (prioriza ergonomia): bivariance de métodos de classe, type assertions, any, enums não nominais; troca soundness total por usabilidade prática em codebases JS existentes",
          "TypeScript é completamente sound; qualquer erro de runtime indica bug no programa, não no type system",
          "Soundness é garantida pelo strict mode; sem strict o sistema é unsound por omissão",
          "Unsound apenas para tipos primitivos; objetos e classes são sempre sound",
        ],
        c: 0,
        e: "Sound type system: se compila sem erros, nenhum runtime type error. TypeScript documentou escolher unsoundness em alguns pontos: bivariant method parameters (para compatibilidade com callbacks), type assertion (as T) bypassa checks, any disabilita tudo, function parameter bivariance em métodos de classe. Razão: JS é dinâmico; 100% soundness tornaria muitos padrões JS impossíveis de tipar. Haskell, Elm: sound. Typescript, Flow: unsound por design.",
        x: "Bivariance de método: class Animal { speak(a: Animal) {} } class Dog extends Animal { speak(d: Dog) {} }. TypeScript aceita (unsound): Dog pode ser atribuído a Animal mesmo que speak espere Dog mais restrito. strictFunctionTypes (strict): corrige para types de função mas não para métodos de classe (retrocompat). (x as any as OutroType): force cast total. Esses pontos geram runtime errors reais.",
      },
    ],
  },
};

function mergeLangBankRounds(
  base: Record<string, Record<UserLevel, SeedCard[]>>,
  ...extras: Record<string, Record<UserLevel, SeedCard[]>>[]
): Record<string, Record<UserLevel, SeedCard[]>> {
  const result: Record<string, Record<UserLevel, SeedCard[]>> = {};
  for (const cat of Object.keys(base)) {
    result[cat] = {} as Record<UserLevel, SeedCard[]>;
    for (const level of ["Fácil", "Médio", "Difícil"] as UserLevel[]) {
      const baseCards = base[cat]?.[level] ?? [];
      const seen = new Set(baseCards.map((c) => c.q.trim().toLowerCase()));
      const merged = [...baseCards];
      for (const extra of extras) {
        for (const card of extra[cat]?.[level] ?? []) {
          if (!seen.has(card.q.trim().toLowerCase())) {
            seen.add(card.q.trim().toLowerCase());
            merged.push(card);
          }
        }
      }
      result[cat][level] = merged;
    }
  }
  return result;
}

export const linguagensBank = mergeLangBankRounds(
  linguagensBankBase,
  linguagensRound1Extras,
);
