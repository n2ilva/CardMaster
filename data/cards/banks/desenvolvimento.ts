import type { SeedCard } from "../generator";

type UserLevel = "Fácil" | "Médio" | "Difícil";

// ─── Desenvolvimento · 12 categorias × 3 níveis × 7 questões (rodada 4/30) ───

export const desenvolvimentoBank: Record<
  string,
  Record<UserLevel, SeedCard[]>
> = {
  // ── Algoritmos e Estruturas de Dados ──
  "Algoritmos e Estruturas de Dados": {
    Fácil: [
      {
        q: "Qual estrutura de dados segue o princípio FIFO (primeiro a entrar, primeiro a sair)?",
        o: ["Fila (Queue)", "Pilha (Stack)", "Árvore Binária", "Grafo"],
        c: 0,
        e: "A Fila (Queue) segue o princípio FIFO: o primeiro elemento inserido é o primeiro a ser removido. Operações básicas são enqueue (inserir no final) e dequeue (remover do início).",
        x: "Fila de impressão: documento A entra primeiro, depois B e C. A impressora processa A primeiro, depois B, depois C — exatamente na ordem de chegada.",
      },
      {
        q: "Qual estrutura de dados usa o princípio LIFO (last in, first out)?",
        o: ["Pilha (Stack)", "Fila (Queue)", "Lista Ligada", "Hash Table"],
        c: 0,
        e: "A Pilha segue LIFO: o último elemento inserido é o primeiro removido. Operações: push (inserir no topo) e pop (remover do topo). Usada em chamadas de funções (call stack), undo/redo e avaliação de expressões.",
        x: "Empilhe pratos: A, B, C. Para tirar, só consegue pegar C primeiro (topo), depois B, depois A. Ctrl+Z (undo) funciona como pilha: a última ação é desfeita primeiro.",
      },
      {
        q: "Qual é a complexidade de tempo para acessar um elemento por índice em um array?",
        o: ["O(1)", "O(n)", "O(log n)", "O(n²)"],
        c: 0,
        e: "Arrays armazenam elementos em posições contíguas de memória. Como cada posição tem tamanho fixo, o endereço do elemento i é calculado diretamente: base + (i × tamanho). Isso permite acesso em tempo constante O(1), independente do tamanho do array.",
        x: "Array com 1 milhão de elementos: arr[999999] acessa diretamente o último elemento tão rápido quanto arr[0]. Mas inserir no início é O(n) porque todos os elementos precisam ser deslocados.",
      },
      {
        q: "O que é uma Lista Ligada (Linked List) e qual sua vantagem sobre arrays?",
        o: [
          "Estrutura onde cada nó aponta para o próximo; inserção/remoção em O(1) sem deslocar elementos",
          "Array mais rápido",
          "Lista que ordena automaticamente",
          "Tipo de árvore binária",
        ],
        c: 0,
        e: "Lista Ligada: cada nó contém um valor e um ponteiro para o próximo nó. Inserção/remoção no início é O(1) (sem deslocamento). Desvantagem: acesso por índice é O(n) (percorrer nó a nó). Arrays: acesso O(1), inserção O(n).",
        x: "Array: inserir no início desloca todos os 100 mil itens. Lista Ligada: cria nó novo e aponta para o antigo head — O(1). Mas acessar o item 50.000 na lista requer percorrer 50 mil nós.",
      },
      {
        q: "O que é uma Árvore Binária de Busca (BST) e qual sua propriedade principal?",
        o: [
          "Árvore onde filhos à esquerda são menores e à direita são maiores que o nó pai",
          "Árvore com exatamente dois filhos por nó",
          "Lista ordenada em formato de árvore",
          "Estrutura FIFO hierárquica",
        ],
        c: 0,
        e: "BST: para cada nó, todos os valores na subárvore esquerda são menores e na direita são maiores. Busca, inserção e remoção são O(log n) quando balanceada. Permite busca eficiente, in-order traversal retorna elementos em ordem crescente.",
        x: "BST com raiz 10: esquerda 5 (esquerda 3, direita 7), direita 15 (esquerda 12, direita 20). Buscar 7: 10→5→7 (3 passos). In-order: 3, 5, 7, 10, 12, 15, 20.",
      },
      {
        q: "O que é uma busca binária e qual sua complexidade?",
        o: [
          "Algoritmo que divide o array ordenado ao meio a cada passo; O(log n)",
          "Percorrer todo o array; O(n)",
          "Busca em lista ligada; O(n²)",
          "Busca em grafo; O(V+E)",
        ],
        c: 0,
        e: "Busca binária funciona em arrays ORDENADOS. Compara o elemento do meio: se igual, encontrou; se menor, busca na metade esquerda; se maior, busca na metade direita. Elimina metade dos elementos a cada passo → O(log n). Array desordenado requer busca linear O(n).",
        x: "Array [2,5,8,12,16,23,38,45] — buscar 23: meio=12 (menor → direita), meio=23 (encontrou!). 2 passos em vez de 6 na busca linear. Para 1M de itens: ~20 passos vs 1M.",
      },
      {
        q: "O que é um grafo e qual a diferença entre dirigido e não-dirigido?",
        o: [
          "Estrutura com nós e arestas; dirigido tem direção nas arestas, não-dirigido não tem",
          "Tipo de árvore binária",
          "Array bidimensional",
          "Lista com ponteiros",
        ],
        c: 0,
        e: "Grafo: conjunto de vértices (nós) conectados por arestas. Dirigido: arestas têm direção (A→B não implica B→A). Não-dirigido: conexão bilateral. Ponderado: arestas têm peso (distância). Usos: GPS, redes sociais, dependências.",
        x: "Rede social (não-dirigido): Ana-Bob = amizade mútua. Twitter (dirigido): Ana→Bob = Ana segue Bob, não implica Bob seguir Ana. GPS (ponderado): São Paulo→5km→Guarulhos.",
      },
    ],
    Médio: [
      {
        q: "Qual é a complexidade de tempo no pior caso para buscar um elemento em uma árvore binária de busca (BST) desbalanceada?",
        o: ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
        c: 0,
        e: "Em uma BST desbalanceada, os nós podem formar uma lista encadeada (todos à direita ou todos à esquerda), fazendo com que a busca percorra todos os n nós no pior caso, resultando em O(n). BSTs balanceadas (AVL, Red-Black) garantem O(log n).",
        x: "Inserindo 1, 2, 3, 4, 5 em sequência numa BST, cada nó fica à direita do anterior (lista). Buscar 5 requer percorrer todos os 5 nós: O(n).",
      },
      {
        q: "Qual algoritmo de ordenação tem complexidade O(n log n) no caso médio e é baseado em divisão e conquista?",
        o: ["Merge Sort", "Bubble Sort", "Selection Sort", "Insertion Sort"],
        c: 0,
        e: "O Merge Sort divide o array ao meio recursivamente até ter sub-arrays de 1 elemento, depois combina (merge) os sub-arrays em ordem. Complexidade: O(n log n) em todos os casos (melhor, médio e pior). Desvantagem: usa O(n) de espaço extra.",
        x: "[38, 27, 43, 3] → divide em [38,27] e [43,3] → divide em [38],[27],[43],[3] → merge: [27,38],[3,43] → merge final: [3,27,38,43]. Número de operações: n × log₂(n).",
      },
      {
        q: "O que é uma Hash Table e qual é sua complexidade média para busca?",
        o: [
          "Estrutura que mapeia chaves a valores usando função hash, com busca O(1) na média",
          "Array ordenado com busca O(log n)",
          "Árvore binária com busca O(n)",
          "Lista ligada com busca O(n)",
        ],
        c: 0,
        e: "Hash Table usa uma função hash para converter chaves em índices de um array. Busca, inserção e remoção são O(1) na média. No pior caso (muitas colisões), degenera para O(n). JavaScript Objects e Maps são implementados como hash tables.",
        x: "const mapa = new Map(); mapa.set('ana', 28); mapa.get('ana') → 28 em O(1). A função hash converte 'ana' em índice 42 do array interno, acesso direto.",
      },
      {
        q: "O que é o algoritmo Quick Sort e qual sua complexidade no caso médio?",
        o: [
          "Algoritmo de divisão e conquista que escolhe um pivô e particiona o array; O(n log n) na média",
          "Algoritmo que ordena comparando pares adjacentes; O(n²)",
          "Algoritmo que encontra o mínimo a cada passo; O(n log n)",
          "Algoritmo baseado em heap; O(n)",
        ],
        c: 0,
        e: "Quick Sort escolhe um pivô, particiona o array em menores e maiores que o pivô, e repete recursivamente. Caso médio: O(n log n). Pior caso: O(n²) quando pivô é sempre o menor/maior. Na prática é o mais rápido. In-place (sem memória extra).",
        x: "[3,6,8,10,1,2,1]: pivô=6 → [3,1,2,1] + 6 + [8,10]. Recursão nos sub-arrays. Pior caso: array já ordenado com pivô no extremo → cada partição remove apenas 1 elemento → O(n²).",
      },
      {
        q: "O que é uma Heap (fila de prioridade) e para que é usada?",
        o: [
          "Árvore binária completa onde o pai é sempre maior (max-heap) ou menor (min-heap) que os filhos",
          "Hash table com prioridade",
          "Fila FIFO com prioridade",
          "Array ordenado",
        ],
        c: 0,
        e: "Heap é uma árvore binária completa que satisfaz a propriedade heap: em min-heap, o pai é menor que os filhos (raiz = mínimo). Inserção e remoção são O(log n). Usada em filas de prioridade, Dijkstra, heap sort e agendamento de tarefas.",
        x: "Min-heap: [1, 3, 5, 7, 9]. Inserir 2: coloca no final e faz sift-up até posição correta → [1, 2, 5, 7, 9, 3]. Extrair mínimo (1): troca raiz com último, remove, sift-down.",
      },
      {
        q: "O que é uma Árvore AVL e qual problema ela resolve?",
        o: [
          "Árvore binária de busca auto-balanceada que garante O(log n) em todas as operações",
          "Array circular",
          "Hash table com encadeamento",
          "Lista duplamente ligada",
        ],
        c: 0,
        e: "AVL é uma BST que mantém o fator de balanceamento (diferença de altura entre subárvores) em {-1, 0, 1} para cada nó. Após inserção/remoção, rotações (simples ou dupla) rebalanceiam a árvore. Garante O(log n) no pior caso, ao contrário de BST simples.",
        x: "Inserir 1,2,3 em BST: 1→2→3 (lista, busca O(n)). Em AVL: após inserir 3, rotação esquerda → 2 (raiz), 1 (esquerda), 3 (direita). Busca O(log n) garantida.",
      },
      {
        q: "O que é o algoritmo de ordenação Counting Sort e quando é mais eficiente?",
        o: [
          "Algoritmo O(n+k) que conta ocorrências; eficiente quando o range de valores (k) é pequeno",
          "Algoritmo O(n log n) geral",
          "Algoritmo O(n²) por comparação",
          "Algoritmo recursivo de divisão",
        ],
        c: 0,
        e: "Counting Sort não compara elementos: conta quantas vezes cada valor aparece e reconstrói o array. Complexidade O(n+k), onde k é o range dos valores. Ideal quando k é pequeno relativo a n. Não funciona bem com floats ou strings longas.",
        x: "Ordenar notas [3,1,2,3,1,2,3]: contagem=[0,2,2,3]. Reconstrói: [1,1,2,2,3,3,3]. 7 passos (n=7, k=3). Merge Sort faria 7×log7 ≈ 20 operações por comparação.",
      },
    ],
    Difícil: [
      {
        q: "Em um algoritmo de Dijkstra usando min-heap (priority queue), qual é a complexidade de tempo para um grafo com V vértices e E arestas?",
        o: ["O((V + E) log V)", "O(V²)", "O(V × E)", "O(E log E)"],
        c: 0,
        e: "Com min-heap, cada vértice é extraído uma vez — O(V log V). Cada aresta pode causar uma operação decrease-key — O(E log V). Total: O((V + E) log V). Sem heap (array), a complexidade seria O(V²), melhor para grafos densos.",
        x: "Grafo com 1000 vértices e 5000 arestas: com heap → O(6000 × 10) ≈ 60.000 operações. Sem heap → O(1.000.000) operações. Heap é ~16x mais rápido neste caso.",
      },
      {
        q: "O que é programação dinâmica e em quais problemas ela é mais eficaz que a abordagem recursiva ingrénua?",
        o: [
          "Técnica que armazena resultados de subproblemas para evitar recálculo; eficaz em problemas com subproblemas sobrepostos",
          "Método de alocação de memória",
          "Tipo de paralelismo",
          "Linguagem de programação",
        ],
        c: 0,
        e: "Programação dinâmica resolve problemas dividindo-os em subproblemas e armazenando resultados (memoization ou tabulation) para evitar recálculo. Eficaz quando há subproblemas sobrepostos (mesma subcomputação repetida) e subestrutura ótima. Exemplos: Fibonacci, mochila, LCS.",
        x: "Fibonacci recursivo: fib(50) faz 2⁵⁰ chamadas (exponencial). Com memoization: fib(50) faz 50 chamadas (linear). const memo = {}; function fib(n) { if (memo[n]) return memo[n]; memo[n] = fib(n-1) + fib(n-2); return memo[n]; }",
      },
      {
        q: "Qual é a diferença entre BFS (Breadth-First Search) e DFS (Depth-First Search) em grafos?",
        o: [
          "BFS explora vizinhos nível a nível (usa fila); DFS vai o mais fundo possível primeiro (usa pilha)",
          "São idênticos",
          "DFS é mais rápido",
          "BFS só funciona em árvores",
        ],
        c: 0,
        e: "BFS (Busca em Largura): explora todos os vizinhos do nó atual antes de ir para o próximo nível. Usa fila (FIFO). Encontra menor caminho em grafos não-ponderados. DFS (Busca em Profundidade): segue um caminho até o fim antes de retroceder. Usa pilha (LIFO) ou recursão. Usado em detecção de ciclos e ordenação topológica.",
        x: "Grafo: A-B, A-C, B-D, C-D. BFS a partir de A: A → B,C → D (nível por nível). DFS a partir de A: A → B → D → (volta) → C (desce ao máximo antes de voltar).",
      },
      {
        q: "O que é o algoritmo A* (A-star) e em que ele difere do Dijkstra?",
        o: [
          "Algoritmo que usa heurística para estimar distância ao destino, focando a busca na direção certa",
          "Versão mais lenta do Dijkstra",
          "Algoritmo que só funciona em grafos sem peso",
          "Dijkstra com backtracking",
        ],
        c: 0,
        e: "A* usa f(n) = g(n) + h(n): g(n) = custo real do início até n, h(n) = heurística estimando custo de n ao destino. Dijkstra é A* com h(n)=0. A heurística direciona a busca, explorando menos nós. A* é ótimo se h(n) for admissível (nunca superestimar).",
        x: "GPS: Dijkstra explora em todas as direções (círculo expandindo). A* com heurística de distância euclidiana foca na direção do destino, visitando ~5x menos nós para encontrar o caminho mínimo.",
      },
      {
        q: "O que é a notação Big-O e qual a diferença entre O(n), O(n²) e O(log n)?",
        o: [
          "Notação que descreve o crescimento do tempo/espaço em função do input; O(log n) < O(n) < O(n²)",
          "Mede o tempo exato em milissegundos",
          "Só se aplica a algoritmos de ordenação",
          "Análise de memória RAM",
        ],
        c: 0,
        e: "Big-O descreve o limite superior de crescimento. O(1): constante. O(log n): busca binária — cada passo elimina metade. O(n): percorrer lista. O(n log n): merge sort. O(n²): comparar todos com todos. O(2^n): subsets. Para n=1M: O(n)=1M ops, O(n²)=1T ops.",
        x: "n=1.000.000: O(log n)=20 ops, O(n)=1M ops, O(n log n)=20M ops, O(n²)=1T ops. Um algoritmo O(n²) com n=1M demoraria ~11 dias; O(n log n) demoraria 0.2 segundos.",
      },
      {
        q: "O que é o Trie (Prefix Tree) e para que é usado?",
        o: [
          "Árvore onde cada nó representa um caractere, otimizada para busca por prefixo em strings",
          "Tipo de hash table",
          "Árvore binária balanceada",
          "Grafo acíclico para números",
        ],
        c: 0,
        e: "Trie armazena strings caractere por caractere nos nós. Busca por prefixo é O(m) onde m = tamanho do prefixo. Ideal para autocomplete, spell check, dicionários e roteamento IP. Consome mais memória que hash table mas é superior para operações com prefixo.",
        x: "Trie com 'car', 'card', 'cat': raiz→c→a→r(✓)→d(✓), raiz→c→a→t(✓). Buscar prefixo 'ca': 2 passos → retorna ['car','card','cat']. Hash table precisaria iterar todas as chaves.",
      },
      {
        q: "O que é uma Red-Black Tree e como se compara com AVL?",
        o: [
          "Árvore auto-balanceada com garantias mais relaxadas que AVL; inserção mais rápida, busca ligeiramente mais lenta",
          "Árvore com nós coloridos sem balanceamento",
          "Hash table com cores",
          "Grafo bicolorido",
        ],
        c: 0,
        e: "Red-Black Tree: BST auto-balanceada com regras de coloração (nós vermelhos/pretos). Menos estrita que AVL: permite diferença de altura 2x (vs 1 da AVL). Resultado: menos rotações em inserção/remoção. Usada no Java TreeMap, C++ std::map e Linux kernel.",
        x: "AVL: busca ~1.44×log n (mais curta). Red-Black: busca ~2×log n (pode ser mais alta). Mas inserção AVL: até log n rotações; Red-Black: no máximo 2 rotações. Para muitas escritas: Red-Black. Para muitas leituras: AVL.",
      },
    ],
  },

  // ── APIs REST e GraphQL ──
  "APIs REST e GraphQL": {
    Fácil: [
      {
        q: "Qual método HTTP é utilizado para criar um novo recurso em uma API REST?",
        o: ["POST", "GET", "PUT", "DELETE"],
        c: 0,
        e: "O método POST é usado para criar novos recursos. Ele envia dados no corpo da requisição para o servidor, que cria o recurso e retorna normalmente o status 201 (Created) com a URL do novo recurso no header Location.",
        x: 'POST /api/users com body { "name": "Ana", "email": "ana@email.com" } → resposta 201 Created com Location: /api/users/42.',
      },
      {
        q: "Qual método HTTP é idempotente e usado para atualizar completamente um recurso existente?",
        o: ["PUT", "POST", "PATCH", "DELETE"],
        c: 0,
        e: "PUT é idempotente: enviar o mesmo PUT várias vezes produz o mesmo resultado. Ele substitui o recurso inteiro com os dados enviados. Diferente de PATCH, que altera parcialmente, e POST, que cria novo recurso (não idempotente).",
        x: 'PUT /api/users/42 com body { "name": "Ana Silva", "email": "ana@email.com" } — substitui todos os dados do usuário 42. Se repetir a chamada, o resultado é o mesmo.',
      },
      {
        q: "O que significa o código de status HTTP 404?",
        o: [
          "Not Found — o recurso solicitado não foi encontrado",
          "Sucesso na operação",
          "Erro interno do servidor",
          "Acesso não autorizado",
        ],
        c: 0,
        e: "HTTP 404 Not Found indica que o servidor não encontrou o recurso solicitado. Classes de status: 2xx = sucesso (200 OK, 201 Created), 4xx = erro do cliente (400 Bad Request, 401 Unauthorized, 404 Not Found), 5xx = erro do servidor (500 Internal Server Error).",
        x: "GET /api/users/99999 → 404 Not Found (usuário não existe). GET /api/users/1 → 200 OK com dados do usuário.",
      },
      {
        q: "O que é uma API e para que serve?",
        o: [
          "Interface de programação que permite comunicação entre sistemas diferentes",
          "Linguagem de programação",
          "Banco de dados",
          "Protocolo de rede",
        ],
        c: 0,
        e: "API (Application Programming Interface) define um contrato de comunicação entre sistemas. Expõe funcionalidades de um serviço sem revelar sua implementação interna. APIs HTTP/REST são as mais comuns, mas existem APIs de bibliotecas, SO e hardware.",
        x: "A API do Stripe expõe POST /v1/charges para processar pagamentos. Você não precisa saber como o Stripe processa internamente — só segue o contrato da API.",
      },
      {
        q: "O que significa o verbo HTTP GET e quando usá-lo?",
        o: [
          "Solicita a leitura/busca de um recurso sem alterá-lo",
          "Cria um novo recurso",
          "Deleta um recurso",
          "Atualiza um recurso",
        ],
        c: 0,
        e: "GET é idempotente e seguro (safe): não modifica dados no servidor. Usado para buscar/ler recursos. Parâmetros vão na URL (query string). Respostas podem ser cacheadas. Não deve ter body na requisição.",
        x: "GET /api/users → retorna lista de usuários. GET /api/users/42 → retorna dados do usuário 42. GET /api/users?status=active → filtra por query string.",
      },
      {
        q: "O que é JSON e por que é o formato mais usado em APIs?",
        o: [
          "Formato leve de troca de dados baseado em texto, legível por humanos e fácil de parsear",
          "Linguagem de programação",
          "Banco de dados",
          "Protocolo de rede",
        ],
        c: 0,
        e: "JSON (JavaScript Object Notation): formato texto com pares chave-valor, arrays e tipos primitivos. Leve comparado a XML, suportado nativamente em JavaScript (JSON.parse/stringify) e na maioria das linguagens. Tipo MIME: application/json.",
        x: '{"id": 1, "name": "Ana", "skills": ["TypeScript", "React"], "active": true}. JavaScript: const obj = JSON.parse(jsonString); const str = JSON.stringify(obj);',
      },
      {
        q: "Qual é a diferença entre os métodos HTTP PATCH e PUT?",
        o: [
          "PUT substitui o recurso inteiro; PATCH atualiza parcialmente apenas os campos enviados",
          "São idênticos",
          "PATCH cria e PUT atualiza",
          "PUT é parcial e PATCH é completo",
        ],
        c: 0,
        e: "PUT: envia a representação completa do recurso (campos omitidos são removidos). PATCH: envia apenas os campos que devem mudar. PUT é idempotente por padrão. PATCH pode ou não ser idempotente dependendo da implementação.",
        x: 'Usuário { name: "Ana", email: "ana@x.com", age: 25 }. PUT { name: "Ana S." } → email e age removidos. PATCH { name: "Ana S." } → só name muda, email e age permanecem.',
      },
    ],
    Médio: [
      {
        q: "Qual é a principal vantagem do GraphQL sobre REST quando o cliente precisa de dados de múltiplos recursos relacionados?",
        o: [
          "Buscar todos os dados necessários em uma única requisição, evitando over-fetching e under-fetching",
          "Maior velocidade de rede",
          "Melhor cache no navegador",
          "Menor uso de memória no servidor",
        ],
        c: 0,
        e: "No REST, buscar um usuário com seus posts e comentários exige 3 chamadas (under-fetching). No GraphQL, uma única query especifica exatamente os campos desejados de múltiplos tipos, retornando tudo em uma resposta. Também evita over-fetching ao não trazer campos desnecessários.",
        x: "query { user(id: 1) { name, posts { title, comments { text } } } } — uma única requisição retorna nome do usuário, títulos dos posts e textos dos comentários.",
      },
      {
        q: "O que é paginação em APIs REST e quais são as duas abordagens mais comuns?",
        o: [
          "Offset-based (page/limit) e Cursor-based (after/first); dividem respostas grandes em páginas",
          "Compressão e cache",
          "Autenticação e autorização",
          "Criptografia e hashing",
        ],
        c: 0,
        e: "Offset-based: GET /items?page=3&limit=20 (pula 40, retorna 20). Simples mas inconsistente com inserções. Cursor-based: GET /items?after=abc123&first=20 (retorna 20 após o cursor abc123). Consistente e eficiente para grandes datasets, usado por Facebook e GitHub.",
        x: "Offset: /posts?page=100&limit=20 — banco faz OFFSET 1980 (lento em tabelas grandes). Cursor: /posts?after=eyJpZCI6MTk4MH0&first=20 — banco faz WHERE id > 1980 LIMIT 20 (rápido com índice).",
      },
      {
        q: "O que é rate limiting em APIs e por que é importante?",
        o: [
          "Limitar o número de requisições por cliente em um período, protegendo contra abuso e sobrecarga",
          "Limitar o tamanho do payload",
          "Limitar o número de rotas",
          "Limitar conexões WebSocket",
        ],
        c: 0,
        e: "Rate limiting restringe quantas requisições um cliente pode fazer por período (ex: 100 req/min). Protege contra DDoS, abuso de API, e garante fairness entre clientes. Retorna HTTP 429 Too Many Requests quando o limite é excedido.",
        x: "Headers de resposta: X-RateLimit-Limit: 100, X-RateLimit-Remaining: 23, X-RateLimit-Reset: 1625097600. Cliente sabe que pode fazer mais 23 requests antes do reset.",
      },
      {
        q: "O que é versionamento de API e quais são as abordagens comuns?",
        o: [
          "Mecanismo para evoluir a API sem quebrar clientes existentes; via URL, header ou query param",
          "Controle de versão do código-fonte",
          "Backup de endpoints",
          "Cache de requisições",
        ],
        c: 0,
        e: "Versionamento permite manter versões antigas funcionando ao lançar novas. Via URL: /api/v1/users, /api/v2/users. Via header: Accept: application/vnd.api.v2+json. Via query: /api/users?version=2. URL path é o mais comum e explícito.",
        x: "v1: GET /api/v1/users → { name: 'Ana Silva' }. v2: GET /api/v2/users → { firstName: 'Ana', lastName: 'Silva' }. Ambas coexistem. Clientes migram gradualmente.",
      },
      {
        q: "O que é paginação em APIs REST e por que é importante?",
        o: [
          "Dividir grandes conjuntos de dados em páginas menores para evitar respostas enormes",
          "Ordenar resultados por data",
          "Cachear respostas da API",
          "Comprimir dados da resposta",
        ],
        c: 0,
        e: "Paginação evita retornar milhões de registros de uma vez. Offset-based: ?page=2&limit=20. Cursor-based: ?cursor=abc123&limit=20 (mais eficiente para dados que mudam). Resposta inclui total, hasNext, nextCursor.",
        x: "GET /api/users?page=3&limit=20 → retorna usuários 41-60 de 500 totais. Response: { data: [...], meta: { total: 500, page: 3, limit: 20, totalPages: 25 } }.",
      },
      {
        q: "O que é CORS (Cross-Origin Resource Sharing) e por que é necessário?",
        o: [
          "Mecanismo que permite ou bloqueia requisições HTTP entre domínios diferentes via headers",
          "Tipo de criptografia",
          "Protocolo de autenticação",
          "Compressão de dados",
        ],
        c: 0,
        e: "Browsers bloqueiam requisições cross-origin por segurança (Same-Origin Policy). CORS permite o servidor indicar quais origens podem acessá-lo via headers: Access-Control-Allow-Origin, Access-Control-Allow-Methods. Requisições complexas fazem preflight (OPTIONS).",
        x: "Frontend em localhost:3000 chama API em api.com. Browser envia OPTIONS (preflight). API responde: Access-Control-Allow-Origin: http://localhost:3000, Allow-Methods: GET,POST. Browser permite a requisição.",
      },
      {
        q: "O que é autenticação via JWT (JSON Web Token) em APIs?",
        o: [
          "Token assinado contendo claims do usuário, enviado no header Authorization para autenticação stateless",
          "Cookie de sessão",
          "API key no header",
          "Autenticação básica com senha",
        ],
        c: 0,
        e: "JWT: header.payload.signature codificados em base64. Header (alg, type), Payload (sub, exp, iat, claims customizados), Signature (HMAC ou RSA). Enviado como: Authorization: Bearer <token>. Stateless: servidor não mantém sessão, valida pela assinatura.",
        x: "Login: POST /auth/login {email, password} → {token: 'eyJ...'}. Requisições seguintes: GET /api/users, Header: Authorization: Bearer eyJ... Servidor valida assinatura e extrai userId do payload.",
      },
    ],
    Difícil: [
      {
        q: "Em uma API GraphQL, como o DataLoader resolve o problema N+1 de queries ao banco de dados?",
        o: [
          "Agrupa múltiplas chaves em uma única query batch usando deduplicação e coalescing por tick do event loop",
          "Usa cache de segundo nível no servidor",
          "Limita o número de resolvers executados",
          "Converte GraphQL em REST internamente",
        ],
        c: 0,
        e: "O DataLoader coleta todas as chaves requisitadas dentro de um mesmo tick do event loop e dispara uma única query batch (ex.: WHERE id IN (1,2,3)) em vez de N queries individuais. Também deduplica chaves repetidas e cacheia resultados por request.",
        x: "Sem DataLoader: 1 query para listar 50 posts + 50 queries para buscar o autor de cada post = 51 queries. Com DataLoader: 1 query posts + 1 query WHERE author_id IN (...50 ids) = 2 queries.",
      },
      {
        q: "O que são Mutations no GraphQL e como diferem de Queries?",
        o: [
          "Mutations modificam dados (criar, atualizar, deletar); Queries apenas leem dados",
          "São idênticos",
          "Queries modificam e Mutations leem",
          "Mutations são assincronas e Queries síncronas",
        ],
        c: 0,
        e: "Queries são operações de leitura (análogas a GET). Mutations são operações de escrita (análogas a POST/PUT/DELETE). Queries são executadas em paralelo; Mutations são executadas sequencialmente para garantir consistência. Subscriptions permitem dados em tempo real via WebSocket.",
        x: 'mutation { createUser(input: { name: "Ana", email: "ana@email.com" }) { id, name } } — cria usuário e retorna apenas id e name do recém-criado.',
      },
      {
        q: "O que é o padrão HATEOAS em APIs REST e qual sua vantagem?",
        o: [
          "Respostas incluem links para ações relacionadas, permitindo que o cliente navegue pela API sem conhecer URLs previamente",
          "Protocolo de criptografia para APIs",
          "Formato de compressão de JSON",
          "Tipo de autenticação OAuth",
        ],
        c: 0,
        e: "HATEOAS (Hypermedia as the Engine of Application State) é o nível mais alto de maturidade REST (Richardson Level 3). As respostas incluem links (hypermedia) para ações possíveis, permitindo ao cliente descobrir a API dinamicamente sem documentacação externa.",
        x: 'GET /api/orders/42 retorna: { "id": 42, "status": "pending", "_links": { "self": "/orders/42", "cancel": "/orders/42/cancel", "pay": "/orders/42/pay" } }. O cliente sabe que pode cancelar ou pagar seguindo os links.',
      },
      {
        q: "O que é o problema N+1 em GraphQL e como resolvê-lo?",
        o: [
          "Quando cada item de uma lista dispara uma query adicional; resolvido com DataLoader (batching)",
          "Limite de 1 query por requisição",
          "Erro de sintaxe na query",
          "Problema de cache",
        ],
        c: 0,
        e: "N+1: query de users (1 query) onde cada user resolve posts (N queries). DataLoader agrupa todas as chamadas do mesmo tick em um batch: em vez de 100 queries SELECT * FROM posts WHERE userId=?, faz 1 query SELECT * FROM posts WHERE userId IN (1,2,...100).",
        x: "Sem DataLoader: 1 query users + 100 queries posts = 101 queries (N+1). Com DataLoader: 1 query users + 1 query posts com IN clause = 2 queries. Performance 50x melhor.",
      },
      {
        q: "O que são WebSockets e como diferem de REST para comunicação em tempo real?",
        o: [
          "Protocolo bidirecional persistente; REST é request-response sem conexão persistente",
          "REST mais rápido é idêntico",
          "WebSockets substituem REST completamente",
          "WebSockets só funcionam com GraphQL",
        ],
        c: 0,
        e: "WebSockets: conexão TCP persistente bidirecional. Servidor pode enviar dados ao cliente sem request (push). Ideal para chat, games, dashboards real-time, notificações. REST: cada interação é request-response independente (stateless).",
        x: "Chat com REST: cliente faz polling GET /messages a cada 1s (1000 requests inúteis se não há mensagem nova). Chat com WebSocket: servidor envia mensagem ao cliente instantaneamente quando chega. Latência: 1s vs 50ms.",
      },
      {
        q: "O que é o padrão BFF (Backend for Frontend) e quando usá-lo?",
        o: [
          "Backend específico para cada tipo de cliente (web, mobile) que agrega e formata dados de microsserviços",
          "Framework de frontend",
          "Tipo de API Gateway",
          "Padrão de cache",
        ],
        c: 0,
        e: "BFF: camada backend dedicada por cliente. BFF web retorna dados completos; BFF mobile retorna dados compactos. Cada BFF agrega chamadas a microsserviços internos, formata resposta para o cliente específico. Evita API genérica que não atende bem nenhum cliente.",
        x: "BFF Web: /dashboard → agrega users + orders + analytics → resposta completa com gráficos. BFF Mobile: /dashboard → agrega só orders resumidos → payload 80% menor para economia de dados.",
      },
      {
        q: "O que é gRPC e como difere de REST?",
        o: [
          "Framework RPC que usa Protocol Buffers (binário) sobre HTTP/2; mais rápido que REST/JSON",
          "Versão mais nova do REST",
          "REST com compressão",
          "GraphQL binário",
        ],
        c: 0,
        e: "gRPC: Remote Procedure Call do Google. Usa Protocol Buffers (serialização binária, ~10x menor que JSON) sobre HTTP/2 (multiplexing, streaming bidirecional). Tipagem forte via .proto files. Ideal para comunicação entre microsserviços (alta performance).",
        x: "Proto: service UserService { rpc GetUser(UserRequest) returns (User); }. Gera client e server em qualquer linguagem. Payload: User em protobuf = 50 bytes vs JSON = 500 bytes. Latência: gRPC ~2ms vs REST ~10ms.",
      },
    ],
  },

  // ── Arquitetura de Software ──
  "Arquitetura de Software": {
    Fácil: [
      {
        q: "Qual padrão arquitetural divide a aplicação em três camadas: apresentação, lógica de negócios e acesso a dados?",
        o: [
          "MVC (Model-View-Controller)",
          "Microserviços",
          "Event Sourcing",
          "Serverless",
        ],
        c: 0,
        e: "O MVC separa a aplicação em Model (dados e regras de negócio), View (interface com o usuário) e Controller (intermediário que recebe requisições, manipula o Model e retorna a View). Facilita manutenção e testes independentes de cada camada.",
        x: "No Express.js: Router (Controller) recebe GET /users, chama UserService (Model) para buscar dados do banco, e retorna um JSON (View) ao cliente.",
      },
      {
        q: "O que significa arquitetura 'Cliente-Servidor' e onde ela é aplicada?",
        o: [
          "Modelo onde clientes fazem requisições a um servidor central que processa e responde",
          "Modelo peer-to-peer sem servidor",
          "Modelo onde tudo roda no navegador",
          "Modelo exclusivo para jogos online",
        ],
        c: 0,
        e: "Na arquitetura cliente-servidor, clientes (navegadores, apps móveis) enviam requisições pela rede a um servidor que processa, acessa banco de dados e retorna respostas. O servidor centraliza lógica de negócio e dados. É o modelo básico da web.",
        x: "App React Native (cliente) faz GET /api/cards para o servidor Express (servidor). O servidor consulta o PostgreSQL e retorna os flashcards em JSON.",
      },
      {
        q: "O que é uma API e qual seu papel na arquitetura de software?",
        o: [
          "Interface que define como componentes de software se comunicam sem expor detalhes internos",
          "Banco de dados compartilhado",
          "Linguagem de programação",
          "Framework de interface gráfica",
        ],
        c: 0,
        e: "API (Application Programming Interface) define um contrato de comunicação entre sistemas. Expõe funcionalidades de um serviço sem revelar sua implementação interna. APIs HTTP/REST são as mais comuns, mas existem APIs de bibliotecas, SO e hardware.",
        x: "A API do Stripe expõe POST /v1/charges para processar pagamentos. Você não precisa saber como o Stripe processa internamente — só segue o contrato da API.",
      },
      {
        q: "O que é arquitetura monolítica e quais suas características principais?",
        o: [
          "Aplicação em uma única unidade de código deployável com todos os componentes juntos",
          "Aplicação distribuída em vários serviços",
          "Arquitetura baseada em eventos",
          "Sistema sem banco de dados",
        ],
        c: 0,
        e: "Monolito: toda a aplicação (UI, lógica, acesso a dados) em um único deployável. Vantagens: simples de desenvolver, debugar e deployar inicialmente. Desvantagens: escalação (escala tudo ou nada), acoplamento, deploys arriscados, stack único.",
        x: "E-commerce monolítico: um único servidor Java com módulos de pagamento, estoque, usuários, notificações. Para escalar só o pagamento (Black Friday), precisa escalar o monolito inteiro.",
      },
      {
        q: "O que significa o padrão MVC (Model-View-Controller)?",
        o: [
          "Padrão que separa aplicação em Model (dados), View (interface) e Controller (lógica de controle)",
          "Framework JavaScript",
          "Tipo de banco de dados",
          "Protocolo de comunicação",
        ],
        c: 0,
        e: "MVC separa responsabilidades: Model gerencia dados e regras de negócio, View apresenta a interface ao usuário, Controller recebe input do usuário e coordena Model e View. Reduz acoplamento e facilita testes. Usado em Rails, Django, Spring MVC.",
        x: "Cadastro de usuário: View (formulário HTML) → Controller (recebe POST, valida dados) → Model (salva no banco) → Controller redireciona → View (página de sucesso).",
      },
      {
        q: "Qual a diferença entre escalabilidade horizontal e vertical?",
        o: [
          "Horizontal adiciona mais máquinas; vertical aumenta recursos da máquina existente",
          "São termos para banco de dados apenas",
          "Horizontal é mais barato sempre",
          "Vertical exige microsserviços",
        ],
        c: 0,
        e: "Escala vertical (scale up): mais CPU, RAM ou disco na mesma máquina — simples, mas tem limite físico. Escala horizontal (scale out): adicionar mais instâncias/máquinas atrás de um load balancer — mais complexo (estado, sessão), mas virtualmente ilimitado.",
        x: "Vertical: trocar servidor de 8GB RAM por 64GB. Horizontal: manter 8 servidores de 8GB atrás de um NGINX. Microsserviços facilitam escala horizontal; monolitos geralmente escalam verticalmente.",
      },
      {
        q: "O que é o padrão de camadas (Layered Architecture)?",
        o: [
          "Organização em camadas onde cada uma só se comunica com a camada adjacente",
          "Divisão de código em microsserviços",
          "Padrão de cache multinível",
          "Técnica de compressão de dados",
        ],
        c: 0,
        e: "Layered Architecture organiza o código em camadas horizontais: Apresentação → Lógica de Negócio → Acesso a Dados → Banco. Cada camada depende apenas da camada abaixo. Facilita separação de responsabilidades e substituição de uma camada sem afetar as outras.",
        x: "Controller (Apresentação) → Service (Negócio) → Repository (Dados) → PostgreSQL. O Controller nunca acessa o banco diretamente; sempre passa pelo Service e Repository.",
      },
    ],
    Médio: [
      {
        q: "Qual é a principal diferença entre arquitetura monolítica e microsserviços em termos de deploy?",
        o: [
          "Microsserviços permitem deploy independente de cada serviço; monolito exige deploy da aplicação inteira",
          "Monolito é mais rápido para deploy",
          "Microsserviços não podem ser containerizados",
          "Não há diferença de deploy, apenas de organização de código",
        ],
        c: 0,
        e: "Em microsserviços, cada serviço tem seu próprio repositório, pipeline CI/CD e processo de deploy independente. Uma alteração no serviço de pagamentos pode ser deployada sem afetar o serviço de catálogo. No monolito, qualquer mudança exige rebuild e redeploy de toda a aplicação.",
        x: "Time A faz deploy do serviço de pagamentos às 14h. Time B faz deploy do serviço de notificações às 15h. Nenhum interfere no outro. No monolito, ambos teriam que coordenar um único deploy.",
      },
      {
        q: "O que é o padrão Repository na arquitetura de software?",
        o: [
          "Camada de abstração entre lógica de negócio e acesso a dados, encapsulando operações de persistência",
          "Repositório Git",
          "Cache de banco de dados",
          "Servidor de CI/CD",
        ],
        c: 0,
        e: "O Repository Pattern cria uma interface entre a camada de domínio e a camada de dados. A lógica de negócio usa métodos como findById(), save(), delete() sem saber se os dados vêm de PostgreSQL, MongoDB ou API externa. Facilita testes (mock do repo) e troca de banco.",
        x: "interface UserRepository { findById(id: string): User; save(user: User): void; } class PgUserRepository implements UserRepository { ... } — service usa a interface, teste usa MockUserRepository.",
      },
      {
        q: "O que é DDD (Domain-Driven Design) e qual seu conceito central?",
        o: [
          "Abordagem que coloca o domínio de negócio no centro do design, usando linguagem ubíqua entre devs e especialistas",
          "Metodologia ágil",
          "Ferramenta de deploy",
          "Banco de dados orientado a domínios",
        ],
        c: 0,
        e: "DDD foca em modelar o software refletindo o domínio do negócio. Conceitos-chave: Entidades (identidade única), Value Objects (imutáveis, igualdade por valor), Aggregates (grupo transacional), Bounded Contexts (limites de contexto), Ubiquitous Language (terminologia compartilhada entre devs e negócio).",
        x: "No domínio de e-commerce: Pedido (Entity com ID), Dinheiro (Value Object: { valor: 100, moeda: 'BRL' }), Carrinho (Aggregate Root que contém ItemCarrinho). Dev e PO usam os mesmos termos: 'Pedido', não 'Order row'.",
      },
      {
        q: "O que é arquitetura de microsserviços e quais suas vantagens sobre monolitos?",
        o: [
          "Dividir a aplicação em serviços independentes, cada um com deploy e escalabilidade própria",
          "Monolito com módulos internos",
          "Aplicação frontend dividida",
          "Banco de dados distribuído",
        ],
        c: 0,
        e: "Microsserviços: cada serviço é independente (deploy, stack, banco próprio), comunica via API/mensageria. Vantagens: escala independente, deploys frequentes, equipes autônomas. Desvantagens: complexidade operacional, consistência distribuída, latency overhead.",
        x: "Netflix: serviço de recomendação (Python/ML), serviço de streaming (Java), serviço de billing (Go), serviço de perfil (Node.js). Cada um escala independentemente conforme demanda.",
      },
      {
        q: "O que é o padrão CQRS (Command Query Responsibility Segregation)?",
        o: [
          "Separar operações de leitura (Query) e escrita (Command) em modelos diferentes",
          "Cache de queries SQL",
          "Compressão de requisições",
          "Controle de acesso por query",
        ],
        c: 0,
        e: "CQRS separa leitura e escrita: Command modelo otimizado para writes (validações, regras), Query modelo otimizado para reads (denormalizado, rápido). Frequentemente combinado com Event Sourcing. Ideal quando leitura e escrita têm cargas muito diferentes.",
        x: "E-commerce: Command escreve pedido no banco normalizado com validações. Query lê de uma view materializada denormalizada com join pré-calculado. Escrita: 100 req/s. Leitura: 10.000 req/s — modelos otimizados separadamente.",
      },
      {
        q: "O que é o padrão Strangler Fig para migração de monolito para microsserviços?",
        o: [
          "Substituir gradualmente partes do monolito por microsserviços, roteando tráfego progressivamente",
          "Derrubar o monolito e reescrever tudo do zero",
          "Executar monolito e microsserviços em paralelo permanentemente",
          "Usar cache para acelerar o monolito",
        ],
        c: 0,
        e: "Strangler Fig (inspirado na figueira que envolve a árvore hospedeira) migra gradualmente: cria o microsserviço novo, roteia parte do tráfego para ele via proxy, e quando 100% do tráfego estiver no novo serviço, remove o código antigo do monolito. Minimiza risco.",
        x: "Monolito com módulo de pagamento. Cria PagamentoService em microsserviço. NGINX redireciona /api/pagamentos para o novo serviço. Testa com 10% do tráfego → 50% → 100%. Remove módulo de pagamento do monolito.",
      },
      {
        q: "O que é Event-Driven Architecture (EDA) e quando usá-la?",
        o: [
          "Arquitetura onde componentes se comunicam por eventos assíncronos via message broker",
          "Arquitetura com chamadas síncronas entre serviços",
          "Arquitetura exclusiva para frontend",
          "Tipo de banco de dados reativo",
        ],
        c: 0,
        e: "EDA: produtores emitem eventos (PedidoCriado, PagamentoConfirmado) para um broker (Kafka, RabbitMQ). Consumidores processam independentemente. Vantagens: desacoplamento, escalabilidade, resiliência. Desvantagens: complexidade, eventual consistency, debug mais difícil.",
        x: "Pedido criado → evento PedidoCriado no Kafka → EstoqueService consome (reserva itens), NotificacaoService consome (envia email), AnalyticsService consome (registra métrica). Cada um independente.",
      },
    ],
    Difícil: [
      {
        q: "No padrão CQRS (Command Query Responsibility Segregation), por que separar os modelos de leitura e escrita pode aumentar a escalabilidade?",
        o: [
          "Permite otimizar e escalar independentemente cada lado: writes para consistência e reads para performance com modelos desnormalizados",
          "Reduz o número de tabelas no banco",
          "Elimina a necessidade de eventos assíncronos",
          "Simplifica o código removendo validações",
        ],
        c: 0,
        e: "CQRS separa o modelo de comando (escrita) do modelo de consulta (leitura). O lado de escrita pode usar um modelo normalizado otimizado para integridade. O lado de leitura usa modelos desnormalizados (views materializadas) otimizados para queries. Cada lado escala independentemente.",
        x: "Write side: insere pedido na tabela normalizada Orders + OrderItems. Read side: tabela desnormalizada OrderSummary com todos os dados pré-calculados. 10x mais reads que writes → escale apenas o read side.",
      },
      {
        q: "O que é o padrão Saga em microsserviços e como ele substitui transações distribuídas?",
        o: [
          "Sequência de transações locais com compensações em caso de falha, substituindo 2PC",
          "Transação SQL distribuída",
          "Cache distribuído",
          "Tipo de mensageria",
        ],
        c: 0,
        e: "O padrão Saga divide uma transação distribuída em uma sequência de transações locais. Cada passo tem uma ação compensatória (rollback). Se o passo 3 falhar, executa compensações 2 e 1 na ordem inversa. Abordagens: coreografia (eventos) ou orquestração (orquestrador central).",
        x: "Criar Pedido: 1) ReservarEstoque → 2) ProcessarPagamento → 3) EnviarNotificação. Se pagamento falhar: compensar estoque (liberar reserva). Cada serviço gerencia sua transação local.",
      },
      {
        q: "Qual é a diferença entre arquitetura hexagonal (Ports & Adapters) e arquitetura em camadas tradicional?",
        o: [
          "Hexagonal coloca o domínio no centro com portas (interfaces) e adaptadores (implementações), invertendo dependências",
          "São idênticas",
          "Hexagonal não usa interfaces",
          "Camadas é mais modular",
        ],
        c: 0,
        e: "Na arquitetura hexagonal, o domínio (core) não depende de nada externo. Ports são interfaces definidas pelo domínio (ex: IOrderRepo). Adapters são implementações concretas (ex: PostgresOrderRepo, HttpOrderController). Dependências apontam para dentro. Na arquitetura em camadas, dependências vão de cima para baixo.",
        x: "Core: OrderService depende de IOrderRepository (port). Adapter DB: PostgresOrderRepo implements IOrderRepository. Adapter HTTP: ExpressController chama OrderService. Trocar PostgreSQL por MongoDB: apenas novo adapter, core intocado.",
      },
      {
        q: "O que é Event Sourcing e como difere de CRUD tradicional?",
        o: [
          "Armazenar sequência de eventos em vez de estado atual; reconstrói o estado reproduzindo eventos",
          "Cache de eventos do DOM",
          "Log de auditoria simples",
          "Banco de dados de séries temporais",
        ],
        c: 0,
        e: "Event Sourcing: em vez de UPDATE no estado, armazena eventos imutáveis (PedidoCriado, ItemAdicionado, PagamentoConfirmado). Estado atual = replay de todos os eventos. Vantagens: auditoria completa, debug no tempo, projetar múltiplas views. Complexidade: snapshots para performance.",
        x: "Conta bancária CRUD: UPDATE saldo=900. Event Sourcing: eventos [ContaCriada(1000), Saque(100)]. Saldo = replay: 1000-100 = 900. Pode auditar toda história e criar novas projeções retroativamente.",
      },
      {
        q: "O que são Design Patterns de arquitetura e qual a diferença entre Saga e Two-Phase Commit em transações distribuídas?",
        o: [
          "Saga usa compensações locais em sequência; 2PC usa coordenador global com lock distribuído",
          "São idênticos",
          "2PC é mais moderno que Saga",
          "Saga só funciona com monolitos",
        ],
        c: 0,
        e: "Two-Phase Commit: coordenador pede prepare a todos, depois commit. Bloqueia recursos e não escala bem. Saga: sequência de transações locais, cada uma com compensação. Falha no passo 3 → executa compensações 2, 1. Tipos: Choreography (eventos) e Orchestration (orquestrador central).",
        x: "Saga de pedido: 1) ReservarEstoque 2) CobrarPagamento 3) EnviarEmail. Se pagamento falha: compensação LiberarEstoque. Orchestrator coordena ou cada serviço ouve eventos do anterior.",
      },
      {
        q: "O que é o padrão Circuit Breaker em microsserviços e como previne falhas em cascata?",
        o: [
          "Monitora falhas de um serviço e 'abre o circuito' para bloquear chamadas quando detecta instabilidade",
          "Balanceador de carga round-robin",
          "Firewall entre microsserviços",
          "Mecanismo de retry infinito",
        ],
        c: 0,
        e: "Circuit Breaker tem 3 estados: Closed (normal, chamadas passam), Open (serviço instável, chamadas bloqueadas com fallback), Half-Open (testa se serviço se recuperou). Previne cascading failures: um serviço lento não trava os que dependem dele.",
        x: "Serviço de recomendação está lento (timeout 5s). Sem CB: 100 requests acumulam, 500s de thread bloqueada → crash. Com CB: após 5 falhas consecutivas, circuito abre, retorna cache local ou lista genérica em 10ms. Testa recuperação a cada 30s.",
      },
      {
        q: "O que é o princípio de Inversão de Dependências (DIP) e como se aplica em arquitetura de software?",
        o: [
          "Módulos de alto nível não devem depender de módulos de baixo nível; ambos devem depender de abstrações",
          "Inverter a ordem das camadas na arquitetura",
          "Usar injeção de dependência com framework",
          "Remover todas as interfaces do código",
        ],
        c: 0,
        e: "DIP (SOLID 'D'): dependências devem apontar para abstrações (interfaces), não implementações concretas. OrderService depende de IPaymentGateway, não de StripeGateway diretamente. Facilita testes (mock), troca de implementação e respeita Open/Closed Principle.",
        x: "Sem DIP: OrderService importa StripeGateway → acoplado ao Stripe. Com DIP: OrderService depende de IPaymentGateway (interface). StripeGateway e PayPalGateway implementam a interface. Trocar gateway: mudar apenas a injeção, zero alteração no OrderService.",
      },
    ],
  },

  // ── Banco de Dados SQL ──
  "Banco de Dados SQL": {
    Fácil: [
      {
        q: "Qual comando SQL é usado para buscar dados de uma tabela filtrando por uma condição específica?",
        o: ["SELECT ... WHERE", "INSERT INTO", "CREATE TABLE", "DROP TABLE"],
        c: 0,
        e: "O comando SELECT com cláusula WHERE permite buscar registros de uma tabela que atendam a uma condição. WHERE filtra as linhas antes de retornar o resultado.",
        x: "SELECT nome, email FROM usuarios WHERE idade >= 18; — retorna nome e email de todos os usuários com 18 anos ou mais.",
      },
      {
        q: "Qual comando SQL é usado para inserir um novo registro em uma tabela?",
        o: ["INSERT INTO", "SELECT", "UPDATE", "CREATE TABLE"],
        c: 0,
        e: "O comando INSERT INTO adiciona uma nova linha à tabela especificada. Pode inserir valores explícitos ou dados vindos de um SELECT (INSERT INTO...SELECT). A ordem dos valores deve corresponder à ordem das colunas especificadas.",
        x: "INSERT INTO usuarios (nome, email, idade) VALUES ('Ana Silva', 'ana@email.com', 28); — insere um novo registro na tabela usuarios.",
      },
      {
        q: "O que é uma chave primária (PRIMARY KEY) em SQL?",
        o: [
          "Coluna ou conjunto de colunas que identifica cada registro de forma única",
          "Senha de acesso ao banco",
          "Tipo de índice para buscas",
          "Chave de criptografia",
        ],
        c: 0,
        e: "A PRIMARY KEY garante que cada registro na tabela seja único e não nulo. Normalmente é uma coluna 'id' com auto-incremento (SERIAL no PostgreSQL, AUTO_INCREMENT no MySQL). Uma tabela só pode ter uma PRIMARY KEY, mas ela pode ser composta (múltiplas colunas).",
        x: "CREATE TABLE usuarios (id SERIAL PRIMARY KEY, nome VARCHAR(100), email VARCHAR(255) UNIQUE); — 'id' é chave primária auto-incrementada.",
      },
      {
        q: "O que é uma chave estrangeira (Foreign Key) em SQL?",
        o: [
          "Coluna que referencia a chave primária de outra tabela, criando um relacionamento entre elas",
          "Chave de criptografia do banco",
          "Senha do administrador",
          "Tipo de índice",
        ],
        c: 0,
        e: "Foreign Key cria um relacionamento entre tabelas. Garante integridade referencial: o valor da FK deve existir na tabela referenciada. CASCADE delete/update pode propagar alterações. Implementa relações 1:N e N:M (via tabela associativa).",
        x: "CREATE TABLE pedidos (id SERIAL PRIMARY KEY, usuario_id INTEGER REFERENCES usuarios(id) ON DELETE CASCADE); — cada pedido pertence a um usuário. Deletar usuário deleta seus pedidos.",
      },
      {
        q: "Qual a diferença entre os comandos SQL SELECT, INSERT, UPDATE e DELETE?",
        o: [
          "SELECT lê dados, INSERT cria, UPDATE modifica e DELETE remove registros",
          "Todos modificam dados",
          "SELECT e INSERT são idênticos",
          "DELETE apaga a tabela inteira",
        ],
        c: 0,
        e: "CRUD em SQL: SELECT (Read) busca dados. INSERT (Create) adiciona registros. UPDATE (Update) modifica registros existentes. DELETE (Delete) remove registros. WHERE filtra quais registros são afetados pelo UPDATE/DELETE.",
        x: "INSERT INTO usuarios (nome) VALUES ('Ana'); SELECT * FROM usuarios WHERE nome='Ana'; UPDATE usuarios SET nome='Ana Silva' WHERE id=1; DELETE FROM usuarios WHERE id=1;",
      },
      {
        q: "O que faz o comando GROUP BY em SQL?",
        o: [
          "Agrupa registros com valores iguais para aplicar funções de agregação como COUNT, SUM, AVG",
          "Ordena os resultados por coluna",
          "Filtra registros duplicados",
          "Cria índices automáticos",
        ],
        c: 0,
        e: "GROUP BY agrupa linhas que têm os mesmos valores na(s) coluna(s) especificada(s). Usado com funções de agregação: COUNT (contar), SUM (somar), AVG (média), MIN, MAX. HAVING filtra os grupos (como WHERE para grupos).",
        x: "SELECT departamento, COUNT(*) as total FROM funcionarios GROUP BY departamento HAVING COUNT(*) > 5; — conta funcionários por departamento, mostrando só os com mais de 5.",
      },
      {
        q: "O que é NULL em SQL e como se compara valores nulos?",
        o: [
          "NULL representa ausência de valor; comparação usa IS NULL e IS NOT NULL, não = ou !=",
          "NULL é igual a zero",
          "NULL é uma string vazia",
          "NULL é comparado com = normalmente",
        ],
        c: 0,
        e: "NULL em SQL não é zero nem string vazia — é ausência de valor. Qualquer operação com NULL resulta em NULL (ex: 5 + NULL = NULL). Comparações com = ou != com NULL sempre resultam em UNKNOWN (nem TRUE nem FALSE). Usar IS NULL / IS NOT NULL.",
        x: "SELECT * FROM usuarios WHERE telefone IS NULL; — retorna usuários sem telefone. WHERE telefone = NULL NÃO funciona (retorna 0 resultados, sempre). COALESCE(telefone, 'N/A') retorna 'N/A' se NULL.",
      },
    ],
    Médio: [
      {
        q: "Qual é a diferença entre INNER JOIN e LEFT JOIN em SQL?",
        o: [
          "INNER JOIN retorna apenas registros com correspondência em ambas tabelas; LEFT JOIN retorna todos da tabela esquerda",
          "LEFT JOIN é mais rápido",
          "INNER JOIN permite NULL e LEFT JOIN não",
          "Não há diferença funcional",
        ],
        c: 0,
        e: "INNER JOIN retorna apenas as linhas que têm correspondência nas duas tabelas. LEFT JOIN retorna todas as linhas da tabela da esquerda, preenchendo com NULL os campos da tabela da direita quando não há correspondência.",
        x: "SELECT u.nome, p.titulo FROM usuarios u LEFT JOIN posts p ON u.id = p.user_id — retorna todos os usuários, inclusive os que não têm posts (titulo será NULL).",
      },
      {
        q: "O que são índices (INDEX) em SQL e como eles melhoram performance?",
        o: [
          "Estruturas que aceleram buscas criando um acesso rápido aos dados sem varrer toda a tabela",
          "Cópias da tabela em memória",
          "Backups automáticos",
          "Tipos de chave primária",
        ],
        c: 0,
        e: "Índices criam estruturas auxiliares (geralmente B-trees) que permitem localizar registros rapidamente sem full table scan. Aceleram SELECTs com WHERE e JOINs, mas tornam INSERTs/UPDATEs um pouco mais lentos porque o índice precisa ser atualizado.",
        x: "CREATE INDEX idx_email ON usuarios(email); — SELECT * FROM usuarios WHERE email = 'ana@email.com' agora usa o índice (~0.1ms) em vez de varrer 1M de linhas (~500ms).",
      },
      {
        q: "O que são as propriedades ACID em um banco de dados?",
        o: [
          "Atomicity, Consistency, Isolation, Durability — garantias de integridade transacional",
          "Tipos de dados SQL",
          "Níveis de acesso",
          "Proto col de rede",
        ],
        c: 0,
        e: "ACID: Atomicity (transação é tudo ou nada), Consistency (banco vai de um estado válido para outro), Isolation (transações concorrentes não interferem entre si), Durability (dados confirmados persistem mesmo após falha). Bancos relacionais como PostgreSQL e MySQL garantem ACID por padrão.",
        x: "Transferência bancária (Atomicity): BEGIN; UPDATE contas SET saldo = saldo - 100 WHERE id = 1; UPDATE contas SET saldo = saldo + 100 WHERE id = 2; COMMIT; — se qualquer UPDATE falhar, ambos são desfeitos.",
      },
      {
        q: "O que é um índice (INDEX) em SQL e como melhora a performance?",
        o: [
          "Estrutura que acelera buscas criando uma referência ordenada aos dados, como índice de livro",
          "Cópia de backup da tabela",
          "Cache de queries",
          "Tipo de VIEW",
        ],
        c: 0,
        e: "Índice cria estrutura (B-tree, hash) que permite buscar registros sem percorrer toda a tabela (full scan). SELECT com WHERE em coluna indexada: O(log n) ao invés de O(n). Trade-off: INSERT/UPDATE ficam mais lentos pois o índice precisa ser atualizado.",
        x: "Tabela com 10M registros, busca por email sem índice: 5s (full scan). CREATE INDEX idx_email ON usuarios(email); mesma busca: 5ms. 1000x mais rápido.",
      },
      {
        q: "O que são JOINs em SQL e qual a diferença entre INNER JOIN e LEFT JOIN?",
        o: [
          "INNER retorna só registros com correspondência em ambas tabelas; LEFT retorna todos da esquerda",
          "São idênticos",
          "LEFT JOIN é mais rápido",
          "INNER JOIN retorna mais resultados",
        ],
        c: 0,
        e: "INNER JOIN: retorna apenas linhas que têm correspondência em ambas as tabelas. LEFT JOIN: retorna TODAS as linhas da tabela à esquerda, com NULL onde não há correspondência na direita. RIGHT JOIN: o oposto. FULL OUTER: tudo de ambas.",
        x: "usuarios LEFT JOIN pedidos: retorna todos os usuários, mesmo os sem pedidos (pedido_id = NULL). INNER JOIN: retornaria apenas usuários COM pedidos.",
      },
      {
        q: "O que é uma subquery (subconsulta) em SQL e quando usá-la?",
        o: [
          "SELECT aninhado dentro de outro SELECT, usado para filtrar ou calcular valores dinamicamente",
          "Query que roda em outro banco de dados",
          "Query agendada para execução futura",
          "Backup parcial de uma tabela",
        ],
        c: 0,
        e: "Subquery é um SELECT dentro de outro comando SQL. Pode ser usada no WHERE (filtro), FROM (derived table), SELECT (valor escalar) ou EXISTS. Subqueries correlacionadas (referenciam a query externa) podem ser ineficientes; considerar JOINs como alternativa.",
        x: "SELECT nome FROM usuarios WHERE id IN (SELECT user_id FROM pedidos WHERE valor > 1000); — retorna nomes de usuários que fizeram pedidos acima de R$1000. A subquery filtra os IDs primeiro.",
      },
      {
        q: "O que é uma VIEW em SQL e quando utilizá-la?",
        o: [
          "Consulta salva como tabela virtual que pode ser referenciada como se fosse uma tabela real",
          "Cópia física dos dados em outra tabela",
          "Tipo de índice para consultas",
          "Backup automático de tabela",
        ],
        c: 0,
        e: "VIEW é uma query SELECT nomeada e salva no banco. Não armazena dados (apenas a definição). Ao consultar a VIEW, o banco executa a query subjacente. Vantagens: simplificar queries complexas, controlar acesso (expor apenas colunas necessárias), abstrair JOINs.",
        x: "CREATE VIEW pedidos_resumo AS SELECT u.nome, COUNT(p.id) as total_pedidos, SUM(p.valor) as total_gasto FROM usuarios u JOIN pedidos p ON u.id = p.user_id GROUP BY u.nome; — depois: SELECT * FROM pedidos_resumo WHERE total_gasto > 5000;",
      },
    ],
    Difícil: [
      {
        q: "O que é um deadlock em banco de dados e como o SGBD tipicamente o resolve?",
        o: [
          "Duas transações bloqueiam-se mutuamente; o SGBD aborta uma delas (vítima) para liberar a outra",
          "Duas transações leem o mesmo dado simultaneamente",
          "Uma query demora mais que o timeout",
          "O banco fica sem espaço em disco",
        ],
        c: 0,
        e: "Deadlock ocorre quando duas transações esperam uma pela outra: T1 bloqueia recurso A e espera B, enquanto T2 bloqueia B e espera A. O SGBD detecta o ciclo de espera e escolhe uma 'vítima' (geralmente a transação com menor custo) para fazer rollback, liberando seus locks.",
        x: "T1: UPDATE contas SET saldo=100 WHERE id=1 (lock em id=1), depois UPDATE contas SET saldo=200 WHERE id=2 (espera lock em id=2). T2: UPDATE contas SET saldo=300 WHERE id=2 (lock em id=2), depois UPDATE contas SET saldo=400 WHERE id=1 (espera lock em id=1). Deadlock! SGBD aborta T2.",
      },
      {
        q: "O que é um Execution Plan (EXPLAIN) e como ele ajuda a otimizar queries?",
        o: [
          "Mostra o plano que o banco usará para executar a query, revelando se usa índices ou full scan",
          "Executa a query mais rápido",
          "Cria índices automaticamente",
          "Backup do resultado da query",
        ],
        c: 0,
        e: "EXPLAIN mostra como o optimizer do banco planeja executar a query: se fará Sequential Scan (varredura completa) ou Index Scan, quantas linhas estima processar, ordem de JOINs e custo estimado. EXPLAIN ANALYZE executa de fato e mostra tempos reais. Essencial para identificar queries lentas.",
        x: "EXPLAIN ANALYZE SELECT * FROM pedidos WHERE status = 'pendente'; → Se mostrar Seq Scan com 1M rows e 500ms, crie índice: CREATE INDEX idx_status ON pedidos(status); → Index Scan com 50 rows e 0.5ms.",
      },
      {
        q: "O que são níveis de isolamento de transações SQL e quais problemas cada nível previne?",
        o: [
          "Read Uncommitted, Read Committed, Repeatable Read e Serializable — previnem dirty reads, non-repeatable reads e phantom reads progressivamente",
          "São tipos de lock",
          "São tipos de índice",
          "São tipos de JOIN",
        ],
        c: 0,
        e: "Read Uncommitted: permite dirty reads. Read Committed (padrão PostgreSQL): previne dirty reads. Repeatable Read: previne dirty + non-repeatable reads. Serializable: previne todos, incluindo phantom reads, mas com menor concorrência. Trade-off: mais isolamento = menos performance.",
        x: "Dirty read: T1 lê dado não commitado de T2 (que pode dar rollback). Non-repeatable: T1 lê um dado, T2 altera e commita, T1 lê novamente e vê valor diferente. Phantom: T1 conta rows, T2 insere nova row, T1 conta novamente e vê número diferente.",
      },
      {
        q: "O que é normalização de banco de dados e qual o objetivo das formas normais?",
        o: [
          "Processo de organizar dados para eliminar redundância e dependências parciais",
          "Compressão de dados",
          "Criptografia de tabelas",
          "Backup incremental",
        ],
        c: 0,
        e: "Normalização: 1NF (eliminar grupos repetidos), 2NF (eliminar dependências parciais da PK), 3NF (eliminar dependências transitivas). Reduz redundância, melhora integridade. Desnormalização: adicionar redundância intencionalmente para performance de leitura.",
        x: "Não normalizado: pedidos(id, cliente_nome, cliente_email, produto). Normalizado: pedidos(id, cliente_id, produto_id) + clientes(id, nome, email) + produtos(id, nome). Atualizar email do cliente: 1 lugar só.",
      },
      {
        q: "O que é uma stored procedure e quando usá-la?",
        o: [
          "Função armazenada no banco que encapsula lógica SQL reutilizável",
          "Backup automático do banco",
          "Tipo de índice",
          "Driver de conexão",
        ],
        c: 0,
        e: "Stored procedures são blocos de SQL armazenados no banco, executados com CALL/EXEC. Vantagens: reutilização, performance (compilada), segurança (acesso controlado). Desvantagens: lógica de negócio no banco, difícil versionar, vendor lock-in.",
        x: "CREATE PROCEDURE transfer(from_id INT, to_id INT, amount DECIMAL) BEGIN; UPDATE contas SET saldo = saldo - amount WHERE id = from_id; UPDATE contas SET saldo = saldo + amount WHERE id = to_id; END; CALL transfer(1, 2, 100);",
      },
      {
        q: "O que é particionamento (sharding) de banco de dados e quando aplicá-lo?",
        o: [
          "Dividir dados de uma tabela em múltiplos servidores usando uma chave de partição para escalar horizontalmente",
          "Replicar dados em servidores de backup",
          "Comprimir tabelas grandes",
          "Criar índices distribuídos",
        ],
        c: 0,
        e: "Sharding distribui dados entre múltiplos nós usando uma shard key (ex: user_id % N). Cada shard contém um subconjunto dos dados. Vantagens: escala horizontal de escrita. Desafios: queries cross-shard, rebalanceamento, transações distribuídas, choice de shard key.",
        x: "Tabela de pedidos com 1 bilhão de registros. Shard key: user_id. Shard 1: users 1-33M. Shard 2: users 33M-66M. Shard 3: users 66M-100M. Query WHERE user_id=42 vai direto ao Shard 1. Query WHERE status='pendente' precisa consultar os 3 shards.",
      },
      {
        q: "O que são CTEs (Common Table Expressions) e Window Functions em SQL avançado?",
        o: [
          "CTEs são subconsultas nomeadas com WITH; Window Functions calculam sobre partições sem agrupar linhas",
          "São tipos de stored procedures",
          "São funções de backup incrementais",
          "São extensões NoSQL para bancos relacionais",
        ],
        c: 0,
        e: "CTE: WITH nome AS (SELECT ...) SELECT ... FROM nome — cria resultado temporário nomeado, melhora legibilidade. CTEs recursivas permitem hierarquias. Window Functions: ROW_NUMBER(), RANK(), LAG(), LEAD(), SUM() OVER(PARTITION BY ...) — calculam sobre um 'window' de linhas sem colapsar o resultado como GROUP BY.",
        x: "WITH top_clientes AS (SELECT user_id, SUM(valor) as total FROM pedidos GROUP BY user_id) SELECT u.nome, t.total, RANK() OVER(ORDER BY t.total DESC) as ranking FROM usuarios u JOIN top_clientes t ON u.id = t.user_id; — CTE calcula totais, Window Function rankeia.",
      },
    ],
  },

  // ── Banco de Dados NoSQL ──
  "Banco de Dados NoSQL": {
    Fácil: [
      {
        q: "Qual tipo de banco de dados NoSQL armazena dados como documentos JSON flexíveis, sem esquema rígido?",
        o: [
          "Banco de documentos (ex.: MongoDB)",
          "Banco relacional (ex.: PostgreSQL)",
          "Banco de grafos (ex.: Neo4j)",
          "Banco colunar (ex.: Cassandra)",
        ],
        c: 0,
        e: "Bancos de documentos como MongoDB armazenam dados como documentos JSON/BSON. Cada documento pode ter estrutura diferente (schema-less), permitindo campos variáveis. Ideal para dados semi-estruturados e desenvolvimento ágil.",
        x: "db.usuarios.insertOne({ nome: 'Ana', idade: 28, hobbies: ['leitura', 'yoga'] }) — o campo 'hobbies' é um array e outro documento pode não ter esse campo.",
      },
      {
        q: "Qual tipo de banco NoSQL é otimizado para armazenar e consultar relações complexas entre entidades, como redes sociais?",
        o: [
          "Banco de grafos (ex.: Neo4j)",
          "Banco de documentos (ex.: MongoDB)",
          "Banco chave-valor (ex.: Redis)",
          "Banco colunar (ex.: Cassandra)",
        ],
        c: 0,
        e: "Bancos de grafos armazenam nós (entidades) e arestas (relações) de forma nativa, permitindo queries de relacionamento eficientes. Ideal para redes sociais, grafos de conhecimento, detecção de fraude e recomendações.",
        x: "Neo4j: MATCH (u:User)-[:FOLLOWS]->(friend)-[:LIKES]->(movie) WHERE u.name = 'Ana' RETURN movie.title — encontra filmes que amigos da Ana curtiram, percorrendo o grafo.",
      },
      {
        q: "Para que serve o Redis e qual é sua principal característica?",
        o: [
          "Banco chave-valor em memória, extremamente rápido, usado para cache e sessões",
          "Banco SQL completo",
          "Banco de documentos como MongoDB",
          "Ferramenta de backup",
        ],
        c: 0,
        e: "Redis armazena dados em memória RAM (in-memory), oferecendo latência sub-milissegundo. Suporta estruturas: strings, hashes, listas, sets, sorted sets. Usado como cache, session store, fila de mensagens, rate limiter e leaderboard. Persistência opcional via RDB/AOF.",
        x: "// Cache de query custosa:\nawait redis.setex('user:42', 3600, JSON.stringify(userData)); // TTL 1h\nconst cached = await redis.get('user:42'); // <1ms vs ~50ms no banco.",
      },
      {
        q: "Qual a principal diferença entre um banco de dados relacional (SQL) e um NoSQL?",
        o: [
          "SQL usa tabelas com esquema fixo; NoSQL usa modelos flexíveis (documentos, chave-valor, grafo)",
          "NoSQL é sempre mais rápido",
          "SQL não suporta relações",
          "NoSQL não pode armazenar dados",
        ],
        c: 0,
        e: "SQL (relacional): tabelas com esquema rígido, JOINs, ACID, SQL como linguagem. NoSQL: modelo flexível (documentos, chave-valor, colunar, grafo), escala horizontal, schema-less. SQL melhor para dados relacionais; NoSQL para dados semi-estruturados e alta escala.",
        x: "Usuários com endereços: SQL — tabela usuarios + tabela enderecos (JOIN). MongoDB — um documento { nome: 'Ana', enderecos: [{rua: 'A'}] } com tudo embutido.",
      },
      {
        q: "O que é o MongoDB e qual seu modelo de dados?",
        o: [
          "Banco NoSQL orientado a documentos que armazena dados em formato BSON (similar a JSON)",
          "Banco relacional",
          "Banco de grafos",
          "Banco chave-valor",
        ],
        c: 0,
        e: "MongoDB armazena documentos BSON (Binary JSON) em coleções (equivalente a tabelas). Schema flexível: documentos na mesma coleção podem ter campos diferentes. Queries via MQL (MongoDB Query Language). Suporta índices, agregação, replicação e sharding.",
        x: "db.users.insertOne({ name: 'Ana', age: 28, hobbies: ['coding', 'music'] }); db.users.find({ age: { $gte: 18 } }); — schema flexível, sem migrations.",
      },
      {
        q: "O que é uma coleção (collection) em bancos de documentos como MongoDB?",
        o: [
          "Agrupamento de documentos equivalente a uma tabela em bancos relacionais, mas sem esquema fixo",
          "Arquivo de backup do banco",
          "Tipo de índice",
          "Linguagem de consulta",
        ],
        c: 0,
        e: "Em MongoDB, uma coleção é um grupo de documentos. Diferente de tabelas SQL, não exige que todos os documentos tenham a mesma estrutura (schema-less). Coleções são criadas automaticamente ao inserir o primeiro documento. Análogo: banco SQL (database) → tabela (collection) → linha (document).",
        x: "db.createCollection('usuarios'); // ou simplesmente: db.usuarios.insertOne({ nome: 'Ana' }); — a coleção 'usuarios' é criada automaticamente na primeira inserção.",
      },
      {
        q: "Qual a diferença entre bancos chave-valor e bancos de documentos?",
        o: [
          "Chave-valor armazena dados opacos acessados por chave; documentos armazenam JSON estruturado com queries em campos internos",
          "São idênticos",
          "Chave-valor é mais lento",
          "Documentos não suportam JSON",
        ],
        c: 0,
        e: "Chave-valor (Redis, DynamoDB): dados são um blob opaco acessado exclusivamente pela chave. Rápido para GET/SET, sem queries em campos internos. Documentos (MongoDB, Firestore): armazena JSON, permite queries em qualquer campo interno (find({ age: { $gt: 18 } })).",
        x: "Redis: SET user:42 '{\"nome\":\"Ana\"}' → GET user:42 (retorna blob). MongoDB: db.users.find({ nome: 'Ana', idade: { $gte: 18 } }) — consulta por campos internos do documento.",
      },
    ],
    Médio: [
      {
        q: "No teorema CAP, é impossível que um sistema distribuído garanta simultaneamente quais três propriedades?",
        o: [
          "Consistency, Availability e Partition Tolerance",
          "Concurrency, Atomicity e Performance",
          "Cache, Authentication e Privacy",
          "Compression, Aggregation e Partitioning",
        ],
        c: 0,
        e: "O teorema CAP afirma que um sistema distribuído pode garantir no máximo duas das três propriedades: Consistency (todos os nós veem os mesmos dados), Availability (toda requisição recebe resposta) e Partition Tolerance (funciona mesmo com falhas de rede). Na prática, partições acontecem, então a escolha é entre C e A.",
        x: "MongoDB (CP): durante partição de rede, o primary pode ficar indisponível até eleger novo primary, garantindo consistência. Cassandra (AP): sempre responde, mas réplicas podem ter dados temporariamente diferentes.",
      },
      {
        q: "O que é eventual consistency e em que cenários ela é aceitável?",
        o: [
          "Modelo onde réplicas convergem ao mesmo estado eventualmente, sem garantia de leitura imediata do último write",
          "Consistência em tempo real",
          "Backup eventual",
          "Cache invalidation",
        ],
        c: 0,
        e: "Na eventual consistency, após um write, réplicas podem retornar dados desatualizados por um breve período até que a propagação se complete. Aceitável para: timeline de redes sociais, contadores de views, feeds de notícias. Inaceitável para: saldo bancário, estoque de produtos.",
        x: "Ana posta uma foto. Usuários na mesma região veem instantaneamente, mas usuários em outra região podem levar 2-5 segundos para ver. Para um feed social, isso é aceitável.",
      },
      {
        q: "O que é sharding em bancos NoSQL e qual problema ele resolve?",
        o: [
          "Divisão horizontal de dados entre múltiplos servidores, permitindo escala além de uma única máquina",
          "Backup distribuído",
          "Compressão de dados",
          "Criptografia de dados",
        ],
        c: 0,
        e: "Sharding distribui dados entre múltiplos nós usando uma shard key (ex.: hash do userId). Cada shard contém um subconjunto dos dados. Permite escalar horizontalmente: mais dados = mais shards. Desafio: queries que cruzam shards (scatter-gather) são mais lentas.",
        x: "MongoDB com 3 shards usando userId como shard key: users 1-1M no shard1, 1M-2M no shard2, 2M-3M no shard3. Query por userId é roteada para 1 shard (rápido). Query sem userId vai para todos (lento).",
      },
      {
        q: "O que é o teorema CAP e como ele se aplica a bancos NoSQL?",
        o: [
          "Impossível ter simultâneo: Consistência forte, Alta disponibilidade e Tolerância a partições — escolha 2",
          "Three propriedades sempre garantidas",
          "Aplica-se apenas a SQL",
          "Cache, API e Protocolos",
        ],
        c: 0,
        e: "CAP: em presença de partição de rede (P), precisa escolher entre Consistência (C) ou Disponibilidade (A). CP: MongoDB (rejeita escrita se primary cair). AP: Cassandra (aceita escrita em qualquer nó, resolução posterior). Na prática: PACELC é modelo mais preciso.",
        x: "Partição de rede entre nós: CP (MongoDB) → recusa writes até eleger novo primary (consistente, indisponível). AP (Cassandra) → aceita writes em ambos lados, merge depois (disponível, inconsistente temporariamente).",
      },
      {
        q: "O que é o conceito de embedding vs referencing em MongoDB?",
        o: [
          "Embedding: documento aninhado no pai; Referencing: armazenar ID para lookup em outra coleção",
          "São idênticos",
          "Referencing é sempre melhor",
          "Embedding só funciona com arrays",
        ],
        c: 0,
        e: "Embedding: dados relacionados dentro do mesmo documento (denormalizado). Bom para 1:1, 1:poucos, lidos juntos. Referencing: ObjectId apontando para outro documento. Bom para 1:muitos, N:M, dados acessados independentemente. Trade-off: performance de leitura vs flexibilidade.",
        x: "Embedding: { post: 'Hello', comments: [{text: 'Nice'}] } — 1 query. Referencing: { post: 'Hello', commentIds: ['id1'] } + comments collection — 2 queries, mas comments podem ter milhões sem estourar o documento (limite 16MB).",
      },
      {
        q: "O que é um Replica Set no MongoDB e para que serve?",
        o: [
          "Grupo de instâncias MongoDB que mantêm cópias dos mesmos dados para alta disponibilidade e failover automático",
          "Conjunto de índices replicados",
          "Backup agendado",
          "Cluster de sharding",
        ],
        c: 0,
        e: "Replica Set: 1 primary (recebe writes) + N secondaries (replicam dados). Se o primary cair, eleição automática promove um secondary a primary. Vantagens: alta disponibilidade, read scaling (ler de secondaries), disaster recovery. Mínimo recomendado: 3 membros.",
        x: "Replica Set com 3 nós. Primary recebe write. Secondary1 e Secondary2 replicam via oplog. Primary cai → eleição em ~10s → Secondary1 vira primary. App reconecta automaticamente. Zero downtime.",
      },
      {
        q: "O que é o Aggregation Pipeline no MongoDB?",
        o: [
          "Sequência de estágios que processam documentos: filtram, agrupam, transformam e calculam resultados",
          "Ferramenta de backup incremental",
          "Driver de conexão",
          "Tipo de índice composto",
        ],
        c: 0,
        e: "Aggregation Pipeline: documentos passam por estágios sequenciais ($match, $group, $sort, $project, $lookup, $unwind). Cada estágio transforma os documentos e passa ao próximo. Equivalente NoSQL de queries complexas com GROUP BY, JOIN e subqueries do SQL.",
        x: "db.pedidos.aggregate([ { $match: { status: 'completo' } }, { $group: { _id: '$userId', total: { $sum: '$valor' } } }, { $sort: { total: -1 } }, { $limit: 10 } ]); — top 10 clientes por valor gasto.",
      },
    ],
    Difícil: [
      {
        q: "No DynamoDB, como o design de single-table com overloading de atributos e GSIs permite modelar relações complexas em uma única tabela?",
        o: [
          "Usando PK e SK genéricos com prefixos que representam diferentes entidades, e GSIs invertendo chaves para consultas alternativas",
          "Normalizando dados em múltiplas tabelas com foreign keys",
          "Usando JOINs entre partições",
          "Criando views materializadas SQL",
        ],
        c: 0,
        e: "No single-table design, PK e SK usam prefixos (ex.: PK=USER#123, SK=ORDER#456) para armazenar múltiplas entidades na mesma tabela. GSIs (Global Secondary Indexes) com chaves invertidas ou overloaded permitem diferentes padrões de acesso sem tabelas adicionais.",
        x: "PK=USER#1, SK=PROFILE → dados do usuário. PK=USER#1, SK=ORDER#100 → pedido do usuário. GSI1: PK=ORDER#100, SK=USER#1 → buscar pedido por ID. Tudo em uma tabela.",
      },
      {
        q: "O que é um banco de dados de séries temporais (TSDB) e para que serve?",
        o: [
          "Banco otimizado para dados com timestamp, como métricas de infraestrutura e IoT",
          "Banco de grafos temporal",
          "Banco SQL com colunas de data",
          "Cache temporal",
        ],
        c: 0,
        e: "TSDBs (InfluxDB, TimescaleDB, Prometheus) são otimizados para writes de alta velocidade de dados com timestamp, queries por faixa de tempo, agregações temporais (média por hora/dia) e compressão eficiente de dados sequenciais. Ideal para métricas, IoT, logs financeiros.",
        x: "InfluxDB: INSERT cpu,host=server01 usage=65.4 1625097600000000000. Query: SELECT mean(usage) FROM cpu WHERE time > now() - 1h GROUP BY time(5m) — média de CPU a cada 5 minutos na última hora.",
      },
      {
        q: "Qual a diferença entre replicação síncrona e assíncrona em bancos NoSQL distribuídos?",
        o: [
          "Síncrona espera confirmação de todas as réplicas antes de confirmar write; assíncrona confirma imediatamente e replica em background",
          "São idênticas",
          "Síncrona é mais rápida",
          "Assíncrona não replica",
        ],
        c: 0,
        e: "Síncrona: write só é confirmado após N réplicas confirmarem (consistência forte, maior latência). Assíncrona: write é confirmado após persistência local, réplicas recebem em background (menor latência, risco de dados não replicados em caso de falha). Muitos bancos oferecem níveis configuráveis.",
        x: "MongoDB: w: 'majority' (síncrono — espera maioria confirmar). w: 1 (assíncrono — apenas primary confirma). Cassandra: QUORUM (maioria), ONE (1 nó). Trade-off: consistência vs latência.",
      },
      {
        q: "O que é o Firebase Firestore e como difere de um banco NoSQL tradicional?",
        o: [
          "Banco NoSQL serverless com sincronização em tempo real, SDKs client-side e regras de segurança integradas",
          "Banco SQL gerenciado pelo Google",
          "Clone do MongoDB",
          "Apenas para Android",
        ],
        c: 0,
        e: "Firestore: banco de documentos (coleções/documentos) com sync em tempo real (onSnapshot), SDKs para web/mobile, security rules declarativas, escala automática (serverless). Diferenças de MongoDB: sem servidor para gerenciar, security rules no banco, pricing por operação.",
        x: "Firestore: onSnapshot(collection(db, 'chats'), (snap) => { updateUI(snap.docs) }); — UI atualiza automaticamente quando qualquer usuário envia mensagem. Zero código de polling.",
      },
      {
        q: "O que é uma transação distribuída em NoSQL e quais os desafios?",
        o: [
          "Operação atômica que abrange múltiplos documentos/nós; desafio de consistência entre partições",
          "Transação SQL normal",
          "Backup simúltaneo de shards",
          "Transferência de dados entre bancos",
        ],
        c: 0,
        e: "NoSQL nativamente otimiza operações em documento único. Transações multi-documento foram adicionadas (MongoDB 4.0+, Firestore nativo). Desafios: performance inferior a transações single-doc, timeouts, na maioria é melhor modelar dados para evitar transações multi-doc.",
        x: "Firestore: await runTransaction(db, async (t) => { const doc = await t.get(ref); t.update(ref, { saldo: doc.data().saldo - 100 }); t.update(ref2, { saldo: doc2.data().saldo + 100 }); }); — atômico.",
      },
      {
        q: "O que é Change Data Capture (CDC) e como é usado com bancos NoSQL?",
        o: [
          "Captura mudanças em tempo real no banco para propagar a outros sistemas via stream de eventos",
          "Backup incremental agendado",
          "Compressão de dados alterados",
          "Versionamento de esquema",
        ],
        c: 0,
        e: "CDC captura INSERT/UPDATE/DELETE em tempo real e propaga como eventos. MongoDB: Change Streams (watch()). DynamoDB: DynamoDB Streams. Firestore: onSnapshot. Usos: sincronizar cache, alimentar Elasticsearch, event sourcing, materializar views, integrar microsserviços.",
        x: "MongoDB: db.collection('pedidos').watch().on('change', (change) => { if (change.operationType === 'insert') { elasticsearch.index(change.fullDocument); } }); — indexa automaticamente cada novo pedido no Elasticsearch.",
      },
      {
        q: "Quais critérios usar para escolher entre consistência forte e eventual em um banco NoSQL?",
        o: [
          "Forte para dados financeiros/críticos; eventual para feeds, contadores e dados que toleram atraso de propagação",
          "Sempre usar consistência forte",
          "Sempre usar eventual consistency",
          "Depende apenas do preço do serviço",
        ],
        c: 0,
        e: "Consistência forte: toda leitura retorna o último write (saldo bancário, estoque com unidade única, reservas). Eventual: leituras podem estar desatualizadas por ms/s (feeds sociais, contadores de likes, analytics). Trade-off: forte = maior latência e menor throughput; eventual = inverso.",
        x: "Saldo bancário: forte (ler R$100, sacar R$50, outro nó não pode ler R$100 ainda). Timeline Instagram: eventual (post aparece 2s depois para seguidores em outra região — aceitável). DynamoDB: ConsistentRead: true para forte.",
      },
    ],
  },

  // ── Clean Code e Boas Práticas ──
  "Clean Code e Boas Práticas": {
    Fácil: [
      {
        q: "Segundo os princípios de Clean Code, qual prática melhora a legibilidade ao nomear variáveis?",
        o: [
          "Usar nomes descritivos que revelam a intenção da variável",
          "Usar abreviações de uma letra para economizar espaço",
          "Usar prefixos com o tipo da variável (strNome, intIdade)",
          "Usar nomes genéricos como 'data' e 'info'",
        ],
        c: 0,
        e: "Nomes descritivos eliminam a necessidade de comentários e tornam o código auto-explicativo. O leitor entende imediatamente o que a variável representa sem precisar analisar o contexto.",
        x: "Ruim: const d = new Date(); const n = users.length; Bom: const createdAt = new Date(); const totalUsers = users.length;",
      },
      {
        q: "O que é o princípio de Responsabilidade Única (SRP) e por que é importante?",
        o: [
          "Uma classe/função deve ter apenas uma razão para mudar, ou seja, uma única responsabilidade",
          "Uma função só pode ter um parâmetro",
          "Um arquivo só pode ter uma classe",
          "Uma variável só pode ser usada uma vez",
        ],
        c: 0,
        e: "SRP (primeiro princípio do SOLID): cada módulo deve ter uma única razão para mudar. Se uma classe gerencia usuários E envia e-mails, mudanças na lógica de e-mail forçam alterações na classe de usuários. Separe em UserService e EmailService.",
        x: "Ruim: class UserService { createUser() {...} sendEmail() {...} generateReport() {...} } — 3 razões para mudar. Bom: UserService (crud), EmailService (emails), ReportService (relatórios).",
      },
      {
        q: "Por que funções devem ser pequenas e fazer apenas uma coisa, segundo Clean Code?",
        o: [
          "Facilita leitura, teste e manutenção; funções grandes são difíceis de entender e testar",
          "Funções grandes são mais rápidas",
          "O compilador exige funções pequenas",
          "Funções grandes ocupam mais memória",
        ],
        c: 0,
        e: "Funções pequenas (5-20 linhas) são mais fáceis de: ler (cabém na tela), entender (fazem uma coisa), testar (menos cenários) e reutilizar. Robert C. Martin (Clean Code) defende que funções devem fazer uma única coisa (one level of abstraction) e ter nomes descritivos.",
        x: "Ruim: processOrder() com 200 linhas que valida, calcula, cobra e envia e-mail. Bom: processOrder() chama validateOrder(), calculateTotal(), chargePayment(), sendConfirmation() — cada uma faz uma coisa.",
      },
      {
        q: "O que é DRY (Don't Repeat Yourself) e por que é importante?",
        o: [
          "Princípio de evitar duplicação de código; cada lógica deve existir em um único lugar",
          "Secar o código removendo espaços",
          "Não repetir testes",
          "Deletar código antigo",
        ],
        c: 0,
        e: "DRY: cada pedaço de conhecimento deve ter uma única representação no sistema. Código duplicado é bug duplo: se corrigir em um lugar e esquecer no outro, têm-se comportamentos inconsistentes. Extraia funções, constantes e módulos reutilizáveis.",
        x: "Ruim: validação de email duplicada em registerUser() e updateProfile(). Bom: função validateEmail(email) reutilizada em ambos. Correção de bug: altera em 1 lugar só.",
      },
      {
        q: "O que são nomes descritivos e por que são importantes no Clean Code?",
        o: [
          "Variáveis e funções com nomes que revelam intenção, eliminando a necessidade de comentários",
          "Nomes curtos de 1-2 caracteres",
          "Nomes em inglês obrigatoriamente",
          "Usar sempre abreviações",
        ],
        c: 0,
        e: "Nomes descritivos tornam o código auto-documentável. Ruim: d, temp, data, info (genéricos). Bom: daysUntilExpiration, activeUserCount, isPaymentOverdue. O nome deve responder: o que é, para que serve, por que existe.",
        x: "Ruim: const d = new Date(); const t = d.getTime(); Bom: const currentDate = new Date(); const timestampMs = currentDate.getTime(); O código se explica sozinho.",
      },
      {
        q: "O que significa 'Early Return' e como melhora a legibilidade do código?",
        o: [
          "Retornar cedo de uma função quando condições de guarda falham, evitando aninhamento profundo",
          "Retornar sempre null",
          "Encerrar o programa o mais rápido possível",
          "Usar return em todas as linhas",
        ],
        c: 0,
        e: "Early return usa cláusulas de guarda no início da função para tratar casos inválidos e retornar imediatamente. Evita múltiplos níveis de if/else aninhados (arrow anti-pattern). O fluxo principal fica no nível mais alto de indentação, facilitando leitura.",
        x: "Ruim: function process(user) { if (user) { if (user.active) { if (user.verified) { // lógica } } } }\nBom: function process(user) { if (!user) return; if (!user.active) return; if (!user.verified) return; // lógica no nível principal }",
      },
      {
        q: "Por que evitar números mágicos (magic numbers) no código?",
        o: [
          "Porque não transmitem significado; usar constantes nomeadas torna o código auto-explicativo",
          "Porque causam erros de compilação",
          "Porque ocupam mais memória",
          "Porque são mais lentos",
        ],
        c: 0,
        e: "Números mágicos são valores literais sem contexto (ex: if (status === 3)). Não revelam a intenção: o que é 3? Extrair para constantes nomeadas (const STATUS_APPROVED = 3) torna o código legível, facilita manutenção e evita erros de digitação.",
        x: "Ruim: if (days > 30) { charge(amount * 0.02); }\nBom: const OVERDUE_THRESHOLD_DAYS = 30; const LATE_FEE_RATE = 0.02; if (days > OVERDUE_THRESHOLD_DAYS) { charge(amount * LATE_FEE_RATE); }",
      },
    ],
    Médio: [
      {
        q: "O que é o princípio DRY (Don't Repeat Yourself) e qual problema ele resolve?",
        o: [
          "Eliminar duplicação de lógica, garantindo que cada conhecimento tenha uma única representação no código",
          "Nunca reutilizar código entre projetos",
          "Escrever código sem comentários",
          "Não repetir testes unitários",
        ],
        c: 0,
        e: "DRY determina que cada pedaço de conhecimento/lógica deve existir em um único lugar. Duplicação de código leva a inconsistências quando uma cópia é corrigida mas as outras não. A solução é extrair a lógica duplicada para uma função, módulo ou classe reutilizável.",
        x: "Ruim: cálculo de imposto duplicado em 5 controllers. Bom: função calculateTax(amount, rate) chamada pelos 5 controllers. Corrigir o cálculo exige alterar apenas 1 lugar.",
      },
      {
        q: "O que é o princípio KISS (Keep It Simple, Stupid) aplicado ao código?",
        o: [
          "Preferir soluções simples e diretas, evitando complexidade desnecessária",
          "Usar apenas uma linguagem de programação",
          "Não usar frameworks",
          "Escrever o mínimo de código possível",
        ],
        c: 0,
        e: "KISS defende que a simplicidade deve ser um objetivo central do design. Código simples é mais fácil de entender, manter e debugar. Over-engineering (adicionar abstrações prematuramente, usar patterns complexos para problemas simples) viola KISS.",
        x: "KISS: usar if/else para 3 casos. Over-engineering: criar Strategy Pattern com factory e DI container para os mesmos 3 casos. Se não vai crescer, KISS ganha.",
      },
      {
        q: "O que é refactoring e quando deve ser feito?",
        o: [
          "Reestruturar código existente sem alterar seu comportamento externo, melhorando qualidade interna",
          "Reescrever o sistema do zero",
          "Adicionar novas features",
          "Corrigir bugs",
        ],
        c: 0,
        e: "Refactoring melhora a estrutura interna (legibilidade, manutenção, performance) sem mudar o comportamento externo. Deve ser feito continuamente (boy scout rule: deixe o código melhor do que encontrou), antes de adicionar features, e quando code smells são identificados.",
        x: "Code smell: função com 200 linhas. Refactoring: extrair em 5 funções menores. Code smell: duplicação. Refactoring: extrair função reutilizável. Testes passam antes e depois → comportamento preservado.",
      },
      {
        q: "O que é Technical Debt (dívida técnica) e como gerenciá-la?",
        o: [
          "Custo futuro causado por atalhos ou decisões de design subótimas; gerenciar com refactoring contínuo",
          "Dívida financeira do projeto",
          "Bug no código de produção",
          "Código sem comentários",
        ],
        c: 0,
        e: "Dívida técnica: atalhos que aceleram agora mas custam depois (código duplicado, sem testes, arquitetura frágil). Como dívida financeira, acumula juros (cada feature fica mais cara). Gerenciar: reservar % do sprint para refactoring, boy scout rule, tech debt backlog.",
        x: "Sprint 1: gambiarra rápida para entregar no prazo (1h). Sprint 5: bug causado pela gambiarra leva 8h para resolver + 4h de regressão. Juros da dívida: 12h vs 1h original.",
      },
      {
        q: "O que é code review e quais são as melhores práticas?",
        o: [
          "Revisão de código por pares antes do merge; buscar clareza, correção e mantenibilidade",
          "Teste automático do código",
          "Reviso do gerente de projeto",
          "Análise de performance",
        ],
        c: 0,
        e: "Code review detecta bugs antes de produzir, compartilha conhecimento na equipe, mantém padrões. Boas práticas: PRs pequenas (<400 linhas), comentários construtivos, automatizar lint/formato, focar em lógica (não estilo), responder rápido (<24h).",
        x: "PR com 50 linhas: revisada em 15 min, 2 sugestões, merge no mesmo dia. PR com 2000 linhas: 3 dias para revisar, 20 comentários, conflitos de merge. Menor = melhor.",
      },
      {
        q: "O que são os princípios SOLID e por que são importantes no design orientado a objetos?",
        o: [
          "Cinco princípios de design que reduzem acoplamento e facilitam manutenção: SRP, OCP, LSP, ISP, DIP",
          "Framework de testes",
          "Linguagem de programação",
          "Metodologia ágil",
        ],
        c: 0,
        e: "SOLID: S (Single Responsibility), O (Open/Closed), L (Liskov Substitution), I (Interface Segregation), D (Dependency Inversion). Juntos, criam código com baixo acoplamento, alta coesão, fácil de testar, estender e manter. Fundamentais para design orientado a objetos robusto.",
        x: "Sem SOLID: classe UserService com 2000 linhas que faz CRUD, envia email, gera relatório, valida pagamento. Com SOLID: UserService (CRUD), EmailService, ReportService, PaymentValidator — cada um com responsabilidade única (SRP).",
      },
      {
        q: "O que é o princípio YAGNI (You Aren't Gonna Need It)?",
        o: [
          "Não implementar funcionalidades até que sejam realmente necessárias, evitando over-engineering",
          "Nunca usar bibliotecas externas",
          "Não escrever documentação",
          "Sempre implementar o máximo possível",
        ],
        c: 0,
        e: "YAGNI: não adicione funcionalidades especulativas. Código não usado é custo sem valor: precisa ser mantido, testado e compreendido. Complementar ao KISS. Origem: Extreme Programming (XP). 'Do the simplest thing that could possibly work.'",
        x: "YAGNI violado: criar sistema de plugins extensível para app de TODO list que nunca terá plugins. YAGNI respeitado: implementar apenas as features no backlog atual. Se futuramente precisar de plugins, refatore na hora.",
      },
    ],
    Difícil: [
      {
        q: "No princípio SOLID, o que estabelece a letra 'D' (Dependency Inversion Principle) e como ele impacta a testabilidade do código?",
        o: [
          "Módulos de alto nível devem depender de abstrações, não de implementações concretas, facilitando mocks em testes",
          "Dependências devem ser instaladas em ordem inversa",
          "Código deve evitar qualquer dependência externa",
          "Módulos devem depender sempre de implementações concretas para performance",
        ],
        c: 0,
        e: "O Dependency Inversion Principle (DIP) determina que módulos de alto nível não devem depender de módulos de baixo nível — ambos devem depender de abstrações (interfaces). Isso permite substituir implementações concretas por mocks/stubs nos testes e trocar implementações sem modificar o código consumidor.",
        x: "class OrderService { constructor(private repo: IOrderRepository) {} } — depende da interface, não do PostgresOrderRepository concreto. No teste: new OrderService(new MockOrderRepository()).",
      },
      {
        q: "O que são Code Smells e quais são os mais comuns?",
        o: [
          "Indicadores de problemas no código: funções longas, duplicação, parâmetros excessivos, classes grandes",
          "Erros de compilação",
          "Vulnerabilidades de segurança",
          "Problemas de performance",
        ],
        c: 0,
        e: "Code smells são indicadores de design problemático (não são bugs). Comuns: Long Method (função longa), Duplicated Code, Large Class (classe com muitas responsabilidades), Feature Envy (método usa mais dados de outra classe), Primitive Obsession (usar primitivos em vez de Value Objects).",
        x: "Feature Envy: calculateDiscount(order) acessa order.customer.memberSince, order.customer.totalPurchases, order.customer.tier — deveria estar na classe Customer: customer.calculateDiscount().",
      },
      {
        q: "O que é o princípio Open/Closed (OCP) do SOLID e como implementá-lo?",
        o: [
          "Entidades devem estar abertas para extensão mas fechadas para modificação, usando abstrações",
          "Código deve ser open-source",
          "Arquivos devem ficar abertos durante o deploy",
          "Funções devem aceitar qualquer tipo de parâmetro",
        ],
        c: 0,
        e: "OCP: você deve poder adicionar novos comportamentos sem modificar código existente. Implementação: usar interfaces, herança, Strategy Pattern ou composição. Novo caso = nova classe que implementa a interface, sem alterar nenhuma classe existente.",
        x: "Antes (viola OCP): if (shape === 'circle') calcCircle(); else if (shape === 'square') calcSquare(); — adicionar triângulo exige modificar a função. Depois: interface Shape { area(): number } + classes Circle, Square, Triangle — adicionar Triangle não modifica nada.",
      },
      {
        q: "O que é o princípio KISS (Keep It Simple, Stupid) no desenvolvimento?",
        o: [
          "Manter soluções simples e diretas; evitar complexidade desnecessária",
          "Usar sempre a tecnologia mais avançada",
          "Minimizar número de arquivos",
          "Usar abreviações em todo o código",
        ],
        c: 0,
        e: "KISS: a simplicidade deve ser um objetivo-chave. Soluções simples são mais fáceis de entender, manter e debugar. Evite over-engineering: não use design patterns complexos para problemas simples. YAGNI (You Aren't Gonna Need It) é complementar.",
        x: "Over-engineering: criar AbstractFactoryStrategyObserver para uma feature de TODO list. KISS: uma função addTodo(text) e uma lista. Complexidade só quando a necessidade justificar.",
      },
      {
        q: "O que é o princípio de Separação de Concerns (Separation of Concerns)?",
        o: [
          "Dividir o sistema em partes distintas, cada uma tratando uma preocupação específica",
          "Separar código frontend e backend em repos diferentes",
          "Usar apenas um padrão de projeto",
          "Manter todo código em um arquivo",
        ],
        c: 0,
        e: "Cada módulo/classe/função deve tratar de uma única preocupação. Separação reduz acoplamento e aumenta coesão. Exemplos: MVC, camadas (UI, lógica, dados), módulos por domínio. Misturar concerns cria código difícil de manter e testar.",
        x: "Violação: componente React que faz fetch, validação, render e logging tudo junto. Separado: custom hook useFetchUsers (dados), validateUser util (lógica), UserList component (UI).",
      },
      {
        q: "O que é complexidade ciclomática e como ela indica qualidade do código?",
        o: [
          "Métrica que conta caminhos independentes de execução; alta complexidade indica código difícil de testar e manter",
          "Velocidade de execução do código",
          "Quantidade de linhas por arquivo",
          "Número de dependências externas",
        ],
        c: 0,
        e: "Complexidade ciclomática (McCabe) = número de caminhos independentes no fluxo de controle. Cada if, for, while, case, && e || incrementa. CC=1-5: simples. CC=6-10: moderado. CC>10: arriscado (muitos branches = difícil testar todos). Ferramentas: ESLint complexity rule, SonarQube.",
        x: "function check(a,b,c) { if (a) { if (b) return 1; else return 2; } if (c) return 3; return 4; } — CC=4 (4 caminhos). Para testar 100%: 4 testes. CC=20 → 20 testes mínimos, provavelmente precisa refatorar.",
      },
      {
        q: "O que é o princípio de Liskov Substitution (LSP) do SOLID?",
        o: [
          "Subtipos devem ser substituíveis por seus tipos base sem alterar a correção do programa",
          "Listar todas as dependências no início do arquivo",
          "Substituir classes por funções",
          "Usar apenas herança, nunca composição",
        ],
        c: 0,
        e: "LSP: se S é subtipo de T, objetos de tipo T podem ser substituídos por objetos de tipo S sem quebrar o programa. Violação clássica: Square extends Rectangle — setWidth() em Square altera height também, quebrando expectativas de Rectangle. Solução: modelar corretamente a hierarquia.",
        x: "Violação: class Bird { fly() {} } class Penguin extends Bird { fly() { throw Error('Não voa!'); } } — código que chama bird.fly() quebra com Penguin. Solução: interface FlyingBird e interface SwimmingBird separadas.",
      },
    ],
  },

  // ── Design Patterns ──
  "Design Patterns": {
    Fácil: [
      {
        q: "Qual Design Pattern garante que uma classe tenha apenas uma única instância em toda a aplicação?",
        o: ["Singleton", "Factory", "Observer", "Strategy"],
        c: 0,
        e: "O Singleton restringe a instanciação de uma classe a um único objeto. Ele fornece um ponto de acesso global à instância através de um método estático, garantindo que todas as partes do código usem o mesmo objeto.",
        x: "class Database { static instance; static getInstance() { if (!this.instance) this.instance = new Database(); return this.instance; } } — toda chamada a Database.getInstance() retorna o mesmo objeto.",
      },
      {
        q: "Qual Design Pattern cria objetos sem expor a lógica de criação, delegando a decisão para subclasses ou métodos?",
        o: ["Factory", "Singleton", "Observer", "Decorator"],
        c: 0,
        e: "O Factory Method define uma interface para criar objetos, mas deixa subclasses decidirem qual classe instanciar. Abstract Factory cria famílias de objetos relacionados. Ambos encapsulam a lógica de criação, desacoplando o código consumidor das classes concretas.",
        x: "function createPayment(type) { if (type === 'pix') return new PixPayment(); if (type === 'card') return new CardPayment(); } — consumidor usa createPayment('pix') sem conhecer a classe concreta.",
      },
      {
        q: "Qual Design Pattern permite notificar múltiplos objetos quando o estado de outro objeto muda?",
        o: ["Observer", "Singleton", "Factory", "Adapter"],
        c: 0,
        e: "O Observer define uma relação um-para-muitos: quando o 'subject' muda de estado, todos os 'observers' inscritos são notificados automaticamente. Muito usado em eventos de UI, sistemas reativos e padrão pub/sub.",
        x: "EventEmitter do Node.js é Observer: emitter.on('order-created', sendEmail); emitter.on('order-created', updateInventory); emitter.emit('order-created', order); — ambos handlers são notificados.",
      },
      {
        q: "O que é o padrão Singleton e quando utilizá-lo?",
        o: [
          "Garante que uma classe tenha apenas uma instância e fornece um ponto de acesso global",
          "Cria múltiplas instâncias simultaneamente",
          "Padrão para criar interfaces",
          "Padrão para herança múltipla",
        ],
        c: 0,
        e: "Singleton: a classe controla sua própria instanciação, garantindo que exista apenas uma. Usado para: conexão de banco de dados, logger, configuração global. Cuidado: pode dificultar testes (estado global) e violar SRP.",
        x: "class Database { static instance; static getInstance() { if (!this.instance) this.instance = new Database(); return this.instance; } } — Database.getInstance() sempre retorna a mesma conexão.",
      },
      {
        q: "O que é o padrão Factory Method?",
        o: [
          "Define uma interface para criar objetos, mas delega a decisão de qual classe instanciar para subclasses",
          "Método que destrói objetos",
          "Padrão para clonar objetos",
          "Método estático de configuração",
        ],
        c: 0,
        e: "Factory Method encapsula a criação de objetos. O código cliente chama o factory sem saber qual classe concreta será instanciada. Vantagem: adicionar novos tipos sem modificar o código existente (Open/Closed Principle).",
        x: "function createNotification(type) { if (type === 'email') return new EmailNotification(); if (type === 'sms') return new SMSNotification(); } — o cliente não precisa conhecer as classes concretas.",
      },
      {
        q: "O que é o padrão Observer (Observador) e onde é mais utilizado?",
        o: [
          "Padrão que notifica automaticamente múltiplos objetos quando o estado de um objeto muda",
          "Padrão para observar arquivos no disco",
          "Ferramenta de monitoramento",
          "Plugin de depuração",
        ],
        c: 0,
        e: "Observer define relação 1:N. O subject mantém lista de observers e os notifica quando muda. Desacopla emissor de receptores. Usado em: eventos DOM, EventEmitter do Node.js, RxJS Observables, React useState (re-render), Redux subscribe.",
        x: "button.addEventListener('click', handleClick); — o botão (subject) notifica handlers (observers). Não precisa saber quantos ou quem são os listeners.",
      },
      {
        q: "O que é o padrão Adapter e qual problema ele resolve?",
        o: [
          "Converte a interface de uma classe existente para outra interface esperada, permitindo integração",
          "Cria novos objetos",
          "Adiciona funcionalidades a objetos",
          "Gerencia ciclo de vida de objetos",
        ],
        c: 0,
        e: "Adapter é um wrapper que traduz chamadas de uma interface para outra. Útil quando precisa usar uma biblioteca cujos métodos têm nomes e parâmetros diferentes do que seu código espera. Análogo: adaptador de tomada que converte plug americano para padrão brasileiro.",
        x: "Seu código usa interface Logger { info(msg), error(msg) }. Lib usa Winston { log('info', msg) }. WinstonAdapter implements Logger { info(msg) { winston.log('info', msg); } } — integração sem alterar seu código.",
      },
    ],
    Médio: [
      {
        q: "Qual Design Pattern permite definir uma família de algoritmos intercambiáveis, encapsulando cada um em uma classe separada?",
        o: ["Strategy", "Singleton", "Adapter", "Decorator"],
        c: 0,
        e: "O Strategy permite selecionar um algoritmo em tempo de execução. Cada algoritmo é encapsulado em uma classe que implementa uma interface comum. O contexto delega a execução à estratégia selecionada, facilitando adição de novos algoritmos sem modificar código existente.",
        x: "interface PaymentStrategy { pay(amount: number): void } → classes CreditCardPayment, PixPayment, BoletoPayment. Checkout usa strategy.pay(100) sem conhecer a implementação.",
      },
      {
        q: "Qual Design Pattern adiciona funcionalidades a um objeto dinamicamente sem alterar sua classe?",
        o: ["Decorator", "Singleton", "Factory", "Observer"],
        c: 0,
        e: "O Decorator envolve (wraps) um objeto com outro que implementa a mesma interface, adicionando comportamento antes/depois de delegar ao objeto original. Permite combinar funcionalidades em tempo de execução sem explodir o número de subclasses.",
        x: "const logger = withLogging(baseService); const cached = withCache(logger); — baseService ganha logging e cache sem modificação. Em Java: new BufferedReader(new FileReader(file)) — BufferedReader decora FileReader.",
      },
      {
        q: "Qual Design Pattern converte a interface de uma classe em outra interface esperada pelo cliente?",
        o: ["Adapter", "Facade", "Proxy", "Bridge"],
        c: 0,
        e: "O Adapter permite que classes com interfaces incompatíveis trabalhem juntas. Ele cria um wrapper que traduz as chamadas da interface esperada para a interface real do objeto adaptado. Muito útil ao integrar bibliotecas de terceiros ou sistemas legados.",
        x: "Seu código espera interface Payment { charge(amount) }. Lib externa tem StripeSDK { createCharge(cents) }. StripeAdapter implements Payment { charge(amount) { stripe.createCharge(amount * 100); } } — adapta dólares para centavos.",
      },
      {
        q: "O que é o padrão Decorator e como ele difere de herança?",
        o: [
          "Adiciona responsabilidades a objetos dinamicamente via composição, sem alterar a classe original",
          "É igual a herança",
          "Substitui métodos existentes",
          "Remove funcionalidades de objetos",
        ],
        c: 0,
        e: "Decorator envolve (wraps) um objeto adicionando comportamento. Diferente de herança: é dinâmico (runtime), pode combinar múltiplos decorators, e não cria hierarquia profunda. Herança é estática (compile-time) e pode causar explosão de subclasses.",
        x: "const logger = new LoggingDecorator(new AuthDecorator(new HttpClient())); — cada chamada passa por logging → auth → http. Composição dinâmica sem criar ClasseLogAuthHttp.",
      },
      {
        q: "O que é o padrão Builder e quando é mais adequado que um construtor com muitos parâmetros?",
        o: [
          "Constrói objetos complexos passo a passo com uma API fluente, evitando construtores com dezenas de parâmetros",
          "Destrói objetos complexos",
          "Constrói apenas strings",
          "É alternativa ao Factory apenas",
        ],
        c: 0,
        e: "Builder separa a construção de um objeto complexo da sua representação. Útil quando: muitos parâmetros opcionais, construção em etapas, ou diferentes representações do mesmo objeto. API fluente: encadear métodos que retornam this.",
        x: "const query = new QueryBuilder().select('name', 'email').from('users').where('age > 18').orderBy('name').limit(10).build(); — legível e flexível vs new Query('name,email', 'users', 'age>18', 'name', 10).",
      },
      {
        q: "O que é o padrão Proxy e quais suas variações mais comuns?",
        o: [
          "Objeto substituto que controla o acesso ao objeto real; variações: virtual, de proteção, de log e remoto",
          "Servidor intermediário de rede",
          "Cache distribuído",
          "Padrão exclusivo para redes",
        ],
        c: 0,
        e: "Proxy cria um substituto para outro objeto, controlando acesso. Virtual Proxy: lazy loading (carrega objeto pesado só quando necessário). Protection Proxy: controla acesso por permissões. Logging Proxy: registra chamadas. Remote Proxy: representa objeto em outro servidor.",
        x: "Proxy para lazy loading de imagem: class ImageProxy { getImage() { if (!this.image) this.image = loadFromDisk(); return this.image; } } — a imagem pesada só é carregada na primeira chamada, não na construção.",
      },
      {
        q: "O que é o padrão Template Method e como difere do Strategy?",
        o: [
          "Define o esqueleto de um algoritmo na superclasse, delegando passos específicos a subclasses via herança",
          "Permite trocar algoritmos em runtime via composição",
          "Cria objetos dinamicamente",
          "É igual ao Strategy",
        ],
        c: 0,
        e: "Template Method usa herança: superclasse define o algoritmo com 'hooks' que subclasses implementam. Strategy usa composição: algoritmo inteiro é substituído em runtime. Template Method: estrutura fixa, passos variáveis. Strategy: algoritmo inteiramente intercambiável.",
        x: "Template Method: abstract class DataParser { parse(file) { open(file); extract(); validate(); close(); } abstract extract(); } — CSVParser e JSONParser implementam apenas extract(). A sequência open→extract→validate→close é fixa.",
      },
    ],
    Difícil: [
      {
        q: "Como o padrão Event Sourcing difere do CRUD tradicional na persistência de dados e quais são seus trade-offs?",
        o: [
          "Armazena eventos imutáveis em vez de estados atuais; ganha auditoria completa mas aumenta complexidade de queries",
          "Armazena o estado final; ganha simplicidade mas perde histórico",
          "É um pattern de UI, não de persistência",
          "Usa bancos de grafos para armazenar estados",
        ],
        c: 0,
        e: "No Event Sourcing, cada mudança é registrada como um evento imutável (ex.: 'PedidoCriado', 'ItemAdicionado', 'PagamentoConfirmado'). O estado atual é reconstituído reproduzindo os eventos. Vantagens: histórico completo, auditoria, temporal queries. Trade-offs: complexidade de leitura (precisa de projeções), volume de dados, eventual consistency.",
        x: "CRUD: UPDATE accounts SET balance=900 WHERE id=1. Event Sourcing: append { type: 'Debited', amount: 100, accountId: 1 }. O saldo atual é calculado somando todos os eventos da conta.",
      },
      {
        q: "Qual é a diferença entre o padrão Facade e o padrão Adapter?",
        o: [
          "Facade simplifica uma interface complexa; Adapter converte uma interface para outra esperada",
          "São idênticos",
          "Adapter simplifica e Facade converte",
          "Facade é para criação e Adapter para comportamento",
        ],
        c: 0,
        e: "Facade fornece uma interface simplificada para um subsistema complexo (múltiplas classes). Adapter converte a interface de uma classe existente para a interface que o cliente espera. Facade reduz complexidade; Adapter resolve incompatibilidade.",
        x: "Facade: OrderFacade.placeOrder(items) internamente chama InventoryService, PaymentService, ShippingService, NotificationService. Adapter: StripeAdapter converte interface Payment para interface Stripe específica.",
      },
      {
        q: "O que é o padrão Repository e como ele se relaciona com Domain-Driven Design?",
        o: [
          "Abstração que encapsula a lógica de acesso a dados, fazendo o domínio ignorar detalhes de persistência",
          "Repositório Git",
          "Cache de armazenamento",
          "Padrão de UI",
        ],
        c: 0,
        e: "No DDD, Repository é a fronteira entre domínio e infraestrutura. Define uma interface (port) com métodos como findById(), save(), delete() que o domínio usa sem saber se os dados vêm de PostgreSQL, MongoDB, API ou memória. Implementação concreta fica na camada de infraestrutura.",
        x: "interface OrderRepository { findById(id: OrderId): Order; save(order: Order): void; } — Domínio depende dessa interface. PostgresOrderRepository implements OrderRepository na camada de infra.",
      },
      {
        q: "O que é o padrão Mediator e qual problema ele resolve?",
        o: [
          "Centraliza a comunicação entre objetos, reduzindo acoplamento direto entre componentes",
          "Cria conexão direta entre todos os objetos",
          "Padrão de persistência de dados",
          "Padrão para criação de objetos",
        ],
        c: 0,
        e: "Mediator encapsula a interação entre um conjunto de objetos em um único lugar. Em vez de A falar com B, C, D diretamente (N² conexões), todos falam com o Mediator (N conexões). Exemplos: chat room, controlador de tráfego aéreo, Redux store.",
        x: "Sem Mediator: ComponentA chama ComponentB.update() e ComponentC.refresh() diretamente. Com Mediator: ComponentA emite evento para Mediator, que notifica B e C. Adicionar ComponentD não muda A.",
      },
      {
        q: "O que é o padrão Chain of Responsibility e como ele funciona?",
        o: [
          "Encadeia handlers onde cada um decide se processa a requisição ou passa para o próximo",
          "Uma única classe processa tudo",
          "Cadeia de herança entre classes",
          "Padrão para paralelizar processamento",
        ],
        c: 0,
        e: "Chain of Responsibility: requisição passa por uma cadeia de handlers. Cada handler decide: processar, modificar e passar, ou rejeitar. Desacopla o emissor dos receptores. Exemplos: middlewares Express, pipeline de validação, filtros de servlet.",
        x: "Express middlewares: app.use(cors()).use(authMiddleware).use(rateLimiter).use(router) — cada middleware decide se continua (next()) ou interrompe (res.status(401)). Adicionar/remover middleware não afeta outros.",
      },
      {
        q: "O que é o padrão Visitor e quando utilizá-lo?",
        o: [
          "Permite adicionar operações a uma hierarquia de classes sem modificá-las, usando double dispatch",
          "Padrão para rastrear visitantes de um site",
          "Contador de acessos a métodos",
          "Padrão de autenticação",
        ],
        c: 0,
        e: "Visitor separa algoritmos das estruturas sobre as quais operam. Cada elemento aceita um visitor que executa a operação específica. Double dispatch: elemento chama visitor.visit(this), visitor tem overload por tipo. Útil para AST (Abstract Syntax Tree), serialização, relatórios.",
        x: "AST de compilador: nodes IfNode, ForNode, AssignNode. PrintVisitor { visitIf(node), visitFor(node) }. OptimizeVisitor { visitIf(node), visitFor(node) }. Adicionar nova operação (novo visitor) sem alterar os nodes.",
      },
      {
        q: "O que é o padrão State e como simplifica lógica condicional complexa?",
        o: [
          "Encapsula cada estado em uma classe separada, delegando comportamento ao objeto de estado atual",
          "Gerenciador de estado global como Redux",
          "Padrão para banco de dados temporal",
          "Variável que armazena configuração",
        ],
        c: 0,
        e: "State: em vez de if/switch gigante verificando estado, cada estado é uma classe com seu próprio comportamento. O contexto delega ao estado atual. Transições: estado atual define para qual estado ir. Elimina condicionais complexas e respeita Open/Closed Principle.",
        x: "Pedido com estados: Rascunho, Pendente, Pago, Enviado, Entregue. Cada classe implementa: confirmar(), cancelar(), enviar(). DraftState.confirmar() → muda para PendingState. PaidState.cancelar() → inicia reembolso. Sem ifs, cada estado sabe seu comportamento.",
      },
    ],
  },

  // ── Git e Versionamento ──
  "Git e Versionamento": {
    Fácil: [
      {
        q: "Qual comando Git é usado para criar uma cópia local de um repositório remoto?",
        o: ["git clone", "git init", "git pull", "git fork"],
        c: 0,
        e: "O 'git clone' cria uma cópia completa de um repositório remoto na máquina local, incluindo todo o histórico de commits, branches e tags. Ele também configura automaticamente o remote 'origin' apontando para o repositório de origem.",
        x: "git clone https://github.com/user/repo.git — cria a pasta 'repo' localmente com todo o histórico e configura origin automaticamente.",
      },
      {
        q: "Qual comando Git cria uma nova branch e muda para ela ao mesmo tempo?",
        o: [
          "git checkout -b ou git switch -c",
          "git branch",
          "git merge",
          "git stash",
        ],
        c: 0,
        e: "'git checkout -b nova-branch' (ou 'git switch -c nova-branch' na sintaxe moderna) cria uma nova branch a partir do commit atual e muda para ela em um único comando. É equivalente a: git branch nova-branch && git checkout nova-branch.",
        x: "git switch -c feature/login — cria a branch 'feature/login' a partir do commit atual e muda para ela. 'git branch' lista todas as branches; 'git branch -d feature/login' deleta após merge.",
      },
      {
        q: "O que faz o comando 'git add' e qual é a diferença entre working directory, staging area e repository?",
        o: [
          "git add move alterações para a staging area; os 3 estágios são: arquivos modificados, prontos para commit e commitados",
          "git add faz o commit diretamente",
          "Só existem 2 estágios",
          "git add envia para o servidor remoto",
        ],
        c: 0,
        e: "Working Directory: arquivos modificados localmente. Staging Area (index): alterações marcadas com 'git add', prontas para commit. Repository: histórico de commits permanente após 'git commit'. Esse fluxo de 3 estágios permite escolher quais mudanças incluir em cada commit.",
        x: "Editou a.js e b.js. git add a.js → apenas a.js vai para staging. git commit -m 'fix a' → commita só a.js. b.js continua no working directory, não commitado.",
      },
      {
        q: "O que é um commit no Git e como escrever boas mensagens de commit?",
        o: [
          "Snapshot do estado dos arquivos no staging; mensagem deve ser imperativa, curta e descritiva",
          "Upload dos arquivos para o servidor",
          "Backup automático do projeto",
          "Sincronização com repositório remoto",
        ],
        c: 0,
        e: "Commit é um snapshot imutável do estado dos arquivos no staging area. Cada commit tem um hash SHA-1 único, referência ao pai, autor e mensagem. Boas mensagens: imperativo ('Adiciona feature X'), curtas (50 chars), com corpo explicando o porquê se necessário.",
        x: "Ruim: 'fix', 'update', 'changes'. Bom: 'fix: corrige cálculo de frete para pedidos internacionais'. Formato: tipo: descrição curta\n\nCorpo opcional com contexto.",
      },
      {
        q: "O que é o .gitignore e para que serve?",
        o: [
          "Arquivo que lista padrões de arquivos/pastas que o Git deve ignorar e não rastrear",
          "Arquivo de configuração do GitHub",
          "Lista de branches protegidas",
          "Log de erros do Git",
        ],
        c: 0,
        e: ".gitignore define quais arquivos/pastas o Git não deve rastrear. Comum: node_modules/, .env, dist/, *.log, .DS_Store. Adicionado na raiz do projeto. Já rastreados antes de adicionar ao .gitignore continuam rastreados (precisa git rm --cached).",
        x: "# .gitignore\nnode_modules/\n.env\ndist/\n*.log\n.DS_Store\n\nSe node_modules já foi commitado: git rm -r --cached node_modules && git commit -m 'remove node_modules do tracking'.",
      },
      {
        q: "O que mostra o comando git status?",
        o: [
          "Estado atual do working directory e staging area: arquivos modificados, adicionados e não rastreados",
          "Histórico de commits",
          "Lista de branches remotas",
          "Configurações do repositório",
        ],
        c: 0,
        e: "git status mostra: branch atual, relação com remote (ahead/behind), arquivos modificados (vermelho = unstaged, verde = staged), arquivos não rastreados (untracked). É o comando mais usado para saber o estado do repo antes de add/commit.",
        x: "git status\nOn branch feature/login\nChanges to be committed: (verde)\n  modified: auth.ts\nChanges not staged: (vermelho)\n  modified: utils.ts\nUntracked files: (vermelho)\n  new-file.ts",
      },
      {
        q: "O que é o comando git log e como visualizar o histórico?",
        o: [
          "Mostra o histórico de commits com hash, autor, data e mensagem",
          "Lista arquivos modificados",
          "Mostra branches remotas",
          "Exibe conflitos de merge",
        ],
        c: 0,
        e: "git log mostra commits em ordem cronológica reversa. Opções úteis: --oneline (resumido), --graph (visualizar branches), --author='Ana' (filtrar por autor), -n 5 (limitar a 5), --since='2024-01-01'. git log --all --oneline --graph é a visão mais completa.",
        x: "git log --oneline --graph --all\n* abc1234 (HEAD -> feature) Adiciona login\n| * def5678 (main) Fix header\n|/\n* 789abcd Initial commit — visualização de branches no terminal.",
      },
    ],
    Médio: [
      {
        q: "Qual é a diferença entre 'git merge' e 'git rebase' ao integrar alterações de uma branch?",
        o: [
          "Merge cria um commit de merge preservando o histórico; rebase reaplica commits sobre a branch alvo, linearizando o histórico",
          "Merge apaga a branch e rebase não",
          "Rebase é mais seguro que merge",
          "Não há diferença no resultado final",
        ],
        c: 0,
        e: "Git merge cria um commit de merge (com dois pais), preservando a ramificação no histórico. Git rebase move os commits da branch para o topo da branch alvo, criando um histórico linear. Rebase reescreve hashes dos commits, então não deve ser usado em branches públicas compartilhadas.",
        x: "git checkout feature && git rebase main — reaplica os commits da feature sobre o último commit de main, como se a feature tivesse sido criada a partir do estado atual de main.",
      },
      {
        q: "O que é um conflito de merge no Git e como resolvê-lo?",
        o: [
          "Ocorre quando mesmas linhas foram alteradas em branches diferentes; deve ser resolvido manualmente editando os arquivos",
          "Erro irrecuperável que deleta o código",
          "Bug causado pelo GitHub",
          "Acontece apenas com git rebase",
        ],
        c: 0,
        e: "Conflito ocorre quando duas branches alteram as mesmas linhas de um arquivo. O Git marca com <<<<<<< HEAD (sua versão), ======= e >>>>>>> branch (a outra versão). Você edita manualmente escolhendo o código correto, remove os marcadores e faz git add + git commit.",
        x: "<<<<<<< HEAD\nconst color = 'blue';\n=======\nconst color = 'red';\n>>>>>>> feature\n\nVocê decide: const color = 'blue'; (remove os marcadores). git add arquivo.js && git commit.",
      },
      {
        q: "O que é git stash e quando usá-lo?",
        o: [
          "Salva alterações não commitadas temporariamente para limpar o working directory",
          "Deleta mudanças não salvas",
          "Cria um backup remoto",
          "Faz merge automático",
        ],
        c: 0,
        e: "git stash salva mudanças não commitadas em uma pilha temporária e limpa o working directory. Útil quando precisa trocar de branch mas não quer commitar trabalho incompleto. git stash pop restaura as alterações.",
        x: "Trabalhando na feature, surge bug urgente: git stash → git switch main → corrige bug → git commit → git switch feature → git stash pop → continua trabalhando com as mudanças restauradas.",
      },
      {
        q: "O que é uma Pull Request (PR) / Merge Request (MR) e qual seu papel no fluxo de trabalho?",
        o: [
          "Solicitação para integrar uma branch na branch principal, permitindo revisão de código antes do merge",
          "Comando do Git para baixar código",
          "Requisição HTTP feita pelo Git",
          "Ferramenta de deploy automático",
        ],
        c: 0,
        e: "PR/MR é um recurso de plataformas (GitHub/GitLab/Bitbucket) que propõe integrar mudanças de uma branch em outra. Permite: code review, discussão, CI checks automáticos, aprovações antes do merge. Boas práticas: PRs pequenas, descrição clara, linked issues.",
        x: "Fluxo: git push origin feature/login → Abre PR no GitHub → Reviewer comenta sugestões → Autor corrige → CI passa → Reviewer aprova → Merge → Branch deletada.",
      },
      {
        q: "Qual a diferença entre git fetch e git pull?",
        o: [
          "fetch baixa referências remotas sem alterar o working directory; pull faz fetch + merge automaticamente",
          "São idênticos",
          "fetch envia e pull recebe",
          "pull é mais seguro",
        ],
        c: 0,
        e: "git fetch: baixa commits/branches do remoto para referências locais (origin/main) sem modificar seus arquivos. git pull: faz git fetch + git merge automaticamente. fetch é mais seguro pois permite inspecionar mudanças antes de integrar.",
        x: "git fetch origin → atualiza origin/main localmente. git log main..origin/main → vê o que tem de novo. git merge origin/main → integra. Vs git pull origin main → faz tudo de uma vez (pode causar conflito inesperado).",
      },
      {
        q: "O que é Git Flow e como ele organiza branches no desenvolvimento?",
        o: [
          "Modelo de branching com main, develop, feature/, release/ e hotfix/ para organizar o ciclo de desenvolvimento",
          "Ferramenta de CI/CD",
          "Alternativa ao Git",
          "Plugin do VS Code",
        ],
        c: 0,
        e: "Git Flow: main (produção estável), develop (integração), feature/* (novas features, saem de develop), release/* (preparação de versão), hotfix/* (correções urgentes em produção). Alternativas mais simples: GitHub Flow (main + feature branches) e Trunk-Based Development.",
        x: "Feature: git flow feature start login → trabalha → git flow feature finish login (merge em develop). Release: git flow release start 1.0.0 → testes → finish (merge em main + develop + tag).",
      },
      {
        q: "O que é squash merge e quando utilizá-lo?",
        o: [
          "Combina todos os commits de uma branch em um único commit ao fazer merge, simplificando o histórico",
          "Merge que resolve conflitos automaticamente",
          "Merge que deleta a branch de origem",
          "Merge parcial de alguns commits",
        ],
        c: 0,
        e: "Squash merge: git merge --squash feature → combina todas as mudanças da branch em um único commit na branch destino. Histórico fica limpo (1 commit por PR em vez de 20 commits WIP). Trade-off: perde o histórico granular dos commits individuais.",
        x: "Branch feature com 15 commits: 'WIP', 'fix typo', 'refactor', 'WIP 2'... Squash merge: um único commit 'feat: implementa sistema de login com OAuth' em main. Histórico de main fica limpo e legível.",
      },
    ],
    Difícil: [
      {
        q: "O que é o 'git reflog' e em qual cenário ele é essencial para recuperação de dados?",
        o: [
          "Registra todas as movimentações do HEAD localmente, permitindo recuperar commits após reset --hard ou branch deletada",
          "É um log remoto sincronizado com o GitHub",
          "Registra apenas merges e conflitos",
          "É um alias para git log --oneline",
        ],
        c: 0,
        e: "O git reflog registra cada movimentação do ponteiro HEAD no repositório local (commits, resets, checkouts, rebases). Mesmo após um 'git reset --hard' que parece apagar commits, eles permanecem acessíveis via reflog por 90 dias, permitindo recuperação com 'git checkout' ou 'git reset' para o hash encontrado.",
        x: "Acidentalmente: git reset --hard HEAD~5. Recuperação: git reflog → encontra 'abc1234 HEAD@{1}: commit: feature X'. git reset --hard abc1234 → restaura os 5 commits perdidos.",
      },
      {
        q: "O que é git bisect e como ele ajuda a encontrar o commit que introduziu um bug?",
        o: [
          "Busca binária no histórico de commits para encontrar o commit que introduziu a regressão",
          "Divide o repositório em dois",
          "Cria duas branches",
          "Faz merge bissetorial",
        ],
        c: 0,
        e: "git bisect usa busca binária no histórico: você marca um commit 'bad' (com bug) e um 'good' (sem bug). O Git faz checkout do commit do meio e pergunta se é bom ou ruim. Repetindo, encontra o commit exato em O(log n) passos, mesmo em históricos com milhares de commits.",
        x: "git bisect start → git bisect bad (commit atual tem bug) → git bisect good v1.0 (v1.0 não tinha). Git faz checkout do meio. Você testa: git bisect good/bad. Após ~10 passos em 1000 commits, encontra o culpado.",
      },
      {
        q: "Qual a diferença entre git reset, git revert e git restore e quando usar cada um?",
        o: [
          "reset move HEAD/branch para trás; revert cria commit inverso; restore restaura arquivos do working tree",
          "São sinônimos",
          "Todos desfazem commits igualmente",
          "reset é remoto e revert local",
        ],
        c: 0,
        e: "git reset: move HEAD/branch para commit anterior (reescreve histórico, perigoso em branch compartilhada). git revert: cria novo commit que desfaz mudanças de um commit específico (seguro, preserva histórico). git restore: restaura arquivos no working directory ou staging sem alterar commits.",
        x: "Branch local só sua: git reset --hard HEAD~1 (apaga último commit). Branch compartilhada: git revert abc123 (cria commit que desfaz abc123 sem reescrever histórico). Descartar mudança em arquivo: git restore arquivo.ts.",
      },
      {
        q: "O que são Git Hooks e como podem ser usados para automação?",
        o: [
          "Scripts executados automaticamente em eventos Git como pre-commit, pre-push e commit-msg",
          "Webhooks do GitHub",
          "Plugins do VS Code",
          "Atalhos de teclado para Git",
        ],
        c: 0,
        e: "Git Hooks: scripts em .git/hooks/ executados em eventos. pre-commit: lint/format antes de commitar. commit-msg: validar formato da mensagem. pre-push: rodar testes antes de push. Husky: ferramenta que facilita configuração de hooks no package.json.",
        x: "Com Husky + lint-staged: pre-commit hook roda ESLint e Prettier apenas nos arquivos alterados. Commit rejeitado se lint falhar. npx husky add .husky/pre-commit 'npx lint-staged'.",
      },
      {
        q: "O que é cherry-pick no Git e quando utilizá-lo?",
        o: [
          "Aplica um commit específico de outra branch na branch atual, sem fazer merge completo",
          "Seleciona arquivos para staging",
          "Remove commits do histórico",
          "Copia uma branch inteira",
        ],
        c: 0,
        e: "git cherry-pick: copia um commit específico (pelo hash) para a branch atual, criando um novo commit com as mesmas mudanças. Útil para: aplicar hotfix de uma branch em outra, portar features específicas sem merge completo. Cuidado: pode criar commits duplicados.",
        x: "Bug fix commitado na branch hotfix (hash abc123). Precisa do fix em develop também: git switch develop && git cherry-pick abc123 → aplica apenas aquele commit, sem trazer tudo da branch hotfix.",
      },
      {
        q: "O que é interactive rebase (git rebase -i) e como usá-lo para limpar o histórico?",
        o: [
          "Permite reordenar, editar, combinar (squash) e remover commits interativamente antes de push",
          "Rebase automático sem intervenção",
          "Ferramenta gráfica do GitHub",
          "Modo de resolução de conflitos",
        ],
        c: 0,
        e: "git rebase -i HEAD~N abre editor com últimos N commits. Ações: pick (manter), squash (combinar com anterior), fixup (squash sem mensagem), edit (pausar para alterar), reword (mudar mensagem), drop (remover). Reescreve hashes — só usar em commits não pushados.",
        x: "git rebase -i HEAD~4:\npick abc1234 feat: login page\nsquash def5678 fix typo in login\nsquash ghi9012 WIP login\npick jkl3456 feat: signup page\n→ Resultado: 2 commits limpos em vez de 4.",
      },
      {
        q: "O que são Git submodules e quando utilizá-los?",
        o: [
          "Repositórios Git aninhados dentro de outro repositório, referenciados por commit específico",
          "Módulos Node.js gerenciados pelo Git",
          "Branches automatizadas",
          "Plugins do Git para IDEs",
        ],
        c: 0,
        e: "Submodules permitem incluir um repositório Git dentro de outro, fixando uma versão específica (commit hash). Útil para: bibliotecas compartilhadas entre projetos, dependências que você precisa modificar, monorepo com repos independentes. Alternativa moderna: Git subtree.",
        x: "git submodule add https://github.com/org/shared-lib.git libs/shared → cria referência ao repo externo. git submodule update --init --recursive → clona/atualiza. .gitmodules registra URL e path.",
      },
    ],
  },

  // ── JavaScript e TypeScript ──
  "JavaScript e TypeScript": {
    Fácil: [
      {
        q: "Qual é a diferença entre 'let' e 'const' na declaração de variáveis em JavaScript?",
        o: [
          "let permite reatribuição; const cria uma referência que não pode ser reatribuída",
          "let é para números e const para strings",
          "const é mais lento que let",
          "Não há diferença funcional",
        ],
        c: 0,
        e: "A palavra-chave 'let' declara uma variável com escopo de bloco que pode ser reatribuída. 'const' declara uma variável com escopo de bloco cuja referência não pode ser reatribuída após a inicialização. Porém, objetos e arrays declarados com const ainda podem ter suas propriedades/elementos modificados.",
        x: "const arr = [1, 2, 3]; arr.push(4); // OK — modifica conteúdo. arr = [5]; // TypeError — não pode reatribuir a referência.",
      },
      {
        q: "O que é uma Promise em JavaScript e para que ela serve?",
        o: [
          "Objeto que representa o resultado futuro de uma operação assíncrona (sucesso ou falha)",
          "Função que executa imediatamente",
          "Tipo de loop",
          "Método de array",
        ],
        c: 0,
        e: "Promise é um objeto que pode estar em 3 estados: pending (aguardando), fulfilled (resolvida com valor) ou rejected (rejeitada com erro). Usa .then() para sucesso, .catch() para erro, ou async/await para sintaxe mais legível.",
        x: "fetch('/api/users').then(res => res.json()).then(users => console.log(users)).catch(err => console.error(err)); // Ou com async/await: const users = await fetch('/api/users').then(r => r.json());",
      },
      {
        q: "Qual é a diferença entre '==' e '===' em JavaScript?",
        o: [
          "=== compara valor e tipo (strict); == converte tipos antes de comparar (loose)",
          "São idênticos",
          "=== é mais lento",
          "== é para strings e === para números",
        ],
        c: 0,
        e: "== (igualdade solta) faz coercão de tipos antes de comparar, podendo gerar resultados inesperados. === (igualdade estrita) compara valor E tipo sem coercão. Boas práticas: sempre usar === para evitar bugs subtís.",
        x: "0 == '' // true (ambos viram 0). 0 === '' // false (number ≠ string). null == undefined // true. null === undefined // false. Sempre use ===!",
      },
      {
        q: "O que é o operador spread (...) em JavaScript e quais seus usos?",
        o: [
          "Expande elementos de arrays/objetos; usado para cópias, combinação e desestruturação",
          "Operador de divisão",
          "Criação de variáveis globais",
          "Loop infinito",
        ],
        c: 0,
        e: "Spread (...) expande itens de arrays ou propriedades de objetos. Usos: cópia rasa ([...arr]), combinação ([...a, ...b]), atualização imutável ({ ...obj, key: newVal }), rest params (function(...args)). Fundamental para imutabilidade em React.",
        x: "const a = [1,2]; const b = [...a, 3]; // [1,2,3]. const user = { name: 'Ana' }; const updated = { ...user, age: 25 }; // { name: 'Ana', age: 25 }. Original intacto.",
      },
      {
        q: "O que é async/await em JavaScript e como simplifica código assíncrono?",
        o: [
          "Sintaxe que permite escrever código assíncrono de forma semelhante a síncrono, usando Promises por baixo",
          "Substitui completamente Promises",
          "Cria threads paralelas",
          "Funciona apenas no Node.js",
        ],
        c: 0,
        e: "async marca uma função como assíncrona (retorna Promise). await pausa a execução até a Promise resolver, sem bloquear a thread. Torna o código mais legível que .then() encadeado. Tratamento de erro: try/catch em vez de .catch().",
        x: "// Com .then():\nfetch(url).then(r => r.json()).then(data => console.log(data));\n// Com async/await:\nconst r = await fetch(url); const data = await r.json(); console.log(data); — muito mais legível.",
      },
      {
        q: "O que são template literals (template strings) em JavaScript?",
        o: [
          "Strings delimitadas por crases (`) que suportam interpolação de expressões com ${} e múltiplas linhas",
          "Strings normais com aspas simples",
          "Templates HTML",
          "Funções de formatação",
        ],
        c: 0,
        e: "Template literals usam crases (`) e permitem interpolação de expressões com ${expr}. Suportam múltiplas linhas sem \\n. Tagged templates permitem processar a string com uma função (ex: html`<p>${text}</p>`, sql`SELECT * FROM ${table}`).",
        x: "const name = 'Ana'; const age = 28;\nConcat: 'Olá ' + name + ', você tem ' + age + ' anos.'\nTemplate: `Olá ${name}, você tem ${age} anos.` — mais legível e suporta expressões: ${age + 1}.",
      },
      {
        q: "O que é desestruturação (destructuring) em JavaScript?",
        o: [
          "Sintaxe que extrai valores de arrays ou propriedades de objetos em variáveis individuais",
          "Método para destruir objetos da memória",
          "Função para deletar propriedades",
          "Técnica de compressão de dados",
        ],
        c: 0,
        e: "Destructuring extrai dados de arrays e objetos de forma concisa. Em objetos: { name, age } = user. Em arrays: [first, second] = arr. Suporta valores padrão ({ name = 'Anônimo' }), renomeação ({ name: userName }) e aninhamento.",
        x: "const { name, age } = { name: 'Ana', age: 28 }; // name='Ana', age=28\nconst [first, ...rest] = [1, 2, 3, 4]; // first=1, rest=[2,3,4]\nfunction greet({ name, age = 0 }) { } // destructuring em parâmetros.",
      },
    ],
    Médio: [
      {
        q: "No TypeScript, qual é a diferença entre 'interface' e 'type alias' para declarar tipos de objetos?",
        o: [
          "Interfaces podem ser estendidas com extends e são abertas a declaration merging; types usam interseção e são fechados",
          "Types são mais rápidos em compilação",
          "Interfaces não suportam métodos",
          "Não há diferença alguma desde o TS 4.0",
        ],
        c: 0,
        e: "Interfaces usam 'extends' para herança e suportam declaration merging (declarar a mesma interface duas vezes combina os membros). Types usam '&' para interseção e não suportam merging. Types são mais versáteis (unions, mapped types, etc.). Para objetos simples, ambos funcionam de forma equivalente.",
        x: "interface User { name: string } interface User { age: number } // Merge: User tem name e age. type User2 = { name: string } & { age: number } // Interseção: mesmo resultado, mas sem merging.",
      },
      {
        q: "O que é o Event Loop no JavaScript e como ele gerencia operações assíncronas?",
        o: [
          "Mecanismo que executa código síncrono na call stack e processa callbacks assíncronos da fila quando a stack esvazia",
          "Thread pool igual a Java",
          "Compilador JIT",
          "Gerenciador de memória",
        ],
        c: 0,
        e: "JavaScript é single-threaded. O Event Loop verifica: 1) a call stack está vazia? 2) Se sim, pega a próxima callback da microtask queue (Promises) ou macrotask queue (setTimeout, I/O). Microtasks têm prioridade. Isso permite assincronismo sem threads.",
        x: "console.log('1'); setTimeout(() => console.log('2'), 0); Promise.resolve().then(() => console.log('3')); console.log('4'); → Saída: 1, 4, 3, 2. Síncrono primeiro, depois microtask (Promise), depois macrotask (setTimeout).",
      },
      {
        q: "No TypeScript, o que são Generics e qual problema eles resolvem?",
        o: [
          "Tipos parametrizáveis que permitem reutilizar lógica mantendo type safety para diferentes tipos",
          "Tipos que aceitam qualquer valor (any)",
          "Classes genéricas de UI",
          "Funções sem retorno",
        ],
        c: 0,
        e: "Generics permitem criar funções, classes e interfaces que funcionam com múltiplos tipos mantendo type safety. Ao invés de usar 'any' (perde tipagem), você parametriza o tipo com <T> e o TypeScript infere ou o chamador especifica o tipo concreto.",
        x: "function first<T>(arr: T[]): T | undefined { return arr[0]; } first([1,2,3]) → retorno é number | undefined. first(['a','b']) → retorno é string | undefined. Type safety preservada!",
      },
      {
        q: "O que é o conceito de hoisting em JavaScript?",
        o: [
          "Comportamento onde declarações de var e function são movidas para o topo do escopo antes da execução",
          "Otimização do compilador",
          "Método de ordenação",
          "Garbage collection",
        ],
        c: 0,
        e: "Hoisting: declarações var e function são 'elevadas' ao topo do escopo durante a compilação. var é hoisted como undefined; function é hoisted inteiramente. let/const são hoisted mas ficam em 'temporal dead zone' até a declaração (ReferenceError se acessar antes).",
        x: "console.log(x); var x = 5; // undefined (var hoisted, valor não). console.log(y); let y = 5; // ReferenceError (TDZ). greet(); function greet() { } // OK (function hoisted inteira).",
      },
      {
        q: "O que são Higher-Order Functions em JavaScript?",
        o: [
          "Funções que recebem outras funções como argumento ou retornam funções",
          "Funções que rodam mais rápido",
          "Funções com mais de 3 parâmetros",
          "Funções assíncronas",
        ],
        c: 0,
        e: "Higher-Order Functions (HOF) tratam funções como valores: recebem como argumento (callback) ou retornam funções. Exemplos nativos: map, filter, reduce, forEach. Padrão funcional que permite composição e reutilização.",
        x: "const double = (arr) => arr.map(x => x * 2); // map é HOF, recebe função. function multiplier(factor) { return (n) => n * factor; } // retorna função. const triple = multiplier(3); triple(5); // 15.",
      },
      {
        q: "O que são optional chaining (?.) e nullish coalescing (??) em JavaScript/TypeScript?",
        o: [
          "?. acessa propriedades de forma segura retornando undefined se nulo; ?? fornece valor padrão apenas para null/undefined",
          "Operadores matemáticos",
          "Operadores de comparação",
          "Operadores de atribuição",
        ],
        c: 0,
        e: "Optional chaining (?.) evita erros ao acessar propriedades de objetos potencialmente null/undefined: user?.address?.city retorna undefined em vez de TypeError. Nullish coalescing (??) retorna o lado direito apenas se o esquerdo for null/undefined (diferente de || que trata 0 e '' como falsy).",
        x: "const city = user?.address?.city ?? 'Não informada'; — se user, address ou city forem null/undefined, retorna 'Não informada'. Com ||: 0 ?? 'default' = 0 (correto), 0 || 'default' = 'default' (errado se 0 é válido).",
      },
      {
        q: "O que são Utility Types no TypeScript como Partial, Pick e Omit?",
        o: [
          "Tipos genéricos nativos que transformam tipos existentes: tornam opcionais, selecionam ou excluem propriedades",
          "Bibliotecas de funções utilitárias",
          "Tipos exclusivos para React",
          "Plugins do TypeScript",
        ],
        c: 0,
        e: "Partial<T>: todas as props opcionais. Required<T>: todas obrigatórias. Pick<T,K>: seleciona props específicas. Omit<T,K>: exclui props. Record<K,V>: cria tipo com chaves K e valores V. Readonly<T>: props somente leitura. Evitam duplicação de tipos.",
        x: "type User = { name: string; email: string; age: number };\ntype UserUpdate = Partial<User>; // tudo opcional\ntype UserPreview = Pick<User, 'name' | 'email'>; // só name e email\ntype UserWithoutAge = Omit<User, 'age'>; // exclui age",
      },
    ],
    Difícil: [
      {
        q: "No TypeScript, como os 'conditional types' com 'infer' permitem extrair tipos de dentro de outros tipos genéricos?",
        o: [
          "Usam a keyword infer dentro de extends para capturar e reutilizar sub-tipos em tempo de compilação",
          "Usam typeof em runtime para detectar tipos",
          "Dependem de reflection como em Java",
          "Usam decorators para anotar tipos em execução",
        ],
        c: 0,
        e: "Conditional types com 'infer' permitem pattern matching em tipos. A sintaxe T extends SomeType<infer U> ? U : never captura o tipo U se T corresponder ao padrão. É computado inteiramente em tempo de compilação sem impacto no runtime.",
        x: "type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never; type Result = ReturnType<() => string>; // Result = string — extrai o tipo de retorno da função.",
      },
      {
        q: "O que são closures em JavaScript e como elas funcionam?",
        o: [
          "Funções que 'lembram' do ambiente léxico onde foram criadas, mantendo acesso a variáveis externas",
          "Funções que se auto-executam",
          "Métodos de array",
          "Tipo de promise",
        ],
        c: 0,
        e: "Closure é a combinação de uma função com o ambiente léxico (variáveis do escopo) onde foi criada. Mesmo após a função externa terminar, a função interna mantém acesso às variáveis do escopo pai. Usada em encapsulamento, factories e callbacks.",
        x: "function counter() { let count = 0; return { inc: () => ++count, get: () => count }; } const c = counter(); c.inc(); c.inc(); c.get(); // 2. 'count' é privada, acessível apenas via closure.",
      },
      {
        q: "No TypeScript, o que são Mapped Types e como eles permitem transformar tipos existentes?",
        o: [
          "Tipos que iteram sobre propriedades de outro tipo aplicando transformações, gerando novos tipos",
          "Tipos que mapeiam para banco de dados",
          "Tipos de arrays",
          "Tipos de funções",
        ],
        c: 0,
        e: "Mapped Types usam 'in keyof' para iterar sobre propriedades de um tipo e aplicar transformações. Utility types nativos como Partial<T>, Required<T>, Readonly<T> e Pick<T,K> são implementados com mapped types. Permitem criar novos tipos derivados de existentes.",
        x: "type Readonly<T> = { readonly [K in keyof T]: T[K] }; type Partial<T> = { [K in keyof T]?: T[K] }; type ReadonlyUser = Readonly<User>; // Todas as props de User viram readonly.",
      },
      {
        q: "O que é o padrão Module em JavaScript e como closures são usadas para encapsulamento?",
        o: [
          "Padrão que usa IIFE e closures para criar escopo privado, expondo apenas uma API pública",
          "Import/export do ES6",
          "Design pattern para banco de dados",
          "Ferramenta de bundling",
        ],
        c: 0,
        e: "Module Pattern: IIFE que retorna um objeto com métodos públicos. Variáveis dentro da IIFE são privadas (closure). Antes de ES Modules, era a principal forma de encapsulamento. Hoje usado em configurações e bibliotecas que precisam de estado privado.",
        x: "const counter = (() => { let count = 0; return { inc: () => ++count, get: () => count }; })(); counter.inc(); counter.get(); // 1. 'count' é privado — inacessível fora da closure.",
      },
      {
        q: "O que é o TypeScript Discriminated Union e como ele permite narrowing seguro?",
        o: [
          "Union com campo literal comum (discriminante) que permite ao compilador narrowing automático em switch/if",
          "União de strings",
          "Array de tipos diferentes",
          "Enum numérico",
        ],
        c: 0,
        e: "Discriminated Union: cada membro tem um campo literal único (type: 'circle' | type: 'square'). O TS usa esse campo para narrowing em switch/if, sabendo exatamente quais propriedades estão disponíveis. Exhaustiveness check com never no default.",
        x: "type Shape = { type: 'circle'; radius: number } | { type: 'square'; side: number }; function area(s: Shape) { switch(s.type) { case 'circle': return Math.PI * s.radius ** 2; case 'square': return s.side ** 2; } } — TS sabe que s.radius existe no case 'circle'.",
      },
      {
        q: "O que é o objeto Proxy em JavaScript e quais seus casos de uso?",
        o: [
          "Wrapper que intercepta operações fundamentais em objetos (get, set, delete) via handlers chamados traps",
          "Servidor proxy de rede",
          "Cache de requisições HTTP",
          "Design pattern igual ao GoF Proxy",
        ],
        c: 0,
        e: "Proxy cria um objeto que intercepta operações em outro objeto alvo. Traps: get (leitura), set (escrita), has (in), deleteProperty, apply (chamada de função). Usos: validação reativa, logging, lazy loading, observabilidade. Vue 3 usa Proxy para reatividade.",
        x: "const handler = { set(target, prop, value) { console.log(`${prop} mudou para ${value}`); target[prop] = value; return true; } }; const state = new Proxy({}, handler); state.count = 1; // loga: 'count mudou para 1'. Base da reatividade do Vue 3.",
      },
      {
        q: "O que são Template Literal Types no TypeScript e como criam tipos dinâmicos?",
        o: [
          "Tipos que usam template string syntax para criar uniões de strings dinâmicas em tempo de compilação",
          "Strings tipadas em runtime",
          "Templates para geração de código",
          "Validação de strings em runtime",
        ],
        c: 0,
        e: "Template Literal Types combinam strings literais com uniões para criar novos tipos: `on${Capitalize<Event>}` gera 'onClick' | 'onHover' | 'onFocus'. Poderoso para APIs type-safe com padrões de nomenclatura. Usado em libs como Prisma e tRPC.",
        x: "type Event = 'click' | 'hover' | 'focus';\ntype Handler = `on${Capitalize<Event>}`; // 'onClick' | 'onHover' | 'onFocus'\ntype CSSProperty = `${string}-${string}`; // aceita 'font-size', 'margin-top', etc.\ntype Getter<T> = `get${Capitalize<T & string>}`;",
      },
    ],
  },

  // ── Programação Orientada a Objetos ──
  "Programação Orientada a Objetos": {
    Fácil: [
      {
        q: "Qual conceito de POO permite que uma classe filha herde atributos e métodos de uma classe pai?",
        o: ["Herança", "Encapsulamento", "Polimorfismo", "Abstração"],
        c: 0,
        e: "Herança é o mecanismo pelo qual uma classe (filha/subclasse) pode reutilizar atributos e métodos de outra classe (pai/superclasse), promovendo reuso de código. A classe filha pode adicionar novos membros ou sobrescrever comportamentos herdados.",
        x: "class Animal { mover() { } } class Cachorro extends Animal { latir() { } } — Cachorro herda o método mover() de Animal e adiciona latir().",
      },
      {
        q: "O que é encapsulamento em POO e qual sua importância?",
        o: [
          "Ocultar detalhes internos de um objeto, expondo apenas uma interface pública controlada",
          "Colocar tudo em uma única classe",
          "Criptografar atributos",
          "Usar apenas métodos estáticos",
        ],
        c: 0,
        e: "Encapsulamento esconde a implementação interna (atributos privados) e expõe apenas métodos públicos controlados. Protege contra uso indevido, permite mudar a implementação sem afetar código externo e garante consistência dos dados (validação no setter).",
        x: "class ContaBancaria { private saldo = 0; depositar(valor: number) { if (valor > 0) this.saldo += valor; } getSaldo() { return this.saldo; } } — 'saldo' só é acessível via métodos, que validam o valor.",
      },
      {
        q: "O que é polimorfismo e qual é um exemplo prático?",
        o: [
          "Capacidade de objetos de tipos diferentes responderem à mesma mensagem de formas distintas",
          "Ter múltiplas heranças",
          "Criar múltiplas instâncias",
          "Usar variáveis globais",
        ],
        c: 0,
        e: "Polimorfismo permite que diferentes classes implementem o mesmo método de maneiras diferentes. O código que chama o método não precisa saber o tipo concreto — cada objeto responde conforme sua implementação. Tipos: sobrescrita (override) e sobrecarga (overload).",
        x: "function calcularArea(forma: Forma): number { return forma.area(); } — funciona com Circle, Rectangle, Triangle. Cada um implementa area() de forma diferente. O código chamador é o mesmo.",
      },
      {
        q: "O que é abstração em POO e como ela simplifica a complexidade?",
        o: [
          "Esconder detalhes complexos de implementação e expor apenas o essencial para o usuário",
          "Criar classes vazias",
          "Programar sem variáveis",
          "Usar apenas interfaces",
        ],
        c: 0,
        e: "Abstração foca no 'quê' e esconde o 'como'. O usuário de uma classe não precisa saber como ela funciona internamente — só precisa conhecer a interface pública. Reduz complexidade cognitiva e permite mudanças internas sem impactar quem usa.",
        x: "carro.ligar() — o motorista não precisa saber como função, injeção, ignição funcionam internamente. Mesma ideia: array.sort() — você não precisa saber se usa quicksort ou timsort.",
      },
      {
        q: "O que é uma classe em POO e qual a relação com objetos?",
        o: [
          "Classe é o molde/blueprint; objeto é a instância concreta criada a partir da classe",
          "Classe e objeto são a mesma coisa",
          "Objeto é o molde e classe a instância",
          "Classes só existem em Java",
        ],
        c: 0,
        e: "Classe: template que define atributos (dados) e métodos (comportamento). Objeto: instância concreta de uma classe com valores específicos. Uma classe pode gerar múltiplos objetos. Analogia: classe = planta da casa; objeto = casa construída.",
        x: "class User { name: string; constructor(name: string) { this.name = name; } } const user1 = new User('Ana'); const user2 = new User('Bob'); — User é a classe, user1 e user2 são objetos.",
      },
      {
        q: "O que é um construtor (constructor) em POO e para que serve?",
        o: [
          "Método especial chamado automaticamente ao criar uma instância, usado para inicializar atributos",
          "Método para destruir objetos",
          "Função estática da classe",
          "Tipo de herança",
        ],
        c: 0,
        e: "O constructor é executado automaticamente quando se usa 'new'. Inicializa atributos do objeto com valores passados como parâmetros. Em TypeScript, pode usar atalho: constructor(public name: string) declara e inicializa o atributo em uma linha.",
        x: "class Car { brand: string; year: number; constructor(brand: string, year: number) { this.brand = brand; this.year = year; } } const car = new Car('Toyota', 2024); // constructor chamado com 'Toyota' e 2024.",
      },
      {
        q: "Qual a diferença entre métodos de instância e métodos estáticos?",
        o: [
          "Métodos de instância operam sobre o objeto (this); estáticos pertencem à classe e não precisam de instância",
          "São idênticos",
          "Estáticos são mais lentos",
          "Métodos de instância não podem acessar atributos",
        ],
        c: 0,
        e: "Método de instância: chamado em um objeto, acessa 'this' (atributos do objeto). Método estático: chamado na classe diretamente (Classe.metodo()), sem acesso a 'this'. Usado para utilitários e factories que não dependem de estado da instância.",
        x: "class MathUtils { static add(a: number, b: number) { return a + b; } } MathUtils.add(2, 3); // 5, sem new.\nclass User { greet() { return `Olá, ${this.name}`; } } new User('Ana').greet(); // precisa de instância.",
      },
    ],
    Médio: [
      {
        q: "Qual é a diferença entre classe abstrata e interface em linguagens como Java e TypeScript?",
        o: [
          "Classe abstrata pode ter métodos implementados e estado; interface define apenas contratos sem implementação",
          "Interface pode ter construtores e abstrata não",
          "Classe abstrata não pode ter métodos abstratos",
          "Não há diferença prática",
        ],
        c: 0,
        e: "Uma classe abstrata pode conter métodos implementados (com corpo), atributos com estado e construtores, mas não pode ser instanciada diretamente. Uma interface define apenas a assinatura dos métodos (contrato), sem implementação ou estado. Em Java, uma classe pode implementar múltiplas interfaces mas estender apenas uma classe abstrata.",
        x: "abstract class Shape { color: string; abstract area(): number; describe() { return `Shape: ${this.color}`; } } interface Drawable { draw(): void; } class Circle extends Shape implements Drawable { area() { ... } draw() { ... } }",
      },
      {
        q: "O que é composição em POO e por que geralmente é preferida sobre herança?",
        o: [
          "Construir objetos combinando outros objetos como componentes internos, oferecendo mais flexibilidade que herança",
          "Tipo de herança múltipla",
          "Padrão de criação de singletons",
          "Método de otimização",
        ],
        c: 0,
        e: "Composição usa relação 'tem-um' (has-a) em vez de 'é-um' (is-a). Vantagens sobre herança: evita hierarquias rígidas, permite trocar comportamentos em runtime, não herda métodos desnecessários, e permite combinar funcionalidades de múltiplas fontes sem herança múltipla.",
        x: "Herança: class Car extends Engine {} (carro NÃO é motor). Composição: class Car { engine: Engine; gps: GPS; } (carro TEM motor e GPS). Pode trocar Engine por ElectricEngine em runtime.",
      },
      {
        q: "O que são interfaces em TypeScript/Java e qual seu papel em POO?",
        o: [
          "Contratos que definem quais métodos uma classe deve implementar, sem fornecer implementação",
          "Classes com todos métodos implementados",
          "Tipo de herança",
          "Templates de UI",
        ],
        c: 0,
        e: "Interfaces definem um contrato: quais métodos e propriedades um objeto deve ter. Não contêm implementação. Uma classe que implementa uma interface DEVE fornecer todos os métodos declarados. Permite programar para abstrações em vez de implementações concretas.",
        x: "interface Notifier { send(message: string): void; } class EmailNotifier implements Notifier { send(msg) { /* envia email */ } } class SMSNotifier implements Notifier { send(msg) { /* envia SMS */ } } — código usa Notifier, não sabe se é email ou SMS.",
      },
      {
        q: "O que é o princípio DIP (Dependency Inversion Principle) do SOLID?",
        o: [
          "Módulos de alto nível não devem depender de módulos de baixo nível; ambos devem depender de abstrações",
          "Inverter a ordem de execução das funções",
          "Usar dependência circular",
          "Remover todas as interfaces",
        ],
        c: 0,
        e: "DIP: dependa de abstrações (interfaces), não de implementações concretas. O módulo de alto nível (regra de negócio) define a interface que precisa; o módulo de baixo nível (infra) implementa. Injeção de dependência é a técnica para aplicar DIP.",
        x: "Sem DIP: OrderService cria new MySQLRepository() diretamente. Com DIP: OrderService recebe OrderRepository (interface) no construtor. Pode injetar MySQLRepository ou MongoRepository sem mudar OrderService.",
      },
      {
        q: "O que é o conceito de coerência (cohesion) e acoplamento (coupling) em POO?",
        o: [
          "Coesão alta: classe focada em uma responsabilidade. Acoplamento baixo: classes com pouca dependência entre si",
          "São sinônimos",
          "Coesão é sobre UI e acoplamento sobre backend",
          "Ambos devem ser altos",
        ],
        c: 0,
        e: "Coesão: quão relacionados são os membros de uma classe entre si (alta = bom). Acoplamento: quão dependente uma classe é de outras (baixo = bom). Meta: alta coesão + baixo acoplamento = classes focadas e independentes, fáceis de manter e testar.",
        x: "Alta coesão: UserRepository só lida com persistência de User. Baixa coesão: UserManager valida, persiste, envia email e gera relatório. Baixo acoplamento: OrderService depende de interface PaymentGateway, não de Stripe diretamente.",
      },
      {
        q: "O que é Injeção de Dependência (Dependency Injection) e como funciona?",
        o: [
          "Técnica onde dependências são fornecidas externamente ao objeto em vez de criadas internamente",
          "Instalar pacotes npm",
          "Importar módulos com import",
          "Criar singleton de banco de dados",
        ],
        c: 0,
        e: "DI: em vez da classe criar suas dependências (new MySQLRepo()), ela as recebe por parâmetro do construtor, setter ou interface. Vantagens: testabilidade (injetar mock), flexibilidade (trocar implementação), respeita DIP (SOLID). Frameworks: NestJS, Spring, Angular.",
        x: "Sem DI: class OrderService { repo = new MySQLRepo(); } — acoplado ao MySQL.\nCom DI: class OrderService { constructor(private repo: OrderRepository) {} } — recebe qq implementação. No teste: new OrderService(new MockRepo()).",
      },
      {
        q: "O que são mixins em POO e como funcionam em TypeScript?",
        o: [
          "Padrão que adiciona funcionalidades a uma classe sem herança clássica, combinando múltiplos comportamentos",
          "Tipo de herança múltipla nativa",
          "Método de mesclagem de arrays",
          "Framework de CSS",
        ],
        c: 0,
        e: "Mixins permitem compor uma classe com funcionalidades de múltiplas fontes, contornando a limitação de herança simples. Em TypeScript: funções que recebem uma classe base e retornam uma nova classe com comportamento adicional. Alternativa a herança múltipla.",
        x: "function Timestamped<T extends Constructor>(Base: T) { return class extends Base { createdAt = new Date(); }; }\nfunction Activatable<T extends Constructor>(Base: T) { return class extends Base { active = false; }; }\nclass User extends Timestamped(Activatable(BaseEntity)) {} — User ganha createdAt e active.",
      },
    ],
    Difícil: [
      {
        q: "Qual princípio SOLID é violado quando uma classe pai tem um método que uma subclasse precisa sobrescrever para lançar uma exceção, tornando a substituição insegura?",
        o: [
          "Liskov Substitution Principle (LSP)",
          "Single Responsibility Principle (SRP)",
          "Open/Closed Principle (OCP)",
          "Interface Segregation Principle (ISP)",
        ],
        c: 0,
        e: "O LSP afirma que objetos de uma subclasse devem poder substituir objetos da superclasse sem alterar o comportamento esperado do programa. Se Square herda de Rectangle mas sobrescreve setWidth para lançar exceção ou alterar setHeight junto, o código que espera um Rectangle quebrará ao receber um Square.",
        x: "class Bird { fly() { } } class Penguin extends Bird { fly() { throw new Error('Não voo'); } } — função feedBird(b: Bird) { b.fly(); } quebra com Penguin. Solução: interface FlyingBird separada.",
      },
      {
        q: "O que é o princípio ISP (Interface Segregation Principle) do SOLID?",
        o: [
          "Clientes não devem depender de interfaces com métodos que não usam; prefira interfaces específicas e enxutas",
          "Cada interface deve ter o máximo de métodos",
          "Interfaces devem ser herdadas",
          "Segregar significa juntar",
        ],
        c: 0,
        e: "ISP: em vez de uma interface 'gorda' com muitos métodos, crie várias interfaces pequenas e específicas. Assim, cada classe implementa apenas os métodos que realmente usa, evitando dependências desnecessárias e implementações vazias.",
        x: "Ruim: interface Worker { work(); eat(); sleep(); } — robô precisa implementar eat() e sleep() vazios. Bom: interface Workable { work(); } interface Feedable { eat(); } — robô implementa só Workable.",
      },
      {
        q: "O que é o padrão de double dispatch e como ele resolve o problema do polimorfismo bi-dimensional?",
        o: [
          "Técnica onde o método chamado depende do tipo runtime de dois objetos, usando visitante ou sobrescrita combinada",
          "Chamar um método duas vezes",
          "Criar duas instâncias",
          "Dispatch assíncrono",
        ],
        c: 0,
        e: "Linguagens como Java/TypeScript despacham métodos pelo tipo runtime do receptor (single dispatch). Double dispatch exige que o método dependa de DOIS tipos runtime. O padrão Visitor resolve isso: o elemento chama visitor.visit(this), o que dispara o método sobrecarregado correto do visitor.",
        x: "circle.accept(printer) → printer.visitCircle(this) → imprime círculo. square.accept(printer) → printer.visitSquare(this) → imprime quadrado. O Visitor 'sabe' o tipo concreto porque o accept() resolve o primeiro dispatch.",
      },
      {
        q: "O que é o princípio SRP (Single Responsibility Principle) do SOLID?",
        o: [
          "Uma classe deve ter apenas um motivo para mudar — uma única responsabilidade",
          "Uma classe deve ter um único método",
          "Cada arquivo deve ter uma classe",
          "Funções devem ter um paramâmetro",
        ],
        c: 0,
        e: "SRP: cada classe/módulo deve ter uma única razão para mudar. Se uma classe lida com validação E persistência, mudanças no banco afetam a classe que também valida. Separar responsabilidades = menor risco de efeitos colaterais e mais fácil de testar.",
        x: "Viola SRP: class User { validate() { } save() { } sendEmail() { } } — 3 motivos para mudar. Correto: UserValidator, UserRepository, EmailService — cada uma com uma responsabilidade.",
      },
      {
        q: "O que é o princípio de Substituição de Liskov (LSP) na prática com TypeScript?",
        o: [
          "Subtipos devem poder substituir seus tipos base sem alterar a correção do programa",
          "Listas devem ser substituídas por arrays",
          "Subclasses devem ter mais métodos",
          "Tipos genéricos devem ser evitados",
        ],
        c: 0,
        e: "LSP: se S é subtipo de T, então objetos de T podem ser substituídos por objetos de S sem quebrar o programa. Pré-condições não podem ser fortalecidas, pós-condições não podem ser enfraquecidas, invariantes devem ser mantidas.",
        x: "function processPayment(p: Payment) { p.charge(100); } — CreditCard, DebitCard, PIX implementam Payment. Todas devem funcionar se passadas para processPayment(). Se PIX lançar erro em charge(), viola LSP.",
      },
      {
        q: "O que são os padrões GRASP e quais seus princípios de atribuição de responsabilidade?",
        o: [
          "Conjunto de 9 padrões que guiam a atribuição de responsabilidades a classes: Creator, Expert, Controller, etc.",
          "Framework de testes",
          "Metodologia ágil",
          "Linguagem de modelagem",
        ],
        c: 0,
        e: "GRASP (General Responsibility Assignment Software Patterns): Information Expert (quem tem os dados é responsável), Creator (quem cria instâncias), Controller (quem recebe eventos de sistema), Low Coupling, High Cohesion, Polymorphism, Pure Fabrication, Indirection, Protected Variations.",
        x: "Information Expert: Pedido calcula seu próprio total (tem os itens). Creator: Pedido cria ItemPedido (contém/agrega itens). Controller: PedidoController recebe requisições HTTP. Cada padrão define QUEM deve ter cada responsabilidade.",
      },
      {
        q: "O que é covariância e contravariância em tipos genéricos?",
        o: [
          "Covariância preserva a direção do subtipo; contravariância inverte — aplicados em tipos de retorno e parâmetros",
          "Termos de estatística",
          "Tipos de herança múltipla",
          "Métodos de ordenação",
        ],
        c: 0,
        e: "Covariante: se Dog extends Animal, então List<Dog> é subtipo de List<Animal> (retornos de função). Contravariante: direção inversa (parâmetros de função). Invariante: nenhuma direção. TypeScript: strictFunctionTypes habilita checagem de contravariância em parâmetros.",
        x: "type Animal = { name: string }; type Dog = Animal & { bark(): void };\nCovariante (retorno): () => Dog é subtipo de () => Animal ✔\nContravariante (param): (a: Animal) => void é subtipo de (d: Dog) => void ✔\nInvariante: Array<Dog> !subtipo Array<Animal> se mutar (push de Cat em array de Dog).",
      },
    ],
  },

  // ── React e React Native ──
  "React e React Native": {
    Fácil: [
      {
        q: "No React, qual hook é utilizado para gerenciar estado local em um componente funcional?",
        o: ["useState", "useEffect", "useContext", "useRef"],
        c: 0,
        e: "O hook useState retorna um par [valor, função setter]. Quando o setter é chamado com um novo valor, o React re-renderiza o componente com o estado atualizado. É a forma padrão de gerenciar estado em componentes funcionais.",
        x: "const [count, setCount] = useState(0); return <Button onPress={() => setCount(count + 1)} title={`Cliques: ${count}`} />;",
      },
      {
        q: "No React, o que são props e como elas diferem de state?",
        o: [
          "Props são dados passados pelo pai (read-only); state são dados internos do componente (mutáveis)",
          "São idênticos",
          "Props são mutáveis e state read-only",
          "Ambos são globais",
        ],
        c: 0,
        e: "Props (properties) são dados passados de um componente pai para um filho, são read-only no filho. State é dado gerenciado internamente pelo próprio componente, pode ser alterado via setState/useState, e alterações causam re-renderização.",
        x: "<UserCard name='Ana' age={28} /> — name e age são props. Dentro de UserCard: const [isExpanded, setIsExpanded] = useState(false); — isExpanded é state interno.",
      },
      {
        q: "Qual componente do React Native é usado para renderizar listas longas de forma eficiente?",
        o: ["FlatList", "ScrollView", "View", "Text"],
        c: 0,
        e: "FlatList renderiza apenas os itens visíveis na tela (virtualização), sendo eficiente para listas grandes. ScrollView renderiza TODOS os itens de uma vez (ok para listas curtas <100 items). FlatList exige keyExtractor e renderItem.",
        x: "<FlatList data={users} keyExtractor={item => item.id} renderItem={({ item }) => <UserCard user={item} />} /> — renderiza eficientemente 10.000 usuários mostrando apenas ~10 visíveis.",
      },
      {
        q: "No React, o que é o hook useEffect e para que ele serve?",
        o: [
          "Executa efeitos colaterais (chamadas API, subscriptions) após a renderização do componente",
          "Gerencia estado local",
          "Cria componentes",
          "Formata estilos CSS",
        ],
        c: 0,
        e: "useEffect roda após o componente renderizar. Com array vazio ([]) roda apenas na montagem. Com dependências ([count]) roda quando count muda. Sem array, roda a cada renderização. Retorno opcional é função de cleanup.",
        x: "useEffect(() => { fetchUsers().then(setUsers); }, []); — busca usuários uma vez ao montar o componente. O [] garante que não repete a cada renderização.",
      },
      {
        q: "Qual a diferença entre componentes funcionais e componentes de classe no React?",
        o: [
          "Funcionais são funções que usam hooks; de classe usam this.state e métodos de ciclo de vida",
          "São idênticos",
          "Classes são mais rápidas",
          "Funcionais não têm estado",
        ],
        c: 0,
        e: "Componentes funcionais: funções que recebem props e retornam JSX. Desde React 16.8, usam hooks (useState, useEffect) para estado e efeitos. Classes: usam this.state, this.setState, e lifecycle methods (componentDidMount etc). Funcionais são o padrão moderno.",
        x: "Funcional: function Counter() { const [n, setN] = useState(0); return <button onClick={() => setN(n+1)}>{n}</button>; } Classe: class Counter extends Component { state = {n:0}; render() { return <button onClick={() => this.setState({n: this.state.n+1})}>{this.state.n}</button>; } }",
      },
      {
        q: "O que é JSX e por que o React o utiliza?",
        o: [
          "Extensão de sintaxe que permite escrever estrutura de UI similar a HTML dentro do JavaScript",
          "Linguagem de programação separada",
          "Template engine do Node.js",
          "Substituto do CSS",
        ],
        c: 0,
        e: "JSX (JavaScript XML) é uma extensão sintática que permite escrever elementos de UI de forma declarativa dentro do JS. Babel transpila JSX para React.createElement() calls. Permite interpolação com {}, condições e map(). Não é HTML: usa className em vez de class, htmlFor em vez de for.",
        x: "const element = <h1 className='title'>Olá, {user.name}</h1>; → transpila para: React.createElement('h1', { className: 'title' }, 'Olá, ', user.name). JSX é açúcar sintático.",
      },
      {
        q: "O que é o hook useRef e quando utilizá-lo?",
        o: [
          "Cria uma referência mutável que persiste entre renderizações sem causar re-render ao mudar",
          "Substituto do useState",
          "Hook para efeitos colaterais",
          "Método de estilização",
        ],
        c: 0,
        e: "useRef retorna um objeto { current: valor } que persiste durante todo o ciclo de vida do componente. Mutar .current NÃO causa re-render. Usos: acessar elementos DOM diretamente, armazenar timers/intervals, guardar valor anterior, contar renders.",
        x: "const inputRef = useRef<TextInput>(null); <TextInput ref={inputRef} /> <Button onPress={() => inputRef.current?.focus()} /> — foca o input programáticamente. Também: const renderCount = useRef(0); renderCount.current++ em cada render (sem causar loop).",
      },
    ],
    Médio: [
      {
        q: "No React, para que serve o hook useEffect e quando a função de cleanup é executada?",
        o: [
          "Executa efeitos colaterais após a renderização; cleanup roda antes do próximo efeito e na desmontagem do componente",
          "Cria estado persistente; cleanup roda na montagem",
          "Substitui o useState; cleanup nunca é chamado",
          "Renderiza condicionalmente; cleanup roda a cada clique",
        ],
        c: 0,
        e: "useEffect executa efeitos colaterais (chamadas API, subscriptions, timers) após o DOM ser atualizado. A função de cleanup (retorno do useEffect) executa antes de cada re-execução do efeito e quando o componente é desmontado, evitando memory leaks.",
        x: "useEffect(() => { const sub = api.subscribe(onData); return () => sub.unsubscribe(); // cleanup: cancela subscription }, []) — subscribe na montagem, unsubscribe na desmontagem.",
      },
      {
        q: "No React, o que é o hook useCallback e quando usá-lo?",
        o: [
          "Memoriza uma função para evitar recriação a cada renderização, útil quando passada como prop a componentes memorizados",
          "Chama uma API",
          "Cria estado global",
          "Substitui useEffect",
        ],
        c: 0,
        e: "useCallback retorna uma versão memorizada da função que só muda se as dependências mudarem. Sem useCallback, cada renderização cria uma nova referência de função, potencialmente causando re-renderizações desnecessárias em componentes filhos que usam React.memo.",
        x: "const handlePress = useCallback(() => { setCount(c => c + 1); }, []); <MemoizedChild onPress={handlePress} /> — MemoizedChild não re-renderiza porque handlePress mantém a mesma referência.",
      },
      {
        q: "No React, para que serve o hook useMemo e como difere de useCallback?",
        o: [
          "useMemo memoriza um VALOR calculado; useCallback memoriza uma FUNÇÃO",
          "São idênticos",
          "useMemo é para efeitos colaterais",
          "useCallback memoriza valores",
        ],
        c: 0,
        e: "useMemo(fn, deps) executa fn e memoriza o RESULTADO (valor). Só recalcula quando deps mudam. useCallback(fn, deps) memoriza a própria FUNÇÃO fn. Na prática: useCallback(fn, deps) === useMemo(() => fn, deps). Use useMemo para cálculos custosos e useCallback para callbacks passados a filhos.",
        x: "const sortedItems = useMemo(() => items.sort((a,b) => a.name.localeCompare(b.name)), [items]); — só reordena quando items muda, não a cada renderização.",
      },
      {
        q: "No React, o que é Context API e quando usá-la em vez de prop drilling?",
        o: [
          "Mecanismo para compartilhar dados entre componentes sem passar props manualmente por cada nível",
          "API de rede do React",
          "Substituto do Redux",
          "Banco de dados local",
        ],
        c: 0,
        e: "Context API resolve o prop drilling (passar props por 5+ níveis). Crie um Context com createContext, forneça valor com Provider no topo, e consuma com useContext nos filhos. Ideal para: tema, lang, auth. Não ideal para estado que muda frequentemente (causa re-renders).",
        x: "const ThemeContext = createContext('light'); <ThemeContext.Provider value='dark'> <App /> </ThemeContext.Provider>. Em qualquer componente filho: const theme = useContext(ThemeContext); // 'dark' — sem passar por props.",
      },
      {
        q: "No React Native, qual a diferença entre StyleSheet e estilos inline?",
        o: [
          "StyleSheet.create otimiza estilos criando-os uma vez; inline cria novo objeto a cada renderização",
          "São idênticos",
          "Inline é mais rápido",
          "StyleSheet só aceita cores",
        ],
        c: 0,
        e: "StyleSheet.create: cria estilos uma vez (referenciados por ID numérico), validação em dev, melhor performance. Inline (style={{color:'red'}}): cria novo objeto a cada render, sem validação. NativeWind/Tailwind: alternativa que compila classes para StyleSheet.",
        x: "const styles = StyleSheet.create({ container: { flex: 1, padding: 16 } }); <View style={styles.container} /> — otimizado. Vs <View style={{ flex: 1, padding: 16 }} /> — novo objeto a cada render.",
      },
      {
        q: "No React, o que é React.memo e quando utilizá-lo?",
        o: [
          "HOC que memoriza o componente, evitando re-render se as props não mudaram",
          "Função para memorizar estado",
          "Substituto do useMemo",
          "Método de cache de API",
        ],
        c: 0,
        e: "React.memo envolve um componente funcional e faz shallow comparison das props. Se as props não mudaram, reutiliza o resultado da renderização anterior. Útil para componentes que re-renderizam frequentemente com as mesmas props. Combinar com useCallback para callbacks.",
        x: "const UserCard = React.memo(({ name, avatar }: Props) => { return <View><Image source={avatar} /><Text>{name}</Text></View>; }); — só re-renderiza se name ou avatar mudarem. Pai re-renderiza → UserCard pula se props iguais.",
      },
      {
        q: "O que é um Custom Hook no React e como criá-lo?",
        o: [
          "Função que começa com 'use' e encapsula lógica reutilizável com hooks, extraindo lógica de componentes",
          "Componente especial do React",
          "Plugin de terceiros",
          "Método de classe",
        ],
        c: 0,
        e: "Custom Hooks são funções que começam com 'use' e podem chamar outros hooks. Extraem lógica stateful reutilizável de componentes. Cada instância tem seu próprio estado isolado. Padrão para: fetch de dados, formulários, timers, media queries.",
        x: "function useDebounce<T>(value: T, delay: number): T { const [debounced, setDebounced] = useState(value); useEffect(() => { const timer = setTimeout(() => setDebounced(value), delay); return () => clearTimeout(timer); }, [value, delay]); return debounced; } — reutilizável em qualquer componente.",
      },
    ],
    Difícil: [
      {
        q: "No React 18+, qual é o comportamento do Concurrent Rendering com Suspense para data fetching e como ele difere do modelo síncrono?",
        o: [
          "React pode pausar a renderização de uma subárvore, mostrar fallback e retomar quando os dados estiverem prontos, sem bloquear a UI",
          "Suspense apenas exibe spinners e não afeta a renderização",
          "Concurrent Rendering bloqueia toda a UI até os dados chegarem",
          "Suspense só funciona com lazy loading de componentes, não com dados",
        ],
        c: 0,
        e: "No Concurrent Rendering, quando um componente 'suspende' (lança uma Promise), o React pausa a renderização daquela subárvore e exibe o fallback do Suspense mais próximo. Enquanto isso, a UI existente permanece interativa. Quando a Promise resolve, o React retoma a renderização sem bloquear o thread principal.",
        x: "<Suspense fallback={<Skeleton />}><UserProfile /></Suspense> — enquanto UserProfile busca dados, Skeleton é exibido. A barra de navegação e outros componentes continuam responsivos durante o loading.",
      },
      {
        q: "No React, o que é o Virtual DOM e como ele otimiza a performance de renderização?",
        o: [
          "Representação em memória do DOM real; React compara diferenças (diffing) e aplica apenas as mudanças necessárias",
          "DOM mais rápido que o real",
          "Cache do HTML",
          "Servidor que renderiza HTML",
        ],
        c: 0,
        e: "O Virtual DOM é uma árvore de objetos JavaScript que espelha o DOM real. Quando o state muda, React cria uma nova árvore virtual, compara com a anterior (diffing/reconciliation) e calcula o mínimo de operações DOM necessárias (batching). Evita manipulações DOM custosas e desnecessárias.",
        x: "State muda: lista de 100 items, 1 foi editado. React compara as 2 árvores virtuais, detecta que apenas item 42 mudou, e faz uma única operação DOM para atualizar o texto daquele único elemento.",
      },
      {
        q: "No React Native, como o bridge (antigo) e o New Architecture (JSI/Fabric/TurboModules) diferem na comunicação JS-nativo?",
        o: [
          "Bridge usa serialização JSON assíncrona; New Architecture usa JSI para acesso direto síncrono a objetos nativos",
          "São idênticos",
          "New Architecture é mais lento",
          "Bridge é síncrono",
        ],
        c: 0,
        e: "Bridge (antigo): JS e nativo em threads separadas, comunicação via mensagens JSON serializadas assíncronas (gargalo em operações frequentes). New Architecture: JSI (JavaScript Interface) permite JS acessar objetos C++ diretamente, sem serialização. Fabric (novo renderer) e TurboModules (módulos nativos lazy-loaded) usam JSI.",
        x: "Bridge: JS envia { type: 'scroll', offset: 100 } como JSON para a thread nativa → 100 mensagens/s de scroll = gargalo. JSI: JS chama nativeModule.scroll(100) diretamente como função C++ → zero serialização, performance nativa.",
      },
      {
        q: "No React, como funciona o Reconciliation (algoritmo de diff) e quais são suas heurísticas?",
        o: [
          "Compara árvores virtual DOM usando heurísticas: elementos de diferentes tipos geram subárvores novas; keys identificam elementos em listas",
          "Compara pixel a pixel",
          "Renderiza tudo do zero",
          "Usa machine learning para otimizar",
        ],
        c: 0,
        e: "Reconciliation: React compara old e new virtual DOM trees. Heurísticas: 1) Elementos de tipos diferentes são subárvores completamente novas (div→span = rebuild). 2) Keys em listas permitem identificar quais items foram adicionados/removidos/reordenados. Sem keys, React re-renderiza toda a lista.",
        x: "Lista sem key: adicionar item no início re-renderiza TODOS os items (React acha que todos mudaram). Com key={item.id}: React sabe que items existentes não mudaram e apenas insere o novo. O(n) vs O(n²).",
      },
      {
        q: "No React, o que são Server Components e como diferem dos Client Components?",
        o: [
          "Server Components renderizam no servidor sem JS no bundle do cliente; Client Components são interativos no navegador",
          "São idênticos",
          "Server Components são mais lentos",
          "Client Components rodam no servidor",
        ],
        c: 0,
        e: "React Server Components (RSC): renderizam no servidor, acesso direto a banco/APIs, zero JS enviado ao cliente (menor bundle). Client Components: marcados com 'use client', têm interatividade (useState, onClick). Composição: Server Components podem importar Client Components, mas não vice-versa.",
        x: "// UserList é Server Component (sem 'use client')\nasync function UserList() { const users = await db.query('SELECT * FROM users'); return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>; } — zero JS no cliente, query direta no banco.",
      },
      {
        q: "O que é React Fiber e como melhorou a renderização do React?",
        o: [
          "Reimplementação do algoritmo de reconciliação que permite renderização incremental e priorização de tarefas",
          "Biblioteca de fibra óptica para React",
          "Framework CSS-in-JS",
          "Compilador JIT para React",
        ],
        c: 0,
        e: "React Fiber (React 16+) substituiu o reconciliador síncrono por um assíncrono. Divide o trabalho de renderização em unidades (fibers) que podem ser pausadas, priorizadas e canceladas. Permite: concurrent rendering, Suspense, transições, renderização interruptível sem bloquear a UI.",
        x: "Antes (Stack Reconciler): renderizar 10.000 itens bloqueia a thread ~500ms → UI congela. Com Fiber: divide em fatias de 5ms, cede controle ao browser para processar inputs entre fatias → UI permanece responsiva durante renderização pesada.",
      },
      {
        q: "Quando usar useReducer em vez de useState no React?",
        o: [
          "Quando o estado é complexo com múltiplas sub-valores ou quando a próxima ação depende do estado anterior",
          "Sempre, pois é mais rápido",
          "Apenas para estado global",
          "Nunca, useState é sempre melhor",
        ],
        c: 0,
        e: "useReducer é prefirível quando: estado complexo (objeto com várias props), lógica de transição clara (switch/case), múltiplas ações (ADD, REMOVE, TOGGLE, RESET), ou quando o próximo estado depende do anterior. Padrão similar ao Redux. dispatch(é estável (não precisa de useCallback).",
        x: "const [state, dispatch] = useReducer(reducer, { items: [], filter: 'all', loading: false }); dispatch({ type: 'ADD_ITEM', payload: item }); dispatch({ type: 'SET_FILTER', payload: 'active' }); — lógica centralizada no reducer, ações descritivas.",
      },
    ],
  },

  // ── Testes de Software ──
  "Testes de Software": {
    Fácil: [
      {
        q: "O que é um teste unitário e qual é seu principal objetivo?",
        o: [
          "Testar uma unidade isolada de código (função/método) para verificar se ela produz o resultado esperado",
          "Testar o sistema inteiro em produção",
          "Testar a interface gráfica manualmente",
          "Testar o desempenho sob carga",
        ],
        c: 0,
        e: "Testes unitários verificam o comportamento de uma unidade isolada (função, método ou classe), usando inputs controlados e comparando com outputs esperados. São rápidos, determinísticos e formam a base da pirâmide de testes.",
        x: "test('soma 2 + 3 retorna 5', () => { expect(soma(2, 3)).toBe(5); }); — testa a função soma isoladamente com valores conhecidos.",
      },
      {
        q: "O que é um teste de integração e como ele difere do teste unitário?",
        o: [
          "Testa a interação entre múltiplos componentes juntos; unitário testa componentes isolados",
          "São idênticos",
          "Integração é mais rápido",
          "Unitário testa mais componentes",
        ],
        c: 0,
        e: "Testes unitários isolam uma função/classe mockando dependências. Testes de integração validam que múltiplos componentes funcionam juntos (ex: API + banco de dados). São mais lentos e complexos que unitários, mas encontram problemas de integração que unitários não detectam.",
        x: "Unitário: testa UserService.create() com banco mockado. Integração: testa POST /api/users que passa por Router → Controller → Service → PostgreSQL real (ou container Docker). Verifica toda a cadeia.",
      },
      {
        q: "O que é a pirâmide de testes e quais são suas camadas?",
        o: [
          "Base: muitos testes unitários (rápidos); meio: integração; topo: poucos testes e2e (lentos)",
          "Apenas testes end-to-end",
          "Apenas testes unitários",
          "Testes manuais na base",
        ],
        c: 0,
        e: "Pirâmide de testes (Martin Fowler): base larga de testes unitários (rápidos, muitos, baratos), camada intermediária de testes de integração, e topo estreito de testes end-to-end (lentos, poucos, caros). Anti-padrão: cone de sorvete (muitos e2e, poucos unitários).",
        x: "Projeto saudável: 500 testes unitários (2 min), 50 testes de integração (5 min), 10 testes e2e (15 min). Anti-padrão: 10 unitários, 5 integração, 200 e2e (3 horas, instbáveis).",
      },
      {
        q: "O que é um teste end-to-end (e2e) e quando utilizá-lo?",
        o: [
          "Testa o fluxo completo do usuário, simulando interações reais do início ao fim",
          "Testa funções isoladas",
          "Testa apenas o backend",
          "Substitui testes unitários",
        ],
        c: 0,
        e: "Testes e2e simulam o comportamento real do usuário: abrir app, clicar botões, preencher formulários, verificar resultados. Ferramentas: Cypress, Playwright, Detox (RN). São lentos e frágeis, por isso devem cobrir apenas fluxos críticos (login, checkout, cadastro).",
        x: "Cypress: cy.visit('/login'); cy.get('#email').type('ana@email.com'); cy.get('#password').type('123'); cy.get('button').click(); cy.url().should('include', '/dashboard'); — simula login real.",
      },
      {
        q: "O que é o framework Jest e quais seus principais recursos?",
        o: [
          "Framework de testes JS/TS com assertions, mocking, coverage e snapshot testing integrados",
          "Linter de código",
          "Bundler de módulos",
          "Framework de UI",
        ],
        c: 0,
        e: "Jest: framework de testes all-in-one do Meta. Inclui: test runner, assertions (expect/toBe), mocking (jest.fn, jest.mock), coverage (--coverage), snapshot testing, watch mode, paralelização. Funciona com TypeScript via ts-jest ou babel.",
        x: "test('cria usuário', () => { const mockSave = jest.fn().mockResolvedValue({ id: 1 }); const service = new UserService(mockSave); await service.create('Ana'); expect(mockSave).toHaveBeenCalledWith({ name: 'Ana' }); });",
      },
      {
        q: "O que são assertions (asserções) em testes automatizados?",
        o: [
          "Verificações que comparam o resultado real com o esperado; se diferem, o teste falha",
          "Comentários no código de teste",
          "Configurações do ambiente",
          "Logs de execução",
        ],
        c: 0,
        e: "Assertions são a parte do teste que verifica se o resultado é o esperado. Se a asserção falhar, o teste falha. Jest: expect(valor).toBe(esperado), .toEqual(), .toBeTruthy(), .toThrow(), .toContain(). Cada teste deve ter pelo menos uma assertion relevante.",
        x: "expect(soma(2, 3)).toBe(5); // passa ✔\nexpect(soma(2, 3)).toBe(6); // falha ✘: Expected 6, Received 5\nexpect(users).toHaveLength(3);\nexpect(response.status).toBe(200);\nexpect(() => divide(1, 0)).toThrow('Divisão por zero');",
      },
      {
        q: "O que são testes determinísticos e por que são importantes?",
        o: [
          "Testes que produzem o mesmo resultado independente de quando ou onde são executados",
          "Testes que rodam apenas uma vez",
          "Testes que dependem de dados de produção",
          "Testes que precisam de conexão com internet",
        ],
        c: 0,
        e: "Testes determinísticos sempre dão o mesmo resultado. Testes não-determinísticos (flaky) falham intermitentemente: dependem de tempo (Date.now), rede, ordem de execução ou estado compartilhado. Flaky tests corroem confiança na suite. Solução: mockar tempo, isolar estado, seed fixo para random.",
        x: "Flaky: test depende de Date.now() → falha à meia-noite quando muda o dia. Determinístico: jest.useFakeTimers(); jest.setSystemTime(new Date('2024-06-15')); → sempre mesmo resultado. Isolamento total.",
      },
    ],
    Médio: [
      {
        q: "Qual é a diferença entre mock, stub e spy em testes de software?",
        o: [
          "Stub retorna valores fixos; Mock verifica interações; Spy envolve a implementação real registrando chamadas",
          "São todos sinônimos",
          "Mock é para APIs e Stub para bancos",
          "Spy é usado apenas em testes end-to-end",
        ],
        c: 0,
        e: "Stub: substitui dependência com retorno fixo (ex.: retorna sempre status 200). Mock: substitui dependência e verifica se foi chamada corretamente (quantas vezes, com quais parâmetros). Spy: mantém a implementação real mas registra todas as chamadas para verificação posterior.",
        x: "const emailStub = { send: () => true }; // Stub: retorno fixo. const emailMock = jest.fn(); expect(emailMock).toHaveBeenCalledWith('ana@email.com'); // Mock: verifica chamada. jest.spyOn(service, 'send'); // Spy: registra mas executa real.",
      },
      {
        q: "O que é TDD (Test-Driven Development) e quais são seus passos?",
        o: [
          "Red-Green-Refactor: escrever teste que falha, implementar código mínimo para passar, refatorar",
          "Testar depois de codificar",
          "Apenas testes manuais",
          "Refatorar antes de testar",
        ],
        c: 0,
        e: "TDD segue 3 passos em ciclo: 1) RED: escreva um teste que falha (o código ainda não existe). 2) GREEN: escreva o código mínimo para o teste passar. 3) REFACTOR: melhore o código mantendo os testes passando. Cada ciclo leva minutos. Garante cobertura desde o início.",
        x: "Red: test('soma 2+3=5') → FAIL (function soma não existe). Green: function soma(a,b) { return a+b; } → PASS. Refactor: extrair para módulo math.ts. Testes continuam passando.",
      },
      {
        q: "O que é code coverage e qual é um percentual considerado bom?",
        o: [
          "Percentual de código executado pelos testes; 80% é geralmente considerado um bom alvo",
          "Número total de testes",
          "Velocidade de execução",
          "Quantidade de bugs encontrados",
        ],
        c: 0,
        e: "Code coverage mede quanto % do código é exercitado pelos testes: statements, branches, functions, lines. 80% é um alvo pragmático. 100% não garante ausência de bugs (cobertura não é qualidade). Mais importante: cobrir caminhos críticos e edge cases.",
        x: "npx jest --coverage: Statements: 85%, Branches: 72%, Functions: 90%, Lines: 85%. O branch coverage de 72% indica que 28% dos caminhos if/else não são testados — foco de melhoria.",
      },
      {
        q: "O que é BDD (Behavior-Driven Development) e como difere de TDD?",
        o: [
          "Foco no comportamento do sistema descrito em linguagem natural (Given/When/Then); TDD foca em código",
          "São idênticos",
          "BDD não usa testes automatizados",
          "TDD descreve comportamento e BDD testa código",
        ],
        c: 0,
        e: "BDD: testes escritos em linguagem de negócio (Given/When/Then ou Dado/Quando/Então). Facilitam comunicação com stakeholders não-técnicos. Ferramentas: Cucumber, Jest (describe/it semantics). TDD: foco na unidade de código. BDD: foco no comportamento do sistema.",
        x: "BDD: Given('usuário logado') When('clica em sair') Then('redireciona para login'). TDD: test('logout volta para /login', () => { logout(); expect(location).toBe('/login'); }). BDD é mais legível para não-devs.",
      },
      {
        q: "O que são fixtures e factories em testes e por que são úteis?",
        o: [
          "Dados predefinidos (fixtures) ou geradores de dados (factories) para setup de testes, evitando duplicação",
          "Ferramentas de deploy",
          "Padrões de arquitetura",
          "Tipos de assertions",
        ],
        c: 0,
        e: "Fixtures: dados estáticos reutilizáveis (JSON, seed data) para setup de testes. Factories: funções que geram objetos de teste com valores padrão e sobrescrevíveis. Evitam duplicação de setup e tornam testes mais legíveis e manuteníveis.",
        x: "const userFactory = (overrides = {}) => ({ id: faker.string.uuid(), name: faker.person.firstName(), email: faker.internet.email(), ...overrides }); const admin = userFactory({ role: 'admin' }); — gera usuário com defaults e permite customizar.",
      },
      {
        q: "O que é isolamento de testes (test isolation) e por que é importante?",
        o: [
          "Cada teste deve ser independente, sem dependar de outros testes ou de estado compartilhado",
          "Testes devem rodar em servidor isolado",
          "Testes devem ser escritos por uma única pessoa",
          "Isolar testes significa deletá-los",
        ],
        c: 0,
        e: "Test isolation: cada teste cria seu próprio estado, executa e limpa após si. Testes não devem depender da ordem de execução nem de estado deixado por outros. Violação: teste B só passa se teste A rodar antes. Ferramentas: beforeEach/afterEach, cleanup automático.",
        x: "beforeEach(() => { db = createTestDatabase(); }); afterEach(() => { db.destroy(); }); — cada teste começa com banco limpo. Sem isso: teste 'criar usuário' polui o estado para teste 'listar usuários' (deveria estar vazio).",
      },
      {
        q: "O que é CI/CD com testes automatizados no pipeline?",
        o: [
          "Integração e entrega contínua onde testes rodam automaticamente a cada push, bloqueando merge se falharem",
          "Compilador de código",
          "Ferramenta de design",
          "Banco de dados de testes",
        ],
        c: 0,
        e: "CI (Continuous Integration): a cada push, testes rodam automaticamente (unit, integration, lint). Se falharem, PR não pode ser mergeado. CD (Continuous Delivery/Deployment): após testes passarem, deploy automático para staging/produção. Ferramentas: GitHub Actions, GitLab CI, Jenkins.",
        x: "GitHub Actions: push → lint (1min) → unit tests (2min) → integration tests (5min) → build (2min) → deploy staging (1min). Se qualquer step falhar, pipeline para e PR fica com ✘ vermelho. Só merge com ✔ verde.",
      },
    ],
    Difícil: [
      {
        q: "Na estratégia de testes 'Contract Testing' entre microsserviços, como o Pact framework garante que producer e consumer estejam compatíveis?",
        o: [
          "Consumer gera um contrato com requisições esperadas; Producer verifica que suas respostas atendem ao contrato",
          "Producer define a API e Consumer adapta",
          "Ambos rodam o mesmo teste end-to-end",
          "Usa snapshots de JSON para comparação manual",
        ],
        c: 0,
        e: "No Pact, o Consumer define expectativas (quais requests fará e quais respostas espera) que são salvas como 'contratos' (Pact files). O Producer roda esses contratos contra sua API real, verificando que todas as respostas atendem às expectativas. Contratos são versionados e publicados em um Pact Broker.",
        x: "Consumer cria contrato: GET /users/1 espera { name: string, email: string }. Producer testa: roda GET /users/1 na sua API e verifica que a resposta inclui name e email. Se Producer remover o campo email, o contrato do Consumer falha.",
      },
      {
        q: "O que são property-based tests e como diferem de example-based tests?",
        o: [
          "Geram centenas de inputs aleatórios testando propriedades matemáticas do código, em vez de exemplos fixos",
          "Testes com configurações de ambiente",
          "Testes de propriedades CSS",
          "Testes de performance",
        ],
        c: 0,
        e: "Example-based: você escolhe inputs específicos (soma(2,3) === 5). Property-based: você define propriedades que devem valer para QUALQUER input válido (ex: sort(arr).length === arr.length). O framework (fast-check, QuickCheck) gera centenas de inputs aleatórios e verifica a propriedade.",
        x: "fc.assert(fc.property(fc.array(fc.integer()), (arr) => { const sorted = sort(arr); return sorted.length === arr.length && isSorted(sorted); })); — testa com 100 arrays aleatórios. Encontra edge cases que você não pensaria.",
      },
      {
        q: "O que é mutation testing e como ele avalia a qualidade dos testes?",
        o: [
          "Introduz mutações (bugs) no código e verifica se os testes detectam; mutações não detectadas indicam testes fracos",
          "Testes que mudam frequentemente",
          "Testes de modificação de banco",
          "Testes genéticos",
        ],
        c: 0,
        e: "Mutation testing modifica o código fonte (troca > por <, remove return, inverte booleanos) e roda os testes. Se os testes PASSAM com o código mutado, significa que os testes são fracos (não detectam o bug). Mutation score = mutantes mortos/total. Complementa code coverage.",
        x: "Mutação: trocar 'if (age >= 18)' por 'if (age > 18)'. Se testes passam, nenhum teste verifica o caso age=18 (boundary). Ferramentas: Stryker (JS/TS), PITest (Java). Mutation score alvo: >80%.",
      },
      {
        q: "O que é snapshot testing e quais são seus prós e contras?",
        o: [
          "Captura a saída renderizada e compara com versão salva; detecta mudanças inesperadas mas pode gerar falsos positivos",
          "Screenshot da tela",
          "Backup do banco de dados",
          "Teste de performance",
        ],
        c: 0,
        e: "Snapshot testing: primeira execução salva a saída (JSON/HTML). Execuções seguintes comparam com o snapshot salvo. Se diferir, teste falha. Prós: detecta regressões visuais, fácil de criar. Contras: falsos positivos frequentes, snapshots grandes são ignorados, cultura de 'update all'.",
        x: "test('renders correctly', () => { const tree = renderer.create(<UserCard name='Ana' />).toJSON(); expect(tree).toMatchSnapshot(); }); — gera arquivo .snap. Se UserCard mudar, teste falha até rodar: jest --updateSnapshot.",
      },
      {
        q: "O que é o conceito de test doubles e como se aplicam na arquitetura hexagonal?",
        o: [
          "Substitutos para dependências reais nos testes; na hexa, ports são facilmente substituídos por adapters falsos",
          "Testes executados duas vezes",
          "Cópias do banco de produção",
          "Duplicação de código de teste",
        ],
        c: 0,
        e: "Test doubles (termo genérico para mocks, stubs, fakes, spies, dummies) substituem dependências reais em testes. Na arquitetura hexagonal, ports (interfaces) permitem injetar adapters falsos facilmente. Fakes: implementação funcional simplificada (ex: InMemoryRepository).",
        x: "interface UserRepo { save(u: User): Promise<void>; } class InMemoryUserRepo implements UserRepo { users = []; async save(u) { this.users.push(u); } } — fake completo para testes sem banco. Mesma interface, implementação trivial.",
      },
      {
        q: "O que é Chaos Engineering e como difere de testes tradicionais?",
        o: [
          "Prática de injetar falhas controladas em produção para verificar resiliência do sistema",
          "Testes unitários com dados aleatórios",
          "Testes de performance com carga alta",
          "Debugging em ambiente local",
        ],
        c: 0,
        e: "Chaos Engineering: 'quebre coisas de propósito para provar que o sistema resiste'. Injeta falhas controladas: matar instâncias (Chaos Monkey), latência artificial, partições de rede. Verifica se redundancy, failover e graceful degradation funcionam. Difere de testes: roda em produção com tráfego real.",
        x: "Netflix Chaos Monkey: mata instâncias EC2 aleatórias em produção durante horário comercial. Se o sistema não se recuperar automáticamente, há um problema de resiliência antes que um incidente real ocorra.",
      },
      {
        q: "O que são testes de carga e performance e quais métricas monitorar?",
        o: [
          "Simulam alto volume de usuários para medir throughput, latência, error rate e identificar gargalos",
          "Testes de funcionalidade com muitos dados",
          "Testes de UI em diferentes resoluções",
          "Testes de segurança com ataques DDoS",
        ],
        c: 0,
        e: "Load testing: simula carga esperada. Stress testing: aumenta além do limite. Spike testing: picos súbitos. Soak testing: carga constante por longo período. Métricas: throughput (req/s), latência (p50, p95, p99), error rate, CPU/memória. Ferramentas: k6, Artillery, JMeter, Locust.",
        x: "k6: 100 VUs (virtual users) durante 5 min. Resultado: p95 latência = 250ms, throughput = 500 req/s, error rate = 0.1%. Stress: 1000 VUs → p95 sobe para 2s, errors 5% → gargalo no banco (pool de conexões esgotado).",
      },
    ],
  },
};
