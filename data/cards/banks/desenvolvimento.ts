import type { SeedCard } from "../generator";

type UserLevel = "Fácil" | "Médio" | "Difícil";

// ─── Desenvolvimento · 12 categorias × 3 níveis × 7 questões (rodada 4/30) ───

const desenvolvimentoBankBase: Record<string, Record<UserLevel, SeedCard[]>> = {
  // ── Algoritmos e Estruturas de Dados ──
  "Algoritmos e Estruturas de Dados": {
    Fácil: [
      {
        q: "Qual estrutura de dados segue o princípio FIFO (primeiro a entrar, primeiro a sair)?",
        o: ["Fila (Queue)", "Pilha (Stack)", "Árvore Binária", "Grafo"],
        c: 0,
        e: "A Fila (Queue) segue o princípio FIFO: o primeiro elemento inserido é o primeiro a ser removido. Operações básicas são enqueue (inserir no final) e dequeue (remover do início).",
        x: "Fila de impressão: documento A entra primeiro, depois B e C. A impressora processa A primeiro, depois B, depois C — exatamente na ordem de chegada.",
      },
      {
        q: "Qual estrutura de dados usa o princípio LIFO (last in, first out)?",
        o: ["Pilha (Stack)", "Fila (Queue)", "Lista Ligada", "Hash Table"],
        c: 0,
        e: "A Pilha segue LIFO: o último elemento inserido é o primeiro removido. Operações: push (inserir no topo) e pop (remover do topo). Usada em chamadas de funções (call stack), undo/redo e avaliação de expressões.",
        x: "Empilhe pratos: A, B, C. Para tirar, só consegue pegar C primeiro (topo), depois B, depois A. Ctrl+Z (undo) funciona como pilha: a última ação é desfeita primeiro.",
      },
      {
        q: "Qual é a complexidade de tempo para acessar um elemento por índice em um array?",
        o: ["O(1)", "O(n)", "O(log n)", "O(n²)"],
        c: 0,
        e: "Arrays armazenam elementos em posições contíguas de memória. Como cada posição tem tamanho fixo, o endereço do elemento i é calculado diretamente: base + (i × tamanho). Isso permite acesso em tempo constante O(1), independente do tamanho do array.",
        x: "Array com 1 milhão de elementos: arr[999999] acessa diretamente o último elemento tão rápido quanto arr[0]. Mas inserir no início é O(n) porque todos os elementos precisam ser deslocados.",
      },
      {
        q: "O que é uma Lista Ligada (Linked List) e qual sua vantagem sobre arrays?",
        o: [
          "Estrutura onde cada nó aponta para o próximo; inserção/remoção em O(1) sem deslocar elementos",
          "Array mais rápido",
          "Lista que ordena automaticamente",
          "Tipo de árvore binária",
        ],
        c: 0,
        e: "Lista Ligada: cada nó contém um valor e um ponteiro para o próximo nó. Inserção/remoção no início é O(1) (sem deslocamento). Desvantagem: acesso por índice é O(n) (percorrer nó a nó). Arrays: acesso O(1), inserção O(n).",
        x: "Array: inserir no início desloca todos os 100 mil itens. Lista Ligada: cria nó novo e aponta para o antigo head — O(1). Mas acessar o item 50.000 na lista requer percorrer 50 mil nós.",
      },
      {
        q: "O que é uma Árvore Binária de Busca (BST) e qual sua propriedade principal?",
        o: [
          "Árvore onde filhos à esquerda são menores e à direita são maiores que o nó pai",
          "Árvore com exatamente dois filhos por nó",
          "Lista ordenada em formato de árvore",
          "Estrutura FIFO hierárquica",
        ],
        c: 0,
        e: "BST: para cada nó, todos os valores na subárvore esquerda são menores e na direita são maiores. Busca, inserção e remoção são O(log n) quando balanceada. Permite busca eficiente, in-order traversal retorna elementos em ordem crescente.",
        x: "BST com raiz 10: esquerda 5 (esquerda 3, direita 7), direita 15 (esquerda 12, direita 20). Buscar 7: 10→5→7 (3 passos). In-order: 3, 5, 7, 10, 12, 15, 20.",
      },
      {
        q: "O que é uma busca binária e qual sua complexidade?",
        o: [
          "Algoritmo que divide o array ordenado ao meio a cada passo; O(log n)",
          "Percorrer todo o array; O(n)",
          "Busca em lista ligada; O(n²)",
          "Busca em grafo; O(V+E)",
        ],
        c: 0,
        e: "Busca binária funciona em arrays ORDENADOS. Compara o elemento do meio: se igual, encontrou; se menor, busca na metade esquerda; se maior, busca na metade direita. Elimina metade dos elementos a cada passo → O(log n). Array desordenado requer busca linear O(n).",
        x: "Array [2,5,8,12,16,23,38,45] — buscar 23: meio=12 (menor → direita), meio=23 (encontrou!). 2 passos em vez de 6 na busca linear. Para 1M de itens: ~20 passos vs 1M.",
      },
      {
        q: "O que é um grafo e qual a diferença entre dirigido e não-dirigido?",
        o: [
          "Estrutura com nós e arestas; dirigido tem direção nas arestas, não-dirigido não tem",
          "Tipo de árvore binária",
          "Array bidimensional",
          "Lista com ponteiros",
        ],
        c: 0,
        e: "Grafo: conjunto de vértices (nós) conectados por arestas. Dirigido: arestas têm direção (A→B não implica B→A). Não-dirigido: conexão bilateral. Ponderado: arestas têm peso (distância). Usos: GPS, redes sociais, dependências.",
        x: "Rede social (não-dirigido): Ana-Bob = amizade mútua. Twitter (dirigido): Ana→Bob = Ana segue Bob, não implica Bob seguir Ana. GPS (ponderado): São Paulo→5km→Guarulhos.",
      },
    ],
    Médio: [
      {
        q: "Qual é a complexidade de tempo no pior caso para buscar um elemento em uma árvore binária de busca (BST) desbalanceada?",
        o: ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
        c: 0,
        e: "Em uma BST desbalanceada, os nós podem formar uma lista encadeada (todos à direita ou todos à esquerda), fazendo com que a busca percorra todos os n nós no pior caso, resultando em O(n). BSTs balanceadas (AVL, Red-Black) garantem O(log n).",
        x: "Inserindo 1, 2, 3, 4, 5 em sequência numa BST, cada nó fica à direita do anterior (lista). Buscar 5 requer percorrer todos os 5 nós: O(n).",
      },
      {
        q: "Qual algoritmo de ordenação tem complexidade O(n log n) no caso médio e é baseado em divisão e conquista?",
        o: ["Merge Sort", "Bubble Sort", "Selection Sort", "Insertion Sort"],
        c: 0,
        e: "O Merge Sort divide o array ao meio recursivamente até ter sub-arrays de 1 elemento, depois combina (merge) os sub-arrays em ordem. Complexidade: O(n log n) em todos os casos (melhor, médio e pior). Desvantagem: usa O(n) de espaço extra.",
        x: "[38, 27, 43, 3] → divide em [38,27] e [43,3] → divide em [38],[27],[43],[3] → merge: [27,38],[3,43] → merge final: [3,27,38,43]. Número de operações: n × log₂(n).",
      },
      {
        q: "O que é uma Hash Table e qual é sua complexidade média para busca?",
        o: [
          "Estrutura que mapeia chaves a valores usando função hash, com busca O(1) na média",
          "Array ordenado com busca O(log n)",
          "Árvore binária com busca O(n)",
          "Lista ligada com busca O(n)",
        ],
        c: 0,
        e: "Hash Table usa uma função hash para converter chaves em índices de um array. Busca, inserção e remoção são O(1) na média. No pior caso (muitas colisões), degenera para O(n). JavaScript Objects e Maps são implementados como hash tables.",
        x: "const mapa = new Map(); mapa.set('ana', 28); mapa.get('ana') → 28 em O(1). A função hash converte 'ana' em índice 42 do array interno, acesso direto.",
      },
      {
        q: "O que é o algoritmo Quick Sort e qual sua complexidade no caso médio?",
        o: [
          "Algoritmo de divisão e conquista que escolhe um pivô e particiona o array; O(n log n) na média",
          "Algoritmo que ordena comparando pares adjacentes; O(n²)",
          "Algoritmo que encontra o mínimo a cada passo; O(n log n)",
          "Algoritmo baseado em heap; O(n)",
        ],
        c: 0,
        e: "Quick Sort escolhe um pivô, particiona o array em menores e maiores que o pivô, e repete recursivamente. Caso médio: O(n log n). Pior caso: O(n²) quando pivô é sempre o menor/maior. Na prática é o mais rápido. In-place (sem memória extra).",
        x: "[3,6,8,10,1,2,1]: pivô=6 → [3,1,2,1] + 6 + [8,10]. Recursão nos sub-arrays. Pior caso: array já ordenado com pivô no extremo → cada partição remove apenas 1 elemento → O(n²).",
      },
      {
        q: "O que é uma Heap (fila de prioridade) e para que é usada?",
        o: [
          "Árvore binária completa onde o pai é sempre maior (max-heap) ou menor (min-heap) que os filhos",
          "Hash table com prioridade",
          "Fila FIFO com prioridade",
          "Array ordenado",
        ],
        c: 0,
        e: "Heap é uma árvore binária completa que satisfaz a propriedade heap: em min-heap, o pai é menor que os filhos (raiz = mínimo). Inserção e remoção são O(log n). Usada em filas de prioridade, Dijkstra, heap sort e agendamento de tarefas.",
        x: "Min-heap: [1, 3, 5, 7, 9]. Inserir 2: coloca no final e faz sift-up até posição correta → [1, 2, 5, 7, 9, 3]. Extrair mínimo (1): troca raiz com último, remove, sift-down.",
      },
      {
        q: "O que é uma Árvore AVL e qual problema ela resolve?",
        o: [
          "Árvore binária de busca auto-balanceada que garante O(log n) em todas as operações",
          "Array circular",
          "Hash table com encadeamento",
          "Lista duplamente ligada",
        ],
        c: 0,
        e: "AVL é uma BST que mantém o fator de balanceamento (diferença de altura entre subárvores) em {-1, 0, 1} para cada nó. Após inserção/remoção, rotações (simples ou dupla) rebalanceiam a árvore. Garante O(log n) no pior caso, ao contrário de BST simples.",
        x: "Inserir 1,2,3 em BST: 1→2→3 (lista, busca O(n)). Em AVL: após inserir 3, rotação esquerda → 2 (raiz), 1 (esquerda), 3 (direita). Busca O(log n) garantida.",
      },
      {
        q: "O que é o algoritmo de ordenação Counting Sort e quando é mais eficiente?",
        o: [
          "Algoritmo O(n+k) que conta ocorrências; eficiente quando o range de valores (k) é pequeno",
          "Algoritmo O(n log n) geral",
          "Algoritmo O(n²) por comparação",
          "Algoritmo recursivo de divisão",
        ],
        c: 0,
        e: "Counting Sort não compara elementos: conta quantas vezes cada valor aparece e reconstrói o array. Complexidade O(n+k), onde k é o range dos valores. Ideal quando k é pequeno relativo a n. Não funciona bem com floats ou strings longas.",
        x: "Ordenar notas [3,1,2,3,1,2,3]: contagem=[0,2,2,3]. Reconstrói: [1,1,2,2,3,3,3]. 7 passos (n=7, k=3). Merge Sort faria 7×log7 ≈ 20 operações por comparação.",
      },
    ],
    Difícil: [
      {
        q: "Em um algoritmo de Dijkstra usando min-heap (priority queue), qual é a complexidade de tempo para um grafo com V vértices e E arestas?",
        o: ["O((V + E) log V)", "O(V²)", "O(V × E)", "O(E log E)"],
        c: 0,
        e: "Com min-heap, cada vértice é extraído uma vez — O(V log V). Cada aresta pode causar uma operação decrease-key — O(E log V). Total: O((V + E) log V). Sem heap (array), a complexidade seria O(V²), melhor para grafos densos.",
        x: "Grafo com 1000 vértices e 5000 arestas: com heap → O(6000 × 10) ≈ 60.000 operações. Sem heap → O(1.000.000) operações. Heap é ~16x mais rápido neste caso.",
      },
      {
        q: "O que é programação dinâmica e em quais problemas ela é mais eficaz que a abordagem recursiva ingrénua?",
        o: [
          "Técnica que armazena resultados de subproblemas para evitar recálculo; eficaz em problemas com subproblemas sobrepostos",
          "Método de alocação de memória",
          "Tipo de paralelismo",
          "Linguagem de programação",
        ],
        c: 0,
        e: "Programação dinâmica resolve problemas dividindo-os em subproblemas e armazenando resultados (memoization ou tabulation) para evitar recálculo. Eficaz quando há subproblemas sobrepostos (mesma subcomputação repetida) e subestrutura ótima. Exemplos: Fibonacci, mochila, LCS.",
        x: "Fibonacci recursivo: fib(50) faz 2⁵⁰ chamadas (exponencial). Com memoization: fib(50) faz 50 chamadas (linear). const memo = {}; function fib(n) { if (memo[n]) return memo[n]; memo[n] = fib(n-1) + fib(n-2); return memo[n]; }",
      },
      {
        q: "Qual é a diferença entre BFS (Breadth-First Search) e DFS (Depth-First Search) em grafos?",
        o: [
          "BFS explora vizinhos nível a nível (usa fila); DFS vai o mais fundo possível primeiro (usa pilha)",
          "São idênticos",
          "DFS é mais rápido",
          "BFS só funciona em árvores",
        ],
        c: 0,
        e: "BFS (Busca em Largura): explora todos os vizinhos do nó atual antes de ir para o próximo nível. Usa fila (FIFO). Encontra menor caminho em grafos não-ponderados. DFS (Busca em Profundidade): segue um caminho até o fim antes de retroceder. Usa pilha (LIFO) ou recursão. Usado em detecção de ciclos e ordenação topológica.",
        x: "Grafo: A-B, A-C, B-D, C-D. BFS a partir de A: A → B,C → D (nível por nível). DFS a partir de A: A → B → D → (volta) → C (desce ao máximo antes de voltar).",
      },
      {
        q: "O que é o algoritmo A* (A-star) e em que ele difere do Dijkstra?",
        o: [
          "Algoritmo que usa heurística para estimar distância ao destino, focando a busca na direção certa",
          "Versão mais lenta do Dijkstra",
          "Algoritmo que só funciona em grafos sem peso",
          "Dijkstra com backtracking",
        ],
        c: 0,
        e: "A* usa f(n) = g(n) + h(n): g(n) = custo real do início até n, h(n) = heurística estimando custo de n ao destino. Dijkstra é A* com h(n)=0. A heurística direciona a busca, explorando menos nós. A* é ótimo se h(n) for admissível (nunca superestimar).",
        x: "GPS: Dijkstra explora em todas as direções (círculo expandindo). A* com heurística de distância euclidiana foca na direção do destino, visitando ~5x menos nós para encontrar o caminho mínimo.",
      },
      {
        q: "O que é a notação Big-O e qual a diferença entre O(n), O(n²) e O(log n)?",
        o: [
          "Notação que descreve o crescimento do tempo/espaço em função do input; O(log n) < O(n) < O(n²)",
          "Mede o tempo exato em milissegundos",
          "Só se aplica a algoritmos de ordenação",
          "Análise de memória RAM",
        ],
        c: 0,
        e: "Big-O descreve o limite superior de crescimento. O(1): constante. O(log n): busca binária — cada passo elimina metade. O(n): percorrer lista. O(n log n): merge sort. O(n²): comparar todos com todos. O(2^n): subsets. Para n=1M: O(n)=1M ops, O(n²)=1T ops.",
        x: "n=1.000.000: O(log n)=20 ops, O(n)=1M ops, O(n log n)=20M ops, O(n²)=1T ops. Um algoritmo O(n²) com n=1M demoraria ~11 dias; O(n log n) demoraria 0.2 segundos.",
      },
      {
        q: "O que é o Trie (Prefix Tree) e para que é usado?",
        o: [
          "Árvore onde cada nó representa um caractere, otimizada para busca por prefixo em strings",
          "Tipo de hash table",
          "Árvore binária balanceada",
          "Grafo acíclico para números",
        ],
        c: 0,
        e: "Trie armazena strings caractere por caractere nos nós. Busca por prefixo é O(m) onde m = tamanho do prefixo. Ideal para autocomplete, spell check, dicionários e roteamento IP. Consome mais memória que hash table mas é superior para operações com prefixo.",
        x: "Trie com 'car', 'card', 'cat': raiz→c→a→r(✓)→d(✓), raiz→c→a→t(✓). Buscar prefixo 'ca': 2 passos → retorna ['car','card','cat']. Hash table precisaria iterar todas as chaves.",
      },
      {
        q: "O que é uma Red-Black Tree e como se compara com AVL?",
        o: [
          "Árvore auto-balanceada com garantias mais relaxadas que AVL; inserção mais rápida, busca ligeiramente mais lenta",
          "Árvore com nós coloridos sem balanceamento",
          "Hash table com cores",
          "Grafo bicolorido",
        ],
        c: 0,
        e: "Red-Black Tree: BST auto-balanceada com regras de coloração (nós vermelhos/pretos). Menos estrita que AVL: permite diferença de altura 2x (vs 1 da AVL). Resultado: menos rotações em inserção/remoção. Usada no Java TreeMap, C++ std::map e Linux kernel.",
        x: "AVL: busca ~1.44×log n (mais curta). Red-Black: busca ~2×log n (pode ser mais alta). Mas inserção AVL: até log n rotações; Red-Black: no máximo 2 rotações. Para muitas escritas: Red-Black. Para muitas leituras: AVL.",
      },
    ],
  },

  // ── APIs REST e GraphQL ──
  "APIs REST e GraphQL": {
    Fácil: [
      {
        q: "Qual método HTTP é utilizado para criar um novo recurso em uma API REST?",
        o: ["POST", "GET", "PUT", "DELETE"],
        c: 0,
        e: "O método POST é usado para criar novos recursos. Ele envia dados no corpo da requisição para o servidor, que cria o recurso e retorna normalmente o status 201 (Created) com a URL do novo recurso no header Location.",
        x: 'POST /api/users com body { "name": "Ana", "email": "ana@email.com" } → resposta 201 Created com Location: /api/users/42.',
      },
      {
        q: "Qual método HTTP é idempotente e usado para atualizar completamente um recurso existente?",
        o: ["PUT", "POST", "PATCH", "DELETE"],
        c: 0,
        e: "PUT é idempotente: enviar o mesmo PUT várias vezes produz o mesmo resultado. Ele substitui o recurso inteiro com os dados enviados. Diferente de PATCH, que altera parcialmente, e POST, que cria novo recurso (não idempotente).",
        x: 'PUT /api/users/42 com body { "name": "Ana Silva", "email": "ana@email.com" } — substitui todos os dados do usuário 42. Se repetir a chamada, o resultado é o mesmo.',
      },
      {
        q: "O que significa o código de status HTTP 404?",
        o: [
          "Not Found — o recurso solicitado não foi encontrado",
          "Sucesso na operação",
          "Erro interno do servidor",
          "Acesso não autorizado",
        ],
        c: 0,
        e: "HTTP 404 Not Found indica que o servidor não encontrou o recurso solicitado. Classes de status: 2xx = sucesso (200 OK, 201 Created), 4xx = erro do cliente (400 Bad Request, 401 Unauthorized, 404 Not Found), 5xx = erro do servidor (500 Internal Server Error).",
        x: "GET /api/users/99999 → 404 Not Found (usuário não existe). GET /api/users/1 → 200 OK com dados do usuário.",
      },
      {
        q: "O que é uma API e para que serve?",
        o: [
          "Interface de programação que permite comunicação entre sistemas diferentes",
          "Linguagem de programação",
          "Banco de dados",
          "Protocolo de rede",
        ],
        c: 0,
        e: "API (Application Programming Interface) define um contrato de comunicação entre sistemas. Expõe funcionalidades de um serviço sem revelar sua implementação interna. APIs HTTP/REST são as mais comuns, mas existem APIs de bibliotecas, SO e hardware.",
        x: "A API do Stripe expõe POST /v1/charges para processar pagamentos. Você não precisa saber como o Stripe processa internamente — só segue o contrato da API.",
      },
      {
        q: "O que significa o verbo HTTP GET e quando usá-lo?",
        o: [
          "Solicita a leitura/busca de um recurso sem alterá-lo",
          "Cria um novo recurso",
          "Deleta um recurso",
          "Atualiza um recurso",
        ],
        c: 0,
        e: "GET é idempotente e seguro (safe): não modifica dados no servidor. Usado para buscar/ler recursos. Parâmetros vão na URL (query string). Respostas podem ser cacheadas. Não deve ter body na requisição.",
        x: "GET /api/users → retorna lista de usuários. GET /api/users/42 → retorna dados do usuário 42. GET /api/users?status=active → filtra por query string.",
      },
      {
        q: "O que é JSON e por que é o formato mais usado em APIs?",
        o: [
          "Formato leve de troca de dados baseado em texto, legível por humanos e fácil de parsear",
          "Linguagem de programação",
          "Banco de dados",
          "Protocolo de rede",
        ],
        c: 0,
        e: "JSON (JavaScript Object Notation): formato texto com pares chave-valor, arrays e tipos primitivos. Leve comparado a XML, suportado nativamente em JavaScript (JSON.parse/stringify) e na maioria das linguagens. Tipo MIME: application/json.",
        x: '{"id": 1, "name": "Ana", "skills": ["TypeScript", "React"], "active": true}. JavaScript: const obj = JSON.parse(jsonString); const str = JSON.stringify(obj);',
      },
      {
        q: "Qual é a diferença entre os métodos HTTP PATCH e PUT?",
        o: [
          "PUT substitui o recurso inteiro; PATCH atualiza parcialmente apenas os campos enviados",
          "São idênticos",
          "PATCH cria e PUT atualiza",
          "PUT é parcial e PATCH é completo",
        ],
        c: 0,
        e: "PUT: envia a representação completa do recurso (campos omitidos são removidos). PATCH: envia apenas os campos que devem mudar. PUT é idempotente por padrão. PATCH pode ou não ser idempotente dependendo da implementação.",
        x: 'Usuário { name: "Ana", email: "ana@x.com", age: 25 }. PUT { name: "Ana S." } → email e age removidos. PATCH { name: "Ana S." } → só name muda, email e age permanecem.',
      },
    ],
    Médio: [
      {
        q: "Qual é a principal vantagem do GraphQL sobre REST quando o cliente precisa de dados de múltiplos recursos relacionados?",
        o: [
          "Buscar todos os dados necessários em uma única requisição, evitando over-fetching e under-fetching",
          "Maior velocidade de rede",
          "Melhor cache no navegador",
          "Menor uso de memória no servidor",
        ],
        c: 0,
        e: "No REST, buscar um usuário com seus posts e comentários exige 3 chamadas (under-fetching). No GraphQL, uma única query especifica exatamente os campos desejados de múltiplos tipos, retornando tudo em uma resposta. Também evita over-fetching ao não trazer campos desnecessários.",
        x: "query { user(id: 1) { name, posts { title, comments { text } } } } — uma única requisição retorna nome do usuário, títulos dos posts e textos dos comentários.",
      },
      {
        q: "O que é paginação em APIs REST e quais são as duas abordagens mais comuns?",
        o: [
          "Offset-based (page/limit) e Cursor-based (after/first); dividem respostas grandes em páginas",
          "Compressão e cache",
          "Autenticação e autorização",
          "Criptografia e hashing",
        ],
        c: 0,
        e: "Offset-based: GET /items?page=3&limit=20 (pula 40, retorna 20). Simples mas inconsistente com inserções. Cursor-based: GET /items?after=abc123&first=20 (retorna 20 após o cursor abc123). Consistente e eficiente para grandes datasets, usado por Facebook e GitHub.",
        x: "Offset: /posts?page=100&limit=20 — banco faz OFFSET 1980 (lento em tabelas grandes). Cursor: /posts?after=eyJpZCI6MTk4MH0&first=20 — banco faz WHERE id > 1980 LIMIT 20 (rápido com índice).",
      },
      {
        q: "O que é rate limiting em APIs e por que é importante?",
        o: [
          "Limitar o número de requisições por cliente em um período, protegendo contra abuso e sobrecarga",
          "Limitar o tamanho do payload",
          "Limitar o número de rotas",
          "Limitar conexões WebSocket",
        ],
        c: 0,
        e: "Rate limiting restringe quantas requisições um cliente pode fazer por período (ex: 100 req/min). Protege contra DDoS, abuso de API, e garante fairness entre clientes. Retorna HTTP 429 Too Many Requests quando o limite é excedido.",
        x: "Headers de resposta: X-RateLimit-Limit: 100, X-RateLimit-Remaining: 23, X-RateLimit-Reset: 1625097600. Cliente sabe que pode fazer mais 23 requests antes do reset.",
      },
      {
        q: "O que é versionamento de API e quais são as abordagens comuns?",
        o: [
          "Mecanismo para evoluir a API sem quebrar clientes existentes; via URL, header ou query param",
          "Controle de versão do código-fonte",
          "Backup de endpoints",
          "Cache de requisições",
        ],
        c: 0,
        e: "Versionamento permite manter versões antigas funcionando ao lançar novas. Via URL: /api/v1/users, /api/v2/users. Via header: Accept: application/vnd.api.v2+json. Via query: /api/users?version=2. URL path é o mais comum e explícito.",
        x: "v1: GET /api/v1/users → { name: 'Ana Silva' }. v2: GET /api/v2/users → { firstName: 'Ana', lastName: 'Silva' }. Ambas coexistem. Clientes migram gradualmente.",
      },
      {
        q: "O que é paginação em APIs REST e por que é importante?",
        o: [
          "Dividir grandes conjuntos de dados em páginas menores para evitar respostas enormes",
          "Ordenar resultados por data",
          "Cachear respostas da API",
          "Comprimir dados da resposta",
        ],
        c: 0,
        e: "Paginação evita retornar milhões de registros de uma vez. Offset-based: ?page=2&limit=20. Cursor-based: ?cursor=abc123&limit=20 (mais eficiente para dados que mudam). Resposta inclui total, hasNext, nextCursor.",
        x: "GET /api/users?page=3&limit=20 → retorna usuários 41-60 de 500 totais. Response: { data: [...], meta: { total: 500, page: 3, limit: 20, totalPages: 25 } }.",
      },
      {
        q: "O que é CORS (Cross-Origin Resource Sharing) e por que é necessário?",
        o: [
          "Mecanismo que permite ou bloqueia requisições HTTP entre domínios diferentes via headers",
          "Tipo de criptografia",
          "Protocolo de autenticação",
          "Compressão de dados",
        ],
        c: 0,
        e: "Browsers bloqueiam requisições cross-origin por segurança (Same-Origin Policy). CORS permite o servidor indicar quais origens podem acessá-lo via headers: Access-Control-Allow-Origin, Access-Control-Allow-Methods. Requisições complexas fazem preflight (OPTIONS).",
        x: "Frontend em localhost:3000 chama API em api.com. Browser envia OPTIONS (preflight). API responde: Access-Control-Allow-Origin: http://localhost:3000, Allow-Methods: GET,POST. Browser permite a requisição.",
      },
      {
        q: "O que é autenticação via JWT (JSON Web Token) em APIs?",
        o: [
          "Token assinado contendo claims do usuário, enviado no header Authorization para autenticação stateless",
          "Cookie de sessão",
          "API key no header",
          "Autenticação básica com senha",
        ],
        c: 0,
        e: "JWT: header.payload.signature codificados em base64. Header (alg, type), Payload (sub, exp, iat, claims customizados), Signature (HMAC ou RSA). Enviado como: Authorization: Bearer <token>. Stateless: servidor não mantém sessão, valida pela assinatura.",
        x: "Login: POST /auth/login {email, password} → {token: 'eyJ...'}. Requisições seguintes: GET /api/users, Header: Authorization: Bearer eyJ... Servidor valida assinatura e extrai userId do payload.",
      },
    ],
    Difícil: [
      {
        q: "Em uma API GraphQL, como o DataLoader resolve o problema N+1 de queries ao banco de dados?",
        o: [
          "Agrupa múltiplas chaves em uma única query batch usando deduplicação e coalescing por tick do event loop",
          "Usa cache de segundo nível no servidor",
          "Limita o número de resolvers executados",
          "Converte GraphQL em REST internamente",
        ],
        c: 0,
        e: "O DataLoader coleta todas as chaves requisitadas dentro de um mesmo tick do event loop e dispara uma única query batch (ex.: WHERE id IN (1,2,3)) em vez de N queries individuais. Também deduplica chaves repetidas e cacheia resultados por request.",
        x: "Sem DataLoader: 1 query para listar 50 posts + 50 queries para buscar o autor de cada post = 51 queries. Com DataLoader: 1 query posts + 1 query WHERE author_id IN (...50 ids) = 2 queries.",
      },
      {
        q: "O que são Mutations no GraphQL e como diferem de Queries?",
        o: [
          "Mutations modificam dados (criar, atualizar, deletar); Queries apenas leem dados",
          "São idênticos",
          "Queries modificam e Mutations leem",
          "Mutations são assincronas e Queries síncronas",
        ],
        c: 0,
        e: "Queries são operações de leitura (análogas a GET). Mutations são operações de escrita (análogas a POST/PUT/DELETE). Queries são executadas em paralelo; Mutations são executadas sequencialmente para garantir consistência. Subscriptions permitem dados em tempo real via WebSocket.",
        x: 'mutation { createUser(input: { name: "Ana", email: "ana@email.com" }) { id, name } } — cria usuário e retorna apenas id e name do recém-criado.',
      },
      {
        q: "O que é o padrão HATEOAS em APIs REST e qual sua vantagem?",
        o: [
          "Respostas incluem links para ações relacionadas, permitindo que o cliente navegue pela API sem conhecer URLs previamente",
          "Protocolo de criptografia para APIs",
          "Formato de compressão de JSON",
          "Tipo de autenticação OAuth",
        ],
        c: 0,
        e: "HATEOAS (Hypermedia as the Engine of Application State) é o nível mais alto de maturidade REST (Richardson Level 3). As respostas incluem links (hypermedia) para ações possíveis, permitindo ao cliente descobrir a API dinamicamente sem documentacação externa.",
        x: 'GET /api/orders/42 retorna: { "id": 42, "status": "pending", "_links": { "self": "/orders/42", "cancel": "/orders/42/cancel", "pay": "/orders/42/pay" } }. O cliente sabe que pode cancelar ou pagar seguindo os links.',
      },
      {
        q: "O que é o problema N+1 em GraphQL e como resolvê-lo?",
        o: [
          "Quando cada item de uma lista dispara uma query adicional; resolvido com DataLoader (batching)",
          "Limite de 1 query por requisição",
          "Erro de sintaxe na query",
          "Problema de cache",
        ],
        c: 0,
        e: "N+1: query de users (1 query) onde cada user resolve posts (N queries). DataLoader agrupa todas as chamadas do mesmo tick em um batch: em vez de 100 queries SELECT * FROM posts WHERE userId=?, faz 1 query SELECT * FROM posts WHERE userId IN (1,2,...100).",
        x: "Sem DataLoader: 1 query users + 100 queries posts = 101 queries (N+1). Com DataLoader: 1 query users + 1 query posts com IN clause = 2 queries. Performance 50x melhor.",
      },
      {
        q: "O que são WebSockets e como diferem de REST para comunicação em tempo real?",
        o: [
          "Protocolo bidirecional persistente; REST é request-response sem conexão persistente",
          "REST mais rápido é idêntico",
          "WebSockets substituem REST completamente",
          "WebSockets só funcionam com GraphQL",
        ],
        c: 0,
        e: "WebSockets: conexão TCP persistente bidirecional. Servidor pode enviar dados ao cliente sem request (push). Ideal para chat, games, dashboards real-time, notificações. REST: cada interação é request-response independente (stateless).",
        x: "Chat com REST: cliente faz polling GET /messages a cada 1s (1000 requests inúteis se não há mensagem nova). Chat com WebSocket: servidor envia mensagem ao cliente instantaneamente quando chega. Latência: 1s vs 50ms.",
      },
      {
        q: "O que é o padrão BFF (Backend for Frontend) e quando usá-lo?",
        o: [
          "Backend específico para cada tipo de cliente (web, mobile) que agrega e formata dados de microsserviços",
          "Framework de frontend",
          "Tipo de API Gateway",
          "Padrão de cache",
        ],
        c: 0,
        e: "BFF: camada backend dedicada por cliente. BFF web retorna dados completos; BFF mobile retorna dados compactos. Cada BFF agrega chamadas a microsserviços internos, formata resposta para o cliente específico. Evita API genérica que não atende bem nenhum cliente.",
        x: "BFF Web: /dashboard → agrega users + orders + analytics → resposta completa com gráficos. BFF Mobile: /dashboard → agrega só orders resumidos → payload 80% menor para economia de dados.",
      },
      {
        q: "O que é gRPC e como difere de REST?",
        o: [
          "Framework RPC que usa Protocol Buffers (binário) sobre HTTP/2; mais rápido que REST/JSON",
          "Versão mais nova do REST",
          "REST com compressão",
          "GraphQL binário",
        ],
        c: 0,
        e: "gRPC: Remote Procedure Call do Google. Usa Protocol Buffers (serialização binária, ~10x menor que JSON) sobre HTTP/2 (multiplexing, streaming bidirecional). Tipagem forte via .proto files. Ideal para comunicação entre microsserviços (alta performance).",
        x: "Proto: service UserService { rpc GetUser(UserRequest) returns (User); }. Gera client e server em qualquer linguagem. Payload: User em protobuf = 50 bytes vs JSON = 500 bytes. Latência: gRPC ~2ms vs REST ~10ms.",
      },
    ],
  },

  // ── Arquitetura de Software ──
  "Arquitetura de Software": {
    Fácil: [
      {
        q: "Qual padrão arquitetural divide a aplicação em três camadas: apresentação, lógica de negócios e acesso a dados?",
        o: [
          "MVC (Model-View-Controller)",
          "Microserviços",
          "Event Sourcing",
          "Serverless",
        ],
        c: 0,
        e: "O MVC separa a aplicação em Model (dados e regras de negócio), View (interface com o usuário) e Controller (intermediário que recebe requisições, manipula o Model e retorna a View). Facilita manutenção e testes independentes de cada camada.",
        x: "No Express.js: Router (Controller) recebe GET /users, chama UserService (Model) para buscar dados do banco, e retorna um JSON (View) ao cliente.",
      },
      {
        q: "O que significa arquitetura 'Cliente-Servidor' e onde ela é aplicada?",
        o: [
          "Modelo onde clientes fazem requisições a um servidor central que processa e responde",
          "Modelo peer-to-peer sem servidor",
          "Modelo onde tudo roda no navegador",
          "Modelo exclusivo para jogos online",
        ],
        c: 0,
        e: "Na arquitetura cliente-servidor, clientes (navegadores, apps móveis) enviam requisições pela rede a um servidor que processa, acessa banco de dados e retorna respostas. O servidor centraliza lógica de negócio e dados. É o modelo básico da web.",
        x: "App React Native (cliente) faz GET /api/cards para o servidor Express (servidor). O servidor consulta o PostgreSQL e retorna os flashcards em JSON.",
      },
      {
        q: "O que é uma API e qual seu papel na arquitetura de software?",
        o: [
          "Interface que define como componentes de software se comunicam sem expor detalhes internos",
          "Banco de dados compartilhado",
          "Linguagem de programação",
          "Framework de interface gráfica",
        ],
        c: 0,
        e: "API (Application Programming Interface) define um contrato de comunicação entre sistemas. Expõe funcionalidades de um serviço sem revelar sua implementação interna. APIs HTTP/REST são as mais comuns, mas existem APIs de bibliotecas, SO e hardware.",
        x: "A API do Stripe expõe POST /v1/charges para processar pagamentos. Você não precisa saber como o Stripe processa internamente — só segue o contrato da API.",
      },
      {
        q: "O que é arquitetura monolítica e quais suas características principais?",
        o: [
          "Aplicação em uma única unidade de código deployável com todos os componentes juntos",
          "Aplicação distribuída em vários serviços",
          "Arquitetura baseada em eventos",
          "Sistema sem banco de dados",
        ],
        c: 0,
        e: "Monolito: toda a aplicação (UI, lógica, acesso a dados) em um único deployável. Vantagens: simples de desenvolver, debugar e deployar inicialmente. Desvantagens: escalação (escala tudo ou nada), acoplamento, deploys arriscados, stack único.",
        x: "E-commerce monolítico: um único servidor Java com módulos de pagamento, estoque, usuários, notificações. Para escalar só o pagamento (Black Friday), precisa escalar o monolito inteiro.",
      },
      {
        q: "O que significa o padrão MVC (Model-View-Controller)?",
        o: [
          "Padrão que separa aplicação em Model (dados), View (interface) e Controller (lógica de controle)",
          "Framework JavaScript",
          "Tipo de banco de dados",
          "Protocolo de comunicação",
        ],
        c: 0,
        e: "MVC separa responsabilidades: Model gerencia dados e regras de negócio, View apresenta a interface ao usuário, Controller recebe input do usuário e coordena Model e View. Reduz acoplamento e facilita testes. Usado em Rails, Django, Spring MVC.",
        x: "Cadastro de usuário: View (formulário HTML) → Controller (recebe POST, valida dados) → Model (salva no banco) → Controller redireciona → View (página de sucesso).",
      },
      {
        q: "Qual a diferença entre escalabilidade horizontal e vertical?",
        o: [
          "Horizontal adiciona mais máquinas; vertical aumenta recursos da máquina existente",
          "São termos para banco de dados apenas",
          "Horizontal é mais barato sempre",
          "Vertical exige microsserviços",
        ],
        c: 0,
        e: "Escala vertical (scale up): mais CPU, RAM ou disco na mesma máquina — simples, mas tem limite físico. Escala horizontal (scale out): adicionar mais instâncias/máquinas atrás de um load balancer — mais complexo (estado, sessão), mas virtualmente ilimitado.",
        x: "Vertical: trocar servidor de 8GB RAM por 64GB. Horizontal: manter 8 servidores de 8GB atrás de um NGINX. Microsserviços facilitam escala horizontal; monolitos geralmente escalam verticalmente.",
      },
      {
        q: "O que é o padrão de camadas (Layered Architecture)?",
        o: [
          "Organização em camadas onde cada uma só se comunica com a camada adjacente",
          "Divisão de código em microsserviços",
          "Padrão de cache multinível",
          "Técnica de compressão de dados",
        ],
        c: 0,
        e: "Layered Architecture organiza o código em camadas horizontais: Apresentação → Lógica de Negócio → Acesso a Dados → Banco. Cada camada depende apenas da camada abaixo. Facilita separação de responsabilidades e substituição de uma camada sem afetar as outras.",
        x: "Controller (Apresentação) → Service (Negócio) → Repository (Dados) → PostgreSQL. O Controller nunca acessa o banco diretamente; sempre passa pelo Service e Repository.",
      },
    ],
    Médio: [
      {
        q: "Qual é a principal diferença entre arquitetura monolítica e microsserviços em termos de deploy?",
        o: [
          "Microsserviços permitem deploy independente de cada serviço; monolito exige deploy da aplicação inteira",
          "Monolito é mais rápido para deploy",
          "Microsserviços não podem ser containerizados",
          "Não há diferença de deploy, apenas de organização de código",
        ],
        c: 0,
        e: "Em microsserviços, cada serviço tem seu próprio repositório, pipeline CI/CD e processo de deploy independente. Uma alteração no serviço de pagamentos pode ser deployada sem afetar o serviço de catálogo. No monolito, qualquer mudança exige rebuild e redeploy de toda a aplicação.",
        x: "Time A faz deploy do serviço de pagamentos às 14h. Time B faz deploy do serviço de notificações às 15h. Nenhum interfere no outro. No monolito, ambos teriam que coordenar um único deploy.",
      },
      {
        q: "O que é o padrão Repository na arquitetura de software?",
        o: [
          "Camada de abstração entre lógica de negócio e acesso a dados, encapsulando operações de persistência",
          "Repositório Git",
          "Cache de banco de dados",
          "Servidor de CI/CD",
        ],
        c: 0,
        e: "O Repository Pattern cria uma interface entre a camada de domínio e a camada de dados. A lógica de negócio usa métodos como findById(), save(), delete() sem saber se os dados vêm de PostgreSQL, MongoDB ou API externa. Facilita testes (mock do repo) e troca de banco.",
        x: "interface UserRepository { findById(id: string): User; save(user: User): void; } class PgUserRepository implements UserRepository { ... } — service usa a interface, teste usa MockUserRepository.",
      },
      {
        q: "O que é DDD (Domain-Driven Design) e qual seu conceito central?",
        o: [
          "Abordagem que coloca o domínio de negócio no centro do design, usando linguagem ubíqua entre devs e especialistas",
          "Metodologia ágil",
          "Ferramenta de deploy",
          "Banco de dados orientado a domínios",
        ],
        c: 0,
        e: "DDD foca em modelar o software refletindo o domínio do negócio. Conceitos-chave: Entidades (identidade única), Value Objects (imutáveis, igualdade por valor), Aggregates (grupo transacional), Bounded Contexts (limites de contexto), Ubiquitous Language (terminologia compartilhada entre devs e negócio).",
        x: "No domínio de e-commerce: Pedido (Entity com ID), Dinheiro (Value Object: { valor: 100, moeda: 'BRL' }), Carrinho (Aggregate Root que contém ItemCarrinho). Dev e PO usam os mesmos termos: 'Pedido', não 'Order row'.",
      },
      {
        q: "O que é arquitetura de microsserviços e quais suas vantagens sobre monolitos?",
        o: [
          "Dividir a aplicação em serviços independentes, cada um com deploy e escalabilidade própria",
          "Monolito com módulos internos",
          "Aplicação frontend dividida",
          "Banco de dados distribuído",
        ],
        c: 0,
        e: "Microsserviços: cada serviço é independente (deploy, stack, banco próprio), comunica via API/mensageria. Vantagens: escala independente, deploys frequentes, equipes autônomas. Desvantagens: complexidade operacional, consistência distribuída, latency overhead.",
        x: "Netflix: serviço de recomendação (Python/ML), serviço de streaming (Java), serviço de billing (Go), serviço de perfil (Node.js). Cada um escala independentemente conforme demanda.",
      },
      {
        q: "O que é o padrão CQRS (Command Query Responsibility Segregation)?",
        o: [
          "Separar operações de leitura (Query) e escrita (Command) em modelos diferentes",
          "Cache de queries SQL",
          "Compressão de requisições",
          "Controle de acesso por query",
        ],
        c: 0,
        e: "CQRS separa leitura e escrita: Command modelo otimizado para writes (validações, regras), Query modelo otimizado para reads (denormalizado, rápido). Frequentemente combinado com Event Sourcing. Ideal quando leitura e escrita têm cargas muito diferentes.",
        x: "E-commerce: Command escreve pedido no banco normalizado com validações. Query lê de uma view materializada denormalizada com join pré-calculado. Escrita: 100 req/s. Leitura: 10.000 req/s — modelos otimizados separadamente.",
      },
      {
        q: "O que é o padrão Strangler Fig para migração de monolito para microsserviços?",
        o: [
          "Substituir gradualmente partes do monolito por microsserviços, roteando tráfego progressivamente",
          "Derrubar o monolito e reescrever tudo do zero",
          "Executar monolito e microsserviços em paralelo permanentemente",
          "Usar cache para acelerar o monolito",
        ],
        c: 0,
        e: "Strangler Fig (inspirado na figueira que envolve a árvore hospedeira) migra gradualmente: cria o microsserviço novo, roteia parte do tráfego para ele via proxy, e quando 100% do tráfego estiver no novo serviço, remove o código antigo do monolito. Minimiza risco.",
        x: "Monolito com módulo de pagamento. Cria PagamentoService em microsserviço. NGINX redireciona /api/pagamentos para o novo serviço. Testa com 10% do tráfego → 50% → 100%. Remove módulo de pagamento do monolito.",
      },
      {
        q: "O que é Event-Driven Architecture (EDA) e quando usá-la?",
        o: [
          "Arquitetura onde componentes se comunicam por eventos assíncronos via message broker",
          "Arquitetura com chamadas síncronas entre serviços",
          "Arquitetura exclusiva para frontend",
          "Tipo de banco de dados reativo",
        ],
        c: 0,
        e: "EDA: produtores emitem eventos (PedidoCriado, PagamentoConfirmado) para um broker (Kafka, RabbitMQ). Consumidores processam independentemente. Vantagens: desacoplamento, escalabilidade, resiliência. Desvantagens: complexidade, eventual consistency, debug mais difícil.",
        x: "Pedido criado → evento PedidoCriado no Kafka → EstoqueService consome (reserva itens), NotificacaoService consome (envia email), AnalyticsService consome (registra métrica). Cada um independente.",
      },
    ],
    Difícil: [
      {
        q: "No padrão CQRS (Command Query Responsibility Segregation), por que separar os modelos de leitura e escrita pode aumentar a escalabilidade?",
        o: [
          "Permite otimizar e escalar independentemente cada lado: writes para consistência e reads para performance com modelos desnormalizados",
          "Reduz o número de tabelas no banco",
          "Elimina a necessidade de eventos assíncronos",
          "Simplifica o código removendo validações",
        ],
        c: 0,
        e: "CQRS separa o modelo de comando (escrita) do modelo de consulta (leitura). O lado de escrita pode usar um modelo normalizado otimizado para integridade. O lado de leitura usa modelos desnormalizados (views materializadas) otimizados para queries. Cada lado escala independentemente.",
        x: "Write side: insere pedido na tabela normalizada Orders + OrderItems. Read side: tabela desnormalizada OrderSummary com todos os dados pré-calculados. 10x mais reads que writes → escale apenas o read side.",
      },
      {
        q: "O que é o padrão Saga em microsserviços e como ele substitui transações distribuídas?",
        o: [
          "Sequência de transações locais com compensações em caso de falha, substituindo 2PC",
          "Transação SQL distribuída",
          "Cache distribuído",
          "Tipo de mensageria",
        ],
        c: 0,
        e: "O padrão Saga divide uma transação distribuída em uma sequência de transações locais. Cada passo tem uma ação compensatória (rollback). Se o passo 3 falhar, executa compensações 2 e 1 na ordem inversa. Abordagens: coreografia (eventos) ou orquestração (orquestrador central).",
        x: "Criar Pedido: 1) ReservarEstoque → 2) ProcessarPagamento → 3) EnviarNotificação. Se pagamento falhar: compensar estoque (liberar reserva). Cada serviço gerencia sua transação local.",
      },
      {
        q: "Qual é a diferença entre arquitetura hexagonal (Ports & Adapters) e arquitetura em camadas tradicional?",
        o: [
          "Hexagonal coloca o domínio no centro com portas (interfaces) e adaptadores (implementações), invertendo dependências",
          "São idênticas",
          "Hexagonal não usa interfaces",
          "Camadas é mais modular",
        ],
        c: 0,
        e: "Na arquitetura hexagonal, o domínio (core) não depende de nada externo. Ports são interfaces definidas pelo domínio (ex: IOrderRepo). Adapters são implementações concretas (ex: PostgresOrderRepo, HttpOrderController). Dependências apontam para dentro. Na arquitetura em camadas, dependências vão de cima para baixo.",
        x: "Core: OrderService depende de IOrderRepository (port). Adapter DB: PostgresOrderRepo implements IOrderRepository. Adapter HTTP: ExpressController chama OrderService. Trocar PostgreSQL por MongoDB: apenas novo adapter, core intocado.",
      },
      {
        q: "O que é Event Sourcing e como difere de CRUD tradicional?",
        o: [
          "Armazenar sequência de eventos em vez de estado atual; reconstrói o estado reproduzindo eventos",
          "Cache de eventos do DOM",
          "Log de auditoria simples",
          "Banco de dados de séries temporais",
        ],
        c: 0,
        e: "Event Sourcing: em vez de UPDATE no estado, armazena eventos imutáveis (PedidoCriado, ItemAdicionado, PagamentoConfirmado). Estado atual = replay de todos os eventos. Vantagens: auditoria completa, debug no tempo, projetar múltiplas views. Complexidade: snapshots para performance.",
        x: "Conta bancária CRUD: UPDATE saldo=900. Event Sourcing: eventos [ContaCriada(1000), Saque(100)]. Saldo = replay: 1000-100 = 900. Pode auditar toda história e criar novas projeções retroativamente.",
      },
      {
        q: "O que são Design Patterns de arquitetura e qual a diferença entre Saga e Two-Phase Commit em transações distribuídas?",
        o: [
          "Saga usa compensações locais em sequência; 2PC usa coordenador global com lock distribuído",
          "São idênticos",
          "2PC é mais moderno que Saga",
          "Saga só funciona com monolitos",
        ],
        c: 0,
        e: "Two-Phase Commit: coordenador pede prepare a todos, depois commit. Bloqueia recursos e não escala bem. Saga: sequência de transações locais, cada uma com compensação. Falha no passo 3 → executa compensações 2, 1. Tipos: Choreography (eventos) e Orchestration (orquestrador central).",
        x: "Saga de pedido: 1) ReservarEstoque 2) CobrarPagamento 3) EnviarEmail. Se pagamento falha: compensação LiberarEstoque. Orchestrator coordena ou cada serviço ouve eventos do anterior.",
      },
      {
        q: "O que é o padrão Circuit Breaker em microsserviços e como previne falhas em cascata?",
        o: [
          "Monitora falhas de um serviço e 'abre o circuito' para bloquear chamadas quando detecta instabilidade",
          "Balanceador de carga round-robin",
          "Firewall entre microsserviços",
          "Mecanismo de retry infinito",
        ],
        c: 0,
        e: "Circuit Breaker tem 3 estados: Closed (normal, chamadas passam), Open (serviço instável, chamadas bloqueadas com fallback), Half-Open (testa se serviço se recuperou). Previne cascading failures: um serviço lento não trava os que dependem dele.",
        x: "Serviço de recomendação está lento (timeout 5s). Sem CB: 100 requests acumulam, 500s de thread bloqueada → crash. Com CB: após 5 falhas consecutivas, circuito abre, retorna cache local ou lista genérica em 10ms. Testa recuperação a cada 30s.",
      },
      {
        q: "O que é o princípio de Inversão de Dependências (DIP) e como se aplica em arquitetura de software?",
        o: [
          "Módulos de alto nível não devem depender de módulos de baixo nível; ambos devem depender de abstrações",
          "Inverter a ordem das camadas na arquitetura",
          "Usar injeção de dependência com framework",
          "Remover todas as interfaces do código",
        ],
        c: 0,
        e: "DIP (SOLID 'D'): dependências devem apontar para abstrações (interfaces), não implementações concretas. OrderService depende de IPaymentGateway, não de StripeGateway diretamente. Facilita testes (mock), troca de implementação e respeita Open/Closed Principle.",
        x: "Sem DIP: OrderService importa StripeGateway → acoplado ao Stripe. Com DIP: OrderService depende de IPaymentGateway (interface). StripeGateway e PayPalGateway implementam a interface. Trocar gateway: mudar apenas a injeção, zero alteração no OrderService.",
      },
    ],
  },

  // ── Banco de Dados SQL ──
  "Banco de Dados SQL": {
    Fácil: [
      {
        q: "Qual comando SQL é usado para buscar dados de uma tabela filtrando por uma condição específica?",
        o: ["SELECT ... WHERE", "INSERT INTO", "CREATE TABLE", "DROP TABLE"],
        c: 0,
        e: "O comando SELECT com cláusula WHERE permite buscar registros de uma tabela que atendam a uma condição. WHERE filtra as linhas antes de retornar o resultado.",
        x: "SELECT nome, email FROM usuarios WHERE idade >= 18; — retorna nome e email de todos os usuários com 18 anos ou mais.",
      },
      {
        q: "Qual comando SQL é usado para inserir um novo registro em uma tabela?",
        o: ["INSERT INTO", "SELECT", "UPDATE", "CREATE TABLE"],
        c: 0,
        e: "O comando INSERT INTO adiciona uma nova linha à tabela especificada. Pode inserir valores explícitos ou dados vindos de um SELECT (INSERT INTO...SELECT). A ordem dos valores deve corresponder à ordem das colunas especificadas.",
        x: "INSERT INTO usuarios (nome, email, idade) VALUES ('Ana Silva', 'ana@email.com', 28); — insere um novo registro na tabela usuarios.",
      },
      {
        q: "O que é uma chave primária (PRIMARY KEY) em SQL?",
        o: [
          "Coluna ou conjunto de colunas que identifica cada registro de forma única",
          "Senha de acesso ao banco",
          "Tipo de índice para buscas",
          "Chave de criptografia",
        ],
        c: 0,
        e: "A PRIMARY KEY garante que cada registro na tabela seja único e não nulo. Normalmente é uma coluna 'id' com auto-incremento (SERIAL no PostgreSQL, AUTO_INCREMENT no MySQL). Uma tabela só pode ter uma PRIMARY KEY, mas ela pode ser composta (múltiplas colunas).",
        x: "CREATE TABLE usuarios (id SERIAL PRIMARY KEY, nome VARCHAR(100), email VARCHAR(255) UNIQUE); — 'id' é chave primária auto-incrementada.",
      },
      {
        q: "O que é uma chave estrangeira (Foreign Key) em SQL?",
        o: [
          "Coluna que referencia a chave primária de outra tabela, criando um relacionamento entre elas",
          "Chave de criptografia do banco",
          "Senha do administrador",
          "Tipo de índice",
        ],
        c: 0,
        e: "Foreign Key cria um relacionamento entre tabelas. Garante integridade referencial: o valor da FK deve existir na tabela referenciada. CASCADE delete/update pode propagar alterações. Implementa relações 1:N e N:M (via tabela associativa).",
        x: "CREATE TABLE pedidos (id SERIAL PRIMARY KEY, usuario_id INTEGER REFERENCES usuarios(id) ON DELETE CASCADE); — cada pedido pertence a um usuário. Deletar usuário deleta seus pedidos.",
      },
      {
        q: "Qual a diferença entre os comandos SQL SELECT, INSERT, UPDATE e DELETE?",
        o: [
          "SELECT lê dados, INSERT cria, UPDATE modifica e DELETE remove registros",
          "Todos modificam dados",
          "SELECT e INSERT são idênticos",
          "DELETE apaga a tabela inteira",
        ],
        c: 0,
        e: "CRUD em SQL: SELECT (Read) busca dados. INSERT (Create) adiciona registros. UPDATE (Update) modifica registros existentes. DELETE (Delete) remove registros. WHERE filtra quais registros são afetados pelo UPDATE/DELETE.",
        x: "INSERT INTO usuarios (nome) VALUES ('Ana'); SELECT * FROM usuarios WHERE nome='Ana'; UPDATE usuarios SET nome='Ana Silva' WHERE id=1; DELETE FROM usuarios WHERE id=1;",
      },
      {
        q: "O que faz o comando GROUP BY em SQL?",
        o: [
          "Agrupa registros com valores iguais para aplicar funções de agregação como COUNT, SUM, AVG",
          "Ordena os resultados por coluna",
          "Filtra registros duplicados",
          "Cria índices automáticos",
        ],
        c: 0,
        e: "GROUP BY agrupa linhas que têm os mesmos valores na(s) coluna(s) especificada(s). Usado com funções de agregação: COUNT (contar), SUM (somar), AVG (média), MIN, MAX. HAVING filtra os grupos (como WHERE para grupos).",
        x: "SELECT departamento, COUNT(*) as total FROM funcionarios GROUP BY departamento HAVING COUNT(*) > 5; — conta funcionários por departamento, mostrando só os com mais de 5.",
      },
      {
        q: "O que é NULL em SQL e como se compara valores nulos?",
        o: [
          "NULL representa ausência de valor; comparação usa IS NULL e IS NOT NULL, não = ou !=",
          "NULL é igual a zero",
          "NULL é uma string vazia",
          "NULL é comparado com = normalmente",
        ],
        c: 0,
        e: "NULL em SQL não é zero nem string vazia — é ausência de valor. Qualquer operação com NULL resulta em NULL (ex: 5 + NULL = NULL). Comparações com = ou != com NULL sempre resultam em UNKNOWN (nem TRUE nem FALSE). Usar IS NULL / IS NOT NULL.",
        x: "SELECT * FROM usuarios WHERE telefone IS NULL; — retorna usuários sem telefone. WHERE telefone = NULL NÃO funciona (retorna 0 resultados, sempre). COALESCE(telefone, 'N/A') retorna 'N/A' se NULL.",
      },
    ],
    Médio: [
      {
        q: "Qual é a diferença entre INNER JOIN e LEFT JOIN em SQL?",
        o: [
          "INNER JOIN retorna apenas registros com correspondência em ambas tabelas; LEFT JOIN retorna todos da tabela esquerda",
          "LEFT JOIN é mais rápido",
          "INNER JOIN permite NULL e LEFT JOIN não",
          "Não há diferença funcional",
        ],
        c: 0,
        e: "INNER JOIN retorna apenas as linhas que têm correspondência nas duas tabelas. LEFT JOIN retorna todas as linhas da tabela da esquerda, preenchendo com NULL os campos da tabela da direita quando não há correspondência.",
        x: "SELECT u.nome, p.titulo FROM usuarios u LEFT JOIN posts p ON u.id = p.user_id — retorna todos os usuários, inclusive os que não têm posts (titulo será NULL).",
      },
      {
        q: "O que são índices (INDEX) em SQL e como eles melhoram performance?",
        o: [
          "Estruturas que aceleram buscas criando um acesso rápido aos dados sem varrer toda a tabela",
          "Cópias da tabela em memória",
          "Backups automáticos",
          "Tipos de chave primária",
        ],
        c: 0,
        e: "Índices criam estruturas auxiliares (geralmente B-trees) que permitem localizar registros rapidamente sem full table scan. Aceleram SELECTs com WHERE e JOINs, mas tornam INSERTs/UPDATEs um pouco mais lentos porque o índice precisa ser atualizado.",
        x: "CREATE INDEX idx_email ON usuarios(email); — SELECT * FROM usuarios WHERE email = 'ana@email.com' agora usa o índice (~0.1ms) em vez de varrer 1M de linhas (~500ms).",
      },
      {
        q: "O que são as propriedades ACID em um banco de dados?",
        o: [
          "Atomicity, Consistency, Isolation, Durability — garantias de integridade transacional",
          "Tipos de dados SQL",
          "Níveis de acesso",
          "Proto col de rede",
        ],
        c: 0,
        e: "ACID: Atomicity (transação é tudo ou nada), Consistency (banco vai de um estado válido para outro), Isolation (transações concorrentes não interferem entre si), Durability (dados confirmados persistem mesmo após falha). Bancos relacionais como PostgreSQL e MySQL garantem ACID por padrão.",
        x: "Transferência bancária (Atomicity): BEGIN; UPDATE contas SET saldo = saldo - 100 WHERE id = 1; UPDATE contas SET saldo = saldo + 100 WHERE id = 2; COMMIT; — se qualquer UPDATE falhar, ambos são desfeitos.",
      },
      {
        q: "O que é um índice (INDEX) em SQL e como melhora a performance?",
        o: [
          "Estrutura que acelera buscas criando uma referência ordenada aos dados, como índice de livro",
          "Cópia de backup da tabela",
          "Cache de queries",
          "Tipo de VIEW",
        ],
        c: 0,
        e: "Índice cria estrutura (B-tree, hash) que permite buscar registros sem percorrer toda a tabela (full scan). SELECT com WHERE em coluna indexada: O(log n) ao invés de O(n). Trade-off: INSERT/UPDATE ficam mais lentos pois o índice precisa ser atualizado.",
        x: "Tabela com 10M registros, busca por email sem índice: 5s (full scan). CREATE INDEX idx_email ON usuarios(email); mesma busca: 5ms. 1000x mais rápido.",
      },
      {
        q: "O que são JOINs em SQL e qual a diferença entre INNER JOIN e LEFT JOIN?",
        o: [
          "INNER retorna só registros com correspondência em ambas tabelas; LEFT retorna todos da esquerda",
          "São idênticos",
          "LEFT JOIN é mais rápido",
          "INNER JOIN retorna mais resultados",
        ],
        c: 0,
        e: "INNER JOIN: retorna apenas linhas que têm correspondência em ambas as tabelas. LEFT JOIN: retorna TODAS as linhas da tabela à esquerda, com NULL onde não há correspondência na direita. RIGHT JOIN: o oposto. FULL OUTER: tudo de ambas.",
        x: "usuarios LEFT JOIN pedidos: retorna todos os usuários, mesmo os sem pedidos (pedido_id = NULL). INNER JOIN: retornaria apenas usuários COM pedidos.",
      },
      {
        q: "O que é uma subquery (subconsulta) em SQL e quando usá-la?",
        o: [
          "SELECT aninhado dentro de outro SELECT, usado para filtrar ou calcular valores dinamicamente",
          "Query que roda em outro banco de dados",
          "Query agendada para execução futura",
          "Backup parcial de uma tabela",
        ],
        c: 0,
        e: "Subquery é um SELECT dentro de outro comando SQL. Pode ser usada no WHERE (filtro), FROM (derived table), SELECT (valor escalar) ou EXISTS. Subqueries correlacionadas (referenciam a query externa) podem ser ineficientes; considerar JOINs como alternativa.",
        x: "SELECT nome FROM usuarios WHERE id IN (SELECT user_id FROM pedidos WHERE valor > 1000); — retorna nomes de usuários que fizeram pedidos acima de R$1000. A subquery filtra os IDs primeiro.",
      },
      {
        q: "O que é uma VIEW em SQL e quando utilizá-la?",
        o: [
          "Consulta salva como tabela virtual que pode ser referenciada como se fosse uma tabela real",
          "Cópia física dos dados em outra tabela",
          "Tipo de índice para consultas",
          "Backup automático de tabela",
        ],
        c: 0,
        e: "VIEW é uma query SELECT nomeada e salva no banco. Não armazena dados (apenas a definição). Ao consultar a VIEW, o banco executa a query subjacente. Vantagens: simplificar queries complexas, controlar acesso (expor apenas colunas necessárias), abstrair JOINs.",
        x: "CREATE VIEW pedidos_resumo AS SELECT u.nome, COUNT(p.id) as total_pedidos, SUM(p.valor) as total_gasto FROM usuarios u JOIN pedidos p ON u.id = p.user_id GROUP BY u.nome; — depois: SELECT * FROM pedidos_resumo WHERE total_gasto > 5000;",
      },
    ],
    Difícil: [
      {
        q: "O que é um deadlock em banco de dados e como o SGBD tipicamente o resolve?",
        o: [
          "Duas transações bloqueiam-se mutuamente; o SGBD aborta uma delas (vítima) para liberar a outra",
          "Duas transações leem o mesmo dado simultaneamente",
          "Uma query demora mais que o timeout",
          "O banco fica sem espaço em disco",
        ],
        c: 0,
        e: "Deadlock ocorre quando duas transações esperam uma pela outra: T1 bloqueia recurso A e espera B, enquanto T2 bloqueia B e espera A. O SGBD detecta o ciclo de espera e escolhe uma 'vítima' (geralmente a transação com menor custo) para fazer rollback, liberando seus locks.",
        x: "T1: UPDATE contas SET saldo=100 WHERE id=1 (lock em id=1), depois UPDATE contas SET saldo=200 WHERE id=2 (espera lock em id=2). T2: UPDATE contas SET saldo=300 WHERE id=2 (lock em id=2), depois UPDATE contas SET saldo=400 WHERE id=1 (espera lock em id=1). Deadlock! SGBD aborta T2.",
      },
      {
        q: "O que é um Execution Plan (EXPLAIN) e como ele ajuda a otimizar queries?",
        o: [
          "Mostra o plano que o banco usará para executar a query, revelando se usa índices ou full scan",
          "Executa a query mais rápido",
          "Cria índices automaticamente",
          "Backup do resultado da query",
        ],
        c: 0,
        e: "EXPLAIN mostra como o optimizer do banco planeja executar a query: se fará Sequential Scan (varredura completa) ou Index Scan, quantas linhas estima processar, ordem de JOINs e custo estimado. EXPLAIN ANALYZE executa de fato e mostra tempos reais. Essencial para identificar queries lentas.",
        x: "EXPLAIN ANALYZE SELECT * FROM pedidos WHERE status = 'pendente'; → Se mostrar Seq Scan com 1M rows e 500ms, crie índice: CREATE INDEX idx_status ON pedidos(status); → Index Scan com 50 rows e 0.5ms.",
      },
      {
        q: "O que são níveis de isolamento de transações SQL e quais problemas cada nível previne?",
        o: [
          "Read Uncommitted, Read Committed, Repeatable Read e Serializable — previnem dirty reads, non-repeatable reads e phantom reads progressivamente",
          "São tipos de lock",
          "São tipos de índice",
          "São tipos de JOIN",
        ],
        c: 0,
        e: "Read Uncommitted: permite dirty reads. Read Committed (padrão PostgreSQL): previne dirty reads. Repeatable Read: previne dirty + non-repeatable reads. Serializable: previne todos, incluindo phantom reads, mas com menor concorrência. Trade-off: mais isolamento = menos performance.",
        x: "Dirty read: T1 lê dado não commitado de T2 (que pode dar rollback). Non-repeatable: T1 lê um dado, T2 altera e commita, T1 lê novamente e vê valor diferente. Phantom: T1 conta rows, T2 insere nova row, T1 conta novamente e vê número diferente.",
      },
      {
        q: "O que é normalização de banco de dados e qual o objetivo das formas normais?",
        o: [
          "Processo de organizar dados para eliminar redundância e dependências parciais",
          "Compressão de dados",
          "Criptografia de tabelas",
          "Backup incremental",
        ],
        c: 0,
        e: "Normalização: 1NF (eliminar grupos repetidos), 2NF (eliminar dependências parciais da PK), 3NF (eliminar dependências transitivas). Reduz redundância, melhora integridade. Desnormalização: adicionar redundância intencionalmente para performance de leitura.",
        x: "Não normalizado: pedidos(id, cliente_nome, cliente_email, produto). Normalizado: pedidos(id, cliente_id, produto_id) + clientes(id, nome, email) + produtos(id, nome). Atualizar email do cliente: 1 lugar só.",
      },
      {
        q: "O que é uma stored procedure e quando usá-la?",
        o: [
          "Função armazenada no banco que encapsula lógica SQL reutilizável",
          "Backup automático do banco",
          "Tipo de índice",
          "Driver de conexão",
        ],
        c: 0,
        e: "Stored procedures são blocos de SQL armazenados no banco, executados com CALL/EXEC. Vantagens: reutilização, performance (compilada), segurança (acesso controlado). Desvantagens: lógica de negócio no banco, difícil versionar, vendor lock-in.",
        x: "CREATE PROCEDURE transfer(from_id INT, to_id INT, amount DECIMAL) BEGIN; UPDATE contas SET saldo = saldo - amount WHERE id = from_id; UPDATE contas SET saldo = saldo + amount WHERE id = to_id; END; CALL transfer(1, 2, 100);",
      },
      {
        q: "O que é particionamento (sharding) de banco de dados e quando aplicá-lo?",
        o: [
          "Dividir dados de uma tabela em múltiplos servidores usando uma chave de partição para escalar horizontalmente",
          "Replicar dados em servidores de backup",
          "Comprimir tabelas grandes",
          "Criar índices distribuídos",
        ],
        c: 0,
        e: "Sharding distribui dados entre múltiplos nós usando uma shard key (ex: user_id % N). Cada shard contém um subconjunto dos dados. Vantagens: escala horizontal de escrita. Desafios: queries cross-shard, rebalanceamento, transações distribuídas, choice de shard key.",
        x: "Tabela de pedidos com 1 bilhão de registros. Shard key: user_id. Shard 1: users 1-33M. Shard 2: users 33M-66M. Shard 3: users 66M-100M. Query WHERE user_id=42 vai direto ao Shard 1. Query WHERE status='pendente' precisa consultar os 3 shards.",
      },
      {
        q: "O que são CTEs (Common Table Expressions) e Window Functions em SQL avançado?",
        o: [
          "CTEs são subconsultas nomeadas com WITH; Window Functions calculam sobre partições sem agrupar linhas",
          "São tipos de stored procedures",
          "São funções de backup incrementais",
          "São extensões NoSQL para bancos relacionais",
        ],
        c: 0,
        e: "CTE: WITH nome AS (SELECT ...) SELECT ... FROM nome — cria resultado temporário nomeado, melhora legibilidade. CTEs recursivas permitem hierarquias. Window Functions: ROW_NUMBER(), RANK(), LAG(), LEAD(), SUM() OVER(PARTITION BY ...) — calculam sobre um 'window' de linhas sem colapsar o resultado como GROUP BY.",
        x: "WITH top_clientes AS (SELECT user_id, SUM(valor) as total FROM pedidos GROUP BY user_id) SELECT u.nome, t.total, RANK() OVER(ORDER BY t.total DESC) as ranking FROM usuarios u JOIN top_clientes t ON u.id = t.user_id; — CTE calcula totais, Window Function rankeia.",
      },
    ],
  },

  // ── Banco de Dados NoSQL ──
  "Banco de Dados NoSQL": {
    Fácil: [
      {
        q: "Qual tipo de banco de dados NoSQL armazena dados como documentos JSON flexíveis, sem esquema rígido?",
        o: [
          "Banco de documentos (ex.: MongoDB)",
          "Banco relacional (ex.: PostgreSQL)",
          "Banco de grafos (ex.: Neo4j)",
          "Banco colunar (ex.: Cassandra)",
        ],
        c: 0,
        e: "Bancos de documentos como MongoDB armazenam dados como documentos JSON/BSON. Cada documento pode ter estrutura diferente (schema-less), permitindo campos variáveis. Ideal para dados semi-estruturados e desenvolvimento ágil.",
        x: "db.usuarios.insertOne({ nome: 'Ana', idade: 28, hobbies: ['leitura', 'yoga'] }) — o campo 'hobbies' é um array e outro documento pode não ter esse campo.",
      },
      {
        q: "Qual tipo de banco NoSQL é otimizado para armazenar e consultar relações complexas entre entidades, como redes sociais?",
        o: [
          "Banco de grafos (ex.: Neo4j)",
          "Banco de documentos (ex.: MongoDB)",
          "Banco chave-valor (ex.: Redis)",
          "Banco colunar (ex.: Cassandra)",
        ],
        c: 0,
        e: "Bancos de grafos armazenam nós (entidades) e arestas (relações) de forma nativa, permitindo queries de relacionamento eficientes. Ideal para redes sociais, grafos de conhecimento, detecção de fraude e recomendações.",
        x: "Neo4j: MATCH (u:User)-[:FOLLOWS]->(friend)-[:LIKES]->(movie) WHERE u.name = 'Ana' RETURN movie.title — encontra filmes que amigos da Ana curtiram, percorrendo o grafo.",
      },
      {
        q: "Para que serve o Redis e qual é sua principal característica?",
        o: [
          "Banco chave-valor em memória, extremamente rápido, usado para cache e sessões",
          "Banco SQL completo",
          "Banco de documentos como MongoDB",
          "Ferramenta de backup",
        ],
        c: 0,
        e: "Redis armazena dados em memória RAM (in-memory), oferecendo latência sub-milissegundo. Suporta estruturas: strings, hashes, listas, sets, sorted sets. Usado como cache, session store, fila de mensagens, rate limiter e leaderboard. Persistência opcional via RDB/AOF.",
        x: "// Cache de query custosa:\nawait redis.setex('user:42', 3600, JSON.stringify(userData)); // TTL 1h\nconst cached = await redis.get('user:42'); // <1ms vs ~50ms no banco.",
      },
      {
        q: "Qual a principal diferença entre um banco de dados relacional (SQL) e um NoSQL?",
        o: [
          "SQL usa tabelas com esquema fixo; NoSQL usa modelos flexíveis (documentos, chave-valor, grafo)",
          "NoSQL é sempre mais rápido",
          "SQL não suporta relações",
          "NoSQL não pode armazenar dados",
        ],
        c: 0,
        e: "SQL (relacional): tabelas com esquema rígido, JOINs, ACID, SQL como linguagem. NoSQL: modelo flexível (documentos, chave-valor, colunar, grafo), escala horizontal, schema-less. SQL melhor para dados relacionais; NoSQL para dados semi-estruturados e alta escala.",
        x: "Usuários com endereços: SQL — tabela usuarios + tabela enderecos (JOIN). MongoDB — um documento { nome: 'Ana', enderecos: [{rua: 'A'}] } com tudo embutido.",
      },
      {
        q: "O que é o MongoDB e qual seu modelo de dados?",
        o: [
          "Banco NoSQL orientado a documentos que armazena dados em formato BSON (similar a JSON)",
          "Banco relacional",
          "Banco de grafos",
          "Banco chave-valor",
        ],
        c: 0,
        e: "MongoDB armazena documentos BSON (Binary JSON) em coleções (equivalente a tabelas). Schema flexível: documentos na mesma coleção podem ter campos diferentes. Queries via MQL (MongoDB Query Language). Suporta índices, agregação, replicação e sharding.",
        x: "db.users.insertOne({ name: 'Ana', age: 28, hobbies: ['coding', 'music'] }); db.users.find({ age: { $gte: 18 } }); — schema flexível, sem migrations.",
      },
      {
        q: "O que é uma coleção (collection) em bancos de documentos como MongoDB?",
        o: [
          "Agrupamento de documentos equivalente a uma tabela em bancos relacionais, mas sem esquema fixo",
          "Arquivo de backup do banco",
          "Tipo de índice",
          "Linguagem de consulta",
        ],
        c: 0,
        e: "Em MongoDB, uma coleção é um grupo de documentos. Diferente de tabelas SQL, não exige que todos os documentos tenham a mesma estrutura (schema-less). Coleções são criadas automaticamente ao inserir o primeiro documento. Análogo: banco SQL (database) → tabela (collection) → linha (document).",
        x: "db.createCollection('usuarios'); // ou simplesmente: db.usuarios.insertOne({ nome: 'Ana' }); — a coleção 'usuarios' é criada automaticamente na primeira inserção.",
      },
      {
        q: "Qual a diferença entre bancos chave-valor e bancos de documentos?",
        o: [
          "Chave-valor armazena dados opacos acessados por chave; documentos armazenam JSON estruturado com queries em campos internos",
          "São idênticos",
          "Chave-valor é mais lento",
          "Documentos não suportam JSON",
        ],
        c: 0,
        e: "Chave-valor (Redis, DynamoDB): dados são um blob opaco acessado exclusivamente pela chave. Rápido para GET/SET, sem queries em campos internos. Documentos (MongoDB, Firestore): armazena JSON, permite queries em qualquer campo interno (find({ age: { $gt: 18 } })).",
        x: "Redis: SET user:42 '{\"nome\":\"Ana\"}' → GET user:42 (retorna blob). MongoDB: db.users.find({ nome: 'Ana', idade: { $gte: 18 } }) — consulta por campos internos do documento.",
      },
    ],
    Médio: [
      {
        q: "No teorema CAP, é impossível que um sistema distribuído garanta simultaneamente quais três propriedades?",
        o: [
          "Consistency, Availability e Partition Tolerance",
          "Concurrency, Atomicity e Performance",
          "Cache, Authentication e Privacy",
          "Compression, Aggregation e Partitioning",
        ],
        c: 0,
        e: "O teorema CAP afirma que um sistema distribuído pode garantir no máximo duas das três propriedades: Consistency (todos os nós veem os mesmos dados), Availability (toda requisição recebe resposta) e Partition Tolerance (funciona mesmo com falhas de rede). Na prática, partições acontecem, então a escolha é entre C e A.",
        x: "MongoDB (CP): durante partição de rede, o primary pode ficar indisponível até eleger novo primary, garantindo consistência. Cassandra (AP): sempre responde, mas réplicas podem ter dados temporariamente diferentes.",
      },
      {
        q: "O que é eventual consistency e em que cenários ela é aceitável?",
        o: [
          "Modelo onde réplicas convergem ao mesmo estado eventualmente, sem garantia de leitura imediata do último write",
          "Consistência em tempo real",
          "Backup eventual",
          "Cache invalidation",
        ],
        c: 0,
        e: "Na eventual consistency, após um write, réplicas podem retornar dados desatualizados por um breve período até que a propagação se complete. Aceitável para: timeline de redes sociais, contadores de views, feeds de notícias. Inaceitável para: saldo bancário, estoque de produtos.",
        x: "Ana posta uma foto. Usuários na mesma região veem instantaneamente, mas usuários em outra região podem levar 2-5 segundos para ver. Para um feed social, isso é aceitável.",
      },
      {
        q: "O que é sharding em bancos NoSQL e qual problema ele resolve?",
        o: [
          "Divisão horizontal de dados entre múltiplos servidores, permitindo escala além de uma única máquina",
          "Backup distribuído",
          "Compressão de dados",
          "Criptografia de dados",
        ],
        c: 0,
        e: "Sharding distribui dados entre múltiplos nós usando uma shard key (ex.: hash do userId). Cada shard contém um subconjunto dos dados. Permite escalar horizontalmente: mais dados = mais shards. Desafio: queries que cruzam shards (scatter-gather) são mais lentas.",
        x: "MongoDB com 3 shards usando userId como shard key: users 1-1M no shard1, 1M-2M no shard2, 2M-3M no shard3. Query por userId é roteada para 1 shard (rápido). Query sem userId vai para todos (lento).",
      },
      {
        q: "O que é o teorema CAP e como ele se aplica a bancos NoSQL?",
        o: [
          "Impossível ter simultâneo: Consistência forte, Alta disponibilidade e Tolerância a partições — escolha 2",
          "Three propriedades sempre garantidas",
          "Aplica-se apenas a SQL",
          "Cache, API e Protocolos",
        ],
        c: 0,
        e: "CAP: em presença de partição de rede (P), precisa escolher entre Consistência (C) ou Disponibilidade (A). CP: MongoDB (rejeita escrita se primary cair). AP: Cassandra (aceita escrita em qualquer nó, resolução posterior). Na prática: PACELC é modelo mais preciso.",
        x: "Partição de rede entre nós: CP (MongoDB) → recusa writes até eleger novo primary (consistente, indisponível). AP (Cassandra) → aceita writes em ambos lados, merge depois (disponível, inconsistente temporariamente).",
      },
      {
        q: "O que é o conceito de embedding vs referencing em MongoDB?",
        o: [
          "Embedding: documento aninhado no pai; Referencing: armazenar ID para lookup em outra coleção",
          "São idênticos",
          "Referencing é sempre melhor",
          "Embedding só funciona com arrays",
        ],
        c: 0,
        e: "Embedding: dados relacionados dentro do mesmo documento (denormalizado). Bom para 1:1, 1:poucos, lidos juntos. Referencing: ObjectId apontando para outro documento. Bom para 1:muitos, N:M, dados acessados independentemente. Trade-off: performance de leitura vs flexibilidade.",
        x: "Embedding: { post: 'Hello', comments: [{text: 'Nice'}] } — 1 query. Referencing: { post: 'Hello', commentIds: ['id1'] } + comments collection — 2 queries, mas comments podem ter milhões sem estourar o documento (limite 16MB).",
      },
      {
        q: "O que é um Replica Set no MongoDB e para que serve?",
        o: [
          "Grupo de instâncias MongoDB que mantêm cópias dos mesmos dados para alta disponibilidade e failover automático",
          "Conjunto de índices replicados",
          "Backup agendado",
          "Cluster de sharding",
        ],
        c: 0,
        e: "Replica Set: 1 primary (recebe writes) + N secondaries (replicam dados). Se o primary cair, eleição automática promove um secondary a primary. Vantagens: alta disponibilidade, read scaling (ler de secondaries), disaster recovery. Mínimo recomendado: 3 membros.",
        x: "Replica Set com 3 nós. Primary recebe write. Secondary1 e Secondary2 replicam via oplog. Primary cai → eleição em ~10s → Secondary1 vira primary. App reconecta automaticamente. Zero downtime.",
      },
      {
        q: "O que é o Aggregation Pipeline no MongoDB?",
        o: [
          "Sequência de estágios que processam documentos: filtram, agrupam, transformam e calculam resultados",
          "Ferramenta de backup incremental",
          "Driver de conexão",
          "Tipo de índice composto",
        ],
        c: 0,
        e: "Aggregation Pipeline: documentos passam por estágios sequenciais ($match, $group, $sort, $project, $lookup, $unwind). Cada estágio transforma os documentos e passa ao próximo. Equivalente NoSQL de queries complexas com GROUP BY, JOIN e subqueries do SQL.",
        x: "db.pedidos.aggregate([ { $match: { status: 'completo' } }, { $group: { _id: '$userId', total: { $sum: '$valor' } } }, { $sort: { total: -1 } }, { $limit: 10 } ]); — top 10 clientes por valor gasto.",
      },
    ],
    Difícil: [
      {
        q: "No DynamoDB, como o design de single-table com overloading de atributos e GSIs permite modelar relações complexas em uma única tabela?",
        o: [
          "Usando PK e SK genéricos com prefixos que representam diferentes entidades, e GSIs invertendo chaves para consultas alternativas",
          "Normalizando dados em múltiplas tabelas com foreign keys",
          "Usando JOINs entre partições",
          "Criando views materializadas SQL",
        ],
        c: 0,
        e: "No single-table design, PK e SK usam prefixos (ex.: PK=USER#123, SK=ORDER#456) para armazenar múltiplas entidades na mesma tabela. GSIs (Global Secondary Indexes) com chaves invertidas ou overloaded permitem diferentes padrões de acesso sem tabelas adicionais.",
        x: "PK=USER#1, SK=PROFILE → dados do usuário. PK=USER#1, SK=ORDER#100 → pedido do usuário. GSI1: PK=ORDER#100, SK=USER#1 → buscar pedido por ID. Tudo em uma tabela.",
      },
      {
        q: "O que é um banco de dados de séries temporais (TSDB) e para que serve?",
        o: [
          "Banco otimizado para dados com timestamp, como métricas de infraestrutura e IoT",
          "Banco de grafos temporal",
          "Banco SQL com colunas de data",
          "Cache temporal",
        ],
        c: 0,
        e: "TSDBs (InfluxDB, TimescaleDB, Prometheus) são otimizados para writes de alta velocidade de dados com timestamp, queries por faixa de tempo, agregações temporais (média por hora/dia) e compressão eficiente de dados sequenciais. Ideal para métricas, IoT, logs financeiros.",
        x: "InfluxDB: INSERT cpu,host=server01 usage=65.4 1625097600000000000. Query: SELECT mean(usage) FROM cpu WHERE time > now() - 1h GROUP BY time(5m) — média de CPU a cada 5 minutos na última hora.",
      },
      {
        q: "Qual a diferença entre replicação síncrona e assíncrona em bancos NoSQL distribuídos?",
        o: [
          "Síncrona espera confirmação de todas as réplicas antes de confirmar write; assíncrona confirma imediatamente e replica em background",
          "São idênticas",
          "Síncrona é mais rápida",
          "Assíncrona não replica",
        ],
        c: 0,
        e: "Síncrona: write só é confirmado após N réplicas confirmarem (consistência forte, maior latência). Assíncrona: write é confirmado após persistência local, réplicas recebem em background (menor latência, risco de dados não replicados em caso de falha). Muitos bancos oferecem níveis configuráveis.",
        x: "MongoDB: w: 'majority' (síncrono — espera maioria confirmar). w: 1 (assíncrono — apenas primary confirma). Cassandra: QUORUM (maioria), ONE (1 nó). Trade-off: consistência vs latência.",
      },
      {
        q: "O que é o Firebase Firestore e como difere de um banco NoSQL tradicional?",
        o: [
          "Banco NoSQL serverless com sincronização em tempo real, SDKs client-side e regras de segurança integradas",
          "Banco SQL gerenciado pelo Google",
          "Clone do MongoDB",
          "Apenas para Android",
        ],
        c: 0,
        e: "Firestore: banco de documentos (coleções/documentos) com sync em tempo real (onSnapshot), SDKs para web/mobile, security rules declarativas, escala automática (serverless). Diferenças de MongoDB: sem servidor para gerenciar, security rules no banco, pricing por operação.",
        x: "Firestore: onSnapshot(collection(db, 'chats'), (snap) => { updateUI(snap.docs) }); — UI atualiza automaticamente quando qualquer usuário envia mensagem. Zero código de polling.",
      },
      {
        q: "O que é uma transação distribuída em NoSQL e quais os desafios?",
        o: [
          "Operação atômica que abrange múltiplos documentos/nós; desafio de consistência entre partições",
          "Transação SQL normal",
          "Backup simúltaneo de shards",
          "Transferência de dados entre bancos",
        ],
        c: 0,
        e: "NoSQL nativamente otimiza operações em documento único. Transações multi-documento foram adicionadas (MongoDB 4.0+, Firestore nativo). Desafios: performance inferior a transações single-doc, timeouts, na maioria é melhor modelar dados para evitar transações multi-doc.",
        x: "Firestore: await runTransaction(db, async (t) => { const doc = await t.get(ref); t.update(ref, { saldo: doc.data().saldo - 100 }); t.update(ref2, { saldo: doc2.data().saldo + 100 }); }); — atômico.",
      },
      {
        q: "O que é Change Data Capture (CDC) e como é usado com bancos NoSQL?",
        o: [
          "Captura mudanças em tempo real no banco para propagar a outros sistemas via stream de eventos",
          "Backup incremental agendado",
          "Compressão de dados alterados",
          "Versionamento de esquema",
        ],
        c: 0,
        e: "CDC captura INSERT/UPDATE/DELETE em tempo real e propaga como eventos. MongoDB: Change Streams (watch()). DynamoDB: DynamoDB Streams. Firestore: onSnapshot. Usos: sincronizar cache, alimentar Elasticsearch, event sourcing, materializar views, integrar microsserviços.",
        x: "MongoDB: db.collection('pedidos').watch().on('change', (change) => { if (change.operationType === 'insert') { elasticsearch.index(change.fullDocument); } }); — indexa automaticamente cada novo pedido no Elasticsearch.",
      },
      {
        q: "Quais critérios usar para escolher entre consistência forte e eventual em um banco NoSQL?",
        o: [
          "Forte para dados financeiros/críticos; eventual para feeds, contadores e dados que toleram atraso de propagação",
          "Sempre usar consistência forte",
          "Sempre usar eventual consistency",
          "Depende apenas do preço do serviço",
        ],
        c: 0,
        e: "Consistência forte: toda leitura retorna o último write (saldo bancário, estoque com unidade única, reservas). Eventual: leituras podem estar desatualizadas por ms/s (feeds sociais, contadores de likes, analytics). Trade-off: forte = maior latência e menor throughput; eventual = inverso.",
        x: "Saldo bancário: forte (ler R$100, sacar R$50, outro nó não pode ler R$100 ainda). Timeline Instagram: eventual (post aparece 2s depois para seguidores em outra região — aceitável). DynamoDB: ConsistentRead: true para forte.",
      },
    ],
  },

  // ── Clean Code e Boas Práticas ──
  "Clean Code e Boas Práticas": {
    Fácil: [
      {
        q: "Segundo os princípios de Clean Code, qual prática melhora a legibilidade ao nomear variáveis?",
        o: [
          "Usar nomes descritivos que revelam a intenção da variável",
          "Usar abreviações de uma letra para economizar espaço",
          "Usar prefixos com o tipo da variável (strNome, intIdade)",
          "Usar nomes genéricos como 'data' e 'info'",
        ],
        c: 0,
        e: "Nomes descritivos eliminam a necessidade de comentários e tornam o código auto-explicativo. O leitor entende imediatamente o que a variável representa sem precisar analisar o contexto.",
        x: "Ruim: const d = new Date(); const n = users.length; Bom: const createdAt = new Date(); const totalUsers = users.length;",
      },
      {
        q: "O que é o princípio de Responsabilidade Única (SRP) e por que é importante?",
        o: [
          "Uma classe/função deve ter apenas uma razão para mudar, ou seja, uma única responsabilidade",
          "Uma função só pode ter um parâmetro",
          "Um arquivo só pode ter uma classe",
          "Uma variável só pode ser usada uma vez",
        ],
        c: 0,
        e: "SRP (primeiro princípio do SOLID): cada módulo deve ter uma única razão para mudar. Se uma classe gerencia usuários E envia e-mails, mudanças na lógica de e-mail forçam alterações na classe de usuários. Separe em UserService e EmailService.",
        x: "Ruim: class UserService { createUser() {...} sendEmail() {...} generateReport() {...} } — 3 razões para mudar. Bom: UserService (crud), EmailService (emails), ReportService (relatórios).",
      },
      {
        q: "Por que funções devem ser pequenas e fazer apenas uma coisa, segundo Clean Code?",
        o: [
          "Facilita leitura, teste e manutenção; funções grandes são difíceis de entender e testar",
          "Funções grandes são mais rápidas",
          "O compilador exige funções pequenas",
          "Funções grandes ocupam mais memória",
        ],
        c: 0,
        e: "Funções pequenas (5-20 linhas) são mais fáceis de: ler (cabém na tela), entender (fazem uma coisa), testar (menos cenários) e reutilizar. Robert C. Martin (Clean Code) defende que funções devem fazer uma única coisa (one level of abstraction) e ter nomes descritivos.",
        x: "Ruim: processOrder() com 200 linhas que valida, calcula, cobra e envia e-mail. Bom: processOrder() chama validateOrder(), calculateTotal(), chargePayment(), sendConfirmation() — cada uma faz uma coisa.",
      },
      {
        q: "O que é DRY (Don't Repeat Yourself) e por que é importante?",
        o: [
          "Princípio de evitar duplicação de código; cada lógica deve existir em um único lugar",
          "Secar o código removendo espaços",
          "Não repetir testes",
          "Deletar código antigo",
        ],
        c: 0,
        e: "DRY: cada pedaço de conhecimento deve ter uma única representação no sistema. Código duplicado é bug duplo: se corrigir em um lugar e esquecer no outro, têm-se comportamentos inconsistentes. Extraia funções, constantes e módulos reutilizáveis.",
        x: "Ruim: validação de email duplicada em registerUser() e updateProfile(). Bom: função validateEmail(email) reutilizada em ambos. Correção de bug: altera em 1 lugar só.",
      },
      {
        q: "O que são nomes descritivos e por que são importantes no Clean Code?",
        o: [
          "Variáveis e funções com nomes que revelam intenção, eliminando a necessidade de comentários",
          "Nomes curtos de 1-2 caracteres",
          "Nomes em inglês obrigatoriamente",
          "Usar sempre abreviações",
        ],
        c: 0,
        e: "Nomes descritivos tornam o código auto-documentável. Ruim: d, temp, data, info (genéricos). Bom: daysUntilExpiration, activeUserCount, isPaymentOverdue. O nome deve responder: o que é, para que serve, por que existe.",
        x: "Ruim: const d = new Date(); const t = d.getTime(); Bom: const currentDate = new Date(); const timestampMs = currentDate.getTime(); O código se explica sozinho.",
      },
      {
        q: "O que significa 'Early Return' e como melhora a legibilidade do código?",
        o: [
          "Retornar cedo de uma função quando condições de guarda falham, evitando aninhamento profundo",
          "Retornar sempre null",
          "Encerrar o programa o mais rápido possível",
          "Usar return em todas as linhas",
        ],
        c: 0,
        e: "Early return usa cláusulas de guarda no início da função para tratar casos inválidos e retornar imediatamente. Evita múltiplos níveis de if/else aninhados (arrow anti-pattern). O fluxo principal fica no nível mais alto de indentação, facilitando leitura.",
        x: "Ruim: function process(user) { if (user) { if (user.active) { if (user.verified) { // lógica } } } }\nBom: function process(user) { if (!user) return; if (!user.active) return; if (!user.verified) return; // lógica no nível principal }",
      },
      {
        q: "Por que evitar números mágicos (magic numbers) no código?",
        o: [
          "Porque não transmitem significado; usar constantes nomeadas torna o código auto-explicativo",
          "Porque causam erros de compilação",
          "Porque ocupam mais memória",
          "Porque são mais lentos",
        ],
        c: 0,
        e: "Números mágicos são valores literais sem contexto (ex: if (status === 3)). Não revelam a intenção: o que é 3? Extrair para constantes nomeadas (const STATUS_APPROVED = 3) torna o código legível, facilita manutenção e evita erros de digitação.",
        x: "Ruim: if (days > 30) { charge(amount * 0.02); }\nBom: const OVERDUE_THRESHOLD_DAYS = 30; const LATE_FEE_RATE = 0.02; if (days > OVERDUE_THRESHOLD_DAYS) { charge(amount * LATE_FEE_RATE); }",
      },
    ],
    Médio: [
      {
        q: "O que é o princípio DRY (Don't Repeat Yourself) e qual problema ele resolve?",
        o: [
          "Eliminar duplicação de lógica, garantindo que cada conhecimento tenha uma única representação no código",
          "Nunca reutilizar código entre projetos",
          "Escrever código sem comentários",
          "Não repetir testes unitários",
        ],
        c: 0,
        e: "DRY determina que cada pedaço de conhecimento/lógica deve existir em um único lugar. Duplicação de código leva a inconsistências quando uma cópia é corrigida mas as outras não. A solução é extrair a lógica duplicada para uma função, módulo ou classe reutilizável.",
        x: "Ruim: cálculo de imposto duplicado em 5 controllers. Bom: função calculateTax(amount, rate) chamada pelos 5 controllers. Corrigir o cálculo exige alterar apenas 1 lugar.",
      },
      {
        q: "O que é o princípio KISS (Keep It Simple, Stupid) aplicado ao código?",
        o: [
          "Preferir soluções simples e diretas, evitando complexidade desnecessária",
          "Usar apenas uma linguagem de programação",
          "Não usar frameworks",
          "Escrever o mínimo de código possível",
        ],
        c: 0,
        e: "KISS defende que a simplicidade deve ser um objetivo central do design. Código simples é mais fácil de entender, manter e debugar. Over-engineering (adicionar abstrações prematuramente, usar patterns complexos para problemas simples) viola KISS.",
        x: "KISS: usar if/else para 3 casos. Over-engineering: criar Strategy Pattern com factory e DI container para os mesmos 3 casos. Se não vai crescer, KISS ganha.",
      },
      {
        q: "O que é refactoring e quando deve ser feito?",
        o: [
          "Reestruturar código existente sem alterar seu comportamento externo, melhorando qualidade interna",
          "Reescrever o sistema do zero",
          "Adicionar novas features",
          "Corrigir bugs",
        ],
        c: 0,
        e: "Refactoring melhora a estrutura interna (legibilidade, manutenção, performance) sem mudar o comportamento externo. Deve ser feito continuamente (boy scout rule: deixe o código melhor do que encontrou), antes de adicionar features, e quando code smells são identificados.",
        x: "Code smell: função com 200 linhas. Refactoring: extrair em 5 funções menores. Code smell: duplicação. Refactoring: extrair função reutilizável. Testes passam antes e depois → comportamento preservado.",
      },
      {
        q: "O que é Technical Debt (dívida técnica) e como gerenciá-la?",
        o: [
          "Custo futuro causado por atalhos ou decisões de design subótimas; gerenciar com refactoring contínuo",
          "Dívida financeira do projeto",
          "Bug no código de produção",
          "Código sem comentários",
        ],
        c: 0,
        e: "Dívida técnica: atalhos que aceleram agora mas custam depois (código duplicado, sem testes, arquitetura frágil). Como dívida financeira, acumula juros (cada feature fica mais cara). Gerenciar: reservar % do sprint para refactoring, boy scout rule, tech debt backlog.",
        x: "Sprint 1: gambiarra rápida para entregar no prazo (1h). Sprint 5: bug causado pela gambiarra leva 8h para resolver + 4h de regressão. Juros da dívida: 12h vs 1h original.",
      },
      {
        q: "O que é code review e quais são as melhores práticas?",
        o: [
          "Revisão de código por pares antes do merge; buscar clareza, correção e mantenibilidade",
          "Teste automático do código",
          "Reviso do gerente de projeto",
          "Análise de performance",
        ],
        c: 0,
        e: "Code review detecta bugs antes de produzir, compartilha conhecimento na equipe, mantém padrões. Boas práticas: PRs pequenas (<400 linhas), comentários construtivos, automatizar lint/formato, focar em lógica (não estilo), responder rápido (<24h).",
        x: "PR com 50 linhas: revisada em 15 min, 2 sugestões, merge no mesmo dia. PR com 2000 linhas: 3 dias para revisar, 20 comentários, conflitos de merge. Menor = melhor.",
      },
      {
        q: "O que são os princípios SOLID e por que são importantes no design orientado a objetos?",
        o: [
          "Cinco princípios de design que reduzem acoplamento e facilitam manutenção: SRP, OCP, LSP, ISP, DIP",
          "Framework de testes",
          "Linguagem de programação",
          "Metodologia ágil",
        ],
        c: 0,
        e: "SOLID: S (Single Responsibility), O (Open/Closed), L (Liskov Substitution), I (Interface Segregation), D (Dependency Inversion). Juntos, criam código com baixo acoplamento, alta coesão, fácil de testar, estender e manter. Fundamentais para design orientado a objetos robusto.",
        x: "Sem SOLID: classe UserService com 2000 linhas que faz CRUD, envia email, gera relatório, valida pagamento. Com SOLID: UserService (CRUD), EmailService, ReportService, PaymentValidator — cada um com responsabilidade única (SRP).",
      },
      {
        q: "O que é o princípio YAGNI (You Aren't Gonna Need It)?",
        o: [
          "Não implementar funcionalidades até que sejam realmente necessárias, evitando over-engineering",
          "Nunca usar bibliotecas externas",
          "Não escrever documentação",
          "Sempre implementar o máximo possível",
        ],
        c: 0,
        e: "YAGNI: não adicione funcionalidades especulativas. Código não usado é custo sem valor: precisa ser mantido, testado e compreendido. Complementar ao KISS. Origem: Extreme Programming (XP). 'Do the simplest thing that could possibly work.'",
        x: "YAGNI violado: criar sistema de plugins extensível para app de TODO list que nunca terá plugins. YAGNI respeitado: implementar apenas as features no backlog atual. Se futuramente precisar de plugins, refatore na hora.",
      },
    ],
    Difícil: [
      {
        q: "No princípio SOLID, o que estabelece a letra 'D' (Dependency Inversion Principle) e como ele impacta a testabilidade do código?",
        o: [
          "Módulos de alto nível devem depender de abstrações, não de implementações concretas, facilitando mocks em testes",
          "Dependências devem ser instaladas em ordem inversa",
          "Código deve evitar qualquer dependência externa",
          "Módulos devem depender sempre de implementações concretas para performance",
        ],
        c: 0,
        e: "O Dependency Inversion Principle (DIP) determina que módulos de alto nível não devem depender de módulos de baixo nível — ambos devem depender de abstrações (interfaces). Isso permite substituir implementações concretas por mocks/stubs nos testes e trocar implementações sem modificar o código consumidor.",
        x: "class OrderService { constructor(private repo: IOrderRepository) {} } — depende da interface, não do PostgresOrderRepository concreto. No teste: new OrderService(new MockOrderRepository()).",
      },
      {
        q: "O que são Code Smells e quais são os mais comuns?",
        o: [
          "Indicadores de problemas no código: funções longas, duplicação, parâmetros excessivos, classes grandes",
          "Erros de compilação",
          "Vulnerabilidades de segurança",
          "Problemas de performance",
        ],
        c: 0,
        e: "Code smells são indicadores de design problemático (não são bugs). Comuns: Long Method (função longa), Duplicated Code, Large Class (classe com muitas responsabilidades), Feature Envy (método usa mais dados de outra classe), Primitive Obsession (usar primitivos em vez de Value Objects).",
        x: "Feature Envy: calculateDiscount(order) acessa order.customer.memberSince, order.customer.totalPurchases, order.customer.tier — deveria estar na classe Customer: customer.calculateDiscount().",
      },
      {
        q: "O que é o princípio Open/Closed (OCP) do SOLID e como implementá-lo?",
        o: [
          "Entidades devem estar abertas para extensão mas fechadas para modificação, usando abstrações",
          "Código deve ser open-source",
          "Arquivos devem ficar abertos durante o deploy",
          "Funções devem aceitar qualquer tipo de parâmetro",
        ],
        c: 0,
        e: "OCP: você deve poder adicionar novos comportamentos sem modificar código existente. Implementação: usar interfaces, herança, Strategy Pattern ou composição. Novo caso = nova classe que implementa a interface, sem alterar nenhuma classe existente.",
        x: "Antes (viola OCP): if (shape === 'circle') calcCircle(); else if (shape === 'square') calcSquare(); — adicionar triângulo exige modificar a função. Depois: interface Shape { area(): number } + classes Circle, Square, Triangle — adicionar Triangle não modifica nada.",
      },
      {
        q: "O que é o princípio KISS (Keep It Simple, Stupid) no desenvolvimento?",
        o: [
          "Manter soluções simples e diretas; evitar complexidade desnecessária",
          "Usar sempre a tecnologia mais avançada",
          "Minimizar número de arquivos",
          "Usar abreviações em todo o código",
        ],
        c: 0,
        e: "KISS: a simplicidade deve ser um objetivo-chave. Soluções simples são mais fáceis de entender, manter e debugar. Evite over-engineering: não use design patterns complexos para problemas simples. YAGNI (You Aren't Gonna Need It) é complementar.",
        x: "Over-engineering: criar AbstractFactoryStrategyObserver para uma feature de TODO list. KISS: uma função addTodo(text) e uma lista. Complexidade só quando a necessidade justificar.",
      },
      {
        q: "O que é o princípio de Separação de Concerns (Separation of Concerns)?",
        o: [
          "Dividir o sistema em partes distintas, cada uma tratando uma preocupação específica",
          "Separar código frontend e backend em repos diferentes",
          "Usar apenas um padrão de projeto",
          "Manter todo código em um arquivo",
        ],
        c: 0,
        e: "Cada módulo/classe/função deve tratar de uma única preocupação. Separação reduz acoplamento e aumenta coesão. Exemplos: MVC, camadas (UI, lógica, dados), módulos por domínio. Misturar concerns cria código difícil de manter e testar.",
        x: "Violação: componente React que faz fetch, validação, render e logging tudo junto. Separado: custom hook useFetchUsers (dados), validateUser util (lógica), UserList component (UI).",
      },
      {
        q: "O que é complexidade ciclomática e como ela indica qualidade do código?",
        o: [
          "Métrica que conta caminhos independentes de execução; alta complexidade indica código difícil de testar e manter",
          "Velocidade de execução do código",
          "Quantidade de linhas por arquivo",
          "Número de dependências externas",
        ],
        c: 0,
        e: "Complexidade ciclomática (McCabe) = número de caminhos independentes no fluxo de controle. Cada if, for, while, case, && e || incrementa. CC=1-5: simples. CC=6-10: moderado. CC>10: arriscado (muitos branches = difícil testar todos). Ferramentas: ESLint complexity rule, SonarQube.",
        x: "function check(a,b,c) { if (a) { if (b) return 1; else return 2; } if (c) return 3; return 4; } — CC=4 (4 caminhos). Para testar 100%: 4 testes. CC=20 → 20 testes mínimos, provavelmente precisa refatorar.",
      },
      {
        q: "O que é o princípio de Liskov Substitution (LSP) do SOLID?",
        o: [
          "Subtipos devem ser substituíveis por seus tipos base sem alterar a correção do programa",
          "Listar todas as dependências no início do arquivo",
          "Substituir classes por funções",
          "Usar apenas herança, nunca composição",
        ],
        c: 0,
        e: "LSP: se S é subtipo de T, objetos de tipo T podem ser substituídos por objetos de tipo S sem quebrar o programa. Violação clássica: Square extends Rectangle — setWidth() em Square altera height também, quebrando expectativas de Rectangle. Solução: modelar corretamente a hierarquia.",
        x: "Violação: class Bird { fly() {} } class Penguin extends Bird { fly() { throw Error('Não voa!'); } } — código que chama bird.fly() quebra com Penguin. Solução: interface FlyingBird e interface SwimmingBird separadas.",
      },
    ],
  },

  // ── Design Patterns ──
  "Design Patterns": {
    Fácil: [
      {
        q: "Qual Design Pattern garante que uma classe tenha apenas uma única instância em toda a aplicação?",
        o: ["Singleton", "Factory", "Observer", "Strategy"],
        c: 0,
        e: "O Singleton restringe a instanciação de uma classe a um único objeto. Ele fornece um ponto de acesso global à instância através de um método estático, garantindo que todas as partes do código usem o mesmo objeto.",
        x: "class Database { static instance; static getInstance() { if (!this.instance) this.instance = new Database(); return this.instance; } } — toda chamada a Database.getInstance() retorna o mesmo objeto.",
      },
      {
        q: "Qual Design Pattern cria objetos sem expor a lógica de criação, delegando a decisão para subclasses ou métodos?",
        o: ["Factory", "Singleton", "Observer", "Decorator"],
        c: 0,
        e: "O Factory Method define uma interface para criar objetos, mas deixa subclasses decidirem qual classe instanciar. Abstract Factory cria famílias de objetos relacionados. Ambos encapsulam a lógica de criação, desacoplando o código consumidor das classes concretas.",
        x: "function createPayment(type) { if (type === 'pix') return new PixPayment(); if (type === 'card') return new CardPayment(); } — consumidor usa createPayment('pix') sem conhecer a classe concreta.",
      },
      {
        q: "Qual Design Pattern permite notificar múltiplos objetos quando o estado de outro objeto muda?",
        o: ["Observer", "Singleton", "Factory", "Adapter"],
        c: 0,
        e: "O Observer define uma relação um-para-muitos: quando o 'subject' muda de estado, todos os 'observers' inscritos são notificados automaticamente. Muito usado em eventos de UI, sistemas reativos e padrão pub/sub.",
        x: "EventEmitter do Node.js é Observer: emitter.on('order-created', sendEmail); emitter.on('order-created', updateInventory); emitter.emit('order-created', order); — ambos handlers são notificados.",
      },
      {
        q: "O que é o padrão Singleton e quando utilizá-lo?",
        o: [
          "Garante que uma classe tenha apenas uma instância e fornece um ponto de acesso global",
          "Cria múltiplas instâncias simultaneamente",
          "Padrão para criar interfaces",
          "Padrão para herança múltipla",
        ],
        c: 0,
        e: "Singleton: a classe controla sua própria instanciação, garantindo que exista apenas uma. Usado para: conexão de banco de dados, logger, configuração global. Cuidado: pode dificultar testes (estado global) e violar SRP.",
        x: "class Database { static instance; static getInstance() { if (!this.instance) this.instance = new Database(); return this.instance; } } — Database.getInstance() sempre retorna a mesma conexão.",
      },
      {
        q: "O que é o padrão Factory Method?",
        o: [
          "Define uma interface para criar objetos, mas delega a decisão de qual classe instanciar para subclasses",
          "Método que destrói objetos",
          "Padrão para clonar objetos",
          "Método estático de configuração",
        ],
        c: 0,
        e: "Factory Method encapsula a criação de objetos. O código cliente chama o factory sem saber qual classe concreta será instanciada. Vantagem: adicionar novos tipos sem modificar o código existente (Open/Closed Principle).",
        x: "function createNotification(type) { if (type === 'email') return new EmailNotification(); if (type === 'sms') return new SMSNotification(); } — o cliente não precisa conhecer as classes concretas.",
      },
      {
        q: "O que é o padrão Observer (Observador) e onde é mais utilizado?",
        o: [
          "Padrão que notifica automaticamente múltiplos objetos quando o estado de um objeto muda",
          "Padrão para observar arquivos no disco",
          "Ferramenta de monitoramento",
          "Plugin de depuração",
        ],
        c: 0,
        e: "Observer define relação 1:N. O subject mantém lista de observers e os notifica quando muda. Desacopla emissor de receptores. Usado em: eventos DOM, EventEmitter do Node.js, RxJS Observables, React useState (re-render), Redux subscribe.",
        x: "button.addEventListener('click', handleClick); — o botão (subject) notifica handlers (observers). Não precisa saber quantos ou quem são os listeners.",
      },
      {
        q: "O que é o padrão Adapter e qual problema ele resolve?",
        o: [
          "Converte a interface de uma classe existente para outra interface esperada, permitindo integração",
          "Cria novos objetos",
          "Adiciona funcionalidades a objetos",
          "Gerencia ciclo de vida de objetos",
        ],
        c: 0,
        e: "Adapter é um wrapper que traduz chamadas de uma interface para outra. Útil quando precisa usar uma biblioteca cujos métodos têm nomes e parâmetros diferentes do que seu código espera. Análogo: adaptador de tomada que converte plug americano para padrão brasileiro.",
        x: "Seu código usa interface Logger { info(msg), error(msg) }. Lib usa Winston { log('info', msg) }. WinstonAdapter implements Logger { info(msg) { winston.log('info', msg); } } — integração sem alterar seu código.",
      },
    ],
    Médio: [
      {
        q: "Qual Design Pattern permite definir uma família de algoritmos intercambiáveis, encapsulando cada um em uma classe separada?",
        o: ["Strategy", "Singleton", "Adapter", "Decorator"],
        c: 0,
        e: "O Strategy permite selecionar um algoritmo em tempo de execução. Cada algoritmo é encapsulado em uma classe que implementa uma interface comum. O contexto delega a execução à estratégia selecionada, facilitando adição de novos algoritmos sem modificar código existente.",
        x: "interface PaymentStrategy { pay(amount: number): void } → classes CreditCardPayment, PixPayment, BoletoPayment. Checkout usa strategy.pay(100) sem conhecer a implementação.",
      },
      {
        q: "Qual Design Pattern adiciona funcionalidades a um objeto dinamicamente sem alterar sua classe?",
        o: ["Decorator", "Singleton", "Factory", "Observer"],
        c: 0,
        e: "O Decorator envolve (wraps) um objeto com outro que implementa a mesma interface, adicionando comportamento antes/depois de delegar ao objeto original. Permite combinar funcionalidades em tempo de execução sem explodir o número de subclasses.",
        x: "const logger = withLogging(baseService); const cached = withCache(logger); — baseService ganha logging e cache sem modificação. Em Java: new BufferedReader(new FileReader(file)) — BufferedReader decora FileReader.",
      },
      {
        q: "Qual Design Pattern converte a interface de uma classe em outra interface esperada pelo cliente?",
        o: ["Adapter", "Facade", "Proxy", "Bridge"],
        c: 0,
        e: "O Adapter permite que classes com interfaces incompatíveis trabalhem juntas. Ele cria um wrapper que traduz as chamadas da interface esperada para a interface real do objeto adaptado. Muito útil ao integrar bibliotecas de terceiros ou sistemas legados.",
        x: "Seu código espera interface Payment { charge(amount) }. Lib externa tem StripeSDK { createCharge(cents) }. StripeAdapter implements Payment { charge(amount) { stripe.createCharge(amount * 100); } } — adapta dólares para centavos.",
      },
      {
        q: "O que é o padrão Decorator e como ele difere de herança?",
        o: [
          "Adiciona responsabilidades a objetos dinamicamente via composição, sem alterar a classe original",
          "É igual a herança",
          "Substitui métodos existentes",
          "Remove funcionalidades de objetos",
        ],
        c: 0,
        e: "Decorator envolve (wraps) um objeto adicionando comportamento. Diferente de herança: é dinâmico (runtime), pode combinar múltiplos decorators, e não cria hierarquia profunda. Herança é estática (compile-time) e pode causar explosão de subclasses.",
        x: "const logger = new LoggingDecorator(new AuthDecorator(new HttpClient())); — cada chamada passa por logging → auth → http. Composição dinâmica sem criar ClasseLogAuthHttp.",
      },
      {
        q: "O que é o padrão Builder e quando é mais adequado que um construtor com muitos parâmetros?",
        o: [
          "Constrói objetos complexos passo a passo com uma API fluente, evitando construtores com dezenas de parâmetros",
          "Destrói objetos complexos",
          "Constrói apenas strings",
          "É alternativa ao Factory apenas",
        ],
        c: 0,
        e: "Builder separa a construção de um objeto complexo da sua representação. Útil quando: muitos parâmetros opcionais, construção em etapas, ou diferentes representações do mesmo objeto. API fluente: encadear métodos que retornam this.",
        x: "const query = new QueryBuilder().select('name', 'email').from('users').where('age > 18').orderBy('name').limit(10).build(); — legível e flexível vs new Query('name,email', 'users', 'age>18', 'name', 10).",
      },
      {
        q: "O que é o padrão Proxy e quais suas variações mais comuns?",
        o: [
          "Objeto substituto que controla o acesso ao objeto real; variações: virtual, de proteção, de log e remoto",
          "Servidor intermediário de rede",
          "Cache distribuído",
          "Padrão exclusivo para redes",
        ],
        c: 0,
        e: "Proxy cria um substituto para outro objeto, controlando acesso. Virtual Proxy: lazy loading (carrega objeto pesado só quando necessário). Protection Proxy: controla acesso por permissões. Logging Proxy: registra chamadas. Remote Proxy: representa objeto em outro servidor.",
        x: "Proxy para lazy loading de imagem: class ImageProxy { getImage() { if (!this.image) this.image = loadFromDisk(); return this.image; } } — a imagem pesada só é carregada na primeira chamada, não na construção.",
      },
      {
        q: "O que é o padrão Template Method e como difere do Strategy?",
        o: [
          "Define o esqueleto de um algoritmo na superclasse, delegando passos específicos a subclasses via herança",
          "Permite trocar algoritmos em runtime via composição",
          "Cria objetos dinamicamente",
          "É igual ao Strategy",
        ],
        c: 0,
        e: "Template Method usa herança: superclasse define o algoritmo com 'hooks' que subclasses implementam. Strategy usa composição: algoritmo inteiro é substituído em runtime. Template Method: estrutura fixa, passos variáveis. Strategy: algoritmo inteiramente intercambiável.",
        x: "Template Method: abstract class DataParser { parse(file) { open(file); extract(); validate(); close(); } abstract extract(); } — CSVParser e JSONParser implementam apenas extract(). A sequência open→extract→validate→close é fixa.",
      },
    ],
    Difícil: [
      {
        q: "Como o padrão Event Sourcing difere do CRUD tradicional na persistência de dados e quais são seus trade-offs?",
        o: [
          "Armazena eventos imutáveis em vez de estados atuais; ganha auditoria completa mas aumenta complexidade de queries",
          "Armazena o estado final; ganha simplicidade mas perde histórico",
          "É um pattern de UI, não de persistência",
          "Usa bancos de grafos para armazenar estados",
        ],
        c: 0,
        e: "No Event Sourcing, cada mudança é registrada como um evento imutável (ex.: 'PedidoCriado', 'ItemAdicionado', 'PagamentoConfirmado'). O estado atual é reconstituído reproduzindo os eventos. Vantagens: histórico completo, auditoria, temporal queries. Trade-offs: complexidade de leitura (precisa de projeções), volume de dados, eventual consistency.",
        x: "CRUD: UPDATE accounts SET balance=900 WHERE id=1. Event Sourcing: append { type: 'Debited', amount: 100, accountId: 1 }. O saldo atual é calculado somando todos os eventos da conta.",
      },
      {
        q: "Qual é a diferença entre o padrão Facade e o padrão Adapter?",
        o: [
          "Facade simplifica uma interface complexa; Adapter converte uma interface para outra esperada",
          "São idênticos",
          "Adapter simplifica e Facade converte",
          "Facade é para criação e Adapter para comportamento",
        ],
        c: 0,
        e: "Facade fornece uma interface simplificada para um subsistema complexo (múltiplas classes). Adapter converte a interface de uma classe existente para a interface que o cliente espera. Facade reduz complexidade; Adapter resolve incompatibilidade.",
        x: "Facade: OrderFacade.placeOrder(items) internamente chama InventoryService, PaymentService, ShippingService, NotificationService. Adapter: StripeAdapter converte interface Payment para interface Stripe específica.",
      },
      {
        q: "O que é o padrão Repository e como ele se relaciona com Domain-Driven Design?",
        o: [
          "Abstração que encapsula a lógica de acesso a dados, fazendo o domínio ignorar detalhes de persistência",
          "Repositório Git",
          "Cache de armazenamento",
          "Padrão de UI",
        ],
        c: 0,
        e: "No DDD, Repository é a fronteira entre domínio e infraestrutura. Define uma interface (port) com métodos como findById(), save(), delete() que o domínio usa sem saber se os dados vêm de PostgreSQL, MongoDB, API ou memória. Implementação concreta fica na camada de infraestrutura.",
        x: "interface OrderRepository { findById(id: OrderId): Order; save(order: Order): void; } — Domínio depende dessa interface. PostgresOrderRepository implements OrderRepository na camada de infra.",
      },
      {
        q: "O que é o padrão Mediator e qual problema ele resolve?",
        o: [
          "Centraliza a comunicação entre objetos, reduzindo acoplamento direto entre componentes",
          "Cria conexão direta entre todos os objetos",
          "Padrão de persistência de dados",
          "Padrão para criação de objetos",
        ],
        c: 0,
        e: "Mediator encapsula a interação entre um conjunto de objetos em um único lugar. Em vez de A falar com B, C, D diretamente (N² conexões), todos falam com o Mediator (N conexões). Exemplos: chat room, controlador de tráfego aéreo, Redux store.",
        x: "Sem Mediator: ComponentA chama ComponentB.update() e ComponentC.refresh() diretamente. Com Mediator: ComponentA emite evento para Mediator, que notifica B e C. Adicionar ComponentD não muda A.",
      },
      {
        q: "O que é o padrão Chain of Responsibility e como ele funciona?",
        o: [
          "Encadeia handlers onde cada um decide se processa a requisição ou passa para o próximo",
          "Uma única classe processa tudo",
          "Cadeia de herança entre classes",
          "Padrão para paralelizar processamento",
        ],
        c: 0,
        e: "Chain of Responsibility: requisição passa por uma cadeia de handlers. Cada handler decide: processar, modificar e passar, ou rejeitar. Desacopla o emissor dos receptores. Exemplos: middlewares Express, pipeline de validação, filtros de servlet.",
        x: "Express middlewares: app.use(cors()).use(authMiddleware).use(rateLimiter).use(router) — cada middleware decide se continua (next()) ou interrompe (res.status(401)). Adicionar/remover middleware não afeta outros.",
      },
      {
        q: "O que é o padrão Visitor e quando utilizá-lo?",
        o: [
          "Permite adicionar operações a uma hierarquia de classes sem modificá-las, usando double dispatch",
          "Padrão para rastrear visitantes de um site",
          "Contador de acessos a métodos",
          "Padrão de autenticação",
        ],
        c: 0,
        e: "Visitor separa algoritmos das estruturas sobre as quais operam. Cada elemento aceita um visitor que executa a operação específica. Double dispatch: elemento chama visitor.visit(this), visitor tem overload por tipo. Útil para AST (Abstract Syntax Tree), serialização, relatórios.",
        x: "AST de compilador: nodes IfNode, ForNode, AssignNode. PrintVisitor { visitIf(node), visitFor(node) }. OptimizeVisitor { visitIf(node), visitFor(node) }. Adicionar nova operação (novo visitor) sem alterar os nodes.",
      },
      {
        q: "O que é o padrão State e como simplifica lógica condicional complexa?",
        o: [
          "Encapsula cada estado em uma classe separada, delegando comportamento ao objeto de estado atual",
          "Gerenciador de estado global como Redux",
          "Padrão para banco de dados temporal",
          "Variável que armazena configuração",
        ],
        c: 0,
        e: "State: em vez de if/switch gigante verificando estado, cada estado é uma classe com seu próprio comportamento. O contexto delega ao estado atual. Transições: estado atual define para qual estado ir. Elimina condicionais complexas e respeita Open/Closed Principle.",
        x: "Pedido com estados: Rascunho, Pendente, Pago, Enviado, Entregue. Cada classe implementa: confirmar(), cancelar(), enviar(). DraftState.confirmar() → muda para PendingState. PaidState.cancelar() → inicia reembolso. Sem ifs, cada estado sabe seu comportamento.",
      },
    ],
  },

  // ── Git e Versionamento ──
  "Git e Versionamento": {
    Fácil: [
      {
        q: "Qual comando Git é usado para criar uma cópia local de um repositório remoto?",
        o: ["git clone", "git init", "git pull", "git fork"],
        c: 0,
        e: "O 'git clone' cria uma cópia completa de um repositório remoto na máquina local, incluindo todo o histórico de commits, branches e tags. Ele também configura automaticamente o remote 'origin' apontando para o repositório de origem.",
        x: "git clone https://github.com/user/repo.git — cria a pasta 'repo' localmente com todo o histórico e configura origin automaticamente.",
      },
      {
        q: "Qual comando Git cria uma nova branch e muda para ela ao mesmo tempo?",
        o: [
          "git checkout -b ou git switch -c",
          "git branch",
          "git merge",
          "git stash",
        ],
        c: 0,
        e: "'git checkout -b nova-branch' (ou 'git switch -c nova-branch' na sintaxe moderna) cria uma nova branch a partir do commit atual e muda para ela em um único comando. É equivalente a: git branch nova-branch && git checkout nova-branch.",
        x: "git switch -c feature/login — cria a branch 'feature/login' a partir do commit atual e muda para ela. 'git branch' lista todas as branches; 'git branch -d feature/login' deleta após merge.",
      },
      {
        q: "O que faz o comando 'git add' e qual é a diferença entre working directory, staging area e repository?",
        o: [
          "git add move alterações para a staging area; os 3 estágios são: arquivos modificados, prontos para commit e commitados",
          "git add faz o commit diretamente",
          "Só existem 2 estágios",
          "git add envia para o servidor remoto",
        ],
        c: 0,
        e: "Working Directory: arquivos modificados localmente. Staging Area (index): alterações marcadas com 'git add', prontas para commit. Repository: histórico de commits permanente após 'git commit'. Esse fluxo de 3 estágios permite escolher quais mudanças incluir em cada commit.",
        x: "Editou a.js e b.js. git add a.js → apenas a.js vai para staging. git commit -m 'fix a' → commita só a.js. b.js continua no working directory, não commitado.",
      },
      {
        q: "O que é um commit no Git e como escrever boas mensagens de commit?",
        o: [
          "Snapshot do estado dos arquivos no staging; mensagem deve ser imperativa, curta e descritiva",
          "Upload dos arquivos para o servidor",
          "Backup automático do projeto",
          "Sincronização com repositório remoto",
        ],
        c: 0,
        e: "Commit é um snapshot imutável do estado dos arquivos no staging area. Cada commit tem um hash SHA-1 único, referência ao pai, autor e mensagem. Boas mensagens: imperativo ('Adiciona feature X'), curtas (50 chars), com corpo explicando o porquê se necessário.",
        x: "Ruim: 'fix', 'update', 'changes'. Bom: 'fix: corrige cálculo de frete para pedidos internacionais'. Formato: tipo: descrição curta\n\nCorpo opcional com contexto.",
      },
      {
        q: "O que é o .gitignore e para que serve?",
        o: [
          "Arquivo que lista padrões de arquivos/pastas que o Git deve ignorar e não rastrear",
          "Arquivo de configuração do GitHub",
          "Lista de branches protegidas",
          "Log de erros do Git",
        ],
        c: 0,
        e: ".gitignore define quais arquivos/pastas o Git não deve rastrear. Comum: node_modules/, .env, dist/, *.log, .DS_Store. Adicionado na raiz do projeto. Já rastreados antes de adicionar ao .gitignore continuam rastreados (precisa git rm --cached).",
        x: "# .gitignore\nnode_modules/\n.env\ndist/\n*.log\n.DS_Store\n\nSe node_modules já foi commitado: git rm -r --cached node_modules && git commit -m 'remove node_modules do tracking'.",
      },
      {
        q: "O que mostra o comando git status?",
        o: [
          "Estado atual do working directory e staging area: arquivos modificados, adicionados e não rastreados",
          "Histórico de commits",
          "Lista de branches remotas",
          "Configurações do repositório",
        ],
        c: 0,
        e: "git status mostra: branch atual, relação com remote (ahead/behind), arquivos modificados (vermelho = unstaged, verde = staged), arquivos não rastreados (untracked). É o comando mais usado para saber o estado do repo antes de add/commit.",
        x: "git status\nOn branch feature/login\nChanges to be committed: (verde)\n  modified: auth.ts\nChanges not staged: (vermelho)\n  modified: utils.ts\nUntracked files: (vermelho)\n  new-file.ts",
      },
      {
        q: "O que é o comando git log e como visualizar o histórico?",
        o: [
          "Mostra o histórico de commits com hash, autor, data e mensagem",
          "Lista arquivos modificados",
          "Mostra branches remotas",
          "Exibe conflitos de merge",
        ],
        c: 0,
        e: "git log mostra commits em ordem cronológica reversa. Opções úteis: --oneline (resumido), --graph (visualizar branches), --author='Ana' (filtrar por autor), -n 5 (limitar a 5), --since='2024-01-01'. git log --all --oneline --graph é a visão mais completa.",
        x: "git log --oneline --graph --all\n* abc1234 (HEAD -> feature) Adiciona login\n| * def5678 (main) Fix header\n|/\n* 789abcd Initial commit — visualização de branches no terminal.",
      },
    ],
    Médio: [
      {
        q: "Qual é a diferença entre 'git merge' e 'git rebase' ao integrar alterações de uma branch?",
        o: [
          "Merge cria um commit de merge preservando o histórico; rebase reaplica commits sobre a branch alvo, linearizando o histórico",
          "Merge apaga a branch e rebase não",
          "Rebase é mais seguro que merge",
          "Não há diferença no resultado final",
        ],
        c: 0,
        e: "Git merge cria um commit de merge (com dois pais), preservando a ramificação no histórico. Git rebase move os commits da branch para o topo da branch alvo, criando um histórico linear. Rebase reescreve hashes dos commits, então não deve ser usado em branches públicas compartilhadas.",
        x: "git checkout feature && git rebase main — reaplica os commits da feature sobre o último commit de main, como se a feature tivesse sido criada a partir do estado atual de main.",
      },
      {
        q: "O que é um conflito de merge no Git e como resolvê-lo?",
        o: [
          "Ocorre quando mesmas linhas foram alteradas em branches diferentes; deve ser resolvido manualmente editando os arquivos",
          "Erro irrecuperável que deleta o código",
          "Bug causado pelo GitHub",
          "Acontece apenas com git rebase",
        ],
        c: 0,
        e: "Conflito ocorre quando duas branches alteram as mesmas linhas de um arquivo. O Git marca com <<<<<<< HEAD (sua versão), ======= e >>>>>>> branch (a outra versão). Você edita manualmente escolhendo o código correto, remove os marcadores e faz git add + git commit.",
        x: "<<<<<<< HEAD\nconst color = 'blue';\n=======\nconst color = 'red';\n>>>>>>> feature\n\nVocê decide: const color = 'blue'; (remove os marcadores). git add arquivo.js && git commit.",
      },
      {
        q: "O que é git stash e quando usá-lo?",
        o: [
          "Salva alterações não commitadas temporariamente para limpar o working directory",
          "Deleta mudanças não salvas",
          "Cria um backup remoto",
          "Faz merge automático",
        ],
        c: 0,
        e: "git stash salva mudanças não commitadas em uma pilha temporária e limpa o working directory. Útil quando precisa trocar de branch mas não quer commitar trabalho incompleto. git stash pop restaura as alterações.",
        x: "Trabalhando na feature, surge bug urgente: git stash → git switch main → corrige bug → git commit → git switch feature → git stash pop → continua trabalhando com as mudanças restauradas.",
      },
      {
        q: "O que é uma Pull Request (PR) / Merge Request (MR) e qual seu papel no fluxo de trabalho?",
        o: [
          "Solicitação para integrar uma branch na branch principal, permitindo revisão de código antes do merge",
          "Comando do Git para baixar código",
          "Requisição HTTP feita pelo Git",
          "Ferramenta de deploy automático",
        ],
        c: 0,
        e: "PR/MR é um recurso de plataformas (GitHub/GitLab/Bitbucket) que propõe integrar mudanças de uma branch em outra. Permite: code review, discussão, CI checks automáticos, aprovações antes do merge. Boas práticas: PRs pequenas, descrição clara, linked issues.",
        x: "Fluxo: git push origin feature/login → Abre PR no GitHub → Reviewer comenta sugestões → Autor corrige → CI passa → Reviewer aprova → Merge → Branch deletada.",
      },
      {
        q: "Qual a diferença entre git fetch e git pull?",
        o: [
          "fetch baixa referências remotas sem alterar o working directory; pull faz fetch + merge automaticamente",
          "São idênticos",
          "fetch envia e pull recebe",
          "pull é mais seguro",
        ],
        c: 0,
        e: "git fetch: baixa commits/branches do remoto para referências locais (origin/main) sem modificar seus arquivos. git pull: faz git fetch + git merge automaticamente. fetch é mais seguro pois permite inspecionar mudanças antes de integrar.",
        x: "git fetch origin → atualiza origin/main localmente. git log main..origin/main → vê o que tem de novo. git merge origin/main → integra. Vs git pull origin main → faz tudo de uma vez (pode causar conflito inesperado).",
      },
      {
        q: "O que é Git Flow e como ele organiza branches no desenvolvimento?",
        o: [
          "Modelo de branching com main, develop, feature/, release/ e hotfix/ para organizar o ciclo de desenvolvimento",
          "Ferramenta de CI/CD",
          "Alternativa ao Git",
          "Plugin do VS Code",
        ],
        c: 0,
        e: "Git Flow: main (produção estável), develop (integração), feature/* (novas features, saem de develop), release/* (preparação de versão), hotfix/* (correções urgentes em produção). Alternativas mais simples: GitHub Flow (main + feature branches) e Trunk-Based Development.",
        x: "Feature: git flow feature start login → trabalha → git flow feature finish login (merge em develop). Release: git flow release start 1.0.0 → testes → finish (merge em main + develop + tag).",
      },
      {
        q: "O que é squash merge e quando utilizá-lo?",
        o: [
          "Combina todos os commits de uma branch em um único commit ao fazer merge, simplificando o histórico",
          "Merge que resolve conflitos automaticamente",
          "Merge que deleta a branch de origem",
          "Merge parcial de alguns commits",
        ],
        c: 0,
        e: "Squash merge: git merge --squash feature → combina todas as mudanças da branch em um único commit na branch destino. Histórico fica limpo (1 commit por PR em vez de 20 commits WIP). Trade-off: perde o histórico granular dos commits individuais.",
        x: "Branch feature com 15 commits: 'WIP', 'fix typo', 'refactor', 'WIP 2'... Squash merge: um único commit 'feat: implementa sistema de login com OAuth' em main. Histórico de main fica limpo e legível.",
      },
    ],
    Difícil: [
      {
        q: "O que é o 'git reflog' e em qual cenário ele é essencial para recuperação de dados?",
        o: [
          "Registra todas as movimentações do HEAD localmente, permitindo recuperar commits após reset --hard ou branch deletada",
          "É um log remoto sincronizado com o GitHub",
          "Registra apenas merges e conflitos",
          "É um alias para git log --oneline",
        ],
        c: 0,
        e: "O git reflog registra cada movimentação do ponteiro HEAD no repositório local (commits, resets, checkouts, rebases). Mesmo após um 'git reset --hard' que parece apagar commits, eles permanecem acessíveis via reflog por 90 dias, permitindo recuperação com 'git checkout' ou 'git reset' para o hash encontrado.",
        x: "Acidentalmente: git reset --hard HEAD~5. Recuperação: git reflog → encontra 'abc1234 HEAD@{1}: commit: feature X'. git reset --hard abc1234 → restaura os 5 commits perdidos.",
      },
      {
        q: "O que é git bisect e como ele ajuda a encontrar o commit que introduziu um bug?",
        o: [
          "Busca binária no histórico de commits para encontrar o commit que introduziu a regressão",
          "Divide o repositório em dois",
          "Cria duas branches",
          "Faz merge bissetorial",
        ],
        c: 0,
        e: "git bisect usa busca binária no histórico: você marca um commit 'bad' (com bug) e um 'good' (sem bug). O Git faz checkout do commit do meio e pergunta se é bom ou ruim. Repetindo, encontra o commit exato em O(log n) passos, mesmo em históricos com milhares de commits.",
        x: "git bisect start → git bisect bad (commit atual tem bug) → git bisect good v1.0 (v1.0 não tinha). Git faz checkout do meio. Você testa: git bisect good/bad. Após ~10 passos em 1000 commits, encontra o culpado.",
      },
      {
        q: "Qual a diferença entre git reset, git revert e git restore e quando usar cada um?",
        o: [
          "reset move HEAD/branch para trás; revert cria commit inverso; restore restaura arquivos do working tree",
          "São sinônimos",
          "Todos desfazem commits igualmente",
          "reset é remoto e revert local",
        ],
        c: 0,
        e: "git reset: move HEAD/branch para commit anterior (reescreve histórico, perigoso em branch compartilhada). git revert: cria novo commit que desfaz mudanças de um commit específico (seguro, preserva histórico). git restore: restaura arquivos no working directory ou staging sem alterar commits.",
        x: "Branch local só sua: git reset --hard HEAD~1 (apaga último commit). Branch compartilhada: git revert abc123 (cria commit que desfaz abc123 sem reescrever histórico). Descartar mudança em arquivo: git restore arquivo.ts.",
      },
      {
        q: "O que são Git Hooks e como podem ser usados para automação?",
        o: [
          "Scripts executados automaticamente em eventos Git como pre-commit, pre-push e commit-msg",
          "Webhooks do GitHub",
          "Plugins do VS Code",
          "Atalhos de teclado para Git",
        ],
        c: 0,
        e: "Git Hooks: scripts em .git/hooks/ executados em eventos. pre-commit: lint/format antes de commitar. commit-msg: validar formato da mensagem. pre-push: rodar testes antes de push. Husky: ferramenta que facilita configuração de hooks no package.json.",
        x: "Com Husky + lint-staged: pre-commit hook roda ESLint e Prettier apenas nos arquivos alterados. Commit rejeitado se lint falhar. npx husky add .husky/pre-commit 'npx lint-staged'.",
      },
      {
        q: "O que é cherry-pick no Git e quando utilizá-lo?",
        o: [
          "Aplica um commit específico de outra branch na branch atual, sem fazer merge completo",
          "Seleciona arquivos para staging",
          "Remove commits do histórico",
          "Copia uma branch inteira",
        ],
        c: 0,
        e: "git cherry-pick: copia um commit específico (pelo hash) para a branch atual, criando um novo commit com as mesmas mudanças. Útil para: aplicar hotfix de uma branch em outra, portar features específicas sem merge completo. Cuidado: pode criar commits duplicados.",
        x: "Bug fix commitado na branch hotfix (hash abc123). Precisa do fix em develop também: git switch develop && git cherry-pick abc123 → aplica apenas aquele commit, sem trazer tudo da branch hotfix.",
      },
      {
        q: "O que é interactive rebase (git rebase -i) e como usá-lo para limpar o histórico?",
        o: [
          "Permite reordenar, editar, combinar (squash) e remover commits interativamente antes de push",
          "Rebase automático sem intervenção",
          "Ferramenta gráfica do GitHub",
          "Modo de resolução de conflitos",
        ],
        c: 0,
        e: "git rebase -i HEAD~N abre editor com últimos N commits. Ações: pick (manter), squash (combinar com anterior), fixup (squash sem mensagem), edit (pausar para alterar), reword (mudar mensagem), drop (remover). Reescreve hashes — só usar em commits não pushados.",
        x: "git rebase -i HEAD~4:\npick abc1234 feat: login page\nsquash def5678 fix typo in login\nsquash ghi9012 WIP login\npick jkl3456 feat: signup page\n→ Resultado: 2 commits limpos em vez de 4.",
      },
      {
        q: "O que são Git submodules e quando utilizá-los?",
        o: [
          "Repositórios Git aninhados dentro de outro repositório, referenciados por commit específico",
          "Módulos Node.js gerenciados pelo Git",
          "Branches automatizadas",
          "Plugins do Git para IDEs",
        ],
        c: 0,
        e: "Submodules permitem incluir um repositório Git dentro de outro, fixando uma versão específica (commit hash). Útil para: bibliotecas compartilhadas entre projetos, dependências que você precisa modificar, monorepo com repos independentes. Alternativa moderna: Git subtree.",
        x: "git submodule add https://github.com/org/shared-lib.git libs/shared → cria referência ao repo externo. git submodule update --init --recursive → clona/atualiza. .gitmodules registra URL e path.",
      },
    ],
  },

  // ── JavaScript e TypeScript ──
  "JavaScript e TypeScript": {
    Fácil: [
      {
        q: "Qual é a diferença entre 'let' e 'const' na declaração de variáveis em JavaScript?",
        o: [
          "let permite reatribuição; const cria uma referência que não pode ser reatribuída",
          "let é para números e const para strings",
          "const é mais lento que let",
          "Não há diferença funcional",
        ],
        c: 0,
        e: "A palavra-chave 'let' declara uma variável com escopo de bloco que pode ser reatribuída. 'const' declara uma variável com escopo de bloco cuja referência não pode ser reatribuída após a inicialização. Porém, objetos e arrays declarados com const ainda podem ter suas propriedades/elementos modificados.",
        x: "const arr = [1, 2, 3]; arr.push(4); // OK — modifica conteúdo. arr = [5]; // TypeError — não pode reatribuir a referência.",
      },
      {
        q: "O que é uma Promise em JavaScript e para que ela serve?",
        o: [
          "Objeto que representa o resultado futuro de uma operação assíncrona (sucesso ou falha)",
          "Função que executa imediatamente",
          "Tipo de loop",
          "Método de array",
        ],
        c: 0,
        e: "Promise é um objeto que pode estar em 3 estados: pending (aguardando), fulfilled (resolvida com valor) ou rejected (rejeitada com erro). Usa .then() para sucesso, .catch() para erro, ou async/await para sintaxe mais legível.",
        x: "fetch('/api/users').then(res => res.json()).then(users => console.log(users)).catch(err => console.error(err)); // Ou com async/await: const users = await fetch('/api/users').then(r => r.json());",
      },
      {
        q: "Qual é a diferença entre '==' e '===' em JavaScript?",
        o: [
          "=== compara valor e tipo (strict); == converte tipos antes de comparar (loose)",
          "São idênticos",
          "=== é mais lento",
          "== é para strings e === para números",
        ],
        c: 0,
        e: "== (igualdade solta) faz coercão de tipos antes de comparar, podendo gerar resultados inesperados. === (igualdade estrita) compara valor E tipo sem coercão. Boas práticas: sempre usar === para evitar bugs subtís.",
        x: "0 == '' // true (ambos viram 0). 0 === '' // false (number ≠ string). null == undefined // true. null === undefined // false. Sempre use ===!",
      },
      {
        q: "O que é o operador spread (...) em JavaScript e quais seus usos?",
        o: [
          "Expande elementos de arrays/objetos; usado para cópias, combinação e desestruturação",
          "Operador de divisão",
          "Criação de variáveis globais",
          "Loop infinito",
        ],
        c: 0,
        e: "Spread (...) expande itens de arrays ou propriedades de objetos. Usos: cópia rasa ([...arr]), combinação ([...a, ...b]), atualização imutável ({ ...obj, key: newVal }), rest params (function(...args)). Fundamental para imutabilidade em React.",
        x: "const a = [1,2]; const b = [...a, 3]; // [1,2,3]. const user = { name: 'Ana' }; const updated = { ...user, age: 25 }; // { name: 'Ana', age: 25 }. Original intacto.",
      },
      {
        q: "O que é async/await em JavaScript e como simplifica código assíncrono?",
        o: [
          "Sintaxe que permite escrever código assíncrono de forma semelhante a síncrono, usando Promises por baixo",
          "Substitui completamente Promises",
          "Cria threads paralelas",
          "Funciona apenas no Node.js",
        ],
        c: 0,
        e: "async marca uma função como assíncrona (retorna Promise). await pausa a execução até a Promise resolver, sem bloquear a thread. Torna o código mais legível que .then() encadeado. Tratamento de erro: try/catch em vez de .catch().",
        x: "// Com .then():\nfetch(url).then(r => r.json()).then(data => console.log(data));\n// Com async/await:\nconst r = await fetch(url); const data = await r.json(); console.log(data); — muito mais legível.",
      },
      {
        q: "O que são template literals (template strings) em JavaScript?",
        o: [
          "Strings delimitadas por crases (`) que suportam interpolação de expressões com ${} e múltiplas linhas",
          "Strings normais com aspas simples",
          "Templates HTML",
          "Funções de formatação",
        ],
        c: 0,
        e: "Template literals usam crases (`) e permitem interpolação de expressões com ${expr}. Suportam múltiplas linhas sem \\n. Tagged templates permitem processar a string com uma função (ex: html`<p>${text}</p>`, sql`SELECT * FROM ${table}`).",
        x: "const name = 'Ana'; const age = 28;\nConcat: 'Olá ' + name + ', você tem ' + age + ' anos.'\nTemplate: `Olá ${name}, você tem ${age} anos.` — mais legível e suporta expressões: ${age + 1}.",
      },
      {
        q: "O que é desestruturação (destructuring) em JavaScript?",
        o: [
          "Sintaxe que extrai valores de arrays ou propriedades de objetos em variáveis individuais",
          "Método para destruir objetos da memória",
          "Função para deletar propriedades",
          "Técnica de compressão de dados",
        ],
        c: 0,
        e: "Destructuring extrai dados de arrays e objetos de forma concisa. Em objetos: { name, age } = user. Em arrays: [first, second] = arr. Suporta valores padrão ({ name = 'Anônimo' }), renomeação ({ name: userName }) e aninhamento.",
        x: "const { name, age } = { name: 'Ana', age: 28 }; // name='Ana', age=28\nconst [first, ...rest] = [1, 2, 3, 4]; // first=1, rest=[2,3,4]\nfunction greet({ name, age = 0 }) { } // destructuring em parâmetros.",
      },
    ],
    Médio: [
      {
        q: "No TypeScript, qual é a diferença entre 'interface' e 'type alias' para declarar tipos de objetos?",
        o: [
          "Interfaces podem ser estendidas com extends e são abertas a declaration merging; types usam interseção e são fechados",
          "Types são mais rápidos em compilação",
          "Interfaces não suportam métodos",
          "Não há diferença alguma desde o TS 4.0",
        ],
        c: 0,
        e: "Interfaces usam 'extends' para herança e suportam declaration merging (declarar a mesma interface duas vezes combina os membros). Types usam '&' para interseção e não suportam merging. Types são mais versáteis (unions, mapped types, etc.). Para objetos simples, ambos funcionam de forma equivalente.",
        x: "interface User { name: string } interface User { age: number } // Merge: User tem name e age. type User2 = { name: string } & { age: number } // Interseção: mesmo resultado, mas sem merging.",
      },
      {
        q: "O que é o Event Loop no JavaScript e como ele gerencia operações assíncronas?",
        o: [
          "Mecanismo que executa código síncrono na call stack e processa callbacks assíncronos da fila quando a stack esvazia",
          "Thread pool igual a Java",
          "Compilador JIT",
          "Gerenciador de memória",
        ],
        c: 0,
        e: "JavaScript é single-threaded. O Event Loop verifica: 1) a call stack está vazia? 2) Se sim, pega a próxima callback da microtask queue (Promises) ou macrotask queue (setTimeout, I/O). Microtasks têm prioridade. Isso permite assincronismo sem threads.",
        x: "console.log('1'); setTimeout(() => console.log('2'), 0); Promise.resolve().then(() => console.log('3')); console.log('4'); → Saída: 1, 4, 3, 2. Síncrono primeiro, depois microtask (Promise), depois macrotask (setTimeout).",
      },
      {
        q: "No TypeScript, o que são Generics e qual problema eles resolvem?",
        o: [
          "Tipos parametrizáveis que permitem reutilizar lógica mantendo type safety para diferentes tipos",
          "Tipos que aceitam qualquer valor (any)",
          "Classes genéricas de UI",
          "Funções sem retorno",
        ],
        c: 0,
        e: "Generics permitem criar funções, classes e interfaces que funcionam com múltiplos tipos mantendo type safety. Ao invés de usar 'any' (perde tipagem), você parametriza o tipo com <T> e o TypeScript infere ou o chamador especifica o tipo concreto.",
        x: "function first<T>(arr: T[]): T | undefined { return arr[0]; } first([1,2,3]) → retorno é number | undefined. first(['a','b']) → retorno é string | undefined. Type safety preservada!",
      },
      {
        q: "O que é o conceito de hoisting em JavaScript?",
        o: [
          "Comportamento onde declarações de var e function são movidas para o topo do escopo antes da execução",
          "Otimização do compilador",
          "Método de ordenação",
          "Garbage collection",
        ],
        c: 0,
        e: "Hoisting: declarações var e function são 'elevadas' ao topo do escopo durante a compilação. var é hoisted como undefined; function é hoisted inteiramente. let/const são hoisted mas ficam em 'temporal dead zone' até a declaração (ReferenceError se acessar antes).",
        x: "console.log(x); var x = 5; // undefined (var hoisted, valor não). console.log(y); let y = 5; // ReferenceError (TDZ). greet(); function greet() { } // OK (function hoisted inteira).",
      },
      {
        q: "O que são Higher-Order Functions em JavaScript?",
        o: [
          "Funções que recebem outras funções como argumento ou retornam funções",
          "Funções que rodam mais rápido",
          "Funções com mais de 3 parâmetros",
          "Funções assíncronas",
        ],
        c: 0,
        e: "Higher-Order Functions (HOF) tratam funções como valores: recebem como argumento (callback) ou retornam funções. Exemplos nativos: map, filter, reduce, forEach. Padrão funcional que permite composição e reutilização.",
        x: "const double = (arr) => arr.map(x => x * 2); // map é HOF, recebe função. function multiplier(factor) { return (n) => n * factor; } // retorna função. const triple = multiplier(3); triple(5); // 15.",
      },
      {
        q: "O que são optional chaining (?.) e nullish coalescing (??) em JavaScript/TypeScript?",
        o: [
          "?. acessa propriedades de forma segura retornando undefined se nulo; ?? fornece valor padrão apenas para null/undefined",
          "Operadores matemáticos",
          "Operadores de comparação",
          "Operadores de atribuição",
        ],
        c: 0,
        e: "Optional chaining (?.) evita erros ao acessar propriedades de objetos potencialmente null/undefined: user?.address?.city retorna undefined em vez de TypeError. Nullish coalescing (??) retorna o lado direito apenas se o esquerdo for null/undefined (diferente de || que trata 0 e '' como falsy).",
        x: "const city = user?.address?.city ?? 'Não informada'; — se user, address ou city forem null/undefined, retorna 'Não informada'. Com ||: 0 ?? 'default' = 0 (correto), 0 || 'default' = 'default' (errado se 0 é válido).",
      },
      {
        q: "O que são Utility Types no TypeScript como Partial, Pick e Omit?",
        o: [
          "Tipos genéricos nativos que transformam tipos existentes: tornam opcionais, selecionam ou excluem propriedades",
          "Bibliotecas de funções utilitárias",
          "Tipos exclusivos para React",
          "Plugins do TypeScript",
        ],
        c: 0,
        e: "Partial<T>: todas as props opcionais. Required<T>: todas obrigatórias. Pick<T,K>: seleciona props específicas. Omit<T,K>: exclui props. Record<K,V>: cria tipo com chaves K e valores V. Readonly<T>: props somente leitura. Evitam duplicação de tipos.",
        x: "type User = { name: string; email: string; age: number };\ntype UserUpdate = Partial<User>; // tudo opcional\ntype UserPreview = Pick<User, 'name' | 'email'>; // só name e email\ntype UserWithoutAge = Omit<User, 'age'>; // exclui age",
      },
    ],
    Difícil: [
      {
        q: "No TypeScript, como os 'conditional types' com 'infer' permitem extrair tipos de dentro de outros tipos genéricos?",
        o: [
          "Usam a keyword infer dentro de extends para capturar e reutilizar sub-tipos em tempo de compilação",
          "Usam typeof em runtime para detectar tipos",
          "Dependem de reflection como em Java",
          "Usam decorators para anotar tipos em execução",
        ],
        c: 0,
        e: "Conditional types com 'infer' permitem pattern matching em tipos. A sintaxe T extends SomeType<infer U> ? U : never captura o tipo U se T corresponder ao padrão. É computado inteiramente em tempo de compilação sem impacto no runtime.",
        x: "type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never; type Result = ReturnType<() => string>; // Result = string — extrai o tipo de retorno da função.",
      },
      {
        q: "O que são closures em JavaScript e como elas funcionam?",
        o: [
          "Funções que 'lembram' do ambiente léxico onde foram criadas, mantendo acesso a variáveis externas",
          "Funções que se auto-executam",
          "Métodos de array",
          "Tipo de promise",
        ],
        c: 0,
        e: "Closure é a combinação de uma função com o ambiente léxico (variáveis do escopo) onde foi criada. Mesmo após a função externa terminar, a função interna mantém acesso às variáveis do escopo pai. Usada em encapsulamento, factories e callbacks.",
        x: "function counter() { let count = 0; return { inc: () => ++count, get: () => count }; } const c = counter(); c.inc(); c.inc(); c.get(); // 2. 'count' é privada, acessível apenas via closure.",
      },
      {
        q: "No TypeScript, o que são Mapped Types e como eles permitem transformar tipos existentes?",
        o: [
          "Tipos que iteram sobre propriedades de outro tipo aplicando transformações, gerando novos tipos",
          "Tipos que mapeiam para banco de dados",
          "Tipos de arrays",
          "Tipos de funções",
        ],
        c: 0,
        e: "Mapped Types usam 'in keyof' para iterar sobre propriedades de um tipo e aplicar transformações. Utility types nativos como Partial<T>, Required<T>, Readonly<T> e Pick<T,K> são implementados com mapped types. Permitem criar novos tipos derivados de existentes.",
        x: "type Readonly<T> = { readonly [K in keyof T]: T[K] }; type Partial<T> = { [K in keyof T]?: T[K] }; type ReadonlyUser = Readonly<User>; // Todas as props de User viram readonly.",
      },
      {
        q: "O que é o padrão Module em JavaScript e como closures são usadas para encapsulamento?",
        o: [
          "Padrão que usa IIFE e closures para criar escopo privado, expondo apenas uma API pública",
          "Import/export do ES6",
          "Design pattern para banco de dados",
          "Ferramenta de bundling",
        ],
        c: 0,
        e: "Module Pattern: IIFE que retorna um objeto com métodos públicos. Variáveis dentro da IIFE são privadas (closure). Antes de ES Modules, era a principal forma de encapsulamento. Hoje usado em configurações e bibliotecas que precisam de estado privado.",
        x: "const counter = (() => { let count = 0; return { inc: () => ++count, get: () => count }; })(); counter.inc(); counter.get(); // 1. 'count' é privado — inacessível fora da closure.",
      },
      {
        q: "O que é o TypeScript Discriminated Union e como ele permite narrowing seguro?",
        o: [
          "Union com campo literal comum (discriminante) que permite ao compilador narrowing automático em switch/if",
          "União de strings",
          "Array de tipos diferentes",
          "Enum numérico",
        ],
        c: 0,
        e: "Discriminated Union: cada membro tem um campo literal único (type: 'circle' | type: 'square'). O TS usa esse campo para narrowing em switch/if, sabendo exatamente quais propriedades estão disponíveis. Exhaustiveness check com never no default.",
        x: "type Shape = { type: 'circle'; radius: number } | { type: 'square'; side: number }; function area(s: Shape) { switch(s.type) { case 'circle': return Math.PI * s.radius ** 2; case 'square': return s.side ** 2; } } — TS sabe que s.radius existe no case 'circle'.",
      },
      {
        q: "O que é o objeto Proxy em JavaScript e quais seus casos de uso?",
        o: [
          "Wrapper que intercepta operações fundamentais em objetos (get, set, delete) via handlers chamados traps",
          "Servidor proxy de rede",
          "Cache de requisições HTTP",
          "Design pattern igual ao GoF Proxy",
        ],
        c: 0,
        e: "Proxy cria um objeto que intercepta operações em outro objeto alvo. Traps: get (leitura), set (escrita), has (in), deleteProperty, apply (chamada de função). Usos: validação reativa, logging, lazy loading, observabilidade. Vue 3 usa Proxy para reatividade.",
        x: "const handler = { set(target, prop, value) { console.log(`${prop} mudou para ${value}`); target[prop] = value; return true; } }; const state = new Proxy({}, handler); state.count = 1; // loga: 'count mudou para 1'. Base da reatividade do Vue 3.",
      },
      {
        q: "O que são Template Literal Types no TypeScript e como criam tipos dinâmicos?",
        o: [
          "Tipos que usam template string syntax para criar uniões de strings dinâmicas em tempo de compilação",
          "Strings tipadas em runtime",
          "Templates para geração de código",
          "Validação de strings em runtime",
        ],
        c: 0,
        e: "Template Literal Types combinam strings literais com uniões para criar novos tipos: `on${Capitalize<Event>}` gera 'onClick' | 'onHover' | 'onFocus'. Poderoso para APIs type-safe com padrões de nomenclatura. Usado em libs como Prisma e tRPC.",
        x: "type Event = 'click' | 'hover' | 'focus';\ntype Handler = `on${Capitalize<Event>}`; // 'onClick' | 'onHover' | 'onFocus'\ntype CSSProperty = `${string}-${string}`; // aceita 'font-size', 'margin-top', etc.\ntype Getter<T> = `get${Capitalize<T & string>}`;",
      },
    ],
  },

  // ── Programação Orientada a Objetos ──
  "Programação Orientada a Objetos": {
    Fácil: [
      {
        q: "Qual conceito de POO permite que uma classe filha herde atributos e métodos de uma classe pai?",
        o: ["Herança", "Encapsulamento", "Polimorfismo", "Abstração"],
        c: 0,
        e: "Herança é o mecanismo pelo qual uma classe (filha/subclasse) pode reutilizar atributos e métodos de outra classe (pai/superclasse), promovendo reuso de código. A classe filha pode adicionar novos membros ou sobrescrever comportamentos herdados.",
        x: "class Animal { mover() { } } class Cachorro extends Animal { latir() { } } — Cachorro herda o método mover() de Animal e adiciona latir().",
      },
      {
        q: "O que é encapsulamento em POO e qual sua importância?",
        o: [
          "Ocultar detalhes internos de um objeto, expondo apenas uma interface pública controlada",
          "Colocar tudo em uma única classe",
          "Criptografar atributos",
          "Usar apenas métodos estáticos",
        ],
        c: 0,
        e: "Encapsulamento esconde a implementação interna (atributos privados) e expõe apenas métodos públicos controlados. Protege contra uso indevido, permite mudar a implementação sem afetar código externo e garante consistência dos dados (validação no setter).",
        x: "class ContaBancaria { private saldo = 0; depositar(valor: number) { if (valor > 0) this.saldo += valor; } getSaldo() { return this.saldo; } } — 'saldo' só é acessível via métodos, que validam o valor.",
      },
      {
        q: "O que é polimorfismo e qual é um exemplo prático?",
        o: [
          "Capacidade de objetos de tipos diferentes responderem à mesma mensagem de formas distintas",
          "Ter múltiplas heranças",
          "Criar múltiplas instâncias",
          "Usar variáveis globais",
        ],
        c: 0,
        e: "Polimorfismo permite que diferentes classes implementem o mesmo método de maneiras diferentes. O código que chama o método não precisa saber o tipo concreto — cada objeto responde conforme sua implementação. Tipos: sobrescrita (override) e sobrecarga (overload).",
        x: "function calcularArea(forma: Forma): number { return forma.area(); } — funciona com Circle, Rectangle, Triangle. Cada um implementa area() de forma diferente. O código chamador é o mesmo.",
      },
      {
        q: "O que é abstração em POO e como ela simplifica a complexidade?",
        o: [
          "Esconder detalhes complexos de implementação e expor apenas o essencial para o usuário",
          "Criar classes vazias",
          "Programar sem variáveis",
          "Usar apenas interfaces",
        ],
        c: 0,
        e: "Abstração foca no 'quê' e esconde o 'como'. O usuário de uma classe não precisa saber como ela funciona internamente — só precisa conhecer a interface pública. Reduz complexidade cognitiva e permite mudanças internas sem impactar quem usa.",
        x: "carro.ligar() — o motorista não precisa saber como função, injeção, ignição funcionam internamente. Mesma ideia: array.sort() — você não precisa saber se usa quicksort ou timsort.",
      },
      {
        q: "O que é uma classe em POO e qual a relação com objetos?",
        o: [
          "Classe é o molde/blueprint; objeto é a instância concreta criada a partir da classe",
          "Classe e objeto são a mesma coisa",
          "Objeto é o molde e classe a instância",
          "Classes só existem em Java",
        ],
        c: 0,
        e: "Classe: template que define atributos (dados) e métodos (comportamento). Objeto: instância concreta de uma classe com valores específicos. Uma classe pode gerar múltiplos objetos. Analogia: classe = planta da casa; objeto = casa construída.",
        x: "class User { name: string; constructor(name: string) { this.name = name; } } const user1 = new User('Ana'); const user2 = new User('Bob'); — User é a classe, user1 e user2 são objetos.",
      },
      {
        q: "O que é um construtor (constructor) em POO e para que serve?",
        o: [
          "Método especial chamado automaticamente ao criar uma instância, usado para inicializar atributos",
          "Método para destruir objetos",
          "Função estática da classe",
          "Tipo de herança",
        ],
        c: 0,
        e: "O constructor é executado automaticamente quando se usa 'new'. Inicializa atributos do objeto com valores passados como parâmetros. Em TypeScript, pode usar atalho: constructor(public name: string) declara e inicializa o atributo em uma linha.",
        x: "class Car { brand: string; year: number; constructor(brand: string, year: number) { this.brand = brand; this.year = year; } } const car = new Car('Toyota', 2024); // constructor chamado com 'Toyota' e 2024.",
      },
      {
        q: "Qual a diferença entre métodos de instância e métodos estáticos?",
        o: [
          "Métodos de instância operam sobre o objeto (this); estáticos pertencem à classe e não precisam de instância",
          "São idênticos",
          "Estáticos são mais lentos",
          "Métodos de instância não podem acessar atributos",
        ],
        c: 0,
        e: "Método de instância: chamado em um objeto, acessa 'this' (atributos do objeto). Método estático: chamado na classe diretamente (Classe.metodo()), sem acesso a 'this'. Usado para utilitários e factories que não dependem de estado da instância.",
        x: "class MathUtils { static add(a: number, b: number) { return a + b; } } MathUtils.add(2, 3); // 5, sem new.\nclass User { greet() { return `Olá, ${this.name}`; } } new User('Ana').greet(); // precisa de instância.",
      },
    ],
    Médio: [
      {
        q: "Qual é a diferença entre classe abstrata e interface em linguagens como Java e TypeScript?",
        o: [
          "Classe abstrata pode ter métodos implementados e estado; interface define apenas contratos sem implementação",
          "Interface pode ter construtores e abstrata não",
          "Classe abstrata não pode ter métodos abstratos",
          "Não há diferença prática",
        ],
        c: 0,
        e: "Uma classe abstrata pode conter métodos implementados (com corpo), atributos com estado e construtores, mas não pode ser instanciada diretamente. Uma interface define apenas a assinatura dos métodos (contrato), sem implementação ou estado. Em Java, uma classe pode implementar múltiplas interfaces mas estender apenas uma classe abstrata.",
        x: "abstract class Shape { color: string; abstract area(): number; describe() { return `Shape: ${this.color}`; } } interface Drawable { draw(): void; } class Circle extends Shape implements Drawable { area() { ... } draw() { ... } }",
      },
      {
        q: "O que é composição em POO e por que geralmente é preferida sobre herança?",
        o: [
          "Construir objetos combinando outros objetos como componentes internos, oferecendo mais flexibilidade que herança",
          "Tipo de herança múltipla",
          "Padrão de criação de singletons",
          "Método de otimização",
        ],
        c: 0,
        e: "Composição usa relação 'tem-um' (has-a) em vez de 'é-um' (is-a). Vantagens sobre herança: evita hierarquias rígidas, permite trocar comportamentos em runtime, não herda métodos desnecessários, e permite combinar funcionalidades de múltiplas fontes sem herança múltipla.",
        x: "Herança: class Car extends Engine {} (carro NÃO é motor). Composição: class Car { engine: Engine; gps: GPS; } (carro TEM motor e GPS). Pode trocar Engine por ElectricEngine em runtime.",
      },
      {
        q: "O que são interfaces em TypeScript/Java e qual seu papel em POO?",
        o: [
          "Contratos que definem quais métodos uma classe deve implementar, sem fornecer implementação",
          "Classes com todos métodos implementados",
          "Tipo de herança",
          "Templates de UI",
        ],
        c: 0,
        e: "Interfaces definem um contrato: quais métodos e propriedades um objeto deve ter. Não contêm implementação. Uma classe que implementa uma interface DEVE fornecer todos os métodos declarados. Permite programar para abstrações em vez de implementações concretas.",
        x: "interface Notifier { send(message: string): void; } class EmailNotifier implements Notifier { send(msg) { /* envia email */ } } class SMSNotifier implements Notifier { send(msg) { /* envia SMS */ } } — código usa Notifier, não sabe se é email ou SMS.",
      },
      {
        q: "O que é o princípio DIP (Dependency Inversion Principle) do SOLID?",
        o: [
          "Módulos de alto nível não devem depender de módulos de baixo nível; ambos devem depender de abstrações",
          "Inverter a ordem de execução das funções",
          "Usar dependência circular",
          "Remover todas as interfaces",
        ],
        c: 0,
        e: "DIP: dependa de abstrações (interfaces), não de implementações concretas. O módulo de alto nível (regra de negócio) define a interface que precisa; o módulo de baixo nível (infra) implementa. Injeção de dependência é a técnica para aplicar DIP.",
        x: "Sem DIP: OrderService cria new MySQLRepository() diretamente. Com DIP: OrderService recebe OrderRepository (interface) no construtor. Pode injetar MySQLRepository ou MongoRepository sem mudar OrderService.",
      },
      {
        q: "O que é o conceito de coerência (cohesion) e acoplamento (coupling) em POO?",
        o: [
          "Coesão alta: classe focada em uma responsabilidade. Acoplamento baixo: classes com pouca dependência entre si",
          "São sinônimos",
          "Coesão é sobre UI e acoplamento sobre backend",
          "Ambos devem ser altos",
        ],
        c: 0,
        e: "Coesão: quão relacionados são os membros de uma classe entre si (alta = bom). Acoplamento: quão dependente uma classe é de outras (baixo = bom). Meta: alta coesão + baixo acoplamento = classes focadas e independentes, fáceis de manter e testar.",
        x: "Alta coesão: UserRepository só lida com persistência de User. Baixa coesão: UserManager valida, persiste, envia email e gera relatório. Baixo acoplamento: OrderService depende de interface PaymentGateway, não de Stripe diretamente.",
      },
      {
        q: "O que é Injeção de Dependência (Dependency Injection) e como funciona?",
        o: [
          "Técnica onde dependências são fornecidas externamente ao objeto em vez de criadas internamente",
          "Instalar pacotes npm",
          "Importar módulos com import",
          "Criar singleton de banco de dados",
        ],
        c: 0,
        e: "DI: em vez da classe criar suas dependências (new MySQLRepo()), ela as recebe por parâmetro do construtor, setter ou interface. Vantagens: testabilidade (injetar mock), flexibilidade (trocar implementação), respeita DIP (SOLID). Frameworks: NestJS, Spring, Angular.",
        x: "Sem DI: class OrderService { repo = new MySQLRepo(); } — acoplado ao MySQL.\nCom DI: class OrderService { constructor(private repo: OrderRepository) {} } — recebe qq implementação. No teste: new OrderService(new MockRepo()).",
      },
      {
        q: "O que são mixins em POO e como funcionam em TypeScript?",
        o: [
          "Padrão que adiciona funcionalidades a uma classe sem herança clássica, combinando múltiplos comportamentos",
          "Tipo de herança múltipla nativa",
          "Método de mesclagem de arrays",
          "Framework de CSS",
        ],
        c: 0,
        e: "Mixins permitem compor uma classe com funcionalidades de múltiplas fontes, contornando a limitação de herança simples. Em TypeScript: funções que recebem uma classe base e retornam uma nova classe com comportamento adicional. Alternativa a herança múltipla.",
        x: "function Timestamped<T extends Constructor>(Base: T) { return class extends Base { createdAt = new Date(); }; }\nfunction Activatable<T extends Constructor>(Base: T) { return class extends Base { active = false; }; }\nclass User extends Timestamped(Activatable(BaseEntity)) {} — User ganha createdAt e active.",
      },
    ],
    Difícil: [
      {
        q: "Qual princípio SOLID é violado quando uma classe pai tem um método que uma subclasse precisa sobrescrever para lançar uma exceção, tornando a substituição insegura?",
        o: [
          "Liskov Substitution Principle (LSP)",
          "Single Responsibility Principle (SRP)",
          "Open/Closed Principle (OCP)",
          "Interface Segregation Principle (ISP)",
        ],
        c: 0,
        e: "O LSP afirma que objetos de uma subclasse devem poder substituir objetos da superclasse sem alterar o comportamento esperado do programa. Se Square herda de Rectangle mas sobrescreve setWidth para lançar exceção ou alterar setHeight junto, o código que espera um Rectangle quebrará ao receber um Square.",
        x: "class Bird { fly() { } } class Penguin extends Bird { fly() { throw new Error('Não voo'); } } — função feedBird(b: Bird) { b.fly(); } quebra com Penguin. Solução: interface FlyingBird separada.",
      },
      {
        q: "O que é o princípio ISP (Interface Segregation Principle) do SOLID?",
        o: [
          "Clientes não devem depender de interfaces com métodos que não usam; prefira interfaces específicas e enxutas",
          "Cada interface deve ter o máximo de métodos",
          "Interfaces devem ser herdadas",
          "Segregar significa juntar",
        ],
        c: 0,
        e: "ISP: em vez de uma interface 'gorda' com muitos métodos, crie várias interfaces pequenas e específicas. Assim, cada classe implementa apenas os métodos que realmente usa, evitando dependências desnecessárias e implementações vazias.",
        x: "Ruim: interface Worker { work(); eat(); sleep(); } — robô precisa implementar eat() e sleep() vazios. Bom: interface Workable { work(); } interface Feedable { eat(); } — robô implementa só Workable.",
      },
      {
        q: "O que é o padrão de double dispatch e como ele resolve o problema do polimorfismo bi-dimensional?",
        o: [
          "Técnica onde o método chamado depende do tipo runtime de dois objetos, usando visitante ou sobrescrita combinada",
          "Chamar um método duas vezes",
          "Criar duas instâncias",
          "Dispatch assíncrono",
        ],
        c: 0,
        e: "Linguagens como Java/TypeScript despacham métodos pelo tipo runtime do receptor (single dispatch). Double dispatch exige que o método dependa de DOIS tipos runtime. O padrão Visitor resolve isso: o elemento chama visitor.visit(this), o que dispara o método sobrecarregado correto do visitor.",
        x: "circle.accept(printer) → printer.visitCircle(this) → imprime círculo. square.accept(printer) → printer.visitSquare(this) → imprime quadrado. O Visitor 'sabe' o tipo concreto porque o accept() resolve o primeiro dispatch.",
      },
      {
        q: "O que é o princípio SRP (Single Responsibility Principle) do SOLID?",
        o: [
          "Uma classe deve ter apenas um motivo para mudar — uma única responsabilidade",
          "Uma classe deve ter um único método",
          "Cada arquivo deve ter uma classe",
          "Funções devem ter um paramâmetro",
        ],
        c: 0,
        e: "SRP: cada classe/módulo deve ter uma única razão para mudar. Se uma classe lida com validação E persistência, mudanças no banco afetam a classe que também valida. Separar responsabilidades = menor risco de efeitos colaterais e mais fácil de testar.",
        x: "Viola SRP: class User { validate() { } save() { } sendEmail() { } } — 3 motivos para mudar. Correto: UserValidator, UserRepository, EmailService — cada uma com uma responsabilidade.",
      },
      {
        q: "O que é o princípio de Substituição de Liskov (LSP) na prática com TypeScript?",
        o: [
          "Subtipos devem poder substituir seus tipos base sem alterar a correção do programa",
          "Listas devem ser substituídas por arrays",
          "Subclasses devem ter mais métodos",
          "Tipos genéricos devem ser evitados",
        ],
        c: 0,
        e: "LSP: se S é subtipo de T, então objetos de T podem ser substituídos por objetos de S sem quebrar o programa. Pré-condições não podem ser fortalecidas, pós-condições não podem ser enfraquecidas, invariantes devem ser mantidas.",
        x: "function processPayment(p: Payment) { p.charge(100); } — CreditCard, DebitCard, PIX implementam Payment. Todas devem funcionar se passadas para processPayment(). Se PIX lançar erro em charge(), viola LSP.",
      },
      {
        q: "O que são os padrões GRASP e quais seus princípios de atribuição de responsabilidade?",
        o: [
          "Conjunto de 9 padrões que guiam a atribuição de responsabilidades a classes: Creator, Expert, Controller, etc.",
          "Framework de testes",
          "Metodologia ágil",
          "Linguagem de modelagem",
        ],
        c: 0,
        e: "GRASP (General Responsibility Assignment Software Patterns): Information Expert (quem tem os dados é responsável), Creator (quem cria instâncias), Controller (quem recebe eventos de sistema), Low Coupling, High Cohesion, Polymorphism, Pure Fabrication, Indirection, Protected Variations.",
        x: "Information Expert: Pedido calcula seu próprio total (tem os itens). Creator: Pedido cria ItemPedido (contém/agrega itens). Controller: PedidoController recebe requisições HTTP. Cada padrão define QUEM deve ter cada responsabilidade.",
      },
      {
        q: "O que é covariância e contravariância em tipos genéricos?",
        o: [
          "Covariância preserva a direção do subtipo; contravariância inverte — aplicados em tipos de retorno e parâmetros",
          "Termos de estatística",
          "Tipos de herança múltipla",
          "Métodos de ordenação",
        ],
        c: 0,
        e: "Covariante: se Dog extends Animal, então List<Dog> é subtipo de List<Animal> (retornos de função). Contravariante: direção inversa (parâmetros de função). Invariante: nenhuma direção. TypeScript: strictFunctionTypes habilita checagem de contravariância em parâmetros.",
        x: "type Animal = { name: string }; type Dog = Animal & { bark(): void };\nCovariante (retorno): () => Dog é subtipo de () => Animal ✔\nContravariante (param): (a: Animal) => void é subtipo de (d: Dog) => void ✔\nInvariante: Array<Dog> !subtipo Array<Animal> se mutar (push de Cat em array de Dog).",
      },
    ],
  },

  // ── React e React Native ──
  "React e React Native": {
    Fácil: [
      {
        q: "No React, qual hook é utilizado para gerenciar estado local em um componente funcional?",
        o: ["useState", "useEffect", "useContext", "useRef"],
        c: 0,
        e: "O hook useState retorna um par [valor, função setter]. Quando o setter é chamado com um novo valor, o React re-renderiza o componente com o estado atualizado. É a forma padrão de gerenciar estado em componentes funcionais.",
        x: "const [count, setCount] = useState(0); return <Button onPress={() => setCount(count + 1)} title={`Cliques: ${count}`} />;",
      },
      {
        q: "No React, o que são props e como elas diferem de state?",
        o: [
          "Props são dados passados pelo pai (read-only); state são dados internos do componente (mutáveis)",
          "São idênticos",
          "Props são mutáveis e state read-only",
          "Ambos são globais",
        ],
        c: 0,
        e: "Props (properties) são dados passados de um componente pai para um filho, são read-only no filho. State é dado gerenciado internamente pelo próprio componente, pode ser alterado via setState/useState, e alterações causam re-renderização.",
        x: "<UserCard name='Ana' age={28} /> — name e age são props. Dentro de UserCard: const [isExpanded, setIsExpanded] = useState(false); — isExpanded é state interno.",
      },
      {
        q: "Qual componente do React Native é usado para renderizar listas longas de forma eficiente?",
        o: ["FlatList", "ScrollView", "View", "Text"],
        c: 0,
        e: "FlatList renderiza apenas os itens visíveis na tela (virtualização), sendo eficiente para listas grandes. ScrollView renderiza TODOS os itens de uma vez (ok para listas curtas <100 items). FlatList exige keyExtractor e renderItem.",
        x: "<FlatList data={users} keyExtractor={item => item.id} renderItem={({ item }) => <UserCard user={item} />} /> — renderiza eficientemente 10.000 usuários mostrando apenas ~10 visíveis.",
      },
      {
        q: "No React, o que é o hook useEffect e para que ele serve?",
        o: [
          "Executa efeitos colaterais (chamadas API, subscriptions) após a renderização do componente",
          "Gerencia estado local",
          "Cria componentes",
          "Formata estilos CSS",
        ],
        c: 0,
        e: "useEffect roda após o componente renderizar. Com array vazio ([]) roda apenas na montagem. Com dependências ([count]) roda quando count muda. Sem array, roda a cada renderização. Retorno opcional é função de cleanup.",
        x: "useEffect(() => { fetchUsers().then(setUsers); }, []); — busca usuários uma vez ao montar o componente. O [] garante que não repete a cada renderização.",
      },
      {
        q: "Qual a diferença entre componentes funcionais e componentes de classe no React?",
        o: [
          "Funcionais são funções que usam hooks; de classe usam this.state e métodos de ciclo de vida",
          "São idênticos",
          "Classes são mais rápidas",
          "Funcionais não têm estado",
        ],
        c: 0,
        e: "Componentes funcionais: funções que recebem props e retornam JSX. Desde React 16.8, usam hooks (useState, useEffect) para estado e efeitos. Classes: usam this.state, this.setState, e lifecycle methods (componentDidMount etc). Funcionais são o padrão moderno.",
        x: "Funcional: function Counter() { const [n, setN] = useState(0); return <button onClick={() => setN(n+1)}>{n}</button>; } Classe: class Counter extends Component { state = {n:0}; render() { return <button onClick={() => this.setState({n: this.state.n+1})}>{this.state.n}</button>; } }",
      },
      {
        q: "O que é JSX e por que o React o utiliza?",
        o: [
          "Extensão de sintaxe que permite escrever estrutura de UI similar a HTML dentro do JavaScript",
          "Linguagem de programação separada",
          "Template engine do Node.js",
          "Substituto do CSS",
        ],
        c: 0,
        e: "JSX (JavaScript XML) é uma extensão sintática que permite escrever elementos de UI de forma declarativa dentro do JS. Babel transpila JSX para React.createElement() calls. Permite interpolação com {}, condições e map(). Não é HTML: usa className em vez de class, htmlFor em vez de for.",
        x: "const element = <h1 className='title'>Olá, {user.name}</h1>; → transpila para: React.createElement('h1', { className: 'title' }, 'Olá, ', user.name). JSX é açúcar sintático.",
      },
      {
        q: "O que é o hook useRef e quando utilizá-lo?",
        o: [
          "Cria uma referência mutável que persiste entre renderizações sem causar re-render ao mudar",
          "Substituto do useState",
          "Hook para efeitos colaterais",
          "Método de estilização",
        ],
        c: 0,
        e: "useRef retorna um objeto { current: valor } que persiste durante todo o ciclo de vida do componente. Mutar .current NÃO causa re-render. Usos: acessar elementos DOM diretamente, armazenar timers/intervals, guardar valor anterior, contar renders.",
        x: "const inputRef = useRef<TextInput>(null); <TextInput ref={inputRef} /> <Button onPress={() => inputRef.current?.focus()} /> — foca o input programáticamente. Também: const renderCount = useRef(0); renderCount.current++ em cada render (sem causar loop).",
      },
    ],
    Médio: [
      {
        q: "No React, para que serve o hook useEffect e quando a função de cleanup é executada?",
        o: [
          "Executa efeitos colaterais após a renderização; cleanup roda antes do próximo efeito e na desmontagem do componente",
          "Cria estado persistente; cleanup roda na montagem",
          "Substitui o useState; cleanup nunca é chamado",
          "Renderiza condicionalmente; cleanup roda a cada clique",
        ],
        c: 0,
        e: "useEffect executa efeitos colaterais (chamadas API, subscriptions, timers) após o DOM ser atualizado. A função de cleanup (retorno do useEffect) executa antes de cada re-execução do efeito e quando o componente é desmontado, evitando memory leaks.",
        x: "useEffect(() => { const sub = api.subscribe(onData); return () => sub.unsubscribe(); // cleanup: cancela subscription }, []) — subscribe na montagem, unsubscribe na desmontagem.",
      },
      {
        q: "No React, o que é o hook useCallback e quando usá-lo?",
        o: [
          "Memoriza uma função para evitar recriação a cada renderização, útil quando passada como prop a componentes memorizados",
          "Chama uma API",
          "Cria estado global",
          "Substitui useEffect",
        ],
        c: 0,
        e: "useCallback retorna uma versão memorizada da função que só muda se as dependências mudarem. Sem useCallback, cada renderização cria uma nova referência de função, potencialmente causando re-renderizações desnecessárias em componentes filhos que usam React.memo.",
        x: "const handlePress = useCallback(() => { setCount(c => c + 1); }, []); <MemoizedChild onPress={handlePress} /> — MemoizedChild não re-renderiza porque handlePress mantém a mesma referência.",
      },
      {
        q: "No React, para que serve o hook useMemo e como difere de useCallback?",
        o: [
          "useMemo memoriza um VALOR calculado; useCallback memoriza uma FUNÇÃO",
          "São idênticos",
          "useMemo é para efeitos colaterais",
          "useCallback memoriza valores",
        ],
        c: 0,
        e: "useMemo(fn, deps) executa fn e memoriza o RESULTADO (valor). Só recalcula quando deps mudam. useCallback(fn, deps) memoriza a própria FUNÇÃO fn. Na prática: useCallback(fn, deps) === useMemo(() => fn, deps). Use useMemo para cálculos custosos e useCallback para callbacks passados a filhos.",
        x: "const sortedItems = useMemo(() => items.sort((a,b) => a.name.localeCompare(b.name)), [items]); — só reordena quando items muda, não a cada renderização.",
      },
      {
        q: "No React, o que é Context API e quando usá-la em vez de prop drilling?",
        o: [
          "Mecanismo para compartilhar dados entre componentes sem passar props manualmente por cada nível",
          "API de rede do React",
          "Substituto do Redux",
          "Banco de dados local",
        ],
        c: 0,
        e: "Context API resolve o prop drilling (passar props por 5+ níveis). Crie um Context com createContext, forneça valor com Provider no topo, e consuma com useContext nos filhos. Ideal para: tema, lang, auth. Não ideal para estado que muda frequentemente (causa re-renders).",
        x: "const ThemeContext = createContext('light'); <ThemeContext.Provider value='dark'> <App /> </ThemeContext.Provider>. Em qualquer componente filho: const theme = useContext(ThemeContext); // 'dark' — sem passar por props.",
      },
      {
        q: "No React Native, qual a diferença entre StyleSheet e estilos inline?",
        o: [
          "StyleSheet.create otimiza estilos criando-os uma vez; inline cria novo objeto a cada renderização",
          "São idênticos",
          "Inline é mais rápido",
          "StyleSheet só aceita cores",
        ],
        c: 0,
        e: "StyleSheet.create: cria estilos uma vez (referenciados por ID numérico), validação em dev, melhor performance. Inline (style={{color:'red'}}): cria novo objeto a cada render, sem validação. NativeWind/Tailwind: alternativa que compila classes para StyleSheet.",
        x: "const styles = StyleSheet.create({ container: { flex: 1, padding: 16 } }); <View style={styles.container} /> — otimizado. Vs <View style={{ flex: 1, padding: 16 }} /> — novo objeto a cada render.",
      },
      {
        q: "No React, o que é React.memo e quando utilizá-lo?",
        o: [
          "HOC que memoriza o componente, evitando re-render se as props não mudaram",
          "Função para memorizar estado",
          "Substituto do useMemo",
          "Método de cache de API",
        ],
        c: 0,
        e: "React.memo envolve um componente funcional e faz shallow comparison das props. Se as props não mudaram, reutiliza o resultado da renderização anterior. Útil para componentes que re-renderizam frequentemente com as mesmas props. Combinar com useCallback para callbacks.",
        x: "const UserCard = React.memo(({ name, avatar }: Props) => { return <View><Image source={avatar} /><Text>{name}</Text></View>; }); — só re-renderiza se name ou avatar mudarem. Pai re-renderiza → UserCard pula se props iguais.",
      },
      {
        q: "O que é um Custom Hook no React e como criá-lo?",
        o: [
          "Função que começa com 'use' e encapsula lógica reutilizável com hooks, extraindo lógica de componentes",
          "Componente especial do React",
          "Plugin de terceiros",
          "Método de classe",
        ],
        c: 0,
        e: "Custom Hooks são funções que começam com 'use' e podem chamar outros hooks. Extraem lógica stateful reutilizável de componentes. Cada instância tem seu próprio estado isolado. Padrão para: fetch de dados, formulários, timers, media queries.",
        x: "function useDebounce<T>(value: T, delay: number): T { const [debounced, setDebounced] = useState(value); useEffect(() => { const timer = setTimeout(() => setDebounced(value), delay); return () => clearTimeout(timer); }, [value, delay]); return debounced; } — reutilizável em qualquer componente.",
      },
    ],
    Difícil: [
      {
        q: "No React 18+, qual é o comportamento do Concurrent Rendering com Suspense para data fetching e como ele difere do modelo síncrono?",
        o: [
          "React pode pausar a renderização de uma subárvore, mostrar fallback e retomar quando os dados estiverem prontos, sem bloquear a UI",
          "Suspense apenas exibe spinners e não afeta a renderização",
          "Concurrent Rendering bloqueia toda a UI até os dados chegarem",
          "Suspense só funciona com lazy loading de componentes, não com dados",
        ],
        c: 0,
        e: "No Concurrent Rendering, quando um componente 'suspende' (lança uma Promise), o React pausa a renderização daquela subárvore e exibe o fallback do Suspense mais próximo. Enquanto isso, a UI existente permanece interativa. Quando a Promise resolve, o React retoma a renderização sem bloquear o thread principal.",
        x: "<Suspense fallback={<Skeleton />}><UserProfile /></Suspense> — enquanto UserProfile busca dados, Skeleton é exibido. A barra de navegação e outros componentes continuam responsivos durante o loading.",
      },
      {
        q: "No React, o que é o Virtual DOM e como ele otimiza a performance de renderização?",
        o: [
          "Representação em memória do DOM real; React compara diferenças (diffing) e aplica apenas as mudanças necessárias",
          "DOM mais rápido que o real",
          "Cache do HTML",
          "Servidor que renderiza HTML",
        ],
        c: 0,
        e: "O Virtual DOM é uma árvore de objetos JavaScript que espelha o DOM real. Quando o state muda, React cria uma nova árvore virtual, compara com a anterior (diffing/reconciliation) e calcula o mínimo de operações DOM necessárias (batching). Evita manipulações DOM custosas e desnecessárias.",
        x: "State muda: lista de 100 items, 1 foi editado. React compara as 2 árvores virtuais, detecta que apenas item 42 mudou, e faz uma única operação DOM para atualizar o texto daquele único elemento.",
      },
      {
        q: "No React Native, como o bridge (antigo) e o New Architecture (JSI/Fabric/TurboModules) diferem na comunicação JS-nativo?",
        o: [
          "Bridge usa serialização JSON assíncrona; New Architecture usa JSI para acesso direto síncrono a objetos nativos",
          "São idênticos",
          "New Architecture é mais lento",
          "Bridge é síncrono",
        ],
        c: 0,
        e: "Bridge (antigo): JS e nativo em threads separadas, comunicação via mensagens JSON serializadas assíncronas (gargalo em operações frequentes). New Architecture: JSI (JavaScript Interface) permite JS acessar objetos C++ diretamente, sem serialização. Fabric (novo renderer) e TurboModules (módulos nativos lazy-loaded) usam JSI.",
        x: "Bridge: JS envia { type: 'scroll', offset: 100 } como JSON para a thread nativa → 100 mensagens/s de scroll = gargalo. JSI: JS chama nativeModule.scroll(100) diretamente como função C++ → zero serialização, performance nativa.",
      },
      {
        q: "No React, como funciona o Reconciliation (algoritmo de diff) e quais são suas heurísticas?",
        o: [
          "Compara árvores virtual DOM usando heurísticas: elementos de diferentes tipos geram subárvores novas; keys identificam elementos em listas",
          "Compara pixel a pixel",
          "Renderiza tudo do zero",
          "Usa machine learning para otimizar",
        ],
        c: 0,
        e: "Reconciliation: React compara old e new virtual DOM trees. Heurísticas: 1) Elementos de tipos diferentes são subárvores completamente novas (div→span = rebuild). 2) Keys em listas permitem identificar quais items foram adicionados/removidos/reordenados. Sem keys, React re-renderiza toda a lista.",
        x: "Lista sem key: adicionar item no início re-renderiza TODOS os items (React acha que todos mudaram). Com key={item.id}: React sabe que items existentes não mudaram e apenas insere o novo. O(n) vs O(n²).",
      },
      {
        q: "No React, o que são Server Components e como diferem dos Client Components?",
        o: [
          "Server Components renderizam no servidor sem JS no bundle do cliente; Client Components são interativos no navegador",
          "São idênticos",
          "Server Components são mais lentos",
          "Client Components rodam no servidor",
        ],
        c: 0,
        e: "React Server Components (RSC): renderizam no servidor, acesso direto a banco/APIs, zero JS enviado ao cliente (menor bundle). Client Components: marcados com 'use client', têm interatividade (useState, onClick). Composição: Server Components podem importar Client Components, mas não vice-versa.",
        x: "// UserList é Server Component (sem 'use client')\nasync function UserList() { const users = await db.query('SELECT * FROM users'); return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>; } — zero JS no cliente, query direta no banco.",
      },
      {
        q: "O que é React Fiber e como melhorou a renderização do React?",
        o: [
          "Reimplementação do algoritmo de reconciliação que permite renderização incremental e priorização de tarefas",
          "Biblioteca de fibra óptica para React",
          "Framework CSS-in-JS",
          "Compilador JIT para React",
        ],
        c: 0,
        e: "React Fiber (React 16+) substituiu o reconciliador síncrono por um assíncrono. Divide o trabalho de renderização em unidades (fibers) que podem ser pausadas, priorizadas e canceladas. Permite: concurrent rendering, Suspense, transições, renderização interruptível sem bloquear a UI.",
        x: "Antes (Stack Reconciler): renderizar 10.000 itens bloqueia a thread ~500ms → UI congela. Com Fiber: divide em fatias de 5ms, cede controle ao browser para processar inputs entre fatias → UI permanece responsiva durante renderização pesada.",
      },
      {
        q: "Quando usar useReducer em vez de useState no React?",
        o: [
          "Quando o estado é complexo com múltiplas sub-valores ou quando a próxima ação depende do estado anterior",
          "Sempre, pois é mais rápido",
          "Apenas para estado global",
          "Nunca, useState é sempre melhor",
        ],
        c: 0,
        e: "useReducer é prefirível quando: estado complexo (objeto com várias props), lógica de transição clara (switch/case), múltiplas ações (ADD, REMOVE, TOGGLE, RESET), ou quando o próximo estado depende do anterior. Padrão similar ao Redux. dispatch(é estável (não precisa de useCallback).",
        x: "const [state, dispatch] = useReducer(reducer, { items: [], filter: 'all', loading: false }); dispatch({ type: 'ADD_ITEM', payload: item }); dispatch({ type: 'SET_FILTER', payload: 'active' }); — lógica centralizada no reducer, ações descritivas.",
      },
    ],
  },

  // ── Testes de Software ──
  "Testes de Software": {
    Fácil: [
      {
        q: "O que é um teste unitário e qual é seu principal objetivo?",
        o: [
          "Testar uma unidade isolada de código (função/método) para verificar se ela produz o resultado esperado",
          "Testar o sistema inteiro em produção",
          "Testar a interface gráfica manualmente",
          "Testar o desempenho sob carga",
        ],
        c: 0,
        e: "Testes unitários verificam o comportamento de uma unidade isolada (função, método ou classe), usando inputs controlados e comparando com outputs esperados. São rápidos, determinísticos e formam a base da pirâmide de testes.",
        x: "test('soma 2 + 3 retorna 5', () => { expect(soma(2, 3)).toBe(5); }); — testa a função soma isoladamente com valores conhecidos.",
      },
      {
        q: "O que é um teste de integração e como ele difere do teste unitário?",
        o: [
          "Testa a interação entre múltiplos componentes juntos; unitário testa componentes isolados",
          "São idênticos",
          "Integração é mais rápido",
          "Unitário testa mais componentes",
        ],
        c: 0,
        e: "Testes unitários isolam uma função/classe mockando dependências. Testes de integração validam que múltiplos componentes funcionam juntos (ex: API + banco de dados). São mais lentos e complexos que unitários, mas encontram problemas de integração que unitários não detectam.",
        x: "Unitário: testa UserService.create() com banco mockado. Integração: testa POST /api/users que passa por Router → Controller → Service → PostgreSQL real (ou container Docker). Verifica toda a cadeia.",
      },
      {
        q: "O que é a pirâmide de testes e quais são suas camadas?",
        o: [
          "Base: muitos testes unitários (rápidos); meio: integração; topo: poucos testes e2e (lentos)",
          "Apenas testes end-to-end",
          "Apenas testes unitários",
          "Testes manuais na base",
        ],
        c: 0,
        e: "Pirâmide de testes (Martin Fowler): base larga de testes unitários (rápidos, muitos, baratos), camada intermediária de testes de integração, e topo estreito de testes end-to-end (lentos, poucos, caros). Anti-padrão: cone de sorvete (muitos e2e, poucos unitários).",
        x: "Projeto saudável: 500 testes unitários (2 min), 50 testes de integração (5 min), 10 testes e2e (15 min). Anti-padrão: 10 unitários, 5 integração, 200 e2e (3 horas, instbáveis).",
      },
      {
        q: "O que é um teste end-to-end (e2e) e quando utilizá-lo?",
        o: [
          "Testa o fluxo completo do usuário, simulando interações reais do início ao fim",
          "Testa funções isoladas",
          "Testa apenas o backend",
          "Substitui testes unitários",
        ],
        c: 0,
        e: "Testes e2e simulam o comportamento real do usuário: abrir app, clicar botões, preencher formulários, verificar resultados. Ferramentas: Cypress, Playwright, Detox (RN). São lentos e frágeis, por isso devem cobrir apenas fluxos críticos (login, checkout, cadastro).",
        x: "Cypress: cy.visit('/login'); cy.get('#email').type('ana@email.com'); cy.get('#password').type('123'); cy.get('button').click(); cy.url().should('include', '/dashboard'); — simula login real.",
      },
      {
        q: "O que é o framework Jest e quais seus principais recursos?",
        o: [
          "Framework de testes JS/TS com assertions, mocking, coverage e snapshot testing integrados",
          "Linter de código",
          "Bundler de módulos",
          "Framework de UI",
        ],
        c: 0,
        e: "Jest: framework de testes all-in-one do Meta. Inclui: test runner, assertions (expect/toBe), mocking (jest.fn, jest.mock), coverage (--coverage), snapshot testing, watch mode, paralelização. Funciona com TypeScript via ts-jest ou babel.",
        x: "test('cria usuário', () => { const mockSave = jest.fn().mockResolvedValue({ id: 1 }); const service = new UserService(mockSave); await service.create('Ana'); expect(mockSave).toHaveBeenCalledWith({ name: 'Ana' }); });",
      },
      {
        q: "O que são assertions (asserções) em testes automatizados?",
        o: [
          "Verificações que comparam o resultado real com o esperado; se diferem, o teste falha",
          "Comentários no código de teste",
          "Configurações do ambiente",
          "Logs de execução",
        ],
        c: 0,
        e: "Assertions são a parte do teste que verifica se o resultado é o esperado. Se a asserção falhar, o teste falha. Jest: expect(valor).toBe(esperado), .toEqual(), .toBeTruthy(), .toThrow(), .toContain(). Cada teste deve ter pelo menos uma assertion relevante.",
        x: "expect(soma(2, 3)).toBe(5); // passa ✔\nexpect(soma(2, 3)).toBe(6); // falha ✘: Expected 6, Received 5\nexpect(users).toHaveLength(3);\nexpect(response.status).toBe(200);\nexpect(() => divide(1, 0)).toThrow('Divisão por zero');",
      },
      {
        q: "O que são testes determinísticos e por que são importantes?",
        o: [
          "Testes que produzem o mesmo resultado independente de quando ou onde são executados",
          "Testes que rodam apenas uma vez",
          "Testes que dependem de dados de produção",
          "Testes que precisam de conexão com internet",
        ],
        c: 0,
        e: "Testes determinísticos sempre dão o mesmo resultado. Testes não-determinísticos (flaky) falham intermitentemente: dependem de tempo (Date.now), rede, ordem de execução ou estado compartilhado. Flaky tests corroem confiança na suite. Solução: mockar tempo, isolar estado, seed fixo para random.",
        x: "Flaky: test depende de Date.now() → falha à meia-noite quando muda o dia. Determinístico: jest.useFakeTimers(); jest.setSystemTime(new Date('2024-06-15')); → sempre mesmo resultado. Isolamento total.",
      },
    ],
    Médio: [
      {
        q: "Qual é a diferença entre mock, stub e spy em testes de software?",
        o: [
          "Stub retorna valores fixos; Mock verifica interações; Spy envolve a implementação real registrando chamadas",
          "São todos sinônimos",
          "Mock é para APIs e Stub para bancos",
          "Spy é usado apenas em testes end-to-end",
        ],
        c: 0,
        e: "Stub: substitui dependência com retorno fixo (ex.: retorna sempre status 200). Mock: substitui dependência e verifica se foi chamada corretamente (quantas vezes, com quais parâmetros). Spy: mantém a implementação real mas registra todas as chamadas para verificação posterior.",
        x: "const emailStub = { send: () => true }; // Stub: retorno fixo. const emailMock = jest.fn(); expect(emailMock).toHaveBeenCalledWith('ana@email.com'); // Mock: verifica chamada. jest.spyOn(service, 'send'); // Spy: registra mas executa real.",
      },
      {
        q: "O que é TDD (Test-Driven Development) e quais são seus passos?",
        o: [
          "Red-Green-Refactor: escrever teste que falha, implementar código mínimo para passar, refatorar",
          "Testar depois de codificar",
          "Apenas testes manuais",
          "Refatorar antes de testar",
        ],
        c: 0,
        e: "TDD segue 3 passos em ciclo: 1) RED: escreva um teste que falha (o código ainda não existe). 2) GREEN: escreva o código mínimo para o teste passar. 3) REFACTOR: melhore o código mantendo os testes passando. Cada ciclo leva minutos. Garante cobertura desde o início.",
        x: "Red: test('soma 2+3=5') → FAIL (function soma não existe). Green: function soma(a,b) { return a+b; } → PASS. Refactor: extrair para módulo math.ts. Testes continuam passando.",
      },
      {
        q: "O que é code coverage e qual é um percentual considerado bom?",
        o: [
          "Percentual de código executado pelos testes; 80% é geralmente considerado um bom alvo",
          "Número total de testes",
          "Velocidade de execução",
          "Quantidade de bugs encontrados",
        ],
        c: 0,
        e: "Code coverage mede quanto % do código é exercitado pelos testes: statements, branches, functions, lines. 80% é um alvo pragmático. 100% não garante ausência de bugs (cobertura não é qualidade). Mais importante: cobrir caminhos críticos e edge cases.",
        x: "npx jest --coverage: Statements: 85%, Branches: 72%, Functions: 90%, Lines: 85%. O branch coverage de 72% indica que 28% dos caminhos if/else não são testados — foco de melhoria.",
      },
      {
        q: "O que é BDD (Behavior-Driven Development) e como difere de TDD?",
        o: [
          "Foco no comportamento do sistema descrito em linguagem natural (Given/When/Then); TDD foca em código",
          "São idênticos",
          "BDD não usa testes automatizados",
          "TDD descreve comportamento e BDD testa código",
        ],
        c: 0,
        e: "BDD: testes escritos em linguagem de negócio (Given/When/Then ou Dado/Quando/Então). Facilitam comunicação com stakeholders não-técnicos. Ferramentas: Cucumber, Jest (describe/it semantics). TDD: foco na unidade de código. BDD: foco no comportamento do sistema.",
        x: "BDD: Given('usuário logado') When('clica em sair') Then('redireciona para login'). TDD: test('logout volta para /login', () => { logout(); expect(location).toBe('/login'); }). BDD é mais legível para não-devs.",
      },
      {
        q: "O que são fixtures e factories em testes e por que são úteis?",
        o: [
          "Dados predefinidos (fixtures) ou geradores de dados (factories) para setup de testes, evitando duplicação",
          "Ferramentas de deploy",
          "Padrões de arquitetura",
          "Tipos de assertions",
        ],
        c: 0,
        e: "Fixtures: dados estáticos reutilizáveis (JSON, seed data) para setup de testes. Factories: funções que geram objetos de teste com valores padrão e sobrescrevíveis. Evitam duplicação de setup e tornam testes mais legíveis e manuteníveis.",
        x: "const userFactory = (overrides = {}) => ({ id: faker.string.uuid(), name: faker.person.firstName(), email: faker.internet.email(), ...overrides }); const admin = userFactory({ role: 'admin' }); — gera usuário com defaults e permite customizar.",
      },
      {
        q: "O que é isolamento de testes (test isolation) e por que é importante?",
        o: [
          "Cada teste deve ser independente, sem dependar de outros testes ou de estado compartilhado",
          "Testes devem rodar em servidor isolado",
          "Testes devem ser escritos por uma única pessoa",
          "Isolar testes significa deletá-los",
        ],
        c: 0,
        e: "Test isolation: cada teste cria seu próprio estado, executa e limpa após si. Testes não devem depender da ordem de execução nem de estado deixado por outros. Violação: teste B só passa se teste A rodar antes. Ferramentas: beforeEach/afterEach, cleanup automático.",
        x: "beforeEach(() => { db = createTestDatabase(); }); afterEach(() => { db.destroy(); }); — cada teste começa com banco limpo. Sem isso: teste 'criar usuário' polui o estado para teste 'listar usuários' (deveria estar vazio).",
      },
      {
        q: "O que é CI/CD com testes automatizados no pipeline?",
        o: [
          "Integração e entrega contínua onde testes rodam automaticamente a cada push, bloqueando merge se falharem",
          "Compilador de código",
          "Ferramenta de design",
          "Banco de dados de testes",
        ],
        c: 0,
        e: "CI (Continuous Integration): a cada push, testes rodam automaticamente (unit, integration, lint). Se falharem, PR não pode ser mergeado. CD (Continuous Delivery/Deployment): após testes passarem, deploy automático para staging/produção. Ferramentas: GitHub Actions, GitLab CI, Jenkins.",
        x: "GitHub Actions: push → lint (1min) → unit tests (2min) → integration tests (5min) → build (2min) → deploy staging (1min). Se qualquer step falhar, pipeline para e PR fica com ✘ vermelho. Só merge com ✔ verde.",
      },
    ],
    Difícil: [
      {
        q: "Na estratégia de testes 'Contract Testing' entre microsserviços, como o Pact framework garante que producer e consumer estejam compatíveis?",
        o: [
          "Consumer gera um contrato com requisições esperadas; Producer verifica que suas respostas atendem ao contrato",
          "Producer define a API e Consumer adapta",
          "Ambos rodam o mesmo teste end-to-end",
          "Usa snapshots de JSON para comparação manual",
        ],
        c: 0,
        e: "No Pact, o Consumer define expectativas (quais requests fará e quais respostas espera) que são salvas como 'contratos' (Pact files). O Producer roda esses contratos contra sua API real, verificando que todas as respostas atendem às expectativas. Contratos são versionados e publicados em um Pact Broker.",
        x: "Consumer cria contrato: GET /users/1 espera { name: string, email: string }. Producer testa: roda GET /users/1 na sua API e verifica que a resposta inclui name e email. Se Producer remover o campo email, o contrato do Consumer falha.",
      },
      {
        q: "O que são property-based tests e como diferem de example-based tests?",
        o: [
          "Geram centenas de inputs aleatórios testando propriedades matemáticas do código, em vez de exemplos fixos",
          "Testes com configurações de ambiente",
          "Testes de propriedades CSS",
          "Testes de performance",
        ],
        c: 0,
        e: "Example-based: você escolhe inputs específicos (soma(2,3) === 5). Property-based: você define propriedades que devem valer para QUALQUER input válido (ex: sort(arr).length === arr.length). O framework (fast-check, QuickCheck) gera centenas de inputs aleatórios e verifica a propriedade.",
        x: "fc.assert(fc.property(fc.array(fc.integer()), (arr) => { const sorted = sort(arr); return sorted.length === arr.length && isSorted(sorted); })); — testa com 100 arrays aleatórios. Encontra edge cases que você não pensaria.",
      },
      {
        q: "O que é mutation testing e como ele avalia a qualidade dos testes?",
        o: [
          "Introduz mutações (bugs) no código e verifica se os testes detectam; mutações não detectadas indicam testes fracos",
          "Testes que mudam frequentemente",
          "Testes de modificação de banco",
          "Testes genéticos",
        ],
        c: 0,
        e: "Mutation testing modifica o código fonte (troca > por <, remove return, inverte booleanos) e roda os testes. Se os testes PASSAM com o código mutado, significa que os testes são fracos (não detectam o bug). Mutation score = mutantes mortos/total. Complementa code coverage.",
        x: "Mutação: trocar 'if (age >= 18)' por 'if (age > 18)'. Se testes passam, nenhum teste verifica o caso age=18 (boundary). Ferramentas: Stryker (JS/TS), PITest (Java). Mutation score alvo: >80%.",
      },
      {
        q: "O que é snapshot testing e quais são seus prós e contras?",
        o: [
          "Captura a saída renderizada e compara com versão salva; detecta mudanças inesperadas mas pode gerar falsos positivos",
          "Screenshot da tela",
          "Backup do banco de dados",
          "Teste de performance",
        ],
        c: 0,
        e: "Snapshot testing: primeira execução salva a saída (JSON/HTML). Execuções seguintes comparam com o snapshot salvo. Se diferir, teste falha. Prós: detecta regressões visuais, fácil de criar. Contras: falsos positivos frequentes, snapshots grandes são ignorados, cultura de 'update all'.",
        x: "test('renders correctly', () => { const tree = renderer.create(<UserCard name='Ana' />).toJSON(); expect(tree).toMatchSnapshot(); }); — gera arquivo .snap. Se UserCard mudar, teste falha até rodar: jest --updateSnapshot.",
      },
      {
        q: "O que é o conceito de test doubles e como se aplicam na arquitetura hexagonal?",
        o: [
          "Substitutos para dependências reais nos testes; na hexa, ports são facilmente substituídos por adapters falsos",
          "Testes executados duas vezes",
          "Cópias do banco de produção",
          "Duplicação de código de teste",
        ],
        c: 0,
        e: "Test doubles (termo genérico para mocks, stubs, fakes, spies, dummies) substituem dependências reais em testes. Na arquitetura hexagonal, ports (interfaces) permitem injetar adapters falsos facilmente. Fakes: implementação funcional simplificada (ex: InMemoryRepository).",
        x: "interface UserRepo { save(u: User): Promise<void>; } class InMemoryUserRepo implements UserRepo { users = []; async save(u) { this.users.push(u); } } — fake completo para testes sem banco. Mesma interface, implementação trivial.",
      },
      {
        q: "O que é Chaos Engineering e como difere de testes tradicionais?",
        o: [
          "Prática de injetar falhas controladas em produção para verificar resiliência do sistema",
          "Testes unitários com dados aleatórios",
          "Testes de performance com carga alta",
          "Debugging em ambiente local",
        ],
        c: 0,
        e: "Chaos Engineering: 'quebre coisas de propósito para provar que o sistema resiste'. Injeta falhas controladas: matar instâncias (Chaos Monkey), latência artificial, partições de rede. Verifica se redundancy, failover e graceful degradation funcionam. Difere de testes: roda em produção com tráfego real.",
        x: "Netflix Chaos Monkey: mata instâncias EC2 aleatórias em produção durante horário comercial. Se o sistema não se recuperar automáticamente, há um problema de resiliência antes que um incidente real ocorra.",
      },
      {
        q: "O que são testes de carga e performance e quais métricas monitorar?",
        o: [
          "Simulam alto volume de usuários para medir throughput, latência, error rate e identificar gargalos",
          "Testes de funcionalidade com muitos dados",
          "Testes de UI em diferentes resoluções",
          "Testes de segurança com ataques DDoS",
        ],
        c: 0,
        e: "Load testing: simula carga esperada. Stress testing: aumenta além do limite. Spike testing: picos súbitos. Soak testing: carga constante por longo período. Métricas: throughput (req/s), latência (p50, p95, p99), error rate, CPU/memória. Ferramentas: k6, Artillery, JMeter, Locust.",
        x: "k6: 100 VUs (virtual users) durante 5 min. Resultado: p95 latência = 250ms, throughput = 500 req/s, error rate = 0.1%. Stress: 1000 VUs → p95 sobe para 2s, errors 5% → gargalo no banco (pool de conexões esgotado).",
      },
    ],
  },
};

// ─── Round 1 · +2 questões por nível por categoria ───

const desenvolvimentoRound1Extras: Record<
  string,
  Record<UserLevel, SeedCard[]>
> = {
  "Algoritmos e Estruturas de Dados": {
    Fácil: [
      {
        q: "O que é uma Tabela Hash (Hash Table) e qual é sua complexidade média de busca?",
        o: [
          "Estrutura que mapeia chaves para valores usando função hash; busca em O(1) em média",
          "Árvore que ordena elementos; busca em O(log n)",
          "Lista duplamente ligada com acesso indexado; busca em O(n)",
          "Pilha com função de lookup; busca em O(1) sempre",
        ],
        c: 0,
        e: "Hash Table usa uma função hash para converter a chave em um índice do array, permitindo acesso O(1) em média. Colisões (duas chaves mapeadas ao mesmo índice) são tratadas por encadeamento (linked list no slot) ou endereçamento aberto (probing).",
        x: "Dicionário do Python é uma hash table. {'nome': 'Ana'} → hash('nome') = índice 42. dict['nome'] em O(1). No pior caso (todas as chaves colidem no mesmo slot) degrada para O(n), mas a função hash bem distribuída evita isso.",
      },
      {
        q: "O que é recursão e qual a condição essencial para evitar stack overflow?",
        o: [
          "Função que chama a si mesma com subproblema menor; condição base (base case) interrompe a recursão",
          "Laço que itera sobre uma coleção usando índice decrescente",
          "Função que chama outra função em cadeia infinita",
          "Algoritmo iterativo que usa pilha explícita para simular recursão",
        ],
        c: 0,
        e: "Recursão: função chama a si mesma com um subproblema menor. A condição base é obrigatória — sem ela a função chama infinitamente até estourar a call stack (stack overflow). Cada chamada recursiva cria um novo frame na pilha de execução.",
        x: "Fatorial: fatorial(0) = 1 (base), fatorial(n) = n * fatorial(n-1). fatorial(3) → 3 * fatorial(2) → 3 * 2 * fatorial(1) → 3 * 2 * 1 * fatorial(0) = 6. Sem a base fatorial(0)=1: chamaria para sempre.",
      },
    ],
    Médio: [
      {
        q: "O que é o algoritmo QuickSort e por que seu pior caso é O(n²)?",
        o: [
          "Divide array pelo pivô recursivamente; O(n log n) médio mas O(n²) se pivô sempre é o menor/maior elemento (array já ordenado)",
          "Ordena por inserção com complexidade O(n log n) em todos os casos",
          "Usa heap para ordenar com O(n log n) garantido no pior caso",
          "Ordena por contagem de frequências com O(n+k) sempre",
        ],
        c: 0,
        e: "QuickSort escolhe um pivô, particiona o array (menores à esquerda, maiores à direita) e aplica recursão. Pior caso O(n²): pivô sempre é o menor ou maior elemento — partição desbalanceada (n-1 de um lado, 0 do outro). Mitigações: pivô aleatório, mediana de 3, 3-way partition para duplicatas. In-place, sem array extra.",
        x: "Array já ordenado [1,2,3,4,5] com pivô sempre no início: 5 iterações de n, n-1, n-2... = O(n²). Solução: pivô aleatório; Python usa Timsort (hibrido merge+insertion) para evitar esse cenário. Caso médio: O(n log n) na prática.",
      },
      {
        q: "O que é uma Min-Heap e como funciona a extração do mínimo?",
        o: [
          "Árvore binária completa onde cada pai ≤ filhos; raiz é sempre o mínimo; extração remove raiz, sobe último elemento e aplica sift-down em O(log n)",
          "Array ordenado em ordem crescente com acesso O(1) ao menor",
          "BST com balanceamento automático que garante mínimo na folha mais à esquerda",
          "Fila circular onde o menor elemento fica sempre na frente",
        ],
        c: 0,
        e: "Min-Heap: árvore binária completa (armazenada em array) onde pai ≤ filhos: raiz = mínimo global. Inserção: adiciona ao final e sobe (sift-up). Extração do mínimo: remove raiz, coloca último elemento na raiz e desce (sift-down comparando com filhos). Ambas operações: O(log n).",
        x: "Priority Queue de tarefas urgentes: inserir(pagar_conta, p=1), inserir(tirar_lixo, p=5). extractMin() retorna pagar_conta. Dijkstra usa Min-Heap para sempre processar o vértice de menor distância acumulada. Python: heapq.heappush / heapq.heappop.",
      },
    ],
    Difícil: [
      {
        q: "O que é o algoritmo de Dijkstra e quais estruturas otimizam sua complexidade?",
        o: [
          "Caminho mais curto em grafos com pesos positivos; com Min-Heap (Priority Queue) atinge O((V+E) log V) em vez de O(V²) com array simples",
          "Ordena grafos topologicamente usando pilha; O(V+E)",
          "Encontra caminho mais longo em DAG using programação dinâmica; O(V²)",
          "Busca em largura ponderada com fila simples; O(V+E)",
        ],
        c: 0,
        e: "Dijkstra: inicializa dist[origem]=0, demais=∞. Extrai vértice de menor dist (Min-Heap), relaxa arestas. Arrays simples: O(V²). Min-Heap: O((V+E) log V). Não funciona com pesos negativos (usar Bellman-Ford). Para grafos densos (E≈V²), array simples pode ser tão bom quanto heap.",
        x: "Mapa: SP→RJ=400, SP→BH=600, RJ→BH=350. Dijkstra de SP: dist[RJ]=400, dist[BH]=600. Processa RJ: SP→RJ→BH=750 > 600, mantém. Resultado: SP→BH direto (600) é mais curto que via RJ (750).",
      },
      {
        q: "O que são árvores AVL e como as rotações garantem balanceamento O(log n)?",
        o: [
          "BST auto-balanceada onde |altura(esq)-altura(dir)| ≤ 1 em cada nó; rotações LL, RR, LR e RL reequilibram em O(1) após inserção/remoção",
          "Árvore B usada em bancos de dados com fator de balanceamento variável",
          "BST que usa cores vermelho/preto para balanceamento amortizado",
          "Heap que mantém propriedade de BST com reestruturação por comparação",
        ],
        c: 0,
        e: "AVL: cada nó guarda fator de balanceamento fb = altura(esq) - altura(dir) ∈ {-1, 0, 1}. Após inserção/remoção, se fb sair do intervalo: LL (rotação simples direita), RR (rotação simples esquerda), LR (rotação dupla esq+dir), RL (rotação dupla dir+esq). Garante altura ≤ 1.44 log₂(n). Todas operações em O(log n) garantido.",
        x: "Inserindo 1,2,3 em BST sem balanceamento: lista com 3 nós à direita (O(n) busca). Inserindo 3 na AVL: fb do nó 1 fica -2 (desbalanceado RR). Rotação esquerda: 2 vira raiz, 1 filho esq, 3 filho dir. Árvore balanceada, busca O(log n).",
      },
    ],
  },
  "APIs REST e GraphQL": {
    Fácil: [
      {
        q: "Qual método HTTP deve ser usado para criar um novo recurso em uma API REST?",
        o: ["POST", "GET", "PUT", "DELETE"],
        c: 0,
        e: "POST é o método HTTP para criar novos recursos. A resposta típica é 201 Created com o recurso no body. GET lê recursos (safe, idempotente), PUT substitui recurso completo (idempotente), PATCH atualiza parcialmente, DELETE remove. REST usa verbos HTTP como operações semânticas.",
        x: 'POST /api/usuarios Body: {"nome": "Ana"} → 201 Created {"id": 42, "nome": "Ana"}. GET /api/usuarios/42 → 200 OK {"id": 42, ...}. DELETE /api/usuarios/42 → 204 No Content. PUT /api/usuarios/42 Body: {"nome":"Ana Silva"} → substitui recurso completo.',
      },
      {
        q: "O que significa o código de status HTTP 401 e como difere do 403?",
        o: [
          "401: não autenticado (credenciais ausentes/inválidas); 403: autenticado mas sem permissão para o recurso",
          "401: recurso não encontrado; 403: servidor indisponível",
          "401: erro interno do servidor; 403: requisição mal formada",
          "São sinônimos que indicam acesso negado sem distinção",
        ],
        c: 0,
        e: "401 Unauthorized: sem credenciais ou credenciais inválidas. Header WWW-Authenticate informa método de autenticação. 403 Forbidden: autenticado mas sem permissão (ex: usuário comum tentando acessar area admin). 404 Not Found: recurso inexistente. 429 Too Many Requests: rate limit atingido.",
        x: "GET /api/perfil sem token → 401. Com token expirado → 401. Com token válido de usuário comum em GET /api/admin → 403. GET /api/usuario/999 (não existe) → 404. 100 requisições em 1 minuto → 429.",
      },
    ],
    Médio: [
      {
        q: "Qual é a principal vantagem do GraphQL sobre REST para consultas de dados aninhados?",
        o: [
          "Evita overfetching e underfetching: cliente especifica exatamente os campos necessários e obtém dados de múltiplas entidades relacionadas em uma única requisição",
          "GraphQL é sempre mais rápido que REST por usar protocolo binário",
          "Usa WebSockets nativamente para comunicação em tempo real",
          "Processa queries no cliente sem necessidade de servidor",
        ],
        c: 0,
        e: "REST: endpoints fixos retornam estrutura predefinida. Overfetching: recebe 20 campos quando precisa de 2. Underfetching: precisa de múltiplas requisições para dados relacionados. GraphQL: cliente define query com exatamente os campos desejados. Introspection: schema autodocumentado. Desvantagem: complexidade de caching (sem URLs fixas), curva de aprendizado.",
        x: "REST: GET /usuario/1 (20 campos) + GET /posts?userId=1 = 2 requests. GraphQL: query { usuario(id:1) { nome posts { titulo } } } = 1 request com somente nome e títulos dos posts. N-fields, 1-request. Playground: GraphiQL, Apollo Studio.",
      },
      {
        q: "O que é idempotência em APIs REST e quais métodos HTTP são idempotentes?",
        o: [
          "Operação que produz o mesmo resultado independente de quantas vezes é executada; GET, PUT, DELETE são idempotentes; POST não é",
          "Operação sem efeitos colaterais; somente GET é idempotente",
          "Operação reversível; todos os métodos exceto DELETE são idempotentes",
          "Operação atômica; POST e PATCH são idempotentes",
        ],
        c: 0,
        e: "Idempotência: executar N vezes = executar 1 vez (mesmo estado final). GET: leitura sem efeito. PUT: substituição total — PUT /pedidos/42 com mesmo body sempre resulta no mesmo estado. DELETE: deletar item já deletado retorna 404 mas estado é o mesmo (ausente). POST: cria novo recurso a cada chamada. PATCH: depende da implementação (pode ou não ser idempotente).",
        x: "PUT /pedidos/42 {status:'cancelado'}: executar 10 vezes = mesmo resultado. Importante para retries automáticos em caso de falha de rede. POST /pedidos: 10 execuções = 10 pedidos. Idempotency-Key header: permite POST idempotente em pagamentos (Stripe usa isso).",
      },
    ],
    Difícil: [
      {
        q: "O que é o problema N+1 em GraphQL e como o DataLoader resolve?",
        o: [
          "N+1: cada item de uma lista dispara query individual ao banco; DataLoader agrupa (batching) todos os IDs em um único tick do event loop e faz uma query com IN",
          "N queries para buscar 1 campo; cache do Apollo resolve automaticamente",
          "N+1 é exclusivo de REST; GraphQL não sofre esse problema",
          "DataLoader elimina a necessidade de banco de dados ao fazer cache total",
        ],
        c: 0,
        e: "N+1: query busca 100 usuários (1 query) e, para cada um, busca seus posts (100 queries) = 101 queries. DataLoader: acumula IDs solicitados durante o tick do event loop, executa 1 batch query (SELECT * FROM posts WHERE user_id IN (ids)), distribui resultados. Facebook criou DataLoader para esse problema. Reduz de N+1 para 2 queries.",
        x: "Sem DataLoader: 100 users → 100×SELECT posts WHERE user_id=X. Com DataLoader: dataloader.load(userId) acumula; batchLoadFn recebe [1..100] → SELECT posts WHERE user_id IN (1,...,100). 101 queries → 2 queries. graphql-dataloader, prime cache por key.",
      },
      {
        q: "O que são middlewares de rate limiting e quais algoritmos existem para implementá-los?",
        o: [
          "Controle de taxa de requisições para proteger APIs; algoritmos: Token Bucket (bursts permitidos), Leaky Bucket (saída constante), Fixed Window (janela fixa) e Sliding Window (mais precisa)",
          "Cache de respostas de API para reduzir carga no servidor",
          "Balanceamento de carga entre instâncias da API",
          "Compressão de payload para reduzir largura de banda consumida",
        ],
        c: 0,
        e: "Rate limiting protege contra abuso e DDoS. Token Bucket: tokens gerados a taxa fixa, cada req consome um token (permite bursts ate o tamanho do bucket). Leaky Bucket: fila com saída constante (suaviza tráfego, sem bursts). Fixed Window: conta reqs em janela fixa (problema: burst na virada da janela). Sliding Window Log: preciso mas custoso em memória. Sliding Window Counter: equilíbrio.",
        x: "Token Bucket: limite 100 req/min, 100 tokens disponíveis. 100 reqs simultâneas (burst): aceita todas. Next second: ~1-2 tokens. API Gateway AWS usa Token Bucket. Nginx: limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s. Redis usado para rate limiting distribuído entre múltiplos pods.",
      },
    ],
  },
  "Arquitetura de Software": {
    Fácil: [
      {
        q: "O que é o padrão arquitetural MVC (Model-View-Controller)?",
        o: [
          "Separa a aplicação em Model (dados/regras), View (interface) e Controller (lógica de controle), desacoplando responsabilidades",
          "Padrão de banco de dados com três tabelas obrigatórias",
          "Arquitetura de microsserviços com três serviços core",
          "Metodologia ágil com três papéis: dev, QA e PO",
        ],
        c: 0,
        e: "MVC: Model gerencia dados e regras de negócio. View renderiza a interface ao usuário. Controller recebe input do usuário, atualiza o Model e seleciona a View para resposta. Promove separação de responsabilidades, reuso (mesmo Model para múltiplas Views) e testabilidade independente das camadas.",
        x: "Blog: Model=Post (busca/salva no BD), View=post.html (renderiza HTML), Controller=PostController (recebe GET /post/1, chama Post.find(1), passa para View). Rails, Django, Laravel, ASP.NET MVC seguem esse padrão. Spring MVC e Express.js também.",
      },
      {
        q: "O que é um microsserviço e qual a diferença principal em relação a uma arquitetura monolítica?",
        o: [
          "Serviço pequeno e independente com domínio específico, deployado separadamente; monolito é uma única aplicação unificada deployada por completo",
          "Serviço externo de terceiros integrado via API REST",
          "Container Docker com um único processo isolado",
          "Função serverless com escopo e tempo de vida limitados",
        ],
        c: 0,
        e: "Microsserviços: aplicação decomposta em serviços pequenos e independentes, cada um com sua base de código, banco de dados e ciclo de deploy próprio. Comunicam via APIs HTTP/gRPC ou mensageria (Kafka, RabbitMQ). Monolito: tudo em um processo. Microsserviços: escalabilidade e independência de times a custo de complexidade distribuída.",
        x: "E-commerce monolítico: 1 deploy para tudo (risco: falha afeta tudo). Microsserviços: Pedidos, Pagamentos, Estoque, Usuários independentes. Time de Pagamentos faz deploy isolado. Escalabilidade: 10× o serviço de Pedidos sem escalar Usuários. Netflix, Amazon, Uber usam microsserviços.",
      },
    ],
    Médio: [
      {
        q: "O que é CQRS (Command Query Responsibility Segregation) e qual problema ele resolve?",
        o: [
          "Separa operações de leitura (Query) e escrita (Command) em modelos distintos; permite otimizar leitura e escrita independentemente",
          "Padrão de cache que separa dados quentes de dados frios em camadas",
          "Separação entre banco relacional (escrita) e NoSQL (leitura)",
          "Padrão de segurança que separa autenticação e autorização",
        ],
        c: 0,
        e: "CQRS: Commands (escrita) alteram estado e não retornam dados, executados no modelo de escrita com validação de invariantes. Queries (leitura) retornam dados sem efeito colateral, executadas em modelo de leitura otimizado (desnormalizado, cache, Elasticsearch). Frequentemente combinado com Event Sourcing. Custo: complexidade de sincronização eventual entre os modelos.",
        x: "E-commerce: Command CreateOrder → BD relacional normalizado (grava). Query GetOrderHistory → view materializada ou Elasticsearch desnormalizado (lê rápido). Escrita usa PostgreSQL; leitura usa Elasticsearch para busca por texto livre. Sync via eventos de domínio.",
      },
      {
        q: "O que é Domain-Driven Design (DDD) e o que são Bounded Contexts?",
        o: [
          "Abordagem que alinha código ao domínio do negócio; Bounded Context define limite explícito onde um modelo de domínio tem significado específico e coerente",
          "Framework de banco de dados organizado por domínio de negócio",
          "Metodologia de desenvolvimento de microsserviços orientada a domínio",
          "Padrão de UI que organiza componentes conforme o domínio do usuário",
        ],
        c: 0,
        e: "DDD: modelagem de software orientada ao domínio do problema, com linguagem ubíqua entre devs e especialistas de negócio. Conceitos: Entidades (identidade), Value Objects (imutáveis por valor), Aggregates (cluster com invariantes), Domain Events, Repositories. Bounded Context: fronteira explícita onde termos e modelos têm significado único (Produto em Vendas ≠ Produto em Estoque).",
        x: "E-commerce: Bounded Context de Vendas tem Pedido com lineItems e valor total. Bounded Context de Logística tem Pedido com endereço e tracking. Mesma palavra 'Pedido', modelos completamente diferentes. Comunicação entre contextos via eventos de domínio publicados.",
      },
    ],
    Difícil: [
      {
        q: "O que é Event Sourcing e como difere do armazenamento tradicional de estado?",
        o: [
          "Persiste sequência imutável de eventos ao invés do estado atual; estado reconstruído via replay dos eventos; permite auditoria e viagem no tempo",
          "Cache de eventos em memória para acelerar queries de estado",
          "Pub/Sub para notificar microserviços sobre mudanças de estado em tempo real",
          "Log de auditoria opcional sobre o banco de estado relacional",
        ],
        c: 0,
        e: "Event Sourcing: fonte da verdade = sequência de eventos (OrderCreated, ItemAdded, PaymentProcessed). Estado atual = replay de eventos. Vantagens: auditoria completa e imutável, estado em qualquer ponto do passado, base natural para CQRS. Desvantagens: complexidade de queries diretas, snapshots periódicos para evitar replay longo, eventual consistency.",
        x: "Conta bancária: em vez de saldo=1500, armazenamos Deposito(1000), Deposito(800), Saque(300). saldo = replay = 1500. Saldo em 01/jan: replay até aquela data. Eventstore, Axon, EventStoreDB. Snapshots: a cada 100 eventos, salva snapshot do estado para evitar replay completo.",
      },
      {
        q: "O que é o padrão Saga para gerenciar transações distribuídas em microsserviços?",
        o: [
          "Sequência de transações locais com compensações em caso de falha; implementada via coreografia (eventos) ou orquestração (coordenador central)",
          "Two-phase commit (2PC) distribuído entre microsserviços",
          "Fila de mensagens que garante entrega exatamente uma vez entre serviços",
          "Circuit breaker que interrompe transações em cascata em caso de falha",
        ],
        c: 0,
        e: "Em microsserviços não há transações ACID distribuídas. Saga: sequência de transações locais; se uma falha, executa transações compensatórias nas anteriores. Coreografia: cada serviço emite eventos e reage a eventos de outros (sem coordenador, mas difícil de rastrear). Orquestração: Saga Orchestrator centraliza coordenação (mais visível, ponto único de falha).",
        x: "Pedido: 1-CriarPedido → 2-ReservarEstoque → 3-ProcessarPagamento → 4-DespacharPedido. Se 3 falha: compensação 2=LiberarEstoque, 1=CancelarPedido. Coreografia via eventos Kafka. Orquestração: AWS Step Functions, Temporal, Conductor. Cada etapa tem transação compensatória correspondente.",
      },
    ],
  },
  "Banco de Dados SQL": {
    Fácil: [
      {
        q: "O que faz a cláusula GROUP BY em SQL e como o HAVING a complementa?",
        o: [
          "GROUP BY agrupa linhas com valores iguais permitindo funções de agregação por grupo; HAVING filtra grupos (como WHERE mas para grupos)",
          "GROUP BY ordena resultado por coluna; HAVING ordena grupos",
          "Ambos filtram linhas antes de qualquer agrupamento",
          "GROUP BY cria subgrupos temporários; HAVING os nomeia",
        ],
        c: 0,
        e: "GROUP BY agrupa linhas com mesmo valor, usada com COUNT(), SUM(), AVG(), MAX(), MIN(). WHERE filtra linhas antes do agrupamento. HAVING filtra grupos após agrupamento (pode usar funções de agregação). Ordem: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY.",
        x: "SELECT departamento, COUNT(*) as total, AVG(salario) as media FROM funcionarios WHERE ativo=1 GROUP BY departamento HAVING COUNT(*) > 5 ORDER BY media DESC — departamentos ativos com mais de 5 funcionários, ordenados por salário médio.",
      },
      {
        q: "O que é uma FOREIGN KEY e como o ON DELETE CASCADE se comporta?",
        o: [
          "Coluna que referencia a PK de outra tabela garantindo integridade referencial; ON DELETE CASCADE deleta automaticamente os registros filhos ao deletar o pai",
          "Segundo índice de uma tabela para melhorar performance de joins",
          "Restrição de unicidade composta por múltiplas colunas da mesma tabela",
          "Chave criptográfica para segurança dos dados relacionados",
        ],
        c: 0,
        e: "Foreign Key: garante integridade referencial — impossível ter pedido de cliente inexistente. ON DELETE CASCADE: ao deletar pai, filhos são deletados automaticamente. ON DELETE RESTRICT (padrão): bloqueia deleção se houver filhos. ON DELETE SET NULL: seta FK para NULL nos filhos. ON DELETE NO ACTION: similar ao RESTRICT mas verificado ao final da transação.",
        x: "Deletar cliente com pedidos: ON DELETE RESTRICT → ERRO. ON DELETE CASCADE → cliente + todos seus pedidos deletados. ON DELETE SET NULL → pedidos ficam com cliente_id = NULL. Muito comum em relacionamentos pai-filho: blog (posts cascadeiam comments).",
      },
    ],
    Médio: [
      {
        q: "O que é normalização e o que a Terceira Forma Normal (3NF) requer?",
        o: [
          "3NF: tabela está na 2NF (sem dependências parciais da PK) e sem dependências transitivas entre atributos não-chave",
          "3NF: todas as colunas são indexadas e não contêm valores nulos",
          "3NF: tabela sem grupos repetitivos e com chave primária simples",
          "3NF: nenhum atributo multivalorado e sem relacionamentos recursivos",
        ],
        c: 0,
        e: "1NF: sem grupos repetitivos, valores atômicos. 2NF: sem dependências parciais (todos atributos dependem da PK completa). 3NF: sem dependências transitivas (A→B→C onde B não é chave). Elimina anomalias de insert/update/delete. BCNF: versão mais rígida da 3NF. Desnormalização intencional melhora leitura ao custo de redundância.",
        x: "Tabela: CodPedido, CodCliente, CidadeCliente, PaisCliente. Problema transitivo: CodCliente→Cidade→País. 3NF: separar em Pedidos(CodPedido, CodCliente) e Clientes(CodCliente, Cidade, País). Atualizar cidade de cliente: 1 lugar, não n pedidos.",
      },
      {
        q: "Qual a diferença entre INNER JOIN, LEFT JOIN e FULL OUTER JOIN no SQL?",
        o: [
          "INNER: apenas registros com match em ambas as tabelas; LEFT: todos à esquerda + match à direita (NULL se sem match); FULL OUTER: todos de ambas as tabelas com NULL onde não há correspondência",
          "INNER retorna todos os registros; LEFT somente da tabela esquerda; FULL duplica linhas com match",
          "LEFT e RIGHT são equivalentes ao INNER; FULL é a intersecção das tabelas",
          "INNER é o join mais lento; LEFT e FULL têm melhor performance sempre",
        ],
        c: 0,
        e: "INNER JOIN: intersecção — linhas presentes em AMBAS as tabelas. LEFT JOIN: todos da esquerda + dados da direita (NULL se sem match) — útil para listar clientes sem pedidos. RIGHT JOIN: oposto. FULL OUTER JOIN: união de LEFT + RIGHT — todos os registros de ambas as tabelas, NULL onde sem correspondência.",
        x: "Clientes (A, B, C) e Pedidos (A, D). INNER → somente A (match). LEFT clientes → A(com pedido), B(NULL), C(NULL). FULL OUTER → A(pedido), B(NULL), C(NULL) + D(NULL cliente). Relatório 'clientes sem pedido': LEFT JOIN WHERE pedidos.id IS NULL.",
      },
    ],
    Difícil: [
      {
        q: "O que é um índice parcial em banco de dados e quando é mais eficiente que um índice completo?",
        o: [
          "Índice criado com cláusula WHERE cobrindo apenas subconjunto de linhas; mais eficiente quando queries sempre filtram esse subconjunto (menor tamanho, manutenção mais rápida)",
          "Índice que cobre apenas algumas colunas de uma tabela de alta cardinalidade",
          "Índice aplicado somente às linhas com valores nulos em determinada coluna",
          "Índice com menos de 50% das linhas da tabela por definição de seletividade",
        ],
        c: 0,
        e: "Índice parcial (PostgreSQL/SQLite): CREATE INDEX ... WHERE condição. Indexa apenas linhas que satisfazem a condição. Vantagens: menor tamanho em disco, manutenção mais rápida em INSERTs/UPDATEs, estatísticas mais precisas. Planner usa o índice apenas quando a query inclui o predicado. Ideal quando subset de dados é muito menor que o total.",
        x: "Tabela pedidos com 1M linhas: 99% status='concluido', 1% status='pendente'. Queries sempre em pendentes. CREATE INDEX idx_pendentes ON pedidos(criado_em) WHERE status='pendente' — indexa 10k linhas, não 1M. Consulta pedidos pendentes usa índice 100× menor. Manutenção: INSERT de pedido concluído não toca o índice.",
      },
      {
        q: "O que são os níveis de isolamento de transações SQL e quais anomalias cada um previne?",
        o: [
          "READ UNCOMMITTED: sem proteção; READ COMMITTED: previne dirty read; REPEATABLE READ: +non-repeatable read; SERIALIZABLE: +phantom reads (protecão máxima)",
          "Todos os níveis garantem isolamento total; diferença é apenas na performance",
          "SERIALIZABLE é o único nível com garantias reais; os outros são equivalentes",
          "READ COMMITTED previne todas as anomalias exceto deadlock entre transações",
        ],
        c: 0,
        e: "Anomalias: Dirty Read (ler dados não commitados de outra txn), Non-Repeatable Read (mesma query retorna valores diferentes dentro da txn — UPDATE por outra txn), Phantom Read (nova query retorna linhas diferentes — INSERT/DELETE por outra txn). READ UNCOMMITTED: nenhuma proteção. READ COMMITTED: evita dirty read (padrão PostgreSQL). REPEATABLE READ: evita dirty + non-repeatable (padrão MySQL/InnoDB). SERIALIZABLE: máxima proteção, menor concorrência.",
        x: "T1 lê saldo=1000 em READ COMMITTED. T2 atualiza para 900 e commita. T1 lê novamente: 900 (non-repeatable read). REPEATABLE READ: T1 sempre vê 1000 até commitar. SERIALIZABLE: bloqueia T2 de modificar enquanto T1 está ativa. Trade-off: mais isolamento = menos throughput.",
      },
    ],
  },
  "Banco de Dados NoSQL": {
    Fácil: [
      {
        q: "Qual é o modelo de dados do MongoDB e o que diferencia BSON de JSON?",
        o: [
          "MongoDB é orientado a documentos; BSON é Binary JSON com tipos extras como Date, ObjectId, Int64 e dados binários nativos",
          "MongoDB é relacional; BSON é JSON comprimido em Base64",
          "MongoDB é orientado a colunas; BSON é JSON com suporte a XML",
          "MongoDB é chave-valor; BSON é JSON com suporte a tipos genéricos",
        ],
        c: 0,
        e: "MongoDB armazena documentos BSON em coleções (análogo a tabelas). BSON estende JSON com tipos: Date (nativo, não string), ObjectId (ID distribuído único de 12 bytes), Int32/Int64/Decimal128, Binary, Regex. Schema flexível: documentos na mesma coleção podem ter campos diferentes. Permite documentos aninhados e arrays nativamente.",
        x: "Documento: {_id: ObjectId('6af...'), nome: 'Ana', criado: ISODate('2025-01-15'), tags: ['dev', 'js'], endereco: {rua: 'Av Brasil', cep: '01310'}}. ObjectId = timestamp(4)+machine(3)+pid(2)+counter(3). Coleção users pode ter documentos com campos totalmente distintos.",
      },
      {
        q: "Para que o Redis é mais usado e quais estruturas de dados ele suporta nativamente?",
        o: [
          "Cache em memória e filas; suporta String, List, Hash, Set, Sorted Set (ZSet), Stream e HyperLogLog",
          "Banco de grafos in-memory com vértices e arestas como estruturas nativas",
          "Banco analítico columnar com compressão nativa e alta consulta",
          "Banco de documentos JSON in-memory com índices automáticos",
        ],
        c: 0,
        e: "Redis (Remote Dictionary Server): banco in-memory key-value com estruturas ricas. String: cache simples, contadores INCR/DECR. List: fila FIFO/LIFO (LPUSH/RPOP). Hash: objeto com campos (HSET/HGET). Set: conjunto sem duplicatas (SADD/SMEMBERS). Sorted Set: set ordenado por score — leaderboards. Stream: log de eventos. TTL por chave. Persistência: RDB snapshots ou AOF log.",
        x: "Cache de sessão: SET session:u123 tokenJWT EX 3600. Fila: LPUSH jobs 'email'. Counter: INCR views:home. Leaderboard: ZADD ranking 1500 'playerA'; ZREVRANK ranking 'playerA'. Rate limit: INCR reqs:ip EX 60. Redis Pub/Sub para eventos em tempo real.",
      },
    ],
    Médio: [
      {
        q: "O que é o Teorema CAP e como ele impacta a escolha de bancos NoSQL?",
        o: [
          "Em presença de Partition (falha de rede), sistema distribiudo escolhe entre Consistency e Availability; bancos NoSQL são geralmente AP (Cassandra) ou CP (MongoDB)",
          "Bancos relacionais garantem as 3 propriedades; NoSQL sacrifica as 3",
          "CAP se aplica somente a bancos relacionais com replicação multi-master",
          "Partition Tolerance é sempre opcional em sistemas de produção modernos",
        ],
        c: 0,
        e: "CAP Theorem (Brewer): sistema distribuído não pode garantir simultaneamente Consistency (toda leitura retorna dado mais recente), Availability (toda requisição recebe resposta) e Partition Tolerance (continua operando com falha de rede). Como P é inevitável em redes reais, a escolha é C vs A. CP: MongoDB, HBase. AP: Cassandra, CouchDB, DynamoDB (eventual consistency).",
        x: "Cassandra (AP): durante falha de rede, nó isolado continua respondendo (disponível) com dado possivelmente desatualizado (inconsistente). MongoDB (CP): nó primário cai → elege novo primário, recusa escritas até então (consistente, mas menos disponível). PACELC refina CAP também para o caso sem partição.",
      },
      {
        q: "Quando é mais adequado usar banco de dados orientado a grafos como Neo4j?",
        o: [
          "Quando relacionamentos entre entidades são centrais e queries envolvem múltiplos graus de conexão (amigos de amigos, recomendações, detecção de fraude)",
          "Quando necessita de alta taxa de escrita com grande volume de dados flatten",
          "Quando dados têm estrutura hierárquica profunda como árvores de diretórios",
          "Quando o esquema muda frequentemente e precisa de flexibilidade de documentos",
        ],
        c: 0,
        e: "Bancos de grafos armazenam vértices e arestas como cidadãos de primeira classe, com alta performance em traversal de múltiplos hops. Casos de uso: redes sociais (amigos de amigos), sistemas de recomendação, detecção de fraude (padrões de conexão), autorização RBAC/ABAC complexa, grafos de conhecimento, rotas e logística.",
        x: "LinkedIn: MATCH (ana:Person)-[:KNOWS*1..3]->(rec:Person) WHERE NOT (ana)-[:KNOWS]->(rec) RETURN rec LIMIT 10 — amigos de amigos de amigos em 1 query. SQL equivalente: 3 JOINs aninhados ou CTE recursiva muito mais lenta e complexa. Neo4j, Amazon Neptune, TigerGraph.",
      },
    ],
    Difícil: [
      {
        q: "O que é consistent hashing e por que é usado em sistemas de sharding de bancos NoSQL?",
        o: [
          "Mapeia dados e nós em anel circular; adicionar/remover nó redistribui apenas K/n chaves (não todas), minimizando reorganização do cluster",
          "Função hash que garante zero colisões entre shards de diferentes nós",
          "Técnica de replicação que mantém cópias sempre idênticas entre shards",
          "Balanceamento de carga por round-robin aprimorado para clusters de banco de dados",
        ],
        c: 0,
        e: "Consistent hashing: nós e chaves mapeados em anel (hash 0 a 2³²). Chave vai ao próximo nó em sentido horário. Adicionar nó: apenas 1/n das chaves migram (não todas). Sem consistent hashing: adicionar nó requer rehash de todas as chaves (indisponibilidade). Virtual nodes (vnodes): cada nó físico = múltiplos pontos no anel para distribuição uniforme e rebalanceamento gradual.",
        x: "3 nós no anel: N1(0-120°), N2(121-240°), N3(241-360°). Adicionar N4 entre N1 e N2: apenas keys do intervalo N1→N4 migram de N2. Cassandra usa consistent hashing com vnodes por padrão. DynamoDB usa variante. Reduz downtime de rebalanceamento de horas para minutos.",
      },
      {
        q: "O que é a arquitetura LSM-Tree usada por Cassandra e RocksDB e quais seus trade-offs?",
        o: [
          "Escrita vai para MemTable (in-memory) + WAL, depois flushed como SSTable imutável em disco; compactação periódica mescla SSTables; otimizada para escrita, leitura levemente mais lenta",
          "Árvore B+ que loggeia todas as operações antes de aplicar ao arquivo de dados",
          "Índice invertido para buscas full-text em grandes volumes de documentos",
          "Cache de índices em memória com persistência em disco via checkpoint periódico",
        ],
        c: 0,
        e: "LSM-Tree: escrita sequencial no WAL (durabilidade) + MemTable in-memory ordenada. MemTable cheia → flushed como SSTable imutável. Compactação: mescla SSTables periodicamente (elimina versões antigas, garbage collect). Leitura: MemTable → SSTables (Bloom filter evita I/O desnecessário). Trade-off: escritas muito rápidas (sequencial), leituras levemente piores que B+Tree, write amplification na compactação.",
        x: "Cassandra: escrita em <1ms (MemTable). Bloom filter: 95% de probabilidade de saber se key está na SSTable antes de ler. Compaction strategies: STCS (size-tiered), LCS (leveled, melhor leitura). RocksDB: engine de vários BDs (TiKV, Kafka Streams, MyRocks/MySQL). Read amplification: varrer múltiplas SSTables.",
      },
    ],
  },
  "Clean Code e Boas Práticas": {
    Fácil: [
      {
        q: "O que é o princípio DRY (Don't Repeat Yourself) e como identificar sua violação?",
        o: [
          "Cada pedaço de conhecimento deve ter representação única no sistema; violação: mesma lógica duplicada em múltiplos lugares exigindo mudanças paralelas",
          "Escrever o menor código possível, mesmo sacrificando legibilidade",
          "Comentários não devem repetir o que o código já diz",
          "Reusar variáveis para não alocar memória desnecessária",
        ],
        c: 0,
        e: "DRY: duplicação de código/lógica cria manutenção frágil — mudança precisa ser aplicada em múltiplos lugares, risco de inconsistência. Solução: abstrair em função, classe, constante ou módulo reutilizável. Cuidado: WET (Write Everything Twice) temporariamente pode ser melhor que abstrair prematuramente antes da terceira repetição.",
        x: "Validação de email duplicada em 3 arquivos: se regra muda, 3 lugares para atualizar (risco de esquecer). DRY: extrair validateEmail() usada em todos os lugares. Uma mudança reflete em todos. Exceção: duplicação acidental (código similar, lógica diferente) não deve ser abstraída.",
      },
      {
        q: "O que é refatoração e o que ela NÃO deve alterar?",
        o: [
          "Reestruturar código interno sem alterar comportamento observável externamente; NÃO adiciona features, NÃO corrige bugs intencionalmente",
          "Reescrever algoritmos para melhorar performance mantendo a mesma interface",
          "Adicionar funcionalidades mantendo compatibilidade com código legado",
          "Migrar para nova linguagem ou framework preservando a lógica de negócio",
        ],
        c: 0,
        e: "Refactoring (Martin Fowler): melhorar estrutura interna (legibilidade, manutenibilidade, reduzir dívida técnica) SEM mudar comportamento observável. Testes garantem que comportamento não mudou — refactor sem testes é arriscado. Catálogo: Extract Method, Rename Variable, Replace Conditional with Polymorphism, Extract Class, Inline Function.",
        x: "Antes: if (u.s == 1 && u.p > 0) {}. Depois: if (usuario.estaAtivo() && usuario.temPagamento()) {}. Mesma lógica, mais legível. Renomear 'x' para 'totalVendas', extrair método 'calcularDesconto'. Nenhuma mudança funcional — testes verdes antes e depois.",
      },
    ],
    Médio: [
      {
        q: "O que é o princípio de Responsabilidade Única (SRP) do SOLID e como identificar violação?",
        o: [
          "Classe deve ter apenas um motivo para mudar; violação: classe que muda por razões distintas (lógica de negócio E persistência E apresentação)",
          "Classe deve ter apenas um método público exposto",
          "Módulo deve depender de apenas uma abstração",
          "Função deve realizar no máximo uma operação de I/O",
        ],
        c: 0,
        e: "SRP: cada classe/módulo tem responsabilidade única — um único motivo para mudar. Teste: 'por que essa classe mudaria?' — se múltiplas respostas, viola SRP. UserService que valida dados + salva no BD + envia email + gera relatório tem 4 motivos para mudar. Decomponha: UserValidator, UserRepository, UserNotifier, UserReportGenerator.",
        x: "Classe Report: gera dados + formata HTML + salva arquivo + envia email = 4 responsabilidades. SRP: ReportData, HtmlFormatter, ReportSaver, ReportEmailer. Cada uma muda por uma razão: trocar provedor de email → só ReportEmailer. Trocar formato → só HtmlFormatter.",
      },
      {
        q: "O que é dívida técnica e quais os principais tipos segundo Martin Fowler?",
        o: [
          "Custo futuro de retrabalho por soluções subótimas hoje; tipos: deliberada prudente (shortcut consciente), deliberada imprudente, inadvertida prudente e inadvertida imprudente",
          "Débito financeiro de licenças de software atrasadas",
          "Backlog de features não implementadas por falta de prazo",
          "Horas extras acumuladas da equipe durante períodos de crunch",
        ],
        c: 0,
        e: "Quadrante de Fowler: Reckless/Deliberate (sabemos o que fazemos, não nos importamos), Prudent/Deliberate (prazos, documentamos para pagar depois), Reckless/Inadvertent (não sabíamos de padrões melhores), Prudent/Inadvertent (só descobrimos o design correto após implementar). Cada tipo exige estratégia diferente. 'Juros': cada mudança futura fica mais cara.",
        x: "Deliberada prudente: 'vamos usar essa solução simples agora, criar ticket para refatorar antes da v2'. Inadvertida prudente: 'só após implementar percebemos que Domain Events era a abordagem certa'. Reckless deliberada: copiar-colar 5 vezes por pressa, sem plano de corrigir.",
      },
    ],
    Difícil: [
      {
        q: "O que é o Princípio de Inversão de Dependência (DIP) do SOLID e como Injeção de Dependência o implementa?",
        o: [
          "Módulos de alto e baixo nível devem depender de abstrações (interfaces), não de implementações concretas; DI fornece implementações em runtime sem que a classe as instancie",
          "Classes de alto nível chamam diretamente classes de baixo nível para maior coesão",
          "Interfaces devem depender das classes que as implementam para garantir contrato",
          "Serviços externos devem ser injetados como parâmetros do construtor sem abstração",
        ],
        c: 0,
        e: "DIP: UserService (alto nível) não deve instanciar EmailService (baixo nível) — ambos dependem de IEmailPort (abstração). DI: implementação concreta fornecida externamente (constructor injection, setter, container IoC). Invertente do controle: classe não cria dependências, recebe-as. Facilita testes (mock das interfaces), troca de implementação sem mudar o consumidor.",
        x: "Sem DIP: class UserService { email = new SendGridEmail(); } — acoplado. Com DIP: class UserService { constructor(private email: IEmailPort) {} }. Em produção: container injeta SendGridEmail(). Em testes: injeta MockEmail(). Trocar para AWS SES: nova classe AwsSesEmail implements IEmailPort — UserService não muda.",
      },
      {
        q: "O que é o Princípio de Substituição de Liskov (LSP) e como identificar violações práticas?",
        o: [
          "Subclasse deve ser substituível pela superclasse sem alterar o comportamento do programa; violação clássica: Quadrado extends Retangulo onde setLargura() quebra invariante da área",
          "Subclasse deve sobrescrever todos os métodos herdados da superclasse",
          "Interface deve ser mais específica que a classe que a implementa",
          "Herança múltipla sem conflito de método representa aplicação do LSP",
        ],
        c: 0,
        e: "LSP (Liskov): se S é subtipo de T, programa usando T deve funcionar com S sem saber. Violações: subclasse lança exceção para método herdado, post-conditions mais fracas, pre-conditions mais fortes. Quadrado herda Retangulo: setLargura(5) em Quadrado também altera altura (invariante área = L×A se L≠A quebra). Pinguim extends Ave com voar() lança exceção.",
        x: "Violação: class ReadOnlyList extends List { add(item) { throw Error('Somente leitura'); } } — código que chama list.add() quebra com ReadOnlyList. Solução: segregar interfaces — IReadableList e IWritableList. Outro exemplo: Pinguim — interface IAveVoadora vs IAveNaoVoadora ou composição de comportamentos.",
      },
    ],
  },
  "Design Patterns": {
    Fácil: [
      {
        q: "O que é o padrão Singleton e quais são suas desvantagens em aplicações modernas?",
        o: [
          "Garante uma única instância da classe com acesso global; desvantagens: estado global dificulta testes, viola SRP, acoplamento oculto entre módulos",
          "Cria múltiplas instâncias de forma controlada por uma factory central",
          "Garante uma única implementação de interface sem restrição de instâncias",
          "Cria objetos imutáveis com acesso thread-safe sem estado compartilhado",
        ],
        c: 0,
        e: "Singleton: construtor privado + static getInstance() retorna a mesma instância. Usado para: logger, configuração, pool de conexões. Problemas: estado global contamina testes (instância suja entre testes), viola SRP (gerencia próprio ciclo de vida), acoplamento oculto (modules dependem de instância global). Preferir DI de objetos únicos gerenciados pelo container IoC.",
        x: "class Database { private static instance: Database; static getInstance() { if (!this.instance) this.instance = new Database(); return this.instance; } }. Problema: Database.getInstance() em múltiplos testes compartilha conexões sujas. Alternativa: injetar a instância do banco via DI — mais testável.",
      },
      {
        q: "O que é o padrão Observer e como ele é o núcleo de sistemas reativos?",
        o: [
          "Define dependência um-para-muitos: Subject notifica automaticamente todos os Observers registrados quando seu estado muda",
          "Um objeto observa e modifica outros objetos diretamente",
          "Cria objetos complexos passo a passo com estado intermediário observável",
          "Encapsula algoritmos intercambiáveis com monitoramento de execução",
        ],
        c: 0,
        e: "Observer: Subject mantém lista de Observers e chama update() em todos quando muda. Observer se inscreve (subscribe) e cancela (unsubscribe) dinamicamente. Usado: event listeners DOM, EventEmitter Node.js, RxJS Observables, React useEffect com subscriptions, MVC (View observa Model). Cuidado: memory leaks por não cancelar observadores.",
        x: "EventEmitter (Node.js): emitter.on('data', handler) — Observer. emitter.emit('data', payload) — Subject notifica todos os handlers registrados em 'data'. RxJS: observable$.subscribe(handler) + takeUntil para cancelamento. Componente React subscreve WebSocket no useEffect e cancela no cleanup.",
      },
    ],
    Médio: [
      {
        q: "O que é o padrão Factory Method e como difere do Abstract Factory?",
        o: [
          "Factory Method: método de criação que subclasses sobrescrevem para instanciar produtos concretos; Abstract Factory: interface para criar famílias de objetos relacionados sem especificar classes concretas",
          "São idênticos — apenas nomes diferentes para o mesmo padrão de criação",
          "Factory Method cria múltiplos objetos; Abstract Factory cria apenas um por família",
          "Abstract Factory usa herança; Factory Method usa composição de objetos",
        ],
        c: 0,
        e: "Factory Method: classe base declara createProduct() abstrato, subclasses concretas decidem qual classe instanciar. Abre extensão sem modificar código existente (OCP). Abstract Factory: interface com múltiplos métodos (createButton(), createTextbox(), createDialog()) para família coerente. MacUIFactory vs WindowsUIFactory — garante componentes da mesma família. Abstract Factory compõe Factory Methods.",
        x: "Factory Method: Notificador base com createChannel() abstrato. EmailNotificador retorna EmailChannel; SMSNotificador retorna SMSChannel. Abstract Factory: GUIFactory { createButton(); createInput() }. DarkTheme retorna DarkButton + DarkInput coerentes. LightTheme retorna LightButton + LightInput coerentes.",
      },
      {
        q: "O que é o padrão Decorator e quando é preferível ao subclassing (herança)?",
        o: [
          "Adiciona comportamento a objetos em runtime envolvendo-os (composição); herança é estática e gera explosão de subclasses para cada combinação de comportamentos",
          "É idêntico à herança mas sem reaproveitamento de código da superclasse",
          "Decorator é Singleton que adiciona métodos em runtime; herança cria novos tipos em compile-time",
          "Herança adiciona comportamento em runtime; Decorator é sempre estático",
        ],
        c: 0,
        e: "Decorator: envolve objeto existente com mesmo interface, adicionando comportamento. Pode encadear múltiplos decorators. Herança: estática, explosão de subclasses para combinações (Coffee + Leite + Açúcar + Canela = 2⁴ subclasses vs 4 decorators combináveis). Runtime: pode adicionar/remover decorators dinamicamente. Java I/O, Express middlewares, Python @decorator.",
        x: "Java I/O: new GZIPOutputStream(new BufferedOutputStream(new FileOutputStream(file))) — pipeline de decorators sem subclassing. Python: @lru_cache, @staticmethod, @login_required são decorators. TypeScript: @Log() aplicado em método adiciona logging sem alterar o método original.",
      },
    ],
    Difícil: [
      {
        q: "O que é o padrão Command e como ele suporta undo/redo e processamento assíncrono?",
        o: [
          "Encapsula requisição como objeto (execute, undo); histórico em pilha habilita undo/redo; objetos Command podem ser enfileirados para processamento assíncrono",
          "Controla fluxo de execução com comandos if/else encapsulados em classes",
          "Gerencia pool de threads que executam funções em paralelo com controle",
          "Interface de linha de comando encapsulada em objetos de domínio",
        ],
        c: 0,
        e: "Command encapsula ação como objeto com execute() e opcionalmente undo(). Invoker não precisa saber o que o Command faz. Undo stack: pilha de Commands executados; Ctrl+Z: pop + undo(). Redo stack: undo vai para redo stack. Job Queue: serializar Commands, processar assincronamente (trabalhadores). Logging: persistir Commands para replay de auditoria ou recuperação de falhas.",
        x: "Editor: DigitarText(pos, texto), DeletarChar(pos, char), AplicarNegrito(range). Ctrl+Z: undo() de cada comando na pilha. Redux: cada action é um Command; store = replay de actions = Event Sourcing. Job Queue: EmailCommand enfileirado → Worker processa. AWS SQS: mensagens como Commands persistidos.",
      },
      {
        q: "O que é o padrão Strategy e como difere do Template Method?",
        o: [
          "Strategy: composição — delega algoritmo a objeto separado intercambiável em runtime; Template Method: herança — superclasse define esqueleto, subclasses sobrescrevem steps específicos",
          "Strategy usa herança para delegar; Template Method usa composição para sobrescrição",
          "São intercambiáveis; a escolha é apenas preferência de estilo",
          "Template Method é para algoritmos simples; Strategy só para algoritmos de alta complexidade",
        ],
        c: 0,
        e: "Strategy (composição): contexto recebe strategy como dependência injetada (SortStrategy: BubbleSort, QuickSort), pode trocar em runtime, testável isoladamente, aberto a extensão. Template Method (herança): classe abstrata define algoritmo completo com hooks que subclasses sobrescrevem — estrutura fixa, pontos de variação definidos. Herança = acoplamento mais forte.",
        x: "Strategy: PaymentProcessor { strategy: PaymentStrategy }. Usuário escolhe PIX → injetar PixStrategy; cartão → CreditCardStrategy. Troca em runtime. Template Method: DataImporter.importar() define parse→validate→save. CsvImporter sobrescreve parse(). JsonImporter sobrescreve parse(). Estrutura do algoritmo é fixa.",
      },
    ],
  },
  "Git e Versionamento": {
    Fácil: [
      {
        q: "Qual a diferença entre git reset e git revert ao desfazer commits?",
        o: [
          "git reset remove commits do histórico (reescreve historia, perigoso em repo compartilhado); git revert cria novo commit de reversão (seguro, preserva histórico)",
          "São idênticos em efeito, apenas com sintaxe diferente",
          "git revert apaga arquivos do disco; git reset desfaz apenas o stage",
          "git reset funciona somente em branches locais; revert somente em remotas",
        ],
        c: 0,
        e: "git reset --hard HEAD~1: move HEAD para commit anterior, apaga o commit do histórico. Perigoso em branches compartilhadas — reescreve histórico público. git revert HEAD: cria novo commit que reverte as mudanças, histórico intacto e rastreável. Em branches públicas sempre use revert. reset --soft: remove commit mas mantém changes staged.",
        x: "Commit com senha no código: git reset --hard HEAD~1 + git push --force (avisa equipe!). Já no main compartilhado: git revert abc123 cria 'Revert: remove credentials' — histórico preservado, mais seguro. git revert -n: prepara reversão sem commitar (permite revisar antes).",
      },
      {
        q: "O que é um branch no Git e por que usar branches por feature?",
        o: [
          "Ponteiro para um commit que avança com novos commits; branches por feature isolam desenvolvimento paralelo sem interferência na linha principal",
          "Cópia completa do repositório para desenvolvimento de feature isolada",
          "Snapshot imutável do código para marcação de versões de release",
          "Tag especial que agrupa commits relacionados a uma feature",
        ],
        c: 0,
        e: "Branch: ponteiro leve (um arquivo com SHA do commit HEAD). main/master: linha estável. Feature branch: dev A cria feature/login, dev B cria feature/pagamento — trabalham em paralelo sem interferência. Merge integra de volta ao main após review. Estratégias: Git Flow (feature/release/hotfix), GitHub Flow (feature → main), Trunk-Based (branches curtas < 1 dia).",
        x: "Dev A trabalha em feature/login, Dev B em feature/pagamento. Ambos fazem push ao mesmo tempo sem conflito (repositórios de branches isolados). Após review: PR feature/login → main (aprovado, merge). Conflito só acontece se editaram os mesmos arquivos — resolvido na hora do merge/rebase.",
      },
    ],
    Médio: [
      {
        q: "Qual a diferença entre git merge --no-ff e git rebase ao integrar branches?",
        o: [
          "merge --no-ff cria merge commit preservando histórico da branch; rebase reaplica commits sobre a base gerando histórico linear mas com SHAs reescritos",
          "Produzem resultado idêntico no histórico do repositório",
          "rebase é seguro em branches públicas; merge --no-ff deve ser evitado",
          "merge --no-ff só disponível no GitHub; rebase é apenas local",
        ],
        c: 0,
        e: "merge --no-ff: mesmo com fast-forward possível, força criação de merge commit com 2 parents — rastreabilidade da feature branch no histórico. Fast-forward merge: histórico linear, sem merge commit (branch aparece integrada). rebase: pega commits da feature e os reaplica sobre o tip do target com novos SHAs — histórico linear limpo. Regra: nunca rebase branches públicas/compartilhadas (reescreve SHA pode conflitar com histórico de outros).",
        x: "Feature com 3 commits. merge --no-ff: main recebe merge commit + 3 commits visíveis, git log --graph mostra bifurcação. rebase: 3 commits reescritos com novos SHAs no topo da main (histórico linear). git log --oneline: parece que foram feitos diretamente na main. GitHub Squash and Merge: combina os 3 em 1 commit na main.",
      },
      {
        q: "O que é git cherry-pick e quando é apropriado usá-lo?",
        o: [
          "Aplica commits específicos de outro branch no branch atual; útil para backport de bugfixes em branches de release sem fazer merge completo",
          "Seleciona aleatoriamente commits para resolver conflitos de merge automaticamente",
          "Desfaz commits selecionados mantendo os demais inalterados",
          "Compara diferenças entre commits específicos para análise de mudanças",
        ],
        c: 0,
        e: "git cherry-pick <sha>: copia commit específico, cria novo commit com mesmo diff mas novo SHA. Use quando: bugfix critical no main precisa ser backportado em branches de release v1.x e v2.x; commit acidentalmente feito no branch errado. Cuidado: em branches que serão merged eventualmente, cherry-pick cria commits duplicados (mesmo diff, SHAs diferentes).",
        x: "Bugfix crítico no main (sha: abc123). Release branches v2.5 e v3.0 precisam do fix. git checkout release/v2.5 && git cherry-pick abc123. git checkout release/v3.0 && git cherry-pick abc123. Cada branch recebe cópia do fix. Ferramentas: git cherry em duas bandas para identificar quais commits foram portados.",
      },
    ],
    Difícil: [
      {
        q: "O que é git reflog e como ele recupera commits após um reset --hard?",
        o: [
          "Log de todos os movimentos do HEAD incluindo após reset; permite recuperar SHAs de commits que não aparecem mais no git log mas ainda estão no object store",
          "Log de erros e conflitos de merge registrados pelo Git automaticamente",
          "Histórico de operações de push e pull entre repositório local e remoto",
          "Backup automático de todos os commits antes e depois de qualquer operação destrutiva",
        ],
        c: 0,
        e: "git reflog: registra cada posição do HEAD (commit, checkout, reset, rebase, merge). Git não deleta objetos imediatamente — garbage collection ocorre após ~90 dias. Recuperar: git reflog mostra HEAD@{N}: commit ABC. Encontrar SHA anterior ao reset. git reset --hard SHA ou git checkout -b recovery SHA. Objetos 'órfãos' (sem branch apontando) ficam no object store até GC.",
        x: "git reset --hard HEAD~3 — 3 commits perdidos! git reflog → HEAD@{0}: reset (atual), HEAD@{1}: commit 'feature login', HEAD@{2}: commit 'add tests', HEAD@{3}: commit 'fix bug'. git reset --hard HEAD@{3} ou git checkout -b recovery HEAD@{3}. Commits recuperados. Salvar SHA antes de operações destrutivas!",
      },
      {
        q: "O que são Git Hooks e quais são mais usados em pipelines de CI/CD?",
        o: [
          "Scripts executados automaticamente em eventos Git; pre-commit (lint/format), commit-msg (valida mensagem), pre-push (testes); post-receive no servidor para deploy",
          "Extensões do GitHub Actions para automação de workflows",
          "Tags especiais que marcam pontos de deploy no histórico",
          "Configurações de branch protection no repositório remoto",
        ],
        c: 0,
        e: "Git hooks: scripts em .git/hooks/ executados em eventos. Client-side: pre-commit (ESLint, Prettier, testes rápidos), prepare-commit-msg, commit-msg (Conventional Commits validation), post-commit, pre-push (testes completos). Server-side: pre-receive (validar, rejeitar push), update, post-receive (trigger deploy). Ferramentas de compartilhamento: Husky (Node), pre-commit (Python), lefthook.",
        x: "Husky + lint-staged: pre-commit roda ESLint e Prettier somente em arquivos staged (rápido). commitlint no commit-msg: valida 'feat: mensagem' (Conventional Commits). pre-push: npm test. post-receive no servidor: docker build + kubectl rollout. Resultado: erros básicos bloqueados localmente antes do push, sem desperdiçar CI.",
      },
    ],
  },
  "JavaScript e TypeScript": {
    Fácil: [
      {
        q: "O que é hoisting em JavaScript e como var, let e const se comportam diferentemente?",
        o: [
          "Declarações são movidas ao topo do escopo em compilação; var é hoisted e inicializado com undefined; let e const ficam em Temporal Dead Zone (TDZ) até declaração",
          "Nenhuma declaração é hoisted em JavaScript moderno (ES6+)",
          "var, let e const têm comportamento idêntico com hoisting, diferindo apenas em escopo",
          "Somente funções arrow são sofrem hoisting; funções declaration não",
        ],
        c: 0,
        e: "Hoisting: engine JS move declarações ao topo (não inicializações). var: hoisted e inicializado com undefined — acessível antes da linha de declaração (retorna undefined). let/const: hoisted mas entram em Temporal Dead Zone (TDZ) — ReferenceError se acessados antes da declaração. Function declaration: hoisted completamente com corpo. Function expression (const fn = ...) segue regras da variável.",
        x: "console.log(x); var x = 5; → undefined (não ReferenceError). console.log(y); let y = 5; → ReferenceError: Cannot access 'y' before initialization (TDZ). funcao(); function funcao(){} → OK (hoisted). funcaoExpr(); const funcaoExpr = () => {}; → ReferenceError (TDZ de const).",
      },
      {
        q: "O que é o event loop do JavaScript e por que setTimeout(fn, 0) não executa imediatamente?",
        o: [
          "Event loop processa callbacks da task queue somente após a call stack estar vazia; setTimeout(fn, 0) coloca fn na task queue, executada após todo código síncrono atual",
          "setTimeout(fn, 0) executa fn imediatamente em thread separada paralela ao código principal",
          "Event loop é uma thread separada que roda código assíncrono simultâneo ao síncrono",
          "Microtasks (Promises) e tasks (setTimeout) são processadas na mesma fila de forma intercalada",
        ],
        c: 0,
        e: "JS é single-threaded (1 call stack). Event loop: Web APIs (timers, fetch) executam em background. Ao terminar, callbacks vão para Task Queue (setTimeout, setInterval) ou Microtask Queue (Promise.then, queueMicrotask). Event loop: call stack vazia → drena TODA microtask queue → processa 1 task. setTimeout(fn, 0) = task, executada após código síncrono atual e promises pendentes.",
        x: "console.log('A'); setTimeout(() => console.log('B'), 0); Promise.resolve().then(() => console.log('C')); console.log('D'); Ordem: A, D, C, B. A e D: síncrono. C: microtask (Promise). B: task (setTimeout). Microtasks sempre antes de tasks. setTimeout de 100ms também aguarda stack vazia antes de executar.",
      },
    ],
    Médio: [
      {
        q: "O que são Generics em TypeScript e como diferem de usar o tipo any?",
        o: [
          "Generics preservam informação de tipo com parâmetros de tipo <T>; any descarta type safety completamente — generics permitem reuso sem perder verificação em compile-time",
          "Generics são alias de tipo documentais; any é tipo especial que bypassa erros de runtime",
          "São equivalentes em segurança; Generics apenas têm sintaxe mais verbosa",
          "any é mais performático em runtime pois evita checagens de tipo dinâmico",
        ],
        c: 0,
        e: "Generics: parâmetros de tipo (<T>) criam código reutilizável com preservação de tipos. TypeScript infere T na maioria dos casos. Com any: inferência de tipos perdida, erros só aparecem em runtime. unknown: tipo seguro para valores desconhecidos (exige type guard antes de usar). Constraints: <T extends Comparable> restringe T a tipos que implementam Comparable.",
        x: "function primeiro<T>(arr: T[]): T { return arr[0]; }. primeiro([1,2,3]): retorna number. primeiro(['a','b']): retorna string. TypeScript detecta erros em compile-time. Com any: function primeiro(arr: any[]): any — primeiro(['a','b']).toFixed() compila mas falha em runtime. Generic evita esse bug.",
      },
      {
        q: "O que são Promises e como async/await simplifica o código assíncrono?",
        o: [
          "Promise representa valor futuro com estados pending/fulfilled/rejected; async/await é açúcar sintático sobre Promises que permite escrever código assíncrono como síncrono com try/catch",
          "Promise é callback avançado síncrono; async/await cria threads reais em paralelo",
          "async/await substitui Promises completamente e são mecanismos independentes",
          "Promises são para I/O de disco; async/await para operações de rede",
        ],
        c: 0,
        e: "Promise: estados — pending (aguardando), fulfilled (resolvida), rejected (falhou). .then()/.catch()/.finally() encadeiam operações. async/await: função async retorna Promise implicitamente, await pausa execução até Promise resolver (sem bloquear call stack). try/catch captura rejeições. Promise.all([p1,p2]): executa em paralelo, aguarda todos. Promise.race: primeiro a resolver vence.",
        x: "Callback hell aninhado: getUser(id, (u) => getPosts(u.id, (p) => getComments(p[0].id, fn))). async/await: const user = await getUser(id); const posts = await getPosts(user.id); const comments = await getComments(posts[0].id). Paralelo: const [user, config] = await Promise.all([getUser(id), getConfig()]).",
      },
    ],
    Difícil: [
      {
        q: "O que são tipos condicionais (Conditional Types) em TypeScript e como NonNullable é implementado?",
        o: [
          "Tipos que resolvem para diferentes tipos baseado em condição T extends U ? X : Y; NonNullable<T> = T extends null | undefined ? never : T eliminando nulos da union",
          "Operador ternário aplicado a valores em tempo de execução pelo engine TypeScript",
          "Tipos que mudam conforme configurações do strictNullChecks no tsconfig.json",
          "Union types com narrowing de tipo em condicional if/else explícito",
        ],
        c: 0,
        e: "Conditional Types: T extends U ? X : Y. Distributive: aplicado a union T distribui — (A|B) extends U ? X : Y = (A extends U ? X : Y) | (B extends U ? X : Y). Infer: extrai tipos dentro da condição. ReturnType<T> = T extends (...args: any) => infer R ? R : never. never em union é absorvido. NonNullable<string | null | undefined> = string.",
        x: "type Flatten<T> = T extends Array<infer Item> ? Item : T. Flatten<string[]> = string; Flatten<number> = number. type ReturnType<T extends (...a: any) => any> = T extends (...a: any) => infer R ? R : never. ReturnType<() => string> = string. Usado extensivamente em tipos utilitários da lib padrão do TS.",
      },
      {
        q: "O que é o objeto Proxy em JavaScript e quais são as interceptações (traps) disponíveis?",
        o: [
          "new Proxy(target, handler) intercepta operações em objetos via traps (get, set, has, apply, construct, deleteProperty...); base de sistemas reativos como Vue 3",
          "Objeto de proxy de rede HTTP para interceptar requisições no browser",
          "Design pattern Proxy criado explicitamente para logging e auditoria de objetos",
          "Método de clonagem profunda de objetos complexos com transformação de propriedades",
        ],
        c: 0,
        e: "Proxy ES6: new Proxy(target, handler). Traps: get (leitura), set (escrita), has (operador in), deleteProperty, apply (chamada de função), construct (new), getPrototypeOf, setPrototypeOf, ownKeys, defineProperty, isExtensible, preventExtensions. Vue 3 substituiu Object.defineProperty (Vue 2) por Proxy para melhor reatividade (detecta adição de propriedades, delete, array index).",
        x: "Validação: const handler = { set(target, prop, value) { if (prop === 'age' && !Number.isInteger(value)) throw TypeError('age deve ser inteiro'); target[prop] = value; return true; } }. Vue 3: reactive({count: 0}) cria Proxy; count++ interceptado por set trap → notifica dependentes → re-render automático dos componentes.",
      },
    ],
  },
  "Programação Orientada a Objetos": {
    Fácil: [
      {
        q: "O que é encapsulamento em POO e qual o papel dos modificadores de acesso?",
        o: [
          "Ocultar detalhes de implementação e expor apenas interface pública; private (só na própria classe), protected (classe e subclasses), public (todos)",
          "Técnica de compressão de dados para otimizar uso de memória em objetos",
          "Herdar comportamento do pai mantendo os dados da classe filha privados",
          "Agrupar objetos com mesmo tipo em coleções encapsuladas",
        ],
        c: 0,
        e: "Encapsulamento: estado interno escondido, interação apenas via métodos públicos definidos. Benefícios: controle de invariantes (setter valida antes de alterar), liberdade de mudar implementação sem quebrar consumidores, redução de acoplamento. private: inacessível externamente. protected: acessível em subclasses. public: parte da interface pública.",
        x: "class ContaBancaria { private saldo = 0; depositar(v: number) { if (v <= 0) throw Error('Valor inválido'); this.saldo += v; } sacar(v: number) { if (v > this.saldo) throw Error('Saldo insuficiente'); this.saldo -= v; } getSaldo() { return this.saldo; } }. Saldo nunca fica negativo — invariante garantida pelo encapsulamento.",
      },
      {
        q: "O que é herança em POO e qual problema a herança profunda pode causar?",
        o: [
          "Subclasse reutiliza código e tipo da superclasse; herança profunda (muitos níveis) gera fragilidade — mudança na base quebra subclasses distantes (Fragile Base Class Problem)",
          "Subclasse compartilha instâncias com a superclasse para economizar memória",
          "Técnica de copiar métodos de uma classe para outra sem relação hierárquica",
          "Padrão que permite múltiplas superclasses em todas as linguagens OOP",
        ],
        c: 0,
        e: "Herança: subclasse herda estado e comportamento da superclasse (relação 'é-um'). Fragilidade: mudança em método da classe base pode quebrar subclasses que dependem do comportamento antigo. Herança profunda (5+ níveis) dificulta rastreamento de onde comportamento vem. Regra: máximo 2-3 níveis; preferir composição para hierarquias mais profundas.",
        x: "Animal→Mamifero→Animal Domestico→Pet→Cachorro. Adicionar validação no construtor de Animal quebra todos os 5 níveis se não esperada. Änderung em Mamifero.respirar() pode quebrar Cachorro.respirar() silenciosamente. Solução: compor comportamentos (Respiravel, Domesticavel) ao invés de herança profunda.",
      },
    ],
    Médio: [
      {
        q: "O que é composição versus herança e quando preferir composição em POO?",
        o: [
          "Herança: relação 'é-um' com acoplamento forte; composição: relação 'tem-um' delegando a colaboradores; preferir composição para evitar hierarquias rígidas e explosão de subclasses",
          "Herança é sempre mais reutilizável; composição somente para objetos sem relação de tipo",
          "São equivalentes em todos os aspectos; escolha é puramente estilística",
          "Composição é exclusiva de linguagens funcionais que não suportam herança",
        ],
        c: 0,
        e: "'Favoreça composição sobre herança' (GoF): herança expõe internals da superclasse (acoplamento forte), hierarquias rígidas e difíceis de modificar, Fragile Base Class Problem. Composição: objeto contém colaboradores como membros, delega comportamento, pode trocar implementação em runtime (Strategy), mais testável (mock de colaboradores). Herança válida quando relação 'é-um' é semântica e estável.",
        x: "Explosão de herança: Duck extends Bird; FlyingDuck, SwimmingDuck, FlyingSwimmingDuck. O que herda? Composição: duck = new Duck({ fly: new DroneFlyer(), swim: new DuckSwimmer() }). Pinguin: { fly: new NoFlight(), swim: new DivingSwim() }. Comportamentos trocados injetando implementações.",
      },
      {
        q: "Qual a diferença entre classe abstrata e interface em TypeScript e quando usar cada uma?",
        o: [
          "Classe abstrata: pode ter estado e implementação parcial, estendida por uma subclasse; interface: só define contrato sem estado, implementada por múltiplas classes",
          "São completamente intercambiáveis no TypeScript moderno",
          "Interface pode ter campos de instância; classe abstrata não pode ter campos",
          "Classe abstrata pode ser instanciada diretamente; interface nunca pode ser implementada por classes concretas",
        ],
        c: 0,
        e: "Classe abstrata: campos, construtores, métodos concretos e abstratos. Subclasse usa extends (apenas uma). Use quando há código compartilhado real entre subclasses. Interface: apenas assinaturas de métodos e tipos (TypeScript permite default methods em interfaces? Não — apenas declarações). Classe usa implements (múltiplas). Use para definir capabilities/contratos sem impor hierarquia.",
        x: "abstract class Conversor { abstract converter(d: any): string; logar(msg: string) { console.log(msg); } } — JsonConversor e CsvConversor herdam log() e implementam converter(). interface Serializavel { serializar(): string; } — User e Product implementam sem herança forçada. TypeScript verifica em compile-time.",
      },
    ],
    Difícil: [
      {
        q: "O que é o Princípio Aberto/Fechado (OCP) do SOLID e como evitar violações em código com múltiplos tipos?",
        o: [
          "Código aberto para extensão (novos comportamentos) mas fechado para modificação (sem editar existente); violação: switch/if-else que cresce a cada novo tipo",
          "Código open-source (aberto) com API interna fechada ao usuário externo",
          "Módulo sem modificadores de acesso public mas extensível via herança",
          "Classe que não aceita dependências externas mas é extensível internamente",
        ],
        c: 0,
        e: "OCP: adicionar comportamento = nova classe/módulo, não editar existente. Violação clássica: switch(forma) { case 'circulo': ...; case 'quadrado': ...; } — adicionar triângulo exige editar sempre. Solução: polimorfismo (interface Forma.calcularArea()), Strategy, Decorator. Paradoxo: toda abstração é um palpite — OCP válido quando ponto de variação é identificado corretamente.",
        x: "CalculadoraDesconto com switch(tipoCliente) — cada novo tipo = editar classe. OCP: interface DescontoStrategy, VIPStrategy, NormalStrategy. Calculadora recebe strategy — nova estratégia = nova classe, calculadora não muda. Plugin systems: VS Code extensions não editam o editor, apenas implementam interfaces definidas.",
      },
      {
        q: "O que é covariância e contravariância em definição de tipos genéricos e como TypeScript trata?",
        o: [
          "Covariância: subtipo pode ser substituído em posição de saída (retorno); contravariância: supertipo pode ser substituído em posição de entrada (parâmetro); TypeScript usa structural typing bivariant por default com strictFunctionTypes fixando",
          "São propriedades exclusivas de linguagens com herança múltipla estrita",
          "TypeScript não suporta variância — usa any internamente para todos os genéricos",
          "Covariância e contravariância são idênticas em sistemas de tipos estruturais",
        ],
        c: 0,
        e: "Covariante (out): Producer<Cat> é subtipo de Producer<Animal> — retornar Cat onde Animal esperado é seguro. Contravariante (in): Consumer<Animal> é subtipo de Consumer<Cat> — aceitar Animal onde Cat esperado é seguro (aceita mais amplo). Invariante: mutável T<Cat> não pode substituir T<Animal> (nem covariant nem contravariant). TypeScript: métodos de classe são bivariant (histórico), function types são contravariantes em parâmetros com strictFunctionTypes.",
        x: "Covariante seguro: () => Cat pode ser usada como () => Animal (retorna algo que é Animal). Contravariante seguro: (animal: Animal) => void pode ser usada como (cat: Cat) => void (aceita mais que Cat). Invariante (não seguro): Array<Cat> não é Array<Animal> — push(dog) causaria problema. TypeScript detecta isso com arrays mutáveis.",
      },
    ],
  },
  "React e React Native": {
    Fácil: [
      {
        q: "O que é o hook useState e qual a regra crítica de imutabilidade do estado?",
        o: [
          "Hook para estado local em componentes funcionais; estado NUNCA deve ser mutado diretamente — sempre usar setter para criar novo valor e triggerar re-render",
          "Variável global compartilhada entre todos os componentes da aplicação",
          "Cache de dados remotos fetch com invalidação automática",
          "Equivalente ao this.state de class component sem restrições de mutação",
        ],
        c: 0,
        e: "useState(initial) retorna [state, setState]. setState(novoValor) ou setState(prev => novoValor). React detecta mudança por referência — mutar objeto/array existente não triggera re-render (mesma referência). Regra: sempre criar novo objeto/array: setList([...list, item]), setObj({...obj, key: valor}). Batching: múltiplos setStates em event handler são batched (React 18 em todos os contexts).",
        x: "ERRADO: state.items.push('novo'); setItems(state.items); → mesma referência, sem re-render. CORRETO: setItems([...state.items, 'novo']); → nova referência, re-render. Para objetos: setUser({...user, nome: 'Ana'}) — spread preserva outros campos. Uso com função updater: setCount(prev => prev + 1) — seguro para múltiplos updates rápidos.",
      },
      {
        q: "O que é JSX e por que React usa className em vez de class?",
        o: [
          "JSX é açúcar sintático transformado em React.createElement(); usa className porque class é palavra reservada em JavaScript",
          "JSX é arquivo JSON para configurar componentes React de forma declarativa",
          "JSX é linguagem de template separada compilada independentemente do JavaScript",
          "JSX é substituição do HTML que roda diretamente no browser sem transpilação",
        ],
        c: 0,
        e: "JSX: <Button color='red'>Click</Button> → React.createElement(Button, {color:'red'}, 'Click'). Transpilado por Babel/SWC. Atributos seguem o DOM JavaScript, não HTML: class→className (class é reserved keyword), for→htmlFor, tabindex→tabIndex, onclick→onClick (camelCase). Eventos são SyntheticEvents gerenciados pelo React.",
        x: "<div className='box' onClick={fn} htmlFor='id'>...</div> → React.createElement('div', {className:'box', onClick:fn, htmlFor:'id'}). Fragment: <></> evita div wrapper. JSX permite expressões: {list.map(i => <li key={i.id}>{i.name}</li>)}. Compilado pelo Babel com @babel/plugin-transform-react-jsx.",
      },
    ],
    Médio: [
      {
        q: "Como funciona o array de dependências do useEffect e quais são os 3 comportamentos possíveis?",
        o: [
          "Sem array: executa após todo render; [] vazio: só na montagem; [a,b]: quando a ou b muda; cleanup function executada antes do próximo effect e no unmount",
          "Array vazio: nunca executa; com deps: executa no unmount; sem array: uma única vez na montagem",
          "Controla quantidade máxima de renderers por segundo para throttling",
          "Define quais estados são serializados para persistência entre sessões",
        ],
        c: 0,
        e: "useEffect(fn, deps): 1) sem deps → roda após CADA render. 2) [] → roda só na montagem (componentDidMount equivalent). 3) [a, b] → roda quando a ou b muda (comparação por referência com Object.is). Cleanup: função retornada pela fn roda antes do próximo effect e no unmount — essencial para cancelar subscriptions, clearInterval, removeEventListener para evitar memory leaks.",
        x: "[]: buscar dados uma vez. [userId]: rebuscar ao trocar usuário. Cleanup crítico: useEffect(() => { const timer = setInterval(tick, 1000); return () => clearInterval(timer); }, []). Sem cleanup: timer continua rodando após unmount (memory leak). Dependências exaustivas: eslint-plugin-react-hooks detecta deps faltantes.",
      },
      {
        q: "O que é o Context API no React e qual a principal limitação de performance?",
        o: [
          "Evita prop drilling compartilhando estado via Provider/useContext; limitação: qualquer mudança no valor do context re-renderiza TODOS os consumers, mesmo os que usam apenas partes não alteradas",
          "Substituto completo de Redux com gerenciamento de estado global sem desvantagens",
          "Cache de componentes React para evitar re-renders via memoização automática",
          "Sistema de roteamento sem dependências externas baseado em contexto de URL",
        ],
        c: 0,
        e: "Context: Provider fornece value, useContext(MyContext) acessa em qualquer descendente. Evita prop drilling. Limitação: quando value do Provider muda, todos os useContext(MyContext) re-renderizam — mesmo que componente use apenas parte não alterada. Soluções: dividir em múltiplos contextos granulares, useMemo no value, Zustand/Jotai/Redux para estado frequentemente mutável.",
        x: "Context {user, theme, notifications}: trocar theme → componentes que usam só user re-renderizam. Dividir: UserContext, ThemeContext, NotificationContext. UserProvider: value={useMemo(() => ({user}), [user])} — só re-renderiza consumers de UserContext quando user muda. Context bom para: tema, locale, auth (mudam raramente).",
      },
    ],
    Difícil: [
      {
        q: "O que é o algoritmo de reconciliação do React e como o Virtual DOM otimiza atualizações?",
        o: [
          "React mantém VDOM em memória; ao setState cria novo VDOM, faz diff (O(n) com heurísticas de tipo e key) com anterior e aplica apenas patches mínimos ao DOM real",
          "React serializa componentes em JSON para comparação antes de atualizar o DOM",
          "Novo DOM real criado a cada render e substituído completamente pelo anterior",
          "VDOM sincroniza automaticamente com servidor via SSR sem algoritmo de diff",
        ],
        c: 0,
        e: "VDOM: representação JS leve do DOM. Diffing O(n) com heurísticas: mesmos tipos → atualiza props; tipos diferentes → destrói e recria subárvore; listas → key para identificar elementos. Sem key: inserir no início reordena todos os elementos (O(n) mutations). Com key: React identifica que elementos existentes mantiveram identidade. Fiber (16+): reconciliador interrompível permite priorização de updates.",
        x: "setState({count: 1}) → novo VDOM diff com anterior → apenas textContent do span muda. Sem VDOM: innerHTML repintaria toda a página. Keys em list: <li key={item.id}> — inserir no início move os existentes em vez de recriar. key={Math.random()} é anti-pattern: recria tudo. Profiler DevTools: identifica renders desnecessários.",
      },
      {
        q: "Quando useMemo e useCallback causam problemas de performance ao invés de resolver?",
        o: [
          "Usados desnecessariamente adicionam overhead de closure, comparação de deps e alocação de memória — piores para operações baratas do que computar diretamente a cada render",
          "Sempre melhoram performance pois evitam qualquer recalculação de valor ou função",
          "useCallback é para componentes; useMemo é para valores primitivos simples",
          "Eliminam completamente re-renders desnecessários em qualquer cenário do React",
        ],
        c: 0,
        e: "useMemo e useCallback têm custo: criar closure, manter deps array, comparação por Object.is a cada render. Para operações baratas, é mais caro do que recomputar. useMemo correto: cálculo custoso (sort de lista grande, filtragem complexa). useCallback correto: função passada como prop a React.memo ou dep de useEffect. Prematuro: useMemo(() => a + b, [a,b]) — soma é barata.",
        x: "useMemo ERRADO: useMemo(() => items.length, [items]) — .length é O(1), overhead de useMemo maior. CERTO: useMemo(() => items.filter(complexPredicate).sort(complexSort), [items]) — evita O(n log n) a cada render. useCallback necessário: <Chart onHover={cb}/> onde Chart é React.memo — sem useCallback, cb recria toda render e Chart re-renderiza de qualquer forma.",
      },
    ],
  },
  "Testes de Software": {
    Fácil: [
      {
        q: "O que é um teste unitário e qual a regra FIRST para boas práticas?",
        o: [
          "Testa unidade isolada (função/classe) sem dependências externas reais; FIRST: Fast, Isolated, Repeatable, Self-validating, Timely",
          "Testa toda a aplicação de ponta a ponta incluindo banco e APIs externas",
          "Verifica integração entre múltiplos módulos do sistema em cenários reais",
          "Simula interações do usuário em interface gráfica com browser real",
        ],
        c: 0,
        e: "Teste unitário: menor unidade testável isolada de dependências (mocks para banco, APIs). FIRST: Fast (milissegundos, não segundos), Isolated (sem dependência entre testes — ordem não importa), Repeatable (mesmo resultado em qualquer ambiente/hora), Self-validating (pass/fail automático sem inspeção manual), Timely (escrito junto ao código, não após meses).",
        x: "test('soma(2,3) = 5', () => expect(soma(2,3)).toBe(5)) — unitário, puro, sem dependências. Não é unitário: test que faz SELECT no banco, chama API real, depende de arquivo no disco ou de outro test ter rodado antes. Jest/Vitest: 100 testes unitários em < 1s. 10 testes E2E: 30+ segundos.",
      },
      {
        q: "O que é TDD e qual é o ciclo Red-Green-Refactor?",
        o: [
          "Test-Driven Development: escrever teste que falha (Red), implementar código mínimo para passar (Green), melhorar código mantendo testes verdes (Refactor)",
          "Escrever todos os testes ao final do desenvolvimento como documentação",
          "Gerar testes automaticamente a partir do código de produção via reflection",
          "QA escreve testes antes dos devs como especificação formal do sistema",
        ],
        c: 0,
        e: "TDD: ciclo curto de feedback guiado por testes. Red: escrever teste para comportamento desejado (falha porque código não existe). Green: implementar código MÍNIMO para passar (pode ser feio). Refactor: melhorar sem quebrar funcionalidade (testes como rede de segurança). Benefícios: design emergente, documentação viva (testes), confiança em mudanças, debugging mais fácil.",
        x: "Red: test('juros(1000, 0.01, 12) = 126.83') → CompileError/Fail. Green: function juros(p,r,n) { return p*((1+r)**n-1); } → Pass. Refactor: renomear parâmetros, extrair constante, melhorar arredondamento → testes ainda passam. Ciclo dura minutos, não horas.",
      },
    ],
    Médio: [
      {
        q: "Qual a diferença entre mock, stub e spy em testes?",
        o: [
          "Stub: retorna valores pré-definidos sem verificar chamadas; Mock: verifica se foi chamado corretamente (comportamento); Spy: envolve implementação real registrando chamadas",
          "São sinônimos — termos diferentes para o mesmo conceito de substituição",
          "Mock substitui banco; Stub substitui APIs externas; Spy monitora logs do sistema",
          "Spy é para testes unitários; Mock para integração; Stub para E2E",
        ],
        c: 0,
        e: "Test Doubles (Meszaros): Stub — retorna dados fixos, controla estado, sem assertions sobre chamadas. Mock — pre-programado com expectations: expect(mock.metodo).toHaveBeenCalledWith(arg). Spy — wraps implementação real, registra chamadas para verificação posterior. Fake — implementação simplificada (in-memory DB). Dummy — preenche parâmetros obrigatórios sem uso real.",
        x: "Stub: jest.fn().mockReturnValue({id:1}) — retorna dados sem verificar. Mock: emailService.send = jest.fn(); ... expect(emailService.send).toHaveBeenCalledWith('ana@mail.com', 'Boas-vindas'). Spy: const spy = jest.spyOn(cache, 'get'); cache.get(key); expect(spy).toHaveBeenCalledTimes(1) — implementação real rodou mas registrou.",
      },
      {
        q: "O que é a pirâmide de testes e como equilibrar unitários, integração e E2E?",
        o: [
          "Base: muitos unitários (rápidos/baratos); meio: alguns de integração; topo: poucos E2E (lentos/caros/frágeis); proporção recomendada evita a anti-pattern 'ice cream cone'",
          "Todos os tipos em proporções iguais para cobertura balanceada e justa",
          "Maioria de testes E2E pois simulam o usuário real com maior confiança",
          "Apenas testes E2E são suficientes para garantir qualidade de software",
        ],
        c: 0,
        e: "Pirâmide (Mike Cohn): unitários = base (muitos, ms, baratos, isolados), integração = meio (alguns, segundos, verificam módulos juntos), E2E = topo (poucos, minutos, frágeis, alto valor). Anti-pattern ice cream cone: maioria E2E (lento, caro, frágil). Testing Trophy (Kent Dodds para React): mais integração que unitário (componentes com DOM). Suite típica: 70% unitários, 20% integração, 10% E2E.",
        x: "Suite 500u+50int+10e2e: < 3 minutos. 100 E2E: 30+ minutos, falhas intermitentes por timing. React Testing Library: testa componentes com DOM real (integração) — mais valor que só funções unitárias. Cypress/Playwright: 10 jornadas críticas do usuário. E2E cobre o que unitários não conseguem (routing, auth, fluxo completo).",
      },
    ],
    Difícil: [
      {
        q: "O que é property-based testing e como ele difere de example-based testing?",
        o: [
          "Property-based define propriedades lógicas que devem valer para qualquer input; geradores aleatórios encontram edge cases que testes manuais não cobrem; shrinking minimiza o caso falho",
          "Property-based documenta o sistema; example-based garante cobertura de linhas",
          "São a mesma técnica com nomes diferentes em linguagens distintas",
          "Property-based testa somente tipos primitivos; example-based é para objetos complexos",
        ],
        c: 0,
        e: "Example-based: test('reverse([1,2,3]) = [3,2,1]') — casos escolhidos manualmente. Property-based: define propriedade (reverso do reverso = original, sort preserva elementos, append incrementa length) e gerador cria centenas de inputs aleatórios buscando falsificar a propriedade. Shrinking: ao achar input falho, minimiza para o menor caso. Encontra edge cases (vazio, null, overflow) que humanos não pensam.",
        x: "fast-check: fc.assert(fc.property(fc.array(fc.integer()), (arr) => { const rev = [...arr].reverse(); return [...rev].reverse().join(',') === arr.join(','); })). Roda 100 arrays aleatórios. Se falha: shrinking produz o menor array que quebra. Hypothesis (Python), QuickCheck (Haskell), Jqwik (Java). Propriedade de encode/decode: decode(encode(x)) === x.",
      },
      {
        q: "O que é mutation testing e como ele avalia a qualidade real dos testes?",
        o: [
          "Introduz bugs intencionais (mutantes) no código e verifica se testes os detectam; mutation score = % mutantes mortos; 100% cobertura de linhas não garante alta mutation score",
          "Testa automaticamente código que manipula dados mutáveis vs imutáveis",
          "Gera automaticamente testes unitários a partir de análise estática do código",
          "Verifica se testes são determinísticos eliminando dependências de estado mutável",
        ],
        c: 0,
        e: "Mutation testing (Stryker, PIT): gera mutantes (troca > por >=, remove return, inverte condicionais, altera operadores aritméticos). Executa suite para cada mutante. Morto: algum teste falhou (mutante detctado). Sobrevivente: nenhum teste falhou (lacuna na suite). Mutation score = mortos / (mortos + sobreviventes). 100% line coverage pode ter mutation score baixo se assertions são fracas.",
        x: "Código: if (saldo >= valor). Mutante: if (saldo > valor). Test1: sacar(100) com saldo=200 → passa com ambos. Test2: sacar(100) com saldo=100 → passa com >=, falha com > → mata mutante. Test1 sobrevive com mutante = lacuna. Stryker para JS/TS: stryker run. Mutation score 80%+ indica testes que realmente testam lógica.",
      },
    ],
  },
};

// ─── Round 2 · +2 questões por nível por categoria ───

const desenvolvimentoRound2Extras: Record<
  string,
  Record<UserLevel, SeedCard[]>
> = {
  "Algoritmos e Estruturas de Dados": {
    Fácil: [
      {
        q: "O que é recursão em programação e quais são os dois componentes fundamentais de uma função recursiva?",
        o: [
          "Caso base (condição de parada) e caso recursivo (chamada a si mesma reduzindo o problema)",
          "Loop infinito e variável global de controle",
          "Chamada a outra função e retorno de null",
          "Iteração com for e condição de break",
        ],
        c: 0,
        e: "Recursão: função que chama a si mesma. Caso base: condição que encerra a recursão (sem ele, stack overflow). Caso recursivo: reduz o problema e chama a função novamente. Exemplos: fatorial(n) = n × fatorial(n-1), com fatorial(0) = 1 como caso base; Fibonacci, percurso de árvores.",
        x: "function fatorial(n) { if (n <= 1) return 1; /* caso base */ return n * fatorial(n - 1); /* caso recursivo */ } fatorial(5) → 5×4×3×2×1 = 120. Sem caso base: fatorial(5) → fatorial(4) → ... → stack overflow. Cada chamada empilha um frame na call stack.",
      },
      {
        q: "O que é uma fila de prioridade (priority queue) e qual estrutura de dados a implementa de forma eficiente?",
        o: [
          "Fila onde elementos saem por prioridade (não por ordem de chegada); implementada eficientemente com heap binário",
          "Fila FIFO comum onde o primeiro a entrar sai primeiro; usa array",
          "Pilha LIFO onde o último inserido é removido primeiro; usa linked list",
          "Lista ordenada que mantém elementos em ordem crescente; usa árvore binária de busca",
        ],
        c: 0,
        e: "Priority queue: cada elemento tem prioridade associada. Dequeue retira o de maior (ou menor) prioridade, não o mais antigo. Heap binário: árvore binária completa onde pai ≥ filhos (max-heap) ou pai ≤ filhos (min-heap). Inserção e remoção: O(log n). Peek: O(1). Usos: algoritmo de Dijkstra, agendamento de processos, merge de k listas ordenadas.",
        x: "Min-heap: inserir(5), inserir(2), inserir(8), inserir(1). peek() → 1. remove() → 1, heap reorganiza → peek() = 2. Em Python: import heapq; h=[]; heapq.heappush(h,5); heapq.heappush(h,2); heapq.heappop(h) → 2. Java: PriorityQueue<Integer> pq = new PriorityQueue<>();",
      },
    ],
    Médio: [
      {
        q: "Como funciona o algoritmo Merge Sort e por que ele garante complexidade O(n log n) mesmo no pior caso?",
        o: [
          "Divide o array ao meio recursivamente até ter subarrays unitários, depois intercala (merge) em ordem; log n níveis × O(n) por nível = O(n log n) garantido",
          "Seleciona um pivô e particiona em menores e maiores; no pior caso é O(n²)",
          "Compara elementos adjacentes e troca se necessário; complexidade O(n²)",
          "Constrói um heap e extrai o máximo repetidamente; instável",
        ],
        c: 0,
        e: "Merge Sort: dividir-e-conquistar. 1) Divide array ao meio recursivamente até tamanho 1 (log n divisões). 2) Intercala (merge) dois subarrays ordenados percorrendo ambos linearmente. Cada nível de recursão processa todos os n elementos → O(n) por nível × log n níveis = O(n log n) sempre. Estável (preserva ordem de iguais). Desvantagem: O(n) espaço extra para o merge.",
        x: "[38,27,43,3,9,82,10] → divide até unitários → merge: [27,38],[3,43],[9,82],[10] → [3,27,38,43],[9,10,82] → [3,9,10,27,38,43,82]. 3 níveis (log₂7 ≈ 3), cada nível percorre 7 elementos. Python usa Timsort (merge+insertion híbrido).",
      },
      {
        q: "O que é a técnica Two Pointers em algoritmos e em quais tipos de problemas ela é aplicada?",
        o: [
          "Usa dois índices que percorrem a estrutura (do início/fim ou ambos do início) para resolver problemas em O(n) sem espaço extra",
          "Cria duas cópias do array e compara elemento a elemento",
          "Divide o array em duas metades e processa cada uma separadamente com threads",
          "Usa duas estruturas de dados separadas (pilha e fila) para processar dados",
        ],
        c: 0,
        e: "Two Pointers: dois índices percorrem a estrutura de dados. Variantes: 1) Opostos: left=0, right=n-1, convergem ao centro (ex: two sum em array ordenado, palíndromo). 2) Mesmo sentido: slow/fast (ex: remover duplicatas in-place, detectar ciclo em linked list — Floyd). Complexidade: O(n) tempo, O(1) espaço. Pré-requisito comum: array ordenado.",
        x: "Two Sum em array ordenado [2,7,11,15], target=9: left=0(2), right=3(15), soma=17>9 → right--; left=0(2), right=2(11), soma=13>9 → right--; left=0(2), right=1(7), soma=9=target ✓. O(n) vs O(n²) brute force. Floyd cycle: slow=next, fast=next.next; se encontram = ciclo.",
      },
    ],
    Difícil: [
      {
        q: "O que são Segment Trees e como permitem consultas e atualizações em intervalos de forma eficiente?",
        o: [
          "Árvore binária onde cada nó armazena informação agregada de um intervalo do array; consulta e atualização em O(log n)",
          "Árvore binária de busca auto-balanceada que mantém elementos ordenados",
          "Estrutura que armazena todos os prefixos de um array para consultas rápidas",
          "Grafo direcionado que conecta intervalos sobrepostos para detecção de conflitos",
        ],
        c: 0,
        e: "Segment Tree: árvore binária construída sobre array. Cada nó guarda resultado agregado (soma, mín, máx) de um intervalo [l, r]. Raiz: intervalo total. Folhas: elementos individuais. Construção: O(n). Query de intervalo [ql, qr]: percorre nós relevantes em O(log n). Update pontual: propaga em O(log n). Lazy propagation: permite updates em intervalo também em O(log n).",
        x: "Array [1,3,5,7,9,11]. Segment tree de soma: raiz=36 [0-5]; esq=9 [0-2], dir=27 [3-5]. Query soma(1,4): nós [1-2]=8, [3-3]=7, [4-4]=9 → 24. Update idx=2 para 10: propaga da folha à raiz. Sem segment tree: query O(n); com: O(log n). Usada em competitive programming e bancos de dados geoespaciais.",
      },
      {
        q: "O que é o algoritmo de Kruskal para árvore geradora mínima (MST) e qual estrutura o torna eficiente?",
        o: [
          "Ordena arestas por peso e adiciona a menor que não forma ciclo, usando Union-Find para detectar ciclos em O(α(n)) amortizado",
          "Começa de um vértice e expande adicionando a aresta mais barata ao conjunto visitado",
          "Percorre o grafo em largura calculando distância mínima de cada vértice à origem",
          "Remove iterativamente a aresta de maior peso até restar uma árvore conexa",
        ],
        c: 0,
        e: "Kruskal: algoritmo guloso para MST. 1) Ordena arestas por peso: O(E log E). 2) Itera: para cada aresta (u,v,w), se u e v estão em componentes diferentes (Union-Find), adiciona à MST. 3) Para com V-1 arestas. Union-Find com path compression + union by rank: operações em O(α(n)) ≈ O(1). Total: O(E log E). Prim é melhor para grafos densos.",
        x: "Grafo: A-B(4), A-C(2), B-C(1), B-D(5), C-D(8), D-E(2). Ordenar: B-C(1), A-C(2), D-E(2), A-B(4), B-D(5), C-D(8). Adicionar: B-C(1)✓, A-C(2)✓, D-E(2)✓, A-B(4)→A,B já conectados (skip), B-D(5)✓. MST: {B-C,A-C,D-E,B-D}, peso=10. V-1=4 arestas ✓.",
      },
    ],
  },
  "APIs REST e GraphQL": {
    Fácil: [
      {
        q: "O que é uma query string na URL de uma API e como é usada para filtrar ou paginar resultados?",
        o: [
          "Parte da URL após '?' com pares chave=valor separados por '&'; usada para filtros, paginação e ordenação em requisições GET",
          "Corpo da requisição HTTP em JSON para criar recursos",
          "Header que define o tipo de resposta esperada pelo cliente",
          "Caminho da URL que identifica o recurso específico a ser acessado",
        ],
        c: 0,
        e: "Query string: parte da URL após '?'. Formato: ?chave1=valor1&chave2=valor2. Usada em GET para filtros, paginação, ordenação, busca. Não deve conter dados sensíveis (aparece no log e histórico). Limite prático: ~2048 caracteres. Caracteres especiais são URL-encoded (%20 para espaço).",
        x: "GET /api/products?category=electronics&min_price=100&sort=price&order=asc&page=2&limit=20. Servidor recebe: category='electronics', min_price=100, sort='price', page=2, limit=20. Resposta inclui total, hasMore ou Link header para próxima página.",
      },
      {
        q: "O que significa uma API REST ser stateless e qual a implicação para autenticação entre requisições?",
        o: [
          "Cada requisição deve conter todas as informações necessárias; o servidor não guarda estado da sessão, então tokens (JWT/API key) são enviados em cada request",
          "O servidor mantém sessão em memória e o cliente usa apenas cookie de sessão",
          "Stateless significa que a API não retorna dados, apenas confirma operações",
          "O servidor armazena histórico de todas as requisições do cliente para manter contexto",
        ],
        c: 0,
        e: "Stateless: servidor não guarda estado entre requisições. Cada request é independente. Implicação para auth: não existe sessão no servidor — token (JWT, API key, Bearer) é enviado em cada chamada via Authorization header. Benefícios: escalabilidade horizontal (qualquer servidor atende qualquer request), simplicidade, cacheabilidade.",
        x: "Request 1: GET /api/profile, Authorization: Bearer eyJhbGciOi... → 200 OK {name:'Ana'}. Request 2: GET /api/orders, Authorization: Bearer eyJhbGciOi... → 200 OK [...]. Sem header: 401 Unauthorized. Servidor não 'lembra' request 1 ao processar request 2.",
      },
    ],
    Médio: [
      {
        q: "O que são webhooks e como diferem de polling para receber notificações de eventos de serviços externos?",
        o: [
          "Webhooks: servidor externo envia HTTP POST ao seu endpoint quando evento ocorre (push); polling: seu sistema consulta periodicamente (pull) — webhooks são mais eficientes",
          "Webhooks usam WebSockets bidirecionais; polling usa SSE unidirecional",
          "Webhooks requerem conexão TCP persistente; polling usa UDP",
          "Webhooks são exclusivos para GraphQL; polling é o padrão REST",
        ],
        c: 0,
        e: "Polling: cliente consulta servidor repetidamente em intervalos (ex: GET a cada 30s). Desperdício se não há dados novos. Webhooks: evento ocorre → servidor externo faz POST para URL cadastrada com payload do evento. Eficiente (tráfego só quando há dados). Desafios: idempotência (evento pode ser reenviado), verificar assinatura (HMAC), retry com backoff em falhas.",
        x: "Stripe webhook: pagamento confirmado → POST https://seusite.com/webhooks/stripe, body:{type:'payment_intent.succeeded', data:{amount:5000}}. Servidor: verifica Stripe-Signature header (HMAC-SHA256), processa, retorna 200. Se retornar 5xx, Stripe reenvia com backoff exponencial até 72h.",
      },
      {
        q: "O que é paginação cursor-based e como difere de offset-based em APIs com grandes volumes de dados?",
        o: [
          "Cursor-based usa ponteiro opaco para o último item retornado; offset pula N registros — cursor é mais eficiente e consistente em datasets grandes e mutáveis",
          "Cursor-based numera páginas sequencialmente; offset usa índices de array",
          "Cursor-based só funciona com GraphQL; offset é exclusivo de REST",
          "Ambas são idênticas em performance; a escolha é puramente estética",
        ],
        c: 0,
        e: "Offset-based: GET /items?offset=1000&limit=20. Banco: OFFSET 1000 LIMIT 20 — precisa pular 1000 rows (lento em datasets grandes). Problema: inserções/deleções entre páginas causam duplicatas ou itens pulados. Cursor-based: GET /items?after=eyJpZCI6MTAwMH0. Banco: WHERE id > 1000 LIMIT 20 — usa index, O(log n). Consistente mesmo com mutações.",
        x: "1M registros. Offset página 5000 → OFFSET 100000 — banco itera 100K rows. Cursor after=id_100000 → WHERE id > 100000 LIMIT 20 — index seek direto. Resposta: { data: [...], pageInfo: { endCursor: 'abc123', hasNextPage: true } }. GitHub API v4 usa cursor-based.",
      },
    ],
    Difícil: [
      {
        q: "O que é o problema N+1 em GraphQL e como o DataLoader resolve esse problema de performance?",
        o: [
          "Resolver de campo dispara 1 query por item (N queries + 1 inicial); DataLoader agrupa IDs e faz uma única query batch por tick do event loop",
          "N+1 refere-se ao limite de profundidade de queries; DataLoader limita a N+1 níveis",
          "N+1 é o número máximo de campos retornados; DataLoader comprime a resposta",
          "N+1 é um limite de rate limiting; DataLoader faz cache local ilimitado",
        ],
        c: 0,
        e: "Problema N+1: query { users { posts { title } } }. Resolver users: 1 query. Para cada user, resolver posts: N queries (SELECT FROM posts WHERE user_id=?). Total: N+1 queries. DataLoader: agrupa load(userId) no mesmo tick do event loop → batch function com todos IDs: SELECT FROM posts WHERE user_id IN (1,2,...N). Resultado: 2 queries. Também cacheia por request.",
        x: "Sem DataLoader: users [1,2,3] → SELECT * FROM posts WHERE user_id=1; WHERE user_id=2; WHERE user_id=3 (4 queries). Com: const loader = new DataLoader(ids => db.query('SELECT * FROM posts WHERE user_id IN (?)', [ids])); resolver: loader.load(user.id); → batch: 1 query IN(1,2,3). Total: 2 queries.",
      },
      {
        q: "O que são Server-Sent Events (SSE) e como diferem de WebSockets para comunicação em tempo real?",
        o: [
          "SSE: conexão HTTP unidirecional server→client com reconexão automática e text/event-stream; WebSocket: bidirecional full-duplex sobre protocolo ws://",
          "SSE usa UDP para streaming; WebSocket usa TCP com garantia de entrega",
          "SSE requer servidor dedicado; WebSocket funciona em qualquer servidor HTTP padrão",
          "SSE é bidirecional como WebSocket mas com menor latência",
        ],
        c: 0,
        e: "SSE: API nativa do navegador (EventSource). HTTP simples, Content-Type: text/event-stream. Unidirecional: server→client. Reconexão automática com Last-Event-ID. WebSocket: protocolo ws://, upgrade de HTTP. Bidirecional: client↔server. Mais complexo (handshake, heartbeat, reconnect manual). SSE para: notificações, feeds, dashboards. WebSocket para: chat, gaming, colaboração.",
        x: "SSE server: res.writeHead(200,{'Content-Type':'text/event-stream'}); setInterval(()=>res.write('data:'+JSON.stringify({price:42})+'\\n\\n'),1000). Client: const es=new EventSource('/stream'); es.onmessage=e=>console.log(JSON.parse(e.data)). Se cair, navegador reconecta em 3s com Last-Event-ID.",
      },
    ],
  },
  "Arquitetura de Software": {
    Fácil: [
      {
        q: "O que é escalabilidade horizontal vs vertical e quando cada abordagem é mais adequada?",
        o: [
          "Vertical: aumentar recursos da máquina (CPU, RAM); horizontal: adicionar mais máquinas — horizontal é preferível para alta disponibilidade e elasticidade",
          "Vertical: adicionar servidores; horizontal: melhorar hardware de um servidor",
          "Vertical: escalar frontend; horizontal: escalar backend",
          "Ambas significam adicionar mais capacidade de processamento",
        ],
        c: 0,
        e: "Vertical (scale up): CPU mais potente, mais RAM — mesma máquina. Limite: hardware tem teto, single point of failure. Horizontal (scale out): mais instâncias distribuídas. Requer: app stateless, load balancer, dados compartilhados. Benefícios: sem teto teórico, alta disponibilidade (nó cai, outros continuam). Desafio: consistência de dados, complexidade.",
        x: "App com 10K users. Vertical: trocar de 4GB para 32GB RAM — rápido mas limite ~256GB. Horizontal: 3 instâncias de 4GB atrás de ALB. Sessão: JWT stateless. Upload: S3 compartilhado. Auto-scaling AWS: adiciona instâncias quando CPU > 70%. Kubernetes: HPA escala pods horizontalmente.",
      },
      {
        q: "O que é uma fila de mensagens (message queue) e por que é usada em sistemas distribuídos?",
        o: [
          "Middleware que desacopla produtor/consumidor: produtor envia mensagem à fila, consumidor processa assincronamente — garante resiliência e absorção de picos",
          "Banco NoSQL otimizado para mensagens curtas e efêmeras",
          "Protocolo de comunicação síncrona entre microsserviços",
          "Sistema de cache que armazena respostas de APIs para reduzir latência",
        ],
        c: 0,
        e: "Message queue: produtor publica mensagem → fila armazena → consumidor consome quando disponível. Desacoplamento: produtor e consumidor não precisam estar online simultaneamente. Buffer de picos: 1000 req/s → fila absorve → consumidor processa a 100/s gradualmente. Garantias: at-least-once (RabbitMQ), at-most-once, exactly-once (Kafka). Exemplos: RabbitMQ, Apache Kafka, SQS, Redis Streams.",
        x: "Checkout e-commerce → publica 'pedido_criado' no Kafka. Consumers independentes: email (envia confirmação), estoque (reserva itens), analytics (registra venda). Se serviço de email cair, mensagem permanece no Kafka; ao voltar, consome e envia. Checkout não espera nenhum deles.",
      },
    ],
    Médio: [
      {
        q: "O que é o padrão Outbox para garantir consistência entre banco de dados e sistema de mensageria?",
        o: [
          "Grava o evento numa tabela outbox na mesma transação do dado; processo separado publica os eventos pendentes no broker",
          "Envia mensagem ao broker e depois persiste no banco na mesma operação",
          "Usa transações distribuídas (2PC) entre banco e broker para atomicidade",
          "Replica o banco inteiro para o broker em intervalos regulares",
        ],
        c: 0,
        e: "Problema: salvar no DB + publicar no broker não é atômico. Publicação falha após commit = evento perdido. Outbox pattern: 1) Transação atômica: INSERT pedido + INSERT outbox_events (mesmo TX). 2) Processo separado (polling ou CDC/Debezium) lê outbox e publica no Kafka. 3) Marca evento como publicado. Garante at-least-once. Consumer deve ser idempotente.",
        x: "BEGIN TX; INSERT INTO orders(id,total) VALUES(1,100); INSERT INTO outbox_events(id,type,payload) VALUES(uuid,'Order','{id:1,total:100}'); COMMIT; — Debezium (CDC) detecta INSERT na outbox → publica no Kafka topic 'order.events'. Consumer grava processed_event_id para idempotência.",
      },
      {
        q: "O que é Observability e quais são os três pilares (logs, métricas e traces) em sistemas distribuídos?",
        o: [
          "Capacidade de entender o estado interno do sistema; logs registram eventos, métricas quantificam comportamento e traces rastreiam requisições entre serviços",
          "Monitoramento de uptime com ping; logs são suficientes para total observabilidade",
          "Alertas automáticos que reiniciam serviços quando detectam falhas",
          "Dashboard que mostra apenas uso de CPU e memória",
        ],
        c: 0,
        e: "Observability: diagnosticar problemas em sistemas complexos. Três pilares: 1) Logs: registros de eventos (JSON estruturado). Ferramentas: ELK, Loki. 2) Métricas: valores numéricos ao longo do tempo (latência p99, error rate). Ferramentas: Prometheus, Grafana. 3) Traces: rastreamento de request através de múltiplos serviços com correlation ID. Ferramentas: Jaeger, OpenTelemetry.",
        x: "Request lenta: 1) Métrica: p99 latência subiu de 200ms para 2s no serviço de pagamento. 2) Trace: OpenTelemetry mostra request por API Gateway→Auth→Pagamento→Banco. Span do banco: 1.8s (bottleneck). 3) Log: query SQL com full table scan. Solução: adicionar índice. trace-id=abc123 liga os 3.",
      },
    ],
    Difícil: [
      {
        q: "O que são CRDTs (Conflict-free Replicated Data Types) e como permitem edição concorrente sem coordenação central?",
        o: [
          "Estruturas que garantem convergência eventual automática em réplicas independentes sem consenso ou lock; operações são comutativas e idempotentes",
          "Bancos com transações ACID distribuídas que previnem conflitos via locking pessimista",
          "Algoritmos de consenso como Raft que elegem líder para serializar operações",
          "Caches distribuídos que invalidam entradas conflitantes e forçam releitura",
        ],
        c: 0,
        e: "CRDTs: data structures para replicação sem conflito. State-based (CvRDT): envia estado completo, merge com lattice join. Operation-based (CmRDT): envia operações comutativas. Exemplos: G-Counter (incremento), LWW-Register (last writer wins), OR-Set. Strong Eventual Consistency: réplicas que receberam mesmas updates convergem sem coordenação. Usado em: Google Docs, Figma, Redis CRDTs.",
        x: "G-Counter 3 nós: A=[1,0,0], B=[0,2,0], C=[0,0,1]. A incrementa: A=[2,0,0]. B recebe de A: merge([0,2,0],[2,0,0])=[2,2,0]. Valor=4. Merge comutativo e idempotente → ordem não importa → convergência garantida. Figma usa CRDT para posição de objetos no canvas colaborativo.",
      },
      {
        q: "O que é o padrão Bulkhead e como previne falhas em cascata em arquiteturas de microsserviços?",
        o: [
          "Isola recursos (threads, conexões) em pools separados por funcionalidade; falha de um componente não esgota recursos dos outros",
          "Cria réplicas redundantes de cada serviço para failover automático",
          "Implementa retry com backoff exponencial em todas as chamadas entre serviços",
          "Monitora health checks e remove serviços defeituosos do load balancer",
        ],
        c: 0,
        e: "Bulkhead: inspirado em compartimentos estanques de navios. Se um inunda, outros ficam intactos. Em software: isola pools de recursos. Sem bulkhead: pool único de 100 threads — se API-A travar, todas bloqueadas, APIs B e C param. Com bulkhead: pool-A=30, pool-B=30, pool-C=30, reserva=10. API-A trava → 30 threads afetadas; B e C normais. Implementações: Resilience4j, Polly.",
        x: "E-commerce: pool-pagamento=20 threads (Stripe), pool-frete=10 (Correios API), pool-recomendação=5 (ML). Correios fora: 10 threads pendentes mas pagamento continua com suas 20. Sem bulkhead: 100 threads compartilhadas, Correios consome todas → checkout inteiro para.",
      },
    ],
  },
  "Banco de Dados SQL": {
    Fácil: [
      {
        q: "O que é uma subquery (subconsulta) em SQL e em quais cláusulas ela pode ser utilizada?",
        o: [
          "Query aninhada dentro de outra; pode ser usada em WHERE, FROM, SELECT e HAVING para filtrar, calcular ou gerar conjuntos intermediários",
          "Função que cria tabela temporária permanente no banco de dados",
          "Comando para executar múltiplas queries em paralelo",
          "Procedure que aceita parâmetros e retorna resultados",
        ],
        c: 0,
        e: "Subquery: SELECT dentro de outro SELECT. Em WHERE: filtro dinâmico. Em FROM: tabela derivada. Em SELECT: valor calculado por row. Tipos: escalar (1 valor), tabela (múltiplas rows). Correlacionada: referencia tabela externa (executa para cada row). EXISTS: testa se subquery retorna resultados. CTEs (WITH) são alternativa mais legível.",
        x: "Funcionários com salário acima da média: SELECT name FROM employees WHERE salary > (SELECT AVG(salary) FROM employees). Correlacionada: SELECT * FROM departments d WHERE (SELECT COUNT(*) FROM employees e WHERE e.dept_id = d.id) > 5 — executa subquery para cada departamento.",
      },
      {
        q: "O que é a cláusula ORDER BY em SQL e como combinar com LIMIT para obter os top-N resultados?",
        o: [
          "ORDER BY ordena o resultado por colunas (ASC/DESC); LIMIT restringe o número de linhas — juntos permitem consultar os N primeiros ou últimos registros",
          "ORDER BY filtra registros por condição; LIMIT define número máximo de colunas",
          "ORDER BY agrupa registros semelhantes; LIMIT define tamanho de cada grupo",
          "ORDER BY cria índice temporário; LIMIT impede que o índice cresça demais",
        ],
        c: 0,
        e: "ORDER BY: ordena resultado. ASC (crescente, padrão), DESC (decrescente). Múltiplas colunas: ORDER BY dept ASC, salary DESC. LIMIT (MySQL/PostgreSQL) ou TOP (SQL Server): restringe rows. OFFSET: pula N rows para paginação. Performance: sem índice, faz filesort (lento). Com índice na coluna de ordenação: mais eficiente.",
        x: "Top 5 salários: SELECT name, salary FROM employees ORDER BY salary DESC LIMIT 5. Paginação: SELECT * FROM products ORDER BY id LIMIT 20 OFFSET 40 — página 3. SQL Server: SELECT TOP 5 name, salary FROM employees ORDER BY salary DESC.",
      },
    ],
    Médio: [
      {
        q: "O que é um trigger em SQL e em quais cenários seu uso é apropriado ou deve ser evitado?",
        o: [
          "Bloco de código executado automaticamente em INSERT/UPDATE/DELETE; útil para auditoria e integridade, mas pode causar efeitos colaterais difíceis de rastrear",
          "Comando manual do DBA para limpar dados inconsistentes em massa",
          "Índice especial que acelera queries com condições complexas",
          "Procedure agendada via cron para executar em horários específicos",
        ],
        c: 0,
        e: "Trigger: código que executa automaticamente BEFORE ou AFTER DML. INSTEAD OF: substitui operação (em views). Usos legítimos: audit log (quem alterou, quando), campos calculados, validação complexa. Evitar: lógica de negócio complexa (difícil debugar, cascata de triggers). Alternativas modernas: CDC (Debezium), eventos na aplicação.",
        x: "CREATE TRIGGER audit_salary AFTER UPDATE ON employees FOR EACH ROW INSERT INTO salary_audit(emp_id,old_salary,new_salary,changed_at) VALUES(OLD.id,OLD.salary,NEW.salary,NOW()); — cada UPDATE registra antes/depois. Cuidado: UPDATE em 10K rows = 10K inserts na audit.",
      },
      {
        q: "O que é connection pooling em bancos de dados e por que é essencial para aplicações em produção?",
        o: [
          "Reutilização de conexões pré-estabelecidas em vez de abrir/fechar a cada request; reduz overhead de handshake TCP/SSL e limita conexões simultâneas",
          "Replicação de dados entre servidores para alta disponibilidade",
          "Cache de queries frequentes na memória do servidor de aplicação",
          "Balanceamento de carga entre múltiplas instâncias de banco de dados",
        ],
        c: 0,
        e: "Sem pool: cada request abre conexão (TCP+auth+SSL ~20-50ms) → query → fecha. 1000 req/s = 1000 conexões, esgota max_connections. Com pool: N conexões pré-abertas; request pega do pool → query → devolve. Configuração: min_pool, max_pool, idle_timeout. Ferramentas: PgBouncer, HikariCP (Java), Prisma pool.",
        x: "Node pg pool: const pool = new Pool({min:5, max:20}); await pool.query('SELECT * FROM users WHERE id=$1',[id]). 100 requests: 20 executam, 80 aguardam na fila. Sem pool: 100 conexões TCP abertas/fechadas + risco de esgotar max_connections (PostgreSQL default: 100).",
      },
    ],
    Difícil: [
      {
        q: "O que é MVCC (Multi-Version Concurrency Control) e como permite leituras sem bloqueio em bancos de dados?",
        o: [
          "Mantém múltiplas versões de cada registro; leituras acessam snapshot consistente sem bloquear escritas — cada transação vê a versão válida no seu timestamp",
          "Usa locks de leitura compartilhados para múltiplas leituras simultâneas bloqueando escritas",
          "Replica dados para servidores de leitura dedicados enquanto o primário processa escritas",
          "Armazena dados em cache na memória para evitar acesso ao disco",
        ],
        c: 0,
        e: "MVCC: UPDATE não sobrescreve — cria nova versão com novo timestamp. Leituras usam snapshot: veem versão mais recente visível no início da transação. Readers não bloqueiam writers, writers não bloqueiam readers. PostgreSQL: xmin/xmax por tuple, VACUUM limpa versões antigas. MySQL InnoDB: undo log. READ COMMITTED: snapshot por statement; REPEATABLE READ: snapshot por TX.",
        x: "TX1 (t=100): SELECT balance FROM accounts WHERE id=1 → vê 1000 (versão t=90). TX2 (t=101): UPDATE SET balance=500; COMMIT → cria versão t=101. TX1 (ativa): SELECT novamente → ainda vê 1000 (REPEATABLE READ, snapshot t=100). TX1 nunca bloqueada por TX2.",
      },
      {
        q: "O que são índices compostos em SQL e como a ordem das colunas afeta quais queries se beneficiam?",
        o: [
          "Índice sobre múltiplas colunas; segue a regra do prefixo mais à esquerda — só é usado se a query filtra pelas colunas na mesma ordem a partir da primeira",
          "Índice que combina dois índices simples automaticamente em runtime",
          "Índice que armazena resultado de funções aplicadas às colunas",
          "Índice especial para queries com OR que une resultados de múltiplos índices",
        ],
        c: 0,
        e: "Índice composto: CREATE INDEX idx ON orders(customer_id, status, created_at). B-tree ordena: primeiro customer_id → status → created_at. Regra do prefixo: usado se query filtra (customer_id), (customer_id, status) ou (customer_id, status, created_at). NÃO usado se filtrar só por (status) ou (created_at). Covering index: se colunas do SELECT estão no índice, index-only scan (sem acesso à tabela).",
        x: "INDEX idx ON orders(customer_id, status, created_at). ✓ WHERE customer_id=5 — usa. ✓ WHERE customer_id=5 AND status='paid' — usa. ✓ Todas as 3 — usa totalmente. ✗ WHERE status='paid' — não usa. ✗ WHERE created_at>'2024-01-01' — não usa. Solução: criar índice separado em (status).",
      },
    ],
  },
  "Banco de Dados NoSQL": {
    Fácil: [
      {
        q: "Quais são os quatro principais tipos de bancos NoSQL e qual o caso de uso ideal de cada um?",
        o: [
          "Documento (MongoDB), Chave-Valor (Redis), Colunar (Cassandra) e Grafo (Neo4j) — cada um otimizado para padrões de acesso diferentes",
          "Apenas dois tipos existem: documento e chave-valor; os outros são variações SQL",
          "Relacional, Documento, Arquivo e Objeto — todos armazenam dados em tabelas",
          "Texto, Numérico, Binário e Misto — classificados pelo tipo de dado armazenado",
        ],
        c: 0,
        e: "1) Documento (MongoDB): JSON flexível, queries ricas. Ideal para catálogos, CMS. 2) Chave-Valor (Redis): acesso por chave, ultra-rápido. Ideal para cache, sessões. 3) Colunar/Wide-Column (Cassandra): escritas massivas. Ideal para IoT, logs, séries temporais. 4) Grafo (Neo4j): nós e arestas. Ideal para redes sociais, recomendações, fraud detection.",
        x: "Rede social: Neo4j para amigos-de-amigos em 3 níveis (2ms vs minutos em SQL). Cache: Redis SET session:abc '{user:1}' EX 3600. Catálogo: MongoDB — cada produto tem atributos diferentes. IoT logs: Cassandra — 1M escritas/s com replicação multi-datacenter.",
      },
      {
        q: "O que é o Redis e quais estruturas de dados ele oferece além de simples chave-valor string?",
        o: [
          "Banco in-memory que suporta strings, listas, sets, sorted sets, hashes, streams, bitmaps e HyperLogLog",
          "Banco de documentos JSON que suporta apenas strings e números",
          "Cache simples que armazena apenas pares chave-string com expiração",
          "Banco relacional em memória com tabelas, índices e JOINs",
        ],
        c: 0,
        e: "Redis: Remote Dictionary Server. In-memory, single-threaded. Estruturas: String (cache, INCR), List (filas, LPUSH/RPOP), Set (unique, SADD), Sorted Set (ranking, ZADD com score), Hash (objetos, HSET/HGET), Stream (event log, XADD), Bitmap (flags, SETBIT), HyperLogLog (contagem aproximada de únicos). Persistência: RDB snapshots + AOF.",
        x: "Leaderboard: ZADD game:scores 1500 'alice' 1800 'carol'. ZREVRANGE 0 2 WITHSCORES → carol(1800), alice(1500). Sessão: HSET session:abc user_id 1; EXPIRE 3600. Fila: LPUSH queue:emails '{to:ana}'; worker: BRPOP queue:emails 0.",
      },
    ],
    Médio: [
      {
        q: "O que é o conceito de sharding em bancos NoSQL e como a partition key afeta a distribuição de dados?",
        o: [
          "Distribuição horizontal entre nós baseada em partition key; chave mal escolhida causa hot spots enquanto boa chave distribui uniformemente",
          "Replicação de todos os dados em todos os nós para redundância total",
          "Compressão de dados para reduzir armazenamento em cada nó",
          "Indexação automática de todos os campos para acelerar qualquer query",
        ],
        c: 0,
        e: "Sharding: divide dataset em partições distribuídas entre nós. Key: campo para determinar o shard (hash ou range). Boa key: alta cardinalidade, acesso distribuído (user_id). Má key: baixa cardinalidade (country — 'BR' com 60% tráfego = hot spot). DynamoDB/Cassandra: partition key → hash → shard. Queries devem incluir partition key (scatter-gather é caro).",
        x: "DynamoDB 'orders': partition key=customer_id→1M customers bem distribuídos. Se fosse status ('pending','shipped','delivered'): 3 partições, 'pending' com 60% = hot spot. Cassandra: PRIMARY KEY((user_id), created_at). Eficiente: WHERE user_id='abc'. Ineficiente: WHERE created_at>'2024-01-01' (full scan).",
      },
      {
        q: "O que é modelagem por desnormalização em bancos de documentos e quando duplicar dados é vantajoso?",
        o: [
          "Duplicar dados relacionados no mesmo documento para evitar lookups; vantajoso quando lidos juntos frequentemente e raramente atualizados independentemente",
          "Separar dados em collections normalizadas como em SQL para evitar redundância",
          "Comprimir documentos para reduzir espaço de armazenamento",
          "Criar índices em todos os campos para compensar falta de JOINs",
        ],
        c: 0,
        e: "SQL normalizado: pedido referencia cliente via FK, precisa JOIN. NoSQL documental: embutir dados do cliente no pedido (desnormalizar). Vantagem: uma leitura retorna tudo. Desvantagem: atualizar nome do cliente requer update em todos pedidos. Regra: embutir se 1:poucos e dados lidos juntos; referenciar se 1:muitos ou dados mudam frequentemente. Padrão Extended Reference: copiar só campos mais usados.",
        x: "Blog embedded (poucos comentários): {title:'Post 1', comments:[{user:'Ana',text:'...'}]}. Um read retorna tudo. Referência (milhares): {title:'Post 1', comment_ids:['c1','c2']} + collection separada. Extended Reference: {order_id:1, customer:{name:'Ana',email:'...'}, customer_id:'ref'} — dados de exibição embutidos, id para dados completos.",
      },
    ],
    Difícil: [
      {
        q: "O que é o protocolo Raft para consenso distribuído e como garante eleição de líder e replicação de log?",
        o: [
          "Algoritmo com três papéis (leader, follower, candidate); usa election timeout aleatório e majority quorum para replicação de log consistente",
          "Protocolo de gossip para disseminação eventual entre nós sem líder",
          "Algoritmo de hash consistente para distribuir dados uniformemente",
          "Protocolo de heartbeat para detecção de falhas sem eleição",
        ],
        c: 0,
        e: "Raft: consenso compreensível (alternativa a Paxos). Leader processa writes, Followers replicam, Candidate em eleição. Eleição: follower sem heartbeat → timeout aleatório (150-300ms) → candidate → pede votos → maioria = leader. Replicação: client→leader appenda log→ envia AppendEntries→ maioria confirma→ committed. Usado: etcd, CockroachDB, Consul.",
        x: "Cluster 5 nós: Leader(A), Followers(B,C,D,E). Write x=5: A appenda log → B,C,D confirmam (maioria 4/5) → committed. A morre: B timeout primeiro → candidate → C,D votam → B=novo leader com x=5 preservado. Raft garante: entry committed nunca é perdida.",
      },
      {
        q: "O que são LSM Trees (Log-Structured Merge Trees) e por que bancos como Cassandra e RocksDB as utilizam?",
        o: [
          "Estrutura otimizada para escritas: dados vão para memtable em RAM, depois flush como SSTables imutáveis no disco; compaction periódica faz merge dos níveis",
          "Árvore B+ que agrupa escritas em batches para reduzir I/O",
          "Índice invertido que mapeia valores para posições no disco",
          "Cache em camadas que armazena dados quentes em SSD e frios em HDD",
        ],
        c: 0,
        e: "LSM Tree: write-heavy otimizada. 1) Write → memtable (RAM) + WAL. 2) Memtable cheia → flush como SSTable (Sorted String Table, imutável). 3) SSTables acumulam → compaction: merge em SSTable maior, remove duplicatas/tombstones. Leitura: memtable → SSTables (recente→antigo). Bloom filters evitam reads desnecessários. Write O(1) amortizado; reads mais lentas que B-tree.",
        x: "Write x=5: memtable.put(x,5) + WAL. Memtable cheia: flush → SSTable-L0.sst (ordenada). Compaction L0→L1: merge-sort SSTables. Read x: memtable(miss) → Bloom filter L0(false) → L1(maybe) → check SSTable(found). LevelDB, RocksDB, Cassandra, ScyllaDB usam LSM.",
      },
    ],
  },
  "Clean Code e Boas Práticas": {
    Fácil: [
      {
        q: "O que são guard clauses (cláusulas de guarda) e como simplificam a leitura de funções?",
        o: [
          "Validações no início da função que retornam cedo em casos inválidos, eliminando aninhamento excessivo de if/else",
          "Blocos try/catch no final da função para capturar exceções",
          "Comentários que documentam pré-requisitos da função",
          "Testes unitários que validam parâmetros de entrada antes da execução",
        ],
        c: 0,
        e: "Guard clause: return/throw cedo para cases inválidos no topo da função. Sem: if aninhados profundos (arrow anti-pattern). Com: cada condição inválida sai imediatamente — happy path fica no nível principal sem indentação extra. Princípio: 'fail fast, return early'. Reduz cognitive complexity.",
        x: "Antes: function process(user) { if(user) { if(user.active) { if(user.age>=18) { /*lógica*/ } } } }. Depois: function process(user) { if(!user) return null; if(!user.active) throw Error('Inactive'); if(user.age<18) throw Error('Minor'); /*lógica sem indentação*/ }.",
      },
      {
        q: "O que é formatação consistente de código e por que ferramentas como Prettier e ESLint são importantes em times?",
        o: [
          "Padrões uniformes de indentação, espaçamento e nomenclatura; ferramentas automatizam a formatação eliminando debates de estilo em code reviews",
          "Maneira pessoal de organizar código que cada desenvolvedor escolhe individualmente",
          "Sistema de compilação que otimiza código para produção",
          "Framework de testes que valida regras de negócio do projeto",
        ],
        c: 0,
        e: "Formatação consistente: codebase parece escrito por uma pessoa. Prettier: formatador opinativo (tabs, aspas, trailing commas). ESLint: linter (bugs potenciais, variáveis não usadas). Juntos: ESLint para qualidade, Prettier para estilo. Automação: pre-commit hook (husky + lint-staged) formata antes de cada commit. Zero debates sobre estilo em PRs.",
        x: "Sem Prettier: dev A usa tabs, dev B usa 2 espaços. PR: diff enorme por formatação. Com: npx prettier --write . .prettierrc: {semi:true, singleQuote:true, tabWidth:2}. ESLint: 'no-unused-vars':'error' → CI falha se variável não usada. Husky: git commit → lint-staged roda ambos automaticamente.",
      },
    ],
    Médio: [
      {
        q: "O que é coesão e acoplamento em design de software e qual a relação ideal entre eles?",
        o: [
          "Coesão: grau em que elementos de um módulo pertencem juntos (alta=bom); acoplamento: dependência entre módulos (baixo=bom) — ideal: alta coesão e baixo acoplamento",
          "Coesão: número de classes (menos=melhor); acoplamento: métodos públicos (mais=melhor)",
          "Coesão: velocidade de execução; acoplamento: consumo de memória",
          "Ambos devem ser altos para módulos trabalharem juntos eficientemente",
        ],
        c: 0,
        e: "Alta coesão: módulo faz uma coisa bem (UserRepository: apenas CRUD de users). Baixa coesão: faz coisas não relacionadas (Utils: email+log+crypto). Baixo acoplamento: depende de interface/abstração. Alto: acessa campos internos, instancia classes concretas. Injeção de dependência inverte acoplamento. Lei de Demeter reduz acoplamento.",
        x: "Alta coesão + baixo acoplamento: class OrderService { constructor(private repo: OrderRepository) {} create(data) { return this.repo.save(new Order(data)); } } — interface. Baixa coesão: class GodService { sendEmail() {} processPayment() {} generatePDF() {} }. Alto acoplamento: class X { process() { new PostgresDB().query(...); } } — amarrado ao concreto.",
      },
      {
        q: "O que são code reviews efetivas e quais aspectos priorizar ao revisar código de outros desenvolvedores?",
        o: [
          "Análise de PRs focando em corretude, legibilidade, segurança e aderência a padrões — com feedback construtivo e específico",
          "Revisão focada exclusivamente em bugs de compilação e erros de sintaxe",
          "Reescrever o código do colega no seu próprio estilo",
          "Aprovação automática de PRs que passam nos testes automatizados",
        ],
        c: 0,
        e: "Priorizar: 1) Corretude: lógica, edge cases, race conditions. 2) Design: responsabilidades, abstração. 3) Legibilidade: nomes, complexidade. 4) Segurança: SQL injection, XSS. 5) Testes: cenários cobertos. 6) Performance: N+1, loops desnecessários. Feedback específico, elogiar o bom, perguntar ao invés de impor. PRs pequenos (<400 linhas).",
        x: "Ruim: 'Código confuso'. Bom: 'Esse bloco de 30 linhas poderia ser extraído para calcularDesconto() — mais legível e testável'. Nit: 'nit: renomear d para discount'. Blocking: 'Query dentro do loop causa N+1; use JOIN'. Elogio: 'Boa ideia usar guard clauses, ficou legível!'.",
      },
    ],
    Difícil: [
      {
        q: "O que é Cognitive Complexity e como difere de Cyclomatic Complexity para medir legibilidade?",
        o: [
          "Cognitive penaliza aninhamento proporcionalmente à profundidade; Cyclomatic conta caminhos independentes sem considerar nesting",
          "São sinônimos — ambas contam branches no código",
          "Cognitive mede tempo de execução; Cyclomatic mede uso de memória",
          "Cognitive só se aplica a linguagens OO; Cyclomatic a procedurais",
        ],
        c: 0,
        e: "Cyclomatic (McCabe): conta caminhos de execução. if(a) if(b) if(c) = 4. Não penaliza profundidade. Cognitive (SonarSource): incrementa para quebra de fluxo (+1) E adiciona penalidade por nesting. if(a){if(b){if(c)}} = 1+2+3=6. Mais alinhada com percepção humana. Guideline: ≤15 por método. SonarQube mede automaticamente.",
        x: "function f(a,b,c) {if(a){for(...){if(b){if(c){}}}}}. Cyclomatic: 1+1+1+1=5. Cognitive: if=1, for=1+1(nest), if=1+2(nest), if=1+3(nest) = 10. Cognitive penaliza mais o aninhamento profundo. Refatorar com guard clauses e extração de funções reduz drasticamente o score.",
      },
      {
        q: "O que é Immutability by Default e como a imutabilidade reduz bugs em software concorrente e funcional?",
        o: [
          "Tratar dados como imutáveis por padrão, criando novos objetos ao modificar — elimina race conditions e facilita raciocínio sobre estado",
          "Usar apenas constantes declaradas em tempo de compilação",
          "Impedir reatribuição de qualquer variável durante toda a execução",
          "Congelar objetos na memória para evitar coleta pelo garbage collector",
        ],
        c: 0,
        e: "Imutabilidade: dado criado nunca é alterado. 1) Thread-safety: sem mutação compartilhada, sem race conditions (sem locks). 2) Previsibilidade: ninguém modifica objeto em paralelo. 3) Memoização segura. Custo: alocação de novos objetos (mitigado por structural sharing — Immer/Immutable.js). Linguagens: Rust, Haskell, Kotlin val, JS const/Object.freeze.",
        x: "Mutável (bug): const user={name:'Ana'}; processA(user); processB(user) — A mudou name='Bob', B recebe 'Bob' inesperadamente. Imutável: const updated={...user, name:'Bob'} — user intacto. React: setState({...state, count: state.count+1}). Immer: produce(state, draft=>{draft.count++}) — API mutável, resultado imutável.",
      },
    ],
  },
  "Design Patterns": {
    Fácil: [
      {
        q: "O que é o padrão Iterator e como ele permite percorrer coleções sem expor a estrutura interna?",
        o: [
          "Fornece interface padronizada (next/hasNext) para percorrer elementos sequencialmente independente se é array, árvore ou hash — desacopla iteração da implementação",
          "Cria cópia completa da coleção para iterar sem modificar a original",
          "Ordena a coleção antes de iterar para garantir sequência consistente",
          "Converte qualquer coleção em array para usar métodos de array",
        ],
        c: 0,
        e: "Iterator: interface para percorrer elementos sem expor representação interna. Métodos: next() retorna próximo elemento, hasNext() verifica se há mais. Em JS: Symbol.iterator + protocolo { done, value }. Permite: for...of em qualquer coleção. Array, Map, Set, String — todos implementam. Custom iterables: qualquer objeto pode ser iterável implementando o protocolo.",
        x: "JS: const range = { from:1, to:5, [Symbol.iterator]() { let cur=this.from; return { next:()=> cur<=this.to ? {value:cur++,done:false} : {done:true} }; } }; for(const n of range) console.log(n); // 1,2,3,4,5. Java: Iterator<String> it = list.iterator(); while(it.hasNext()) System.out.println(it.next());",
      },
      {
        q: "O que é o padrão Template Method e como ele define o esqueleto de um algoritmo delegando passos às subclasses?",
        o: [
          "Método na classe base define a estrutura do algoritmo com passos abstratos que as subclasses implementam — mesma sequência, diferentes comportamentos",
          "Template genérico que gera código automaticamente a partir de tipos",
          "Método que aceita funções callback como parâmetro para variar comportamento",
          "Padrão que copia objetos existentes como template para criar novos",
        ],
        c: 0,
        e: "Template Method: classe base define algoritmo com sequência fixa de passos; alguns passos são abstratos (obrigatórios) ou hooks (opcionais). Subclasses sobrescrevem passos específicos sem alterar a estrutura. Princípio Hollywood: 'Don't call us, we'll call you'. Exemplos: frameworks de teste (setUp → test → tearDown), processadores de dados (read → parse → validate → save).",
        x: "abstract class DataProcessor { process() { const data=this.read(); const parsed=this.parse(data); this.validate(parsed); this.save(parsed); } abstract read(): string; abstract parse(d:string): any; validate(d:any) {} /* hook opcional */ abstract save(d:any): void; } class CSVProcessor extends DataProcessor { read() { return fs.readFileSync('data.csv'); } ... }",
      },
    ],
    Médio: [
      {
        q: "O que é o padrão Facade e como ele simplifica a interação com subsistemas complexos?",
        o: [
          "Classe que fornece interface unificada e simplificada para um conjunto de interfaces de subsistemas — oculta a complexidade interna expondo operações de alto nível",
          "Classe que herda de múltiplos subsistemas para combinar funcionalidades",
          "Proxy que intercepta chamadas aos subsistemas para adicionar cache",
          "Adaptador que converte interfaces incompatíveis entre subsistemas",
        ],
        c: 0,
        e: "Facade: interface simplificada sobre múltiplas classes/serviços complexos. Cliente usa Facade sem conhecer subsistemas internos. Benefícios: desacoplamento (cliente não depende de subsistemas), simplicidade (uma chamada vs múltiplas). Não adiciona funcionalidade — apenas orquestra. Diferença de Adapter: Adapter converte interfaces; Facade simplifica. Diferença de Mediator: Mediator coordena comunicação bidirecional entre objetos.",
        x: "class HomeTheaterFacade { constructor(private dvd:DVDPlayer, private amp:Amplifier, private lights:Lights) {} watchMovie(title:string) { this.lights.dim(10); this.amp.setVolume(5); this.dvd.play(title); } endMovie() { this.lights.on(); this.amp.off(); this.dvd.stop(); } } — cliente: theater.watchMovie('Matrix') em vez de 3 chamadas.",
      },
      {
        q: "O que é o padrão Builder e quando usá-lo em vez de construtores com muitos parâmetros?",
        o: [
          "Constrói objetos complexos passo a passo com método encadeado (fluent API); evita construtores telescópicos com muitos parâmetros opcionais",
          "Factory que cria famílias de objetos relacionados sem especificar classes concretas",
          "Padrão que clona objetos existentes para criar novos com pequenas modificações",
          "Singleton que controla a criação para garantir apenas uma instância",
        ],
        c: 0,
        e: "Builder: separa construção de objeto complexo da representação. Problema: construtor com 10+ parâmetros, muitos opcionais — difícil lembrar ordem. Builder permite chamar apenas métodos necessários em qualquer ordem. Fluent API: retorna this em cada método para encadear. Variante: Director orquestra a sequência de construção. Usos: query builders, configurações, requests HTTP.",
        x: "const query = new QueryBuilder().select('name','email').from('users').where('active = true').orderBy('name').limit(10).build(); — vs new Query('name,email','users','active=true',null,'name',10,null,null). Java: User.builder().name('Ana').email('ana@x.com').age(25).build();",
      },
    ],
    Difícil: [
      {
        q: "O que é o padrão Event Sourcing e como ele difere da persistência tradicional baseada em estado?",
        o: [
          "Armazena a sequência de eventos que levaram ao estado atual em vez do estado final; o estado é reconstruído fazendo replay dos eventos",
          "Padrão de cache que armazena o último estado e sincroniza periodicamente com o banco",
          "Sistema de filas que processa eventos assincronamente entre microsserviços",
          "Log de auditoria que registra mudanças mas armazena apenas o estado final no banco",
        ],
        c: 0,
        e: "CRUD: armazena estado final (UPDATE balance=500). Event Sourcing: armazena eventos imutáveis (DepositMade(200), WithdrawMade(100)). Estado atual = replay de todos os eventos. Vantagens: audit trail completo, temporal queries (estado em qualquer ponto no tempo), undo/redo nativo. Desvantagens: complexidade, event schema evolution, eventual consistency. Snapshots: guardam estado periódico para evitar replay completo.",
        x: "Conta bancária: eventos [AccountCreated(0), Deposited(1000), Withdrawn(200), Deposited(500)]. Estado atual: replay → 0+1000-200+500 = 1300. Query temporal: 'saldo em 10/jan' → replay até data. Snapshot a cada 1000 eventos: {balance:1000, eventId:1000}. Replay apenas eventos após snapshot. Usado: sistemas financeiros, e-commerce, contabilidade.",
      },
      {
        q: "O que é o padrão Specification e como ele encapsula regras de negócio reutilizáveis em objetos compostos?",
        o: [
          "Encapsula uma regra de negócio em objeto com método isSatisfiedBy(); permite compor specs com AND, OR, NOT para formar regras complexas reutilizáveis",
          "Define especificação técnica de APIs usando OpenAPI/Swagger para gerar código",
          "Padrão de validação que verifica se dados atendem schema JSON antes de persistir",
          "Interface que especifica métodos obrigatórios para implementação em subclasses",
        ],
        c: 0,
        e: "Specification: encapsula regra de negócio em objeto reutilizável. Método principal: isSatisfiedBy(candidate): boolean. Composição: spec1.and(spec2), spec1.or(spec2), spec1.not(). Benefícios: regras de negócio desacopladas do domínio, reutilizáveis (filtragem, validação, query building). DDD: parte da camada de domínio. Pode ser traduzida em SQL WHERE para queries eficientes.",
        x: "class PremiumUser extends Spec { isSatisfiedBy(u:User) { return u.purchases > 10 && u.totalSpent > 1000; } } class ActiveUser extends Spec { isSatisfiedBy(u:User) { return u.lastLogin > thirtyDaysAgo; } } const eligibleForDiscount = new PremiumUser().and(new ActiveUser()); users.filter(u => eligibleForDiscount.isSatisfiedBy(u));",
      },
    ],
  },
  "Git e Versionamento": {
    Fácil: [
      {
        q: "O que é o comando git stash e quando utilizá-lo durante o desenvolvimento?",
        o: [
          "Salva temporariamente mudanças não commitadas numa pilha para limpar o working directory; útil para trocar de branch sem perder trabalho em progresso",
          "Apaga permanentemente todas as mudanças não commitadas do repositório",
          "Cria um branch temporário com as mudanças atuais para revisão futura",
          "Comprime o histórico de commits para reduzir o tamanho do repositório",
        ],
        c: 0,
        e: "git stash: empilha mudanças (staged e unstaged) numa stash list e limpa working directory. stash pop: recupera e remove da pilha. stash apply: recupera sem remover. stash list: mostra todos os stashes. stash drop: remove um stash. Caso de uso: trabalhando em feature, precisa trocar para branch hotfix urgente sem commitar trabalho incompleto.",
        x: "Trabalhando em feature/login com código incompleto. Precisa consertar bug em main: git stash → working directory limpo. git checkout main → corrigir bug → commit → push. git checkout feature/login → git stash pop → mudanças restauradas. Stash com mensagem: git stash save 'WIP: login form validation'.",
      },
      {
        q: "O que é um arquivo .gitignore e como configurá-lo para excluir arquivos do versionamento?",
        o: [
          "Arquivo que lista padrões de arquivos/diretórios que o Git deve ignorar no rastreamento; suporta wildcards como *, ** e negação com !",
          "Arquivo que define permissões de acesso ao repositório para cada usuário",
          "Configuração que impede push para branches protegidas no servidor remoto",
          "Script que roda antes de cada commit para validar o código automaticamente",
        ],
        c: 0,
        e: ".gitignore: arquivo na raiz do repositório listando padrões a ignorar. Regras: node_modules/ (diretório), *.log (todos .log), !important.log (exceto este), build/ (saída de build), .env (variáveis sensíveis). Globais: ~/.gitignore_global para todos os repos. Já rastreado: git rm --cached arquivo para parar de rastrear. Template: github.com/github/gitignore.",
        x: ".gitignore: node_modules/ | dist/ | .env | *.log | .DS_Store | coverage/ | .idea/ | *.swp. Arquivo já rastreado antes do .gitignore: git rm --cached .env (remove do tracking mas mantém o arquivo local). git status: arquivos ignorados não aparecem. gitignore.io: gera templates por tecnologia.",
      },
    ],
    Médio: [
      {
        q: "O que é git bisect e como ele ajuda a encontrar o commit que introduziu um bug usando busca binária?",
        o: [
          "Comando que faz busca binária no histórico de commits, testando pontos médios até encontrar o commit exato que introduziu o problema",
          "Ferramenta que compara dois branches e lista todas as diferenças entre eles",
          "Comando que reverte múltiplos commits simultaneamente para desfazer uma feature",
          "Análise automática de código que detecta bugs potenciais em qualquer commit",
        ],
        c: 0,
        e: "git bisect: busca binária no histórico. 1) git bisect start. 2) git bisect bad (commit atual com bug). 3) git bisect good <sha> (commit antigo sem bug). 4) Git faz checkout do commit do meio → você testa → marca good/bad. 5) Repete até encontrar o commit exato. 100 commits entre good e bad: ~7 testes (log₂ 100). Automatizável: git bisect run <script-de-teste>.",
        x: "Bug detectado na v2.0 (commit 200), v1.5 (commit 100) funcionava. git bisect start; git bisect bad HEAD; git bisect good abc123. Git faz checkout do commit 150. Teste: bug? 'git bisect bad' → testa 125. Sem bug? 'git bisect good' → testa 137. Após ~7 iterações: 'abc456 is the first bad commit'. Automático: git bisect run npm test.",
      },
      {
        q: "O que é git rebase interativo e como usá-lo para limpar o histórico de commits antes de um merge?",
        o: [
          "Permite reordenar, editar, juntar (squash) ou remover commits de uma branch interativamente; útil para criar histórico limpo antes de abrir um PR",
          "Visualizador gráfico do histórico que permite navegar entre commits",
          "Comando que automaticamente resolve conflitos entre branches",
          "Ferramenta que compara performance entre diferentes commits",
        ],
        c: 0,
        e: "git rebase -i HEAD~N: abre editor com N últimos commits. Ações: pick (manter), squash (juntar com anterior), fixup (squash sem mensagem), edit (parar para editar), reword (mudar mensagem), drop (remover). Caso de uso: 5 commits 'WIP' na feature branch → squash em 1-2 commits semânticos antes do PR. Cuidado: nunca rebase em branch pública/compartilhada (reescreve SHAs).",
        x: "Branch com commits: 'wip', 'fix typo', 'add login form', 'fix test', 'add validation'. git rebase -i HEAD~5: squash 'wip'+'fix typo'+'add login form' → 'feat: add login form'. squash 'fix test'+'add validation' → 'feat: add form validation'. Resultado: 2 commits limpos. Force push: git push --force-with-lease origin feature/login.",
      },
    ],
    Difícil: [
      {
        q: "O que são Git worktrees e como permitem trabalhar em múltiplas branches simultaneamente sem stash ou clone?",
        o: [
          "Cria diretórios de trabalho adicionais vinculados ao mesmo repositório, cada um em branch diferente — permite alternar sem trocar de branch no diretório principal",
          "Cria cópias completas (clones) independentes do repositório para cada branch",
          "Subdiretórios dentro do repositório que contêm submódulos de outros projetos",
          "Branches temporárias criadas automaticamente pelo sistema de CI/CD para testes paralelos",
        ],
        c: 0,
        e: "git worktree: múltiplos working directories ligados ao mesmo .git. Cada worktree em branch diferente. Vantagem sobre git stash: não precisa salvar/restaurar; sobre clone: compartilha histórico e objects (economia de espaço). Uso: hotfix urgente enquanto trabalha em feature, code review de PR enquanto desenvolve, comparar versões lado a lado.",
        x: "Trabalhando em feature/login: git worktree add ../hotfix-branch main → cria diretório ../hotfix-branch na branch main. cd ../hotfix-branch → corrigir bug → commit/push → cd ../meu-projeto (feature/login intacta). git worktree list: mostra todos. git worktree remove ../hotfix-branch: limpa. Cada worktree tem seu HEAD, index e working tree.",
      },
      {
        q: "Como funciona o modelo de objetos internos do Git (blobs, trees, commits, tags) e o que é o object store?",
        o: [
          "Git armazena tudo como objetos endereçados por hash SHA-1: blob (conteúdo de arquivo), tree (diretório), commit (snapshot + metadata + parent) e tag (referência nomeada a commit)",
          "Git usa banco de dados SQL interno para armazenar histórico de commits e branches",
          "Git comprime arquivos em formato ZIP e armazena diffs entre versões consecutivas",
          "Git mantém cópia completa de cada versão de cada arquivo em diretórios separados por data",
        ],
        c: 0,
        e: "Object store (.git/objects): content-addressable storage. Blob: conteúdo de arquivo (sem nome). Hash (SHA-1) do conteúdo → se dois arquivos são idênticos, mesmo blob. Tree: lista de entradas (mode, name, hash) — representa diretório. Commit: referência a tree (snapshot), author, committer, message, parent(s). Tag: referência nomeada a commit (annotated tag tem mensagem). Pack files: objetos comprimidos com delta compression para economia de espaço.",
        x: "git cat-file -p HEAD → tree abc123, parent def456, author Ana. git cat-file -p abc123 (tree) → 100644 blob aaa111 README.md, 040000 tree bbb222 src/. git cat-file -p aaa111 (blob) → conteúdo do README.md. Renomear arquivo: novo tree aponta para mesmo blob (conteúdo inalterado). git count-objects: número de objects no store.",
      },
    ],
  },
  "JavaScript e TypeScript": {
    Fácil: [
      {
        q: "O que são os operadores spread (...) e rest (...) em JavaScript e como diferenciam pelo contexto de uso?",
        o: [
          "Spread expande iteráveis em elementos individuais (chamada/literal); rest coleta múltiplos argumentos em um array (declaração de função/desestruturação)",
          "Spread e rest são o mesmo operador e sempre se comportam de forma idêntica",
          "Spread cria deep copy de objetos; rest converte arrays em objetos",
          "Spread só funciona com arrays; rest só com objetos",
        ],
        c: 0,
        e: "Spread (...): expande. Em arrays: [...arr1, ...arr2] (concatenar). Em objetos: {...obj, key: 'new'} (copiar e sobrescrever). Em chamadas: func(...args). Rest (...): coleta. Em parâmetros: function f(a, ...rest) {} — rest é array com argumentos restantes. Em desestruturação: const [first, ...others] = [1,2,3] → others=[2,3]. Spread = desempacotar; Rest = empacotar.",
        x: "Spread: const merged = [...[1,2], ...[3,4]] → [1,2,3,4]. const user2 = {...user, name:'Bob'} → cópia com name alterado. Math.max(...[5,2,8]) → 8. Rest: function sum(...nums) { return nums.reduce((a,b)=>a+b); } sum(1,2,3) → 6. const {a, ...rest} = {a:1,b:2,c:3} → rest={b:2,c:3}.",
      },
      {
        q: "O que é o operador ternário em JavaScript e como usá-lo como alternativa concisa ao if/else?",
        o: [
          "Expressão condicional com sintaxe condição ? valorSeTrue : valorSeFalse; retorna um valor e pode ser usada em atribuições e JSX",
          "Operador que testa três condições sequencialmente e retorna a primeira verdadeira",
          "Função que aceita três argumentos e retorna o maior entre eles",
          "Bloco condicional que substitui switch/case para exatamente três opções",
        ],
        c: 0,
        e: "Ternário: expressão (não statement) que avalia condição e retorna um dos dois valores. condição ? exprVerdadeira : exprFalsa. Vantagem: conciso para atribuições condicionais simples. Evitar: aninhamento excessivo (difícil de ler). Em JSX/React: usado diretamente na renderização condicional. Pode ser encadeado mas legibilidade sofre.",
        x: "const status = age >= 18 ? 'adulto' : 'menor'; const greeting = isLoggedIn ? `Olá, ${name}` : 'Olá, visitante'; JSX: {isLoading ? <Spinner /> : <Content />}. Evitar: const x = a ? b ? c : d : e ? f : g; — use if/else para clareza. Nullish: const val = input ?? 'default'; (melhor que ternário para null/undefined).",
      },
    ],
    Médio: [
      {
        q: "O que são Map e Set em JavaScript e quando usá-los em vez de objetos simples e arrays?",
        o: [
          "Map: coleção chave-valor com chaves de qualquer tipo e ordem de inserção preservada; Set: coleção de valores únicos com lookup O(1) — ambos superam objetos/arrays em cenários específicos",
          "Map e Set são wrappers de objetos e arrays sem benefícios de performance",
          "Map aceita apenas strings como chave; Set permite duplicatas mas ordena automaticamente",
          "Map e Set são imutáveis por padrão e não permitem adição de novos elementos",
        ],
        c: 0,
        e: "Map vs objeto: chaves de qualquer tipo (objetos, funções), size nativo, iterável com ordem, sem prototype pollution. Set vs array: valores únicos garantidos, has() O(1) vs includes() O(n). Map: new Map([[key,val]]); .set(k,v), .get(k), .has(k), .delete(k), .size. Set: new Set([1,2,2,3]) → {1,2,3}; .add(v), .has(v), .delete(v). WeakMap/WeakSet: chaves com referência fraca (GC-friendly).",
        x: "Map com chave objeto: const cache = new Map(); const key = {id:1}; cache.set(key, 'data'); cache.get(key) → 'data'. Objeto não aceita chave objeto (converte para '[object Object]'). Set para deduplicar: [...new Set([1,2,2,3,3])] → [1,2,3]. Set para intersecção: new Set([...setA].filter(x => setB.has(x))).",
      },
      {
        q: "O que são Generics em TypeScript e como eles permitem criar funções e classes reutilizáveis com type safety?",
        o: [
          "Parâmetros de tipo que permitem definir funções/classes que operam com qualquer tipo mantendo type safety — o tipo concreto é definido no uso, não na declaração",
          "Tipos que aceitam qualquer valor como 'any' mas com melhor performance",
          "Templates de código que geram múltiplas versões de funções em compile-time",
          "Interfaces que definem contratos genéricos para qualquer classe implementar",
        ],
        c: 0,
        e: "Generics: <T> é parâmetro de tipo. function identity<T>(val: T): T { return val; } — sem generic, usaria any (perde type safety) ou escreveria uma versão para cada tipo. Com generic: identity<string>('hello') retorna string; identity<number>(42) retorna number. Inferência: identity('hello') — TS infere T=string. Constraints: <T extends HasLength> limita tipos aceitos. Usado em: Array<T>, Promise<T>, Map<K,V>.",
        x: "function first<T>(arr: T[]): T | undefined { return arr[0]; } first([1,2,3]) → tipo: number. first(['a','b']) → tipo: string. Sem generic: function first(arr: any[]): any — perde tipo de retorno. Constraint: function longest<T extends {length:number}>(a:T, b:T): T { return a.length >= b.length ? a : b; } longest('abc','de') → 'abc' (tipo string preservado).",
      },
    ],
    Difícil: [
      {
        q: "O que é o padrão de Inversion of Control (IoC) em TypeScript e como decorators facilitam injeção de dependência?",
        o: [
          "IoC inverte quem cria dependências: em vez da classe instanciar suas deps, um container externo as injeta — decorators (@Injectable, @Inject) marcam classes e parâmetros para resolução automática",
          "IoC é um padrão de controle de fluxo que inverte a ordem de execução de callbacks",
          "Decorators criam instâncias singleton automaticamente sem necessidade de container",
          "IoC substitui imports de módulos por carregamento dinâmico em runtime",
        ],
        c: 0,
        e: "IoC: framework/container controla a criação e injeção de dependências. Sem IoC: class UserService { constructor() { this.repo = new PostgresRepo(); } } — acoplado. Com IoC: @Injectable() class UserService { constructor(private repo: UserRepository) {} } — container resolve UserRepository para a implementação registrada. Benefícios: testabilidade (mock fácil), flexibilidade (trocar implementação sem alterar código). Ferramentas TS: TSyringe, InversifyJS, NestJS.",
        x: "NestJS: @Injectable() class UserService { constructor(private repo: UserRepository) {} } @Module({ providers: [{ provide: UserRepository, useClass: PostgresRepo }] }) class AppModule {}. Em teste: { provide: UserRepository, useClass: MockRepo }. TSyringe: @injectable() class A { constructor(@inject('IRepo') private repo: IRepo) {} }. container.register('IRepo', { useClass: PostgresRepo });",
      },
      {
        q: "O que são Branded Types (tipos nominais) em TypeScript e como eles previnem mistura acidental de tipos compatíveis?",
        o: [
          "Técnica que adiciona uma propriedade phantom (brand) ao tipo para criar tipos estruturalmente distintos — impede usar UserId onde OrderId é esperado mesmo ambos sendo string",
          "Tipos nativos do TypeScript que diferenciam classes por nome ao invés de estrutura",
          "Enums com valores string que servem como identificadores únicos de tipo",
          "Wrappers de classe que encapsulam tipos primitivos para adicionar métodos",
        ],
        c: 0,
        e: "TypeScript é estrutural: type UserId = string; type OrderId = string; são intercambiáveis. Branded type: type UserId = string & { __brand: 'UserId' }. Agora UserId ≠ OrderId estruturalmente. Criação: function userId(id: string): UserId { return id as UserId; }. Previne: getUser(orderId) — erro de compilação. Custo zero em runtime (brand não existe em JS). Alternativa: unique symbol como brand.",
        x: "type UserId = string & { readonly __brand: unique symbol }; type OrderId = string & { readonly __brand: unique symbol }; function createUserId(id: string): UserId { return id as UserId; } function getUser(id: UserId) { ... } const uid = createUserId('u1'); const oid = createOrderId('o1'); getUser(uid); // OK. getUser(oid); // Erro: OrderId não é UserId. getUser('raw'); // Erro: string não é UserId.",
      },
    ],
  },
  "Programação Orientada a Objetos": {
    Fácil: [
      {
        q: "O que é o conceito de herança em POO e qual a diferença entre herança simples e múltipla?",
        o: [
          "Herança permite que uma classe filha reutilize atributos e métodos da classe pai; simples herda de uma classe, múltipla de várias — múltipla causa o problema do diamante",
          "Herança é a capacidade de um objeto se transformar em outro tipo em runtime",
          "Herança simples permite apenas métodos; múltipla permite atributos e métodos",
          "Herança só funciona entre interfaces, não entre classes concretas",
        ],
        c: 0,
        e: "Herança: classe filha (subclasse) herda comportamentos da classe pai (superclasse) com 'extends'. Simples: uma superclasse (Java, C#, TS). Múltipla: várias superclasses (C++, Python). Problema do diamante: classe herda de B e C que herdam de A — qual versão do método de A usar? Python resolve com MRO (Method Resolution Order, C3 Linearization). Java/C#/TS: interfaces (implements) não causam diamante pois não têm implementação (até default methods).",
        x: "class Animal { eat() {} } class Dog extends Animal { bark() {} } — Dog herda eat(). Diamante (Python): class A: def greet(): 'A'. class B(A): def greet(): 'B'. class C(A): def greet(): 'C'. class D(B,C): pass. D().greet() → 'B' (MRO: D→B→C→A). C++: class D : public B, public C — ambíguo, requer virtual inheritance.",
      },
      {
        q: "O que são métodos getters e setters em POO e por que encapsular acesso a atributos privados?",
        o: [
          "Métodos que controlam leitura (get) e escrita (set) de atributos privados, permitindo validação, cálculos derivados e proteção da invariante do objeto",
          "Funções estáticas que serializam e desserializam objetos para JSON",
          "Decorators que convertem métodos em propriedades computadas acessíveis diretamente",
          "Constantes que definem os valores padrão iniciais de cada atributo",
        ],
        c: 0,
        e: "Getters/Setters: encapsulam acesso a campos internos. Benefícios: 1) Validação: setter verifica se valor é válido antes de atribuir. 2) Computação: getter calcula valor derivado sob demanda. 3) Proteção: invariantes do objeto mantidas (ex: saldo nunca negativo). 4) Evolução: mudar implementação interna sem quebrar API pública. TypeScript/JS: get/set como property accessors. Java: getX()/setX().",
        x: "class BankAccount { private _balance = 0; get balance() { return this._balance; } set balance(value: number) { if (value < 0) throw Error('Saldo negativo'); this._balance = value; } } const acc = new BankAccount(); acc.balance = 100; // OK via setter. acc.balance = -50; // Error. console.log(acc.balance); // 100 via getter.",
      },
    ],
    Médio: [
      {
        q: "O que é o princípio de substituição de Liskov (LSP) e como sua violação causa bugs em hierarquias de classes?",
        o: [
          "Subclasses devem ser substituíveis por suas superclasses sem alterar a corretude do programa — violação: subclasse muda comportamento esperado ou lança exceções inesperadas",
          "Classes com o mesmo nome em módulos diferentes devem ser intercambiáveis",
          "Superclasses devem poder substituir subclasses em qualquer contexto",
          "Toda classe abstrata deve ter pelo menos uma implementação concreta",
        ],
        c: 0,
        e: "LSP (Liskov Substitution Principle): se S é subtipo de T, objetos de T podem ser substituídos por S sem alterar propriedades do programa. Violação clássica: class Retângulo { setLargura(); setAltura(); } class Quadrado extends Retângulo { setLargura(v) { largura=v; altura=v; } } — setLargura num quadrado altera altura, quebrando expectativas de quem usa Retângulo. Solução: evitar herança, usar composição ou interfaces separadas.",
        x: "function calcularArea(r: Retangulo) { r.setLargura(5); r.setAltura(4); assert(r.area() === 20); } — passa para Retangulo, FALHA para Quadrado (5×5=25 ou 4×4=16). LSP violado: Quadrado não é substituível. Solução: interface Shape { area(): number; } class Retangulo implements Shape {...} class Quadrado implements Shape {...} — sem herança problemática.",
      },
      {
        q: "O que são mixins em POO e como resolvem o problema de reutilização de comportamento sem herança múltipla?",
        o: [
          "Classes parciais que adicionam comportamentos específicos a outras classes via composição; permitem combinar funcionalidades sem hierarquia rígida de herança",
          "Interfaces com implementação padrão que substituem classes abstratas",
          "Padrão de design que injeta dependências em runtime usando reflection",
          "Funções utilitárias estáticas agrupadas em um namespace compartilhado",
        ],
        c: 0,
        e: "Mixins: reutilizar comportamento sem herança. Em TS: função que recebe uma classe base e retorna classe estendida com novos métodos. Em Python: class com métodos a serem 'mixados' via herança múltipla (ordem importa: MRO). Diferença de interface: mixin tem implementação. Diferença de herança: mixin é composição de comportamentos, não relação 'é-um'. Uso: adicionar serialização, logging, timestamping a classes diversas.",
        x: "TS: function Timestamped<T extends Constructor>(Base: T) { return class extends Base { createdAt = new Date(); updatedAt = new Date(); } } function Serializable<T extends Constructor>(Base: T) { return class extends Base { toJSON() { return JSON.stringify(this); } } } class User extends Timestamped(Serializable(BaseEntity)) {} — User tem createdAt, updatedAt e toJSON().",
      },
    ],
    Difícil: [
      {
        q: "O que é o padrão CQRS (Command Query Responsibility Segregation) em POO e quando ele é justificado?",
        o: [
          "Separa as operações de leitura (Query) das de escrita (Command) em modelos distintos, permitindo otimizações independentes de cada lado",
          "Padrão que unifica leitura e escrita num único modelo para simplificar o código",
          "Técnica de cache que separa dados quentes (leitura) de frios (escrita)",
          "Framework de testes que separa queries de assertions em steps diferentes",
        ],
        c: 0,
        e: "CQRS: modelo de escrita (Command) separado do modelo de leitura (Query). Write model: normalizado, validações complexas, eventos. Read model: desnormalizado, otimizado para queries específicas (views materializadas). Justificado quando: padrões de leitura e escrita são muito diferentes, alta escala, necessidade de modelos de leitura especializados (search, relatórios). Frequentemente combinado com Event Sourcing. Desvantagem: complexidade, eventual consistency entre modelos.",
        x: "E-commerce: Command side: CreateOrderCommand → validar estoque → persist Order → emit OrderCreated event. Query side: OrderCreated handler → atualiza read DB (desnormalizado: order+customer+items numa tabela/documento). GET /orders → query diretamente no read model (rápido, sem JOINs). Write DB: PostgreSQL normalizado. Read DB: Elasticsearch para busca ou MongoDB desnormalizado.",
      },
      {
        q: "O que é o princípio de covariância e contravariância em tipos genéricos e como afeta hierarquias de classes?",
        o: [
          "Covariância permite subtipo no retorno (Producer<Dog> é subtipo de Producer<Animal>); contravariância permite supertipo nos parâmetros (Consumer<Animal> é subtipo de Consumer<Dog>)",
          "Covariância e contravariância são sinônimos para polimorfismo paramétrico",
          "Covariância aplica-se apenas a arrays; contravariância apenas a funções",
          "Ambas significam que tipos genéricos são sempre intercambiáveis se os tipos base são compatíveis",
        ],
        c: 0,
        e: "Covariância (out): preserva direção da herança. Se Dog extends Animal, Producer<Dog> extends Producer<Animal>. Seguro para retorno/produção. Contravariância (in): inverte direção. Consumer<Animal> extends Consumer<Dog>. Seguro para parâmetros/consumo. Invariância: nenhuma direção (default em Java generics, C# sem in/out). Regra PECS (Java): Producer Extends, Consumer Super. TypeScript: funções são contravariantes nos parâmetros (com strictFunctionTypes).",
        x: "C#: IEnumerable<out T> (covariante): IEnumerable<Dog> atribuível a IEnumerable<Animal> ✓. Action<in T> (contravariante): Action<Animal> atribuível a Action<Dog> ✓ (quem aceita Animal aceita Dog). Java: List<? extends Animal> (covariante: lê Animal), List<? super Dog> (contravariante: escreve Dog). TS: type Fn<T> = (arg: T) => void; Fn<Animal> atribuível a Fn<Dog>? Sim com --strict (contravariância).",
      },
    ],
  },
  "React e React Native": {
    Fácil: [
      {
        q: "O que são props em React e como elas permitem passar dados de componentes pais para filhos?",
        o: [
          "Propriedades somente-leitura passadas de pai para filho via atributos JSX; permitem configurar e customizar componentes de forma declarativa",
          "Variáveis globais compartilhadas entre todos os componentes da aplicação",
          "Estado interno do componente que pode ser modificado por qualquer outro componente",
          "Eventos disparados pelo componente filho que o pai pode interceptar",
        ],
        c: 0,
        e: "Props: dados passados de pai para filho como atributos HTML. Somente leitura no filho (unidirecional). Tipagem: interface Props { name: string; age?: number; }. Desestruturação: function User({ name, age = 18 }: Props). Children: prop especial para conteúdo aninhado. Callback props: função passada como prop para comunicação filho→pai. Props são a base do modelo declarativo do React.",
        x: "<UserCard name='Ana' age={25} onDelete={() => handleDelete(id)} /> — componente filho: function UserCard({ name, age, onDelete }: Props) { return <div>{name}, {age} anos <button onClick={onDelete}>X</button></div>; }. Children: <Card><h1>Título</h1></Card> → function Card({children}) { return <div className='card'>{children}</div>; }.",
      },
      {
        q: "O que é renderização condicional em React e quais são as formas mais comuns de implementá-la?",
        o: [
          "Exibir ou ocultar elementos baseado em condições usando operador ternário, && lógico, ou early return — cada abordagem adequada para cenários diferentes",
          "Usar CSS display:none para esconder componentes condicionalmente",
          "Criar dois componentes separados e trocar entre eles via roteamento",
          "Usar setTimeout para atrasar a renderização até a condição ser verdadeira",
        ],
        c: 0,
        e: "Formas de renderização condicional: 1) Ternário: {isLoggedIn ? <Dashboard /> : <Login />} — quando há ambos os caminhos. 2) && lógico: {isAdmin && <AdminPanel />} — quando só há caminho verdadeiro. Cuidado: {count && <List />} renderiza '0' se count=0 (use count > 0). 3) Early return: if (loading) return <Spinner />; — melhor para múltiplas condições. 4) Variável: let content; if (...) content = <A/>; else content = <B/>; return {content};",
        x: "{isLoading ? <Spinner /> : <DataTable data={data} />}. {error && <ErrorBanner message={error} />}. function Page({user, loading, error}) { if (loading) return <Spinner />; if (error) return <Error msg={error} />; if (!user) return <Login />; return <Dashboard user={user} />; } — guard clauses para renderização.",
      },
    ],
    Médio: [
      {
        q: "O que são custom hooks em React e quais as regras para criá-los corretamente?",
        o: [
          "Funções prefixadas com 'use' que encapsulam lógica stateful reutilizável usando outros hooks; devem seguir as Rules of Hooks (só no top level, só em componentes/hooks)",
          "Classes que estendem React.Component com estado e ciclo de vida customizados",
          "Componentes de ordem superior (HOC) escritos como funções arrow",
          "Plugins do React que adicionam funcionalidades ao core da biblioteca",
        ],
        c: 0,
        e: "Custom hook: função useXxx que usa hooks internamente para extrair e reutilizar lógica. Regras: 1) Prefixo 'use' (ESLint plugin detecta violações). 2) Chamar hooks apenas no top level (nunca em condicionais/loops). 3) Chamar apenas em componentes React ou outros hooks. Cada componente que usa o hook tem seu próprio estado (isolado). Padrões: useFormField, useFetch, useDebounce, useLocalStorage, useMediaQuery.",
        x: "function useFetch<T>(url: string) { const [data, setData] = useState<T|null>(null); const [loading, setLoading] = useState(true); const [error, setError] = useState<Error|null>(null); useEffect(() => { fetch(url).then(r=>r.json()).then(setData).catch(setError).finally(()=>setLoading(false)); }, [url]); return { data, loading, error }; } — Uso: const { data, loading } = useFetch<User[]>('/api/users');",
      },
      {
        q: "O que é React.memo e quando usá-lo para otimizar re-renders de componentes funcionais?",
        o: [
          "HOC que memoriza o resultado da renderização e só re-renderiza se as props mudarem (shallow compare); útil para componentes puros que recebem as mesmas props frequentemente",
          "Função que salva o componente em cache do navegador para carregamento mais rápido",
          "Hook que memoriza valores computados dentro do componente",
          "Método que comprime a árvore de componentes para reduzir uso de memória",
        ],
        c: 0,
        e: "React.memo: wrapa componente funcional, compara props com shallow equality antes de re-renderizar. Se props iguais → pula render (usa output anterior). Útil quando: componente é puro, pai re-renderiza frequentemente mas props do filho não mudam, renderização é custosa. Cuidado: props com objetos/arrays/funções criados inline → nova referência a cada render → memo inútil. Solução: useMemo/useCallback nas props do pai. Custom comparator: React.memo(Comp, (prev, next) => comparison).",
        x: "const ExpensiveList = React.memo(function({ items }: { items: Item[] }) { return items.map(i => <li key={i.id}>{i.name}</li>); }); — pai re-renderiza mas items não mudou → ExpensiveList não re-renderiza. Problema: <Child onClick={() => doSomething()} /> → nova função toda render → memo inútil. Fix: const handleClick = useCallback(() => doSomething(), []); <Child onClick={handleClick} />.",
      },
    ],
    Difícil: [
      {
        q: "O que é o React Reconciliation Algorithm e como a heurística de keys otimiza a diferenciação de listas?",
        o: [
          "Algoritmo que compara árvores virtual DOM antiga e nova em O(n) usando heurísticas: elementos de tipos diferentes são recriados, e keys identificam elementos estáveis em listas",
          "Algoritmo que compara DOMs reais para detectar mudanças manuais feitas via JavaScript",
          "Sistema de cache que armazena renderizações anteriores para reutilizar em componentes idênticos",
          "Processo de compilação que otimiza JSX em instruções DOM mínimas",
        ],
        c: 0,
        e: "Reconciliation: diffing entre árvore virtual anterior e nova. Heurísticas (O(n) vs O(n³) ótimo): 1) Elementos de tipos diferentes → destruir subárvore e recriar (div→span: remonta tudo). 2) Mesmo tipo → compara atributos, atualiza apenas mudanças. 3) Listas: sem key → compara por posição (inserção no início re-renderiza todos). Com key estável → identifica movimentos, inserções, remoções eficientemente. Anti-pattern: key={Math.random()} ou key={index} com reordenação.",
        x: "Lista [A,B,C] → [X,A,B,C]. Sem key: React compara posição: A→X (update), B→A (update), C→B (update), null→C (insert) = 4 operações. Com key: React identifica que A,B,C continuam, X é novo = 1 insert. key={item.id} ✓. key={index} com reorder: React confunde quem é quem → estado vindovinculado ao item errado.",
      },
      {
        q: "O que é Suspense e React Server Components (RSC) e como mudam o modelo de data fetching e renderização?",
        o: [
          "Suspense permite mostrar fallback enquanto componente carrega dados/código; RSC renderiza no servidor sem enviar JS ao client — juntos eliminam waterfalls e reduzem bundle size",
          "Suspense é um error boundary para erros de rede; RSC são componentes que rodam apenas no cliente",
          "Suspense é um hook para gerenciar loading state; RSC compilam JSX em HTML estático",
          "Suspense substitui useEffect para side effects; RSC são Web Components nativos do browser",
        ],
        c: 0,
        e: "Suspense: componente React que mostra fallback (<Suspense fallback={<Spinner/>}>) enquanto children suspendem (lazy loading, data fetching). React 'pausa' a renderização, mostra fallback, resume quando dados prontos. RSC: componentes async que rodam no servidor (podem acessar DB, filesystem diretamente). Output: serializado como payload (não HTML puro). Não enviam JS ao client (zero bundle). Composição: Server Component pode conter Client Component ('use client'). Next.js App Router usa RSC por default.",
        x: "RSC: async function UserProfile({id}) { const user = await db.query('SELECT * FROM users WHERE id=?', [id]); return <div>{user.name}</div>; } — roda no servidor, zero JS no client. Client Component: 'use client'; function LikeButton() { const [liked, setLiked] = useState(false); return <button onClick={()=>setLiked(true)}>Like</button>; }. <Suspense fallback={<Skeleton/>}><UserProfile id={1}/></Suspense>.",
      },
    ],
  },
  "Testes de Software": {
    Fácil: [
      {
        q: "O que é o padrão AAA (Arrange-Act-Assert) em testes unitários e por que seguir essa estrutura?",
        o: [
          "Estrutura que organiza testes em três fases: preparar dados (Arrange), executar ação (Act), verificar resultado (Assert) — torna testes legíveis e previsíveis",
          "Framework de teste que executa Arrange e Assert automaticamente, requerendo apenas Act",
          "Técnica de mock que substitui todas as dependências em três camadas",
          "Padrão de nomenclatura para arquivos de teste: Arrange.test.ts, Act.test.ts, Assert.test.ts",
        ],
        c: 0,
        e: "AAA: 1) Arrange: configurar dados, mocks, estado inicial. 2) Act: executar a ação/método testado (geralmente uma linha). 3) Assert: verificar resultado esperado. Benefícios: legibilidade (qualquer dev entende a estrutura), separação (setup vs execução vs verificação). Variação: Given-When-Then (BDD). Anti-pattern: múltiplos Acts e Asserts misturados (dividir em testes separados).",
        x: "test('calcula desconto de 10% para compras acima de R$100', () => { // Arrange const cart = new Cart(); cart.addItem({ price: 200 }); // Act const total = cart.calculateTotal(); // Assert expect(total).toBe(180); }); — um teste, uma responsabilidade, três fases claras.",
      },
      {
        q: "O que são testes de regressão e por que são importantes quando se adiciona novas funcionalidades?",
        o: [
          "Testes que garantem que funcionalidades existentes continuam funcionando após mudanças no código; previnem que correções ou features novas quebrem comportamento anterior",
          "Testes que verificam performance em carga alta para detectar degradação gradual",
          "Testes executados apenas uma vez na primeira implantação para validar requisitos",
          "Testes manuais feitos pelo QA antes de cada release para aprovação",
        ],
        c: 0,
        e: "Regressão: re-executar suite de testes após cada mudança para detectar quebras. Cenário: dev corrige bug X, inadvertidamente quebra feature Y. Sem regressão: bug Y só descoberto em produção. Com regressão: CI roda toda suite → teste de Y falha → dev corrige antes do merge. Automação é essencial: suites grandes (centenas/milhares de testes) rodam em minutos no CI. Quanto mais testes, maior a rede de segurança.",
        x: "Sprint 5: dev adiciona feature de cupom de desconto. Suite CI: 500 testes →  1 falha: 'test_checkout_total' espera total=100.00, recebeu 90.00 (desconto aplicado indevidamente sem cupom). Bug detectado antes do merge. Fix: condição if (hasCoupon) antes de aplicar desconto. 500 testes passam → merge seguro.",
      },
    ],
    Médio: [
      {
        q: "O que são testes de integração e como diferem de testes unitários e end-to-end em escopo e velocidade?",
        o: [
          "Testam a interação entre módulos reais (ex: serviço + banco de dados); mais lentos que unitários mas mais rápidos que E2E, cobrindo cenários que mocks não capturam",
          "Testam cada função isoladamente com mocks; são os mais lentos pois cobrem todos os caminhos",
          "Testam a aplicação inteira do ponto de vista do usuário via browser automatizado",
          "Testam apenas a interface visual comparando screenshots entre versões",
        ],
        c: 0,
        e: "Unitário: testa função/classe isolada com mocks. Rápido (~ms). Integração: testa interação real entre módulos (API + DB real, serviço A chama serviço B). Médio (~s). Descobre: queries SQL erradas, serializações, configurações. E2E: testa fluxo completo como usuário (Cypress/Playwright). Lento (~min). Pirâmide: muitos unitários, menos integração, poucos E2E. Testcontainers: sobe DB real em Docker para testes de integração.",
        x: "Unitário: test('createUser valida email', () => { expect(() => createUser({email:'invalid'})).toThrow(); }); — mock do repo. Integração: test('createUser persiste no banco', async () => { await createUser({email:'a@b.com'}); const user = await db.query('SELECT * FROM users'); expect(user).toHaveLength(1); }); — banco real (Testcontainers). E2E: test('signup flow', () => { cy.visit('/signup'); cy.type('#email','a@b.com'); cy.click('Submit'); cy.contains('Welcome'); });",
      },
      {
        q: "O que é Test-Driven Development (TDD) e quais são os três passos do ciclo Red-Green-Refactor?",
        o: [
          "Red: escrever teste que falha para comportamento desejado; Green: implementar código mínimo para passar; Refactor: melhorar código mantendo testes verdes",
          "Red: detectar bugs em produção; Green: corrigir; Refactor: otimizar performance",
          "Red: código com erros de compilação; Green: compilação bem-sucedida; Refactor: adicionar testes",
          "Red: branch com conflitos; Green: merge resolvido; Refactor: limpar histórico",
        ],
        c: 0,
        e: "TDD: testes guiam o design do código. Red: escrever teste para funcionalidade que não existe ainda (falha porque código não foi escrito). Green: implementar código MÍNIMO para passar (pode ser feio). Refactor: melhorar estrutura sem quebrar testes (rede de segurança). Ciclo curto: poucos minutos. Benefícios: design emergente, documentação viva, confiança em mudanças, debugging mais fácil. Código testável by design.",
        x: "Funcionalidade: calcular desconto. Red: test('aplica 10% acima de R$100', () => expect(calcDesconto(200)).toBe(20)); → FAIL (calcDesconto não existe). Green: function calcDesconto(v) { return v > 100 ? v*0.1 : 0; } → PASS. Refactor: extrair constantes THRESHOLD=100, RATE=0.1. Testes continuam verdes. Próximo ciclo: test('sem desconto abaixo de R$100', ...).",
      },
    ],
    Difícil: [
      {
        q: "O que são Contract Tests e como eles garantem compatibilidade entre serviços em arquiteturas de microsserviços?",
        o: [
          "Testes que verificam se a interface entre consumer e provider segue um contrato acordado; Pact é a ferramenta mais popular, gerando contratos do lado do consumer que o provider valida",
          "Testes que validam termos legais de uso da API junto com termos de serviço",
          "Testes de integração entre todos os microsserviços executados em ambiente de staging",
          "Documentação OpenAPI/Swagger que descreve endpoints e serve como contrato estático",
        ],
        c: 0,
        e: "Contract Testing: verifica que comunicação entre serviços segue acordo. Consumer-driven (Pact): 1) Consumer gera contrato (expect: GET /users/1 → {id:1, name:string}). 2) Contrato compartilhado via Pact Broker. 3) Provider valida: roda testes contra contrato, garante que implementação atende. Benefício vs integration test: não precisa de ambos os serviços rodando simultaneamente. Detecta: campos removidos, tipos alterados, endpoints renomeados antes do deploy.",
        x: "Consumer (frontend): pact.addInteraction({ uponReceiving: 'get user by id', withRequest: { method: 'GET', path: '/users/1' }, willRespondWith: { status: 200, body: { id: integer(1), name: string('Ana') } } }). Provider (API): verifyPact({ providerBaseUrl: 'http://localhost:3000', pactUrls: ['pact-broker/consumer-provider.json'] }). Provider altera name→fullName: contract test FALHA → breaking change detectada.",
      },
      {
        q: "O que é Chaos Engineering e como experimentos controlados de falha melhoram a resiliência de sistemas?",
        o: [
          "Disciplina de injetar falhas controladas em produção/staging para descobrir fraquezas antes que causem outages reais; segue hipótese → experimento → análise",
          "Testes de carga que simulam milhares de usuários para encontrar limites de capacidade",
          "Processo de code review focado em encontrar vulnerabilidades de segurança",
          "Automação de rollback que reverte deploys automaticamente quando métricas degradam",
        ],
        c: 0,
        e: "Chaos Engineering (Netflix): princípios — 1) Definir estado estável (SLIs normais). 2) Hipótese: 'sistema continua estável se nó X cair'. 3) Injetar falha: matar instância, simular latência, corromper rede. 4) Observar: métricas, logs, alertas. 5) Se hipótese falha → descobrir e corrigir fraqueza antes de outage real. Ferramentas: Chaos Monkey (Netflix), LitmusChaos (Kubernetes), AWS FIS. Blast radius: começar pequeno, escalar gradualmente.",
        x: "Hipótese: 'Se 1 de 3 réplicas do serviço de pagamento cair, latência p99 fica abaixo de 500ms'. Experimento: Chaos Monkey mata 1 container. Observação: latência subiu para 2s porque auto-scaling demorou 3min. Insight: health check interval muito longo (30s → reduzir para 5s) + readiness probe mal configurada. Fix aplicado. Re-teste: latência p99 = 350ms. Resiliência comprovada.",
      },
    ],
  },
};

function mergeDevBankRounds(
  base: Record<string, Record<UserLevel, SeedCard[]>>,
  ...extras: Record<string, Record<UserLevel, SeedCard[]>>[]
): Record<string, Record<UserLevel, SeedCard[]>> {
  const result: Record<string, Record<UserLevel, SeedCard[]>> = {};
  for (const cat of Object.keys(base)) {
    result[cat] = {} as Record<UserLevel, SeedCard[]>;
    for (const level of ["Fácil", "Médio", "Difícil"] as UserLevel[]) {
      const baseCards = base[cat]?.[level] ?? [];
      const seen = new Set(baseCards.map((c) => c.q.trim().toLowerCase()));
      const merged = [...baseCards];
      for (const extra of extras) {
        for (const card of extra[cat]?.[level] ?? []) {
          if (!seen.has(card.q.trim().toLowerCase())) {
            seen.add(card.q.trim().toLowerCase());
            merged.push(card);
          }
        }
      }
      result[cat][level] = merged;
    }
  }
  return result;
}

export const desenvolvimentoBank = mergeDevBankRounds(
  desenvolvimentoBankBase,
  desenvolvimentoRound1Extras,
  desenvolvimentoRound2Extras,
);
